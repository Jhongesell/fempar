! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

function create_jacobi_preconditioner(op) result (res)
    implicit none
    class(fe_operator_t), intent(in)  :: op
    type(jacobi_preconditioner_t) :: res
    call op%GuardTemp()
    call res%create(op)
    call res%setTemp()
    call op%CleanTemp()
 end function create_jacobi_preconditioner

subroutine jacobi_preconditioner_create_w_parameter_list ( this, fe_nonlinear_operator, jacobi_preconditioner_params )
  implicit none
  class(jacobi_preconditioner_t)    , intent(inout) :: this
  class(fe_operator_t)      , target, intent(in)    :: fe_nonlinear_operator
  type(parameterlist_t)    ,  target, intent(in)    :: jacobi_preconditioner_params
  call this%create(fe_nonlinear_operator)
  this%jacobi_preconditioner_params => jacobi_preconditioner_params
end subroutine jacobi_preconditioner_create_w_parameter_list

subroutine jacobi_preconditioner_create_wo_parameter_list ( this, fe_nonlinear_operator )
  implicit none
  class(jacobi_preconditioner_t)          , intent(inout) :: this
  class(fe_operator_t)            , target, intent(in)    :: fe_nonlinear_operator
  type(par_fe_space_t)  , pointer :: fe_space
  class(triangulation_t), pointer :: triangulation
  call this%free()
  assert ( this%state_is_start() )
  this%fe_nonlinear_operator => fe_nonlinear_operator
  fe_space                   => this%get_par_fe_space()
  triangulation              => fe_space%get_triangulation()
  call this%set_par_environment(triangulation%get_environment())
  call this%create_vector_spaces()
  assert ( fe_space%get_num_blocks() == 1 )
  call this%set_state_created()
  nullify(this%jacobi_preconditioner_params)
end subroutine jacobi_preconditioner_create_wo_parameter_list

subroutine jacobi_preconditioner_create_vector_spaces (this)
  implicit none
  class(jacobi_preconditioner_t), intent(inout)  :: this
  type(vector_space_t), pointer :: fe_nonlinear_operator_domain_vector_space
  type(vector_space_t), pointer :: fe_nonlinear_operator_range_vector_space
  type(vector_space_t), pointer :: jacobi_preconditioner_domain_vector_space
  type(vector_space_t), pointer :: jacobi_preconditioner_range_vector_space
  fe_nonlinear_operator_domain_vector_space => this%fe_nonlinear_operator%get_domain_vector_space()
  fe_nonlinear_operator_range_vector_space => this%fe_nonlinear_operator%get_range_vector_space()
  assert ( fe_nonlinear_operator_domain_vector_space%equal_to(fe_nonlinear_operator_range_vector_space) )
  jacobi_preconditioner_domain_vector_space => this%get_domain_vector_space()
  jacobi_preconditioner_range_vector_space => this%get_range_vector_space()
  call fe_nonlinear_operator_domain_vector_space%clone(jacobi_preconditioner_domain_vector_space)
  call fe_nonlinear_operator_range_vector_space%clone(jacobi_preconditioner_range_vector_space)
end subroutine jacobi_preconditioner_create_vector_spaces

subroutine jacobi_preconditioner_create_and_allocate_inverse_diagonal ( this ) 
  implicit none
  class(jacobi_preconditioner_t), intent(inout) :: this
  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )
  call this%free_and_destroy_inverse_diagonal()
  call this%create_domain_vector(this%inverse_diagonal)
  call this%inverse_diagonal%allocate()
end subroutine jacobi_preconditioner_create_and_allocate_inverse_diagonal 

subroutine jacobi_preconditioner_free_and_destroy_inverse_diagonal ( this ) 
  implicit none
  class(jacobi_preconditioner_t), intent(inout) :: this
  integer(ip) :: istat
  if ( allocated(this%inverse_diagonal) ) then
    call this%inverse_diagonal%free()
    deallocate(this%inverse_diagonal, stat=istat); check(istat==0);
  end if
end subroutine jacobi_preconditioner_free_and_destroy_inverse_diagonal 


subroutine jacobi_preconditioner_update_matrix(this, same_nonzero_pattern )
  implicit none
  class(jacobi_preconditioner_t)          , intent(inout) :: this
  logical                  , intent(in)    :: same_nonzero_pattern
  
  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )

  if ( same_nonzero_pattern ) then
    if ( this%state_is_numeric() ) then
      call this%free_numerical_setup()
      call this%numerical_setup()
    end if   
  else
    if ( this%state_is_numeric() ) then
      call this%free_numerical_setup()
      call this%free_symbolic_setup()
      call this%symbolic_setup()
      call this%numerical_setup()
    else if ( this%state_is_symbolic() ) then
      call this%free_symbolic_setup()
      call this%symbolic_setup()
    end if
  end if 
end subroutine jacobi_preconditioner_update_matrix

subroutine jacobi_preconditioner_set_state_start(this)
  class(jacobi_preconditioner_t), intent(inout) :: this
  this%state = jacobi_preconditioner_STATE_START
end subroutine jacobi_preconditioner_set_state_start

subroutine jacobi_preconditioner_set_state_created(this)
  class(jacobi_preconditioner_t), intent(inout) :: this
  this%state = jacobi_preconditioner_STATE_CREATED
end subroutine jacobi_preconditioner_set_state_created

subroutine jacobi_preconditioner_set_state_symbolic(this)
  class(jacobi_preconditioner_t), intent(inout) :: this
  this%state = jacobi_preconditioner_STATE_SYMBOLIC
end subroutine jacobi_preconditioner_set_state_symbolic

subroutine jacobi_preconditioner_set_state_numeric(this)
  class(jacobi_preconditioner_t), intent(inout) :: this
  this%state = jacobi_preconditioner_STATE_NUMERIC
end subroutine jacobi_preconditioner_set_state_numeric

function jacobi_preconditioner_state_is_start(this) result(is_start)
  class(jacobi_preconditioner_t), intent(in) :: this
  logical                                 :: is_start
  is_start = this%state == jacobi_preconditioner_STATE_START
end function jacobi_preconditioner_state_is_start

function jacobi_preconditioner_state_is_created(this) result(is_start)
  class(jacobi_preconditioner_t), intent(in) :: this
  logical                                 :: is_start
  is_start = this%state == jacobi_preconditioner_STATE_CREATED
end function jacobi_preconditioner_state_is_created

function jacobi_preconditioner_state_is_symbolic(this) result(is_symbolic_setup)
  class(jacobi_preconditioner_t), intent(in) :: this
  logical                                 :: is_symbolic_setup
  is_symbolic_setup = this%state == jacobi_preconditioner_STATE_SYMBOLIC
end function jacobi_preconditioner_state_is_symbolic

function jacobi_preconditioner_state_is_numeric(this) result(is_numerical_setup)
  class(jacobi_preconditioner_t), intent(in) :: this
  logical                                 :: is_numerical_setup
  is_numerical_setup= this%state == jacobi_preconditioner_STATE_NUMERIC
end function jacobi_preconditioner_state_is_numeric

subroutine jacobi_preconditioner_symbolic_setup ( this )
  implicit none
  class(jacobi_preconditioner_t), intent(inout) :: this
  type(environment_t), pointer :: par_environment  
  par_environment => this%get_par_environment()
  
  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if ( this%state_is_created() ) then
    ! In the case the call to this subroutine is triggered by 
    ! "this%update_matrix(same_nonzero_pattern=.false.)" it might be
    ! necessary to re-generate vector spaces associated to this. 
    ! Provided that we do not know who triggered this subroutine, 
    ! and that the computational time spent here is not significant, 
    ! we always regenerate vector spaces right before returning control
    ! from a call to symbolic_setup
    call this%create_vector_spaces()
    call this%create_and_allocate_inverse_diagonal()
    call this%set_state_symbolic()
  end if
end subroutine jacobi_preconditioner_symbolic_setup

subroutine jacobi_preconditioner_numerical_setup ( this )
  implicit none
  class(jacobi_preconditioner_t)        , intent(inout)   :: this
  type(environment_t), pointer         :: par_environment

  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if ( this%state_is_created() ) then
    call this%symbolic_setup()
  end if 
  
  assert ( this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if ( this%state_is_symbolic() ) then
    par_environment => this%get_par_environment()
    
    ! 1. Extract diagonal into this%inverse_diagonal
    ! ... select type(matrix)
    !     type is(par_matrix_t
    !        select type(this%inverse_diag)
    !         type is par_scalar_array_t
    !           entries => this%inverse_diag%get_entries()
    !           call matrix%extract_diagonal(entries)
    
    ! 2. Assemble (sum) among subdomains the diagonal
    ! call this%inverse_diagonal%comm()
    
    ! 3. Invert the diagonal 
    ! ... this%entry_wise_invert() ??? (Tentative)
    
    call this%set_state_numeric()
  end if
  
end subroutine jacobi_preconditioner_numerical_setup

!=============================================================================
subroutine jacobi_preconditioner_apply (this, x, y)
  implicit none
  ! Parameters
  class(jacobi_preconditioner_t)   , intent(inout)    :: this
  class(vector_t)   , intent(in)    :: x
  class(vector_t)   , intent(inout) :: y
  
  assert ( this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )

  if (this%state_is_created() ) then
    call this%symbolic_setup()
  end if 
  
  assert ( this%state_is_symbolic() .or. this%state_is_numeric() )
  
  if (this%state_is_symbolic() ) then
    call this%numerical_setup()
  end if 
  
  assert ( this%state_is_numeric() )
  
  call this%abort_if_not_in_domain(x)
  call this%abort_if_not_in_range(y)
  call x%GuardTemp()
  !call y%point_wise_product(x, this%inverse_diagonal)
  call x%CleanTemp()
end subroutine jacobi_preconditioner_apply

!=============================================================================
subroutine jacobi_preconditioner_apply_add(this, x, y)
  implicit none
  ! Parameters
  class(jacobi_preconditioner_t)   , intent(inout)    :: this
  class(vector_t)   , intent(in)    :: x
  class(vector_t)   , intent(inout) :: y
  class(vector_t), allocatable      :: w
  type(vector_space_t), pointer     :: range_vector_space
  integer(ip)                       :: istat
  call this%abort_if_not_in_domain(x)
  call this%abort_if_not_in_range(y)
  call x%GuardTemp()
  range_vector_space => this%get_range_vector_space()
  call range_vector_space%create_vector(w)
  call this%apply(x,w)
  call y%axpby(1.0, w, 1.0)
  call x%CleanTemp()
  call w%free()
  deallocate(w, stat=istat); check(istat==0)
end subroutine jacobi_preconditioner_apply_add

subroutine jacobi_preconditioner_free(this)
  implicit none
  class(jacobi_preconditioner_t)           , intent(inout) :: this
  call this%free_numerical_setup()
  call this%free_symbolic_setup()
  call this%free_clean()
end subroutine jacobi_preconditioner_free

subroutine jacobi_preconditioner_free_clean(this)
  implicit none
  class(jacobi_preconditioner_t)           , intent(inout) :: this
  
  assert ( this%state_is_start() .or. this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )

  if ( this%state_is_numeric() ) then
    call this%free_numerical_setup() 
  end if
  
  if ( this%state_is_symbolic() ) then
    call this%free_symbolic_setup() 
  end if
  
  call this%nullify_operator()
  call this%free_vector_spaces()
  nullify(this%jacobi_preconditioner_params)
  nullify(this%environment)
  
  call this%set_state_start()
end subroutine jacobi_preconditioner_free_clean

subroutine jacobi_preconditioner_free_symbolic_setup(this)
  implicit none
  class(jacobi_preconditioner_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: par_environment
  integer(ip)                               :: istat

  assert ( this%state_is_start() .or. this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )

  if ( this%state_is_numeric() ) then
    call this%free_numerical_setup() 
  end if
  
  if ( this%state_is_symbolic() ) then 
     par_environment => this%get_par_environment()
     call this%set_state_created()
  end if
end subroutine jacobi_preconditioner_free_symbolic_setup

subroutine jacobi_preconditioner_free_numerical_setup(this)
  implicit none
  class(jacobi_preconditioner_t)           , intent(inout) :: this
  type(environment_t)   , pointer       :: par_environment
 
  assert ( this%state_is_start() .or. this%state_is_created() .or. this%state_is_symbolic() .or. this%state_is_numeric() )
  if ( this%state_is_numeric() ) then 
     par_environment => this%get_par_environment()
  end if
end subroutine jacobi_preconditioner_free_numerical_setup

function jacobi_preconditioner_get_par_environment(this)
  implicit none
  class(jacobi_preconditioner_t), target, intent(in) :: this
  class(environment_t), pointer :: jacobi_preconditioner_get_par_environment
  jacobi_preconditioner_get_par_environment => this%environment
end function jacobi_preconditioner_get_par_environment

subroutine jacobi_preconditioner_set_par_environment(this, environment)
  implicit none
  class(jacobi_preconditioner_t)       , intent(inout) :: this
  class(environment_t), target, intent(in)    :: environment
  this%environment => environment
end subroutine jacobi_preconditioner_set_par_environment

! Helper function that extracts a run-time polymorphic class(matrix_t)
! from the fe_nonlinear_operator, and dynamically casts it into  
! type(par_sparse_matrix_t). If the dynamic cast cannot be performed 
! [because class(matrix_t) is NOT of type(par_sparse_matrix_t)], then it 
! aborts the execution of the program.
function jacobi_preconditioner_get_par_sparse_matrix(this)
  implicit none
  class(jacobi_preconditioner_t)          , intent(in) :: this
  type(par_sparse_matrix_t), pointer    :: jacobi_preconditioner_get_par_sparse_matrix
  class(matrix_t), pointer              :: matrix
  matrix => this%fe_nonlinear_operator%get_matrix()
  select type( matrix )
  type is (par_sparse_matrix_t)
     jacobi_preconditioner_get_par_sparse_matrix => matrix
     class default
     check(.false.)
  end select
end function jacobi_preconditioner_get_par_sparse_matrix

function jacobi_preconditioner_get_fe_space(this)
  implicit none
  class(jacobi_preconditioner_t), intent(in) :: this
  class(base_fe_space_t), pointer :: jacobi_preconditioner_get_fe_space
  jacobi_preconditioner_get_fe_space => this%get_par_fe_space()
end function jacobi_preconditioner_get_fe_space

! Helper function that extracts a run-time polymorphic class(serial_fe_space_t)
! from the fe_nonlinear_operator, and dynamically casts it into  
! type(par_fe_space_t). If the dynamic cast cannot be performed 
! [because class(serial_fe_space_t) is NOT of type(par_fe_space_t)], then it 
! aborts the execution of the program.
function jacobi_preconditioner_get_par_fe_space(this)
  implicit none
  class(jacobi_preconditioner_t)          , intent(in) :: this
  type(par_fe_space_t)     , pointer    :: jacobi_preconditioner_get_par_fe_space
  class(serial_fe_space_t) , pointer    :: fe_space
  fe_space => this%fe_nonlinear_operator%get_fe_space()
  select type(fe_space)
  class is (par_fe_space_t)
     jacobi_preconditioner_get_par_fe_space => fe_space
     class default
     check(.false.)
  end select
end function jacobi_preconditioner_get_par_fe_space

function jacobi_preconditioner_am_i_l1_task(this)
  implicit none
  class(jacobi_preconditioner_t)          , intent(in) :: this
  logical                               :: jacobi_preconditioner_am_i_l1_task
  type(environment_t)   , pointer   :: par_environment
  par_environment => this%get_par_environment()
  jacobi_preconditioner_am_i_l1_task = par_environment%am_i_l1_task()
end function jacobi_preconditioner_am_i_l1_task

function jacobi_preconditioner_is_linear( this )
  implicit none
  class(jacobi_preconditioner_t)          , intent(in) :: this
  logical :: jacobi_preconditioner_is_linear
  jacobi_preconditioner_is_linear = .true.
end function jacobi_preconditioner_is_linear

function jacobi_preconditioner_is_operator_associated( this )
  implicit none
  class(jacobi_preconditioner_t)          , intent(in) :: this
  logical :: jacobi_preconditioner_is_operator_associated
  jacobi_preconditioner_is_operator_associated = associated(this%fe_nonlinear_operator)
end function jacobi_preconditioner_is_operator_associated

subroutine jacobi_preconditioner_nullify_operator ( this )
  implicit none
  class(jacobi_preconditioner_t), intent(inout) :: this
  nullify(this%fe_nonlinear_operator)
end subroutine jacobi_preconditioner_nullify_operator 
