! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine par_fe_space_create_same_reference_fes_on_all_cells( this, &
                                                                    triangulation, &
                                                                    conditions, &
                                                                    reference_fes, &
                                                                    field_blocks, &
                                                                    field_coupling )
  implicit none
  class(par_fe_space_t)                 , intent(inout)  :: this
  class(base_static_triangulation_t), target, intent(in)     :: triangulation
  class(conditions_t)                   , intent(in)     :: conditions
  type(p_reference_fe_t)                    , intent(in)     :: reference_fes(:)
  integer(ip)               , optional      , intent(in)     :: field_blocks(:)
  logical                   , optional      , intent(in)     :: field_coupling(:,:)

  type(par_environment_t), pointer :: par_environment 

  call this%free()
  
  ! This is a little bit DIRTY. Many type(par_fe_space_t) TBPs require that 
  ! coarse-grid tasks also associate this (superclass') member variable to a 
  ! target
  this%triangulation => triangulation
  par_environment    => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%create( triangulation, &
                                         conditions, &
                                         reference_fes, &
                                         field_blocks, &
                                         field_coupling )
  else
     this%number_blocks = 1
     if (present(field_blocks)) this%number_blocks = maxval(field_blocks)
     
     ! This is a little bit DIRTY. mlbddc_t%create() requires that coarse-grid
     ! tasks also know how many fields there are
     this%number_fields = size(reference_fes)
     
     ! This is a little bit DIRTY. par_fe_space_t%create_global_fe_function()
     ! requires that strong_dirichlet_values is created and allocated
     call this%strong_dirichlet_values%create_and_allocate(0)
  end if
end subroutine par_fe_space_create_same_reference_fes_on_all_cells


subroutine par_fe_space_free( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat
  type(par_environment_t), pointer :: par_environment
  
  if ( associated (this%triangulation) ) then
     par_environment => this%get_par_environment()
     if ( par_environment%am_i_l1_task() ) then
        do i=1, this%number_blocks
           call this%blocks_dof_import(i)%free()
        end do
        deallocate(this%blocks_dof_import) 
        call this%serial_fe_space_t%free()
        call this%free_coarse_dofs()
        nullify(this%coarse_fe_space)
     else
        ! This is a little bit DIRTY. par_fe_space_t%create_assembler()
        ! requires that this%blocks_dof_import is allocated 
        this%number_blocks = 0
        deallocate ( this%blocks_dof_import )
        
        ! This is a little bit DIRTY. mlbddc%create() requires that the number of
        ! fields is also set on coarse-grid tasks
        this%number_fields = 0
        
        ! This is a little bit DIRTY. par_fe_space_t%create_global_fe_function()
        ! requires that strong_dirichlet_values is created and allocated
        call this%serial_fe_space_t%strong_dirichlet_values%free()
        
        call this%coarse_fe_space%free()
        deallocate (this%coarse_fe_space, stat=istat)
        check (istat==0)
     end if
     nullify(this%triangulation)
  end if

end subroutine par_fe_space_free

! Required (at least) by type(mlbddc_t)
function par_fe_space_get_par_triangulation(this)
  implicit none
  class(par_fe_space_t), target, intent(in) :: this
  type(par_triangulation_t), pointer :: par_fe_space_get_par_triangulation
  
  assert ( associated(this%triangulation) )
  select type ( par_triangulation => this%triangulation )
    class is ( par_triangulation_t )
      par_fe_space_get_par_triangulation => par_triangulation
    class default
      assert(.false.)
  end select
end function par_fe_space_get_par_triangulation

function par_fe_space_get_coarse_fe_space(this)
  implicit none
  class(par_fe_space_t), target, intent(in) :: this
  type(coarse_fe_space_t), pointer :: par_fe_space_get_coarse_fe_space
  par_fe_space_get_coarse_fe_space => this%coarse_fe_space
end function par_fe_space_get_coarse_fe_space

! Required (at least) by type(mlbddc_t)
function par_fe_space_get_par_environment(this)
  implicit none
  class(par_fe_space_t), intent(in) :: this
  type(par_environment_t), pointer :: par_fe_space_get_par_environment
  assert ( associated(this%triangulation) )
  select type ( par_triangulation => this%triangulation )
    class is ( par_triangulation_t )
      par_fe_space_get_par_environment => par_triangulation%get_par_environment()
    class default
      assert(.false.)
  end select
end function par_fe_space_get_par_environment

function par_fe_space_get_environment(this)
  implicit none
  class(par_fe_space_t), intent(in) :: this
  class(environment_t), pointer :: par_fe_space_get_environment
  par_fe_space_get_environment => this%get_par_environment()
end function par_fe_space_get_environment

subroutine par_fe_space_print ( this )
  class(par_fe_space_t), intent(in) :: this 
  integer(ip) :: i,j
  type(par_environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%print()
     !do i = 1, this%number_blocks
     !  call this%blocks_dof_import(i)%print(6)
     !end do
  end if
end subroutine par_fe_space_print

subroutine par_fe_space_fill_dof_info( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock, field_id
  type(par_environment_t), pointer :: par_environment 
  
  
  par_environment => this%get_par_environment ()
  
  if ( par_environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%fill_dof_info()
     do field_id = 1, this%number_fields
        call this%fill_elem2dof_and_count_dofs( field_id )
     end do
     call this%compute_blocks_dof_import()
     ! Step required by the MLBDDC preconditioner
     call this%renumber_dofs_first_interior_then_interface()
     call this%setup_coarse_dofs()
  else
     ! This is a little bit DIRTY. par_fe_space_t%create_assembler()
     ! requires that this%blocks_dof_import is allocated 
     allocate ( this%blocks_dof_import(this%number_blocks) )
  end if
  call this%setup_coarse_fe_space()
end subroutine par_fe_space_fill_dof_info

subroutine par_fe_space_fill_elem2dof_and_count_dofs( this, field_id ) 
  implicit none 
  ! Parameters
  class(par_fe_space_t)  , intent(inout) :: this  
  integer(ip)                , intent(in)    :: field_id

  ! Local variables
  integer(ip) :: ivef, vef_lid, ighost, ielem, elem_id, ivef_in_source_fe
  integer(ip) :: num_elems, num_ghosts
  integer(ip) :: first_face_id, num_faces
  integer(ip) :: iblock, init_dof_block, current_dof_block
  
  type(fe_iterator_t)     :: fe_iterator
  type(fe_accessor_t)     :: fe
  type(fe_accessor_t)     :: source_fe
  type(fe_vef_accessor_t) :: vef 

#ifdef DEBUG
  type(par_environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_task() )
#endif  
  
  iblock            = this%field_blocks(field_id)
  init_dof_block    = this%number_dofs_per_block(iblock)
  current_dof_block = init_dof_block

  if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
     fe_iterator = this%create_fe_iterator()
     do while ( .not. fe_iterator%has_finished() )
        call fe_iterator%current(fe)
        if ( fe%is_ghost() ) then
          do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)
            if ( vef%is_at_interface() ) then
            
              ! Find local element around vef_lid in elem_id
              do ielem=1, vef%get_num_cells_around()
                call vef%get_cell_around(ielem, source_fe)
                if ( source_fe%is_local() ) then
                  ivef_in_source_fe = source_fe%find_lpos_vef_lid(vef%get_lid()) 
                  call fe%fill_own_dofs_on_vef_from_source_fe ( ivef, &
                                                                source_fe, & 
                                                                ivef_in_source_fe, &
                                                                field_id )    
                  exit
                end if
              end do
            end if
          end do
        end if
        call fe_iterator%next() 
     end do
  else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
  
     fe_iterator = this%create_fe_iterator()
     do while ( .not. fe_iterator%has_finished() )
        call fe_iterator%current(fe)
        if ( fe%is_ghost() ) then
          do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)
            if ( vef%is_face() .and. vef%is_at_interface() ) then
               call fe%fill_dofs_face_integration_coupling ( ivef, &
                                                             field_id, &
                                                             current_dof_block )
            end if
          end do
        end if
        call fe_iterator%next() 
     end do
  end if

  this%number_dofs_per_field(field_id) = this%number_dofs_per_field(field_id) + & 
       (current_dof_block - init_dof_block)
  this%number_dofs_per_block(iblock) = this%number_dofs_per_block(iblock) + &
       (current_dof_block - init_dof_block) 
end subroutine par_fe_space_fill_elem2dof_and_count_dofs

subroutine par_fe_space_renumber_dofs_first_interior_then_interface( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock
  integer(ip), allocatable :: perm_old2new_block(:)
  type(par_environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
    do iblock=1, this%get_number_blocks()
      call memalloc (this%number_dofs_per_block(iblock), perm_old2new_block, __FILE__, __LINE__)
      call this%blocks_dof_import(iblock)%fill_first_I_then_G_renumbering(perm_old2new_block)
      call this%renumber_dofs_block(iblock, perm_old2new_block)
      call this%blocks_dof_import(iblock)%renumber_dofs(perm_old2new_block)
      call memfree (perm_old2new_block, __FILE__, __LINE__)
    end do
  end if
end subroutine par_fe_space_renumber_dofs_first_interior_then_interface

subroutine par_fe_space_renumber_dofs_block (this, block_id, perm_old2new)
  implicit none
  class(par_fe_space_t)   , intent(inout) :: this
  integer(ip)                 , intent(in)    :: block_id
  integer(ip)                 , intent(in)    :: perm_old2new(this%number_dofs_per_block(block_id))
  call this%serial_fe_space_t%renumber_dofs_block(block_id, perm_old2new)
end subroutine par_fe_space_renumber_dofs_block

subroutine par_fe_space_compute_blocks_dof_import ( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)                          :: iblock    
  allocate ( this%blocks_dof_import(this%number_blocks) )
  do iblock=1, this%number_blocks
     call this%compute_dof_import(iblock)
  end do
end subroutine par_fe_space_compute_blocks_dof_import

subroutine par_fe_space_compute_dof_import ( this, iblock )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: iblock

  ! Local raw data
  integer(igp), allocatable    :: raw_interface_data(:,:)
  integer(ip) , allocatable    :: dofs_lid(:)
  integer(ip)                  :: total_ubound_num_itfc_couplings
  integer(ip)                  :: total_num_itfc_couplings
  integer(ip), allocatable     :: ubound_num_itfc_couplings(:)
  integer(ip)                  :: num_fe_spaces_in_iblock
  integer(ip)                  :: i, field_id
  type(par_environment_t), pointer :: par_environment
  type(par_context_t)    , pointer :: l1_context

  
  assert ( iblock >= 1 .and. iblock <= this%number_blocks )

  num_fe_spaces_in_iblock = 0
  do field_id = 1, this%number_fields
     if ( this%field_blocks(field_id) == iblock ) then
        num_fe_spaces_in_iblock = num_fe_spaces_in_iblock + 1
     end if
  end do

  call memalloc ( num_fe_spaces_in_iblock, ubound_num_itfc_couplings, __FILE__, __LINE__ )
  total_ubound_num_itfc_couplings = 0 
  ubound_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%number_fields
     if ( this%field_blocks(field_id) == iblock ) then
        if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
           ubound_num_itfc_couplings (i) = this%compute_ubound_num_itfc_couplings_by_continuity(field_id)
        else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
           ubound_num_itfc_couplings (i) = ubound_num_itfc_couplings (i) + &
                this%compute_ubound_num_itfc_couplings_by_face_integ(field_id)
        end if
        total_ubound_num_itfc_couplings = total_ubound_num_itfc_couplings + ubound_num_itfc_couplings (i)
        i=i+1                                  
     end if
  end do

  call memalloc ( num_rows_raw_interface_data, &
                  total_ubound_num_itfc_couplings, &
                  raw_interface_data, __FILE__, __LINE__ )

  call memalloc ( total_ubound_num_itfc_couplings, dofs_lid, __FILE__, __LINE__)

  total_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%number_fields
     if ( this%field_blocks(field_id) == iblock ) then
        if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
           total_num_itfc_couplings = total_num_itfc_couplings + & 
                this%compute_raw_interface_data_by_continuity(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_lid,&
                                                              raw_interface_data )
        else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
           total_num_itfc_couplings = total_num_itfc_couplings + & 
                this%compute_raw_interface_data_by_face_integ(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_lid,&
                                                              raw_interface_data )      
        end if

        i=i+1                                  
     end if
  end do

  par_environment => this%get_par_environment()
  l1_context => par_environment%get_l1_context()
  call this%blocks_dof_import(iblock)%create(l1_context%get_rank()+1, &
                                             l1_context%get_size(), &
                                             this%number_dofs_per_block(iblock), &
                                             total_num_itfc_couplings, &
                                             dofs_lid, &
                                             raw_interface_data )

  call memfree ( ubound_num_itfc_couplings, __FILE__, __LINE__ )                
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  call memfree ( dofs_lid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_dof_import

function pfs_compute_ubound_num_itfc_couplings_by_continuity( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_num_itfc_couplings_by_continuity

  integer(ip)  :: mypart_id, part_id, local_part_id
  integer(ip)  :: ivef, ielem

  integer(ip)                            :: result
  logical, allocatable                   :: touched_neighbours(:)
  logical                                :: vef_active
  type(par_context_t)          , pointer :: l1_context
  type(par_environment_t)      , pointer :: par_environment
  type(par_triangulation_t), pointer :: par_triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(itfc_fe_vef_iterator_t) :: itfc_vef_iterator
  type(fe_vef_accessor_t)      :: vef
  type(fe_accessor_t)          :: fe
  
  par_environment   => this%get_par_environment()
  par_triangulation => this%get_par_triangulation()
  cell_import       => par_triangulation%get_cell_import()
  assert ( par_environment%am_i_l1_task() )

  l1_context => par_environment%get_l1_context()
  mypart_id = l1_context%get_rank() + 1 

  call memalloc ( cell_import%get_number_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  
  itfc_vef_iterator = this%create_itfc_fe_vef_iterator()
  
  result = 0 
  ! Traverse vefs on the interface
  do while ( .not. itfc_vef_iterator%has_finished() )
     call itfc_vef_iterator%current(vef)
     touched_neighbours = .false.
     vef_active = .false. 

     do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        !if ( finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
        ! alert: something has to be done for null FEs
        ! if ( .not.finite_element%is_void ) 
        part_id = fe%get_mypart()
        if ( part_id == mypart_id ) then
           vef_active = .true.
           exit
        end if
     end do

     if ( vef_active ) then
        do ielem=1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem,fe)
           !if ( finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
           part_id = fe%get_mypart()
           if ( part_id /= mypart_id ) then
              local_part_id = cell_import%get_local_neighbour_id(part_id)
              if (.not. touched_neighbours (local_part_id)) then
                 touched_neighbours (local_part_id) = .true.
                 ivef = fe%find_lpos_vef_lid(vef%get_lid())
                 reference_fe => fe%get_reference_fe(field_id)
                 result = result + reference_fe%get_number_own_nodes_n_face(ivef)
              end if
           end if
           !end if
        end do
     end if
     
     call itfc_vef_iterator%next()
  end do
  pfs_compute_ubound_num_itfc_couplings_by_continuity = result

  call memfree ( touched_neighbours, __FILE__, __LINE__ )
end function pfs_compute_ubound_num_itfc_couplings_by_continuity


function pfs_compute_ubound_num_itfc_couplings_by_face_integ( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_num_itfc_couplings_by_face_integ

  integer(ip)  :: elem_lid
  integer(ip)  :: ivef_itfc, ielem, vef_lid
  integer(ip) :: result

  !assert ( associated (this%par_triangulation) )
  !assert ( par_environment%am_i_l1_task() )

  !result = 0 
  !! Traverse vefs on the interface
  !do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs 
  !   vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)
  !   ! Is current vef_lid a face ?
  !   if ( this%triangulation%vefs(vef_lid)%dime == this%triangulation%num_dims-1 ) then
  !      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
  !         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
  !         finite_element => this%get_finite_element(elem_lid)
  !         !if ( .not. finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() .and. &
  !         !     .not. finite_element%reference_fe_phy(fe_space_id)%p%get_conformity() ) then
  !         result = result + finite_element%reference_fe_phy(field_id)%p%get_face_integration_coupling_number_nodes_face( )
  !         !end if
  !      end do
  !   end if
  !   new_parfespace_compute_ubound_num_itfc_couplings_by_face_integ = result
  !end do

end function pfs_compute_ubound_num_itfc_couplings_by_face_integ

function par_fe_space_generate_non_consecutive_dof_gid (cell_gid, lpos_dof_elem2dof, field_id) result(dof_gid)
  implicit none
  integer(igp), intent(in) :: cell_gid
  integer(ip) , intent(in) :: lpos_dof_elem2dof
  integer(ip) , intent(in) :: field_id
  integer(igp)             :: dof_gid
  assert ( cell_gid_shift >= 1  )
  assert ( dofs_per_reference_fe_shift >= 1  )
  assert ( number_fields_shift >= 1 )
  assert ( cell_gid < ISHFT(int(1,igp),int(cell_gid_shift,igp) ) ) 
  assert ( lpos_dof_elem2dof < ISHFT(int(1,igp),int(dofs_per_reference_fe_shift,igp) ) )
  assert ( field_id < ISHFT(int(1,igp),int(number_fields_shift,igp) ) )
  dof_gid = (cell_gid-1) + &
            ISHFT(int(lpos_dof_elem2dof-1,igp),int(cell_gid_shift,igp)) + &
            ISHFT(int(field_id-1,igp),int(cell_gid_shift+dofs_per_reference_fe_shift,igp))
end function par_fe_space_generate_non_consecutive_dof_gid

! TBP temporarily required by type(mlbddc_t) in order to create
! distributed-memory linear algebra data structures
function par_fe_space_get_block_dof_import ( this, block_id )
  implicit none
  class(par_fe_space_t), target, intent(in) :: this
  integer(ip)                      , intent(in) :: block_id
  type(dof_import_t), pointer                   :: par_fe_space_get_block_dof_import
  par_fe_space_get_block_dof_import => this%blocks_dof_import(block_id)
end function par_fe_space_get_block_dof_import

function par_fe_space_get_num_dimensions ( this )
  implicit none
  class(par_fe_space_t), intent(in) :: this
  integer(ip)                       :: par_fe_space_get_num_dimensions
  type(par_environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     par_fe_space_get_num_dimensions = this%serial_fe_space_t%get_num_dimensions()
  end if
end function par_fe_space_get_num_dimensions

function par_fe_space_get_total_number_dofs ( this )
   implicit none
   class(par_fe_space_t), intent(in) :: this
   integer(ip) :: par_fe_space_get_total_number_dofs
   type(par_environment_t), pointer :: par_environment
   par_environment => this%get_par_environment()
   par_fe_space_get_total_number_dofs = 0
   if ( par_environment%am_i_l1_task() ) then
     par_fe_space_get_total_number_dofs = this%serial_fe_space_t%get_total_number_dofs()
   end if
end function par_fe_space_get_total_number_dofs

function par_fe_space_get_field_number_dofs( this, field_id )
   implicit none
   class(par_fe_space_t), intent(in) :: this
   integer(ip)          , intent(in) :: field_id
   integer(ip)                       :: par_fe_space_get_field_number_dofs
   type(par_environment_t), pointer  :: par_environment
   par_environment => this%get_par_environment()
   par_fe_space_get_field_number_dofs = 0
   if ( par_environment%am_i_l1_task() ) then
     par_fe_space_get_field_number_dofs = this%serial_fe_space_t%get_field_number_dofs(field_id)
   end if
end function par_fe_space_get_field_number_dofs

function par_fe_space_get_block_number_dofs ( this, block_id )
   implicit none
   class(par_fe_space_t), intent(in) :: this
   integer(ip)          , intent(in) :: block_id
   integer(ip)                       :: par_fe_space_get_block_number_dofs
   type(par_environment_t), pointer  :: par_environment
   par_environment => this%get_par_environment()
   par_fe_space_get_block_number_dofs = 0
   if ( par_environment%am_i_l1_task() ) then
     par_fe_space_get_block_number_dofs = this%serial_fe_space_t%get_block_number_dofs(block_id)
   end if
end function par_fe_space_get_block_number_dofs

function par_fe_space_get_total_number_interior_dofs ( this )
   implicit none
   class(par_fe_space_t), intent(in) :: this
   integer(ip)                       :: par_fe_space_get_total_number_interior_dofs
   type(par_environment_t), pointer  :: par_environment
   integer(ip) :: block_id
   par_environment => this%get_par_environment()
   par_fe_space_get_total_number_interior_dofs = 0
   if ( par_environment%am_i_l1_task() ) then
    do block_id = 1, this%get_number_blocks()
      par_fe_space_get_total_number_interior_dofs = par_fe_space_get_total_number_interior_dofs + &
                                                     this%get_block_number_interior_dofs(block_id)
    end do 
   end if
end function par_fe_space_get_total_number_interior_dofs 

function par_fe_space_get_total_number_interface_dofs ( this )
   implicit none
   class(par_fe_space_t), intent(in) :: this
   integer(ip)                       :: par_fe_space_get_total_number_interface_dofs
   type(par_environment_t), pointer  :: par_environment
   integer(ip) :: block_id
   par_environment => this%get_par_environment()
   par_fe_space_get_total_number_interface_dofs = 0
   if ( par_environment%am_i_l1_task() ) then
      do block_id = 1, this%get_number_blocks()
        par_fe_space_get_total_number_interface_dofs = par_fe_space_get_total_number_interface_dofs + &
                                                       this%get_block_number_interface_dofs(block_id)
      end do
   end if
end function par_fe_space_get_total_number_interface_dofs

function par_fe_space_get_block_number_interior_dofs ( this, block_id )
   implicit none
   class(par_fe_space_t), intent(in) :: this
   integer(ip)          , intent(in) :: block_id
   integer(ip)                       :: par_fe_space_get_block_number_interior_dofs
      type(par_environment_t), pointer  :: par_environment
   par_environment => this%get_par_environment()
   par_fe_space_get_block_number_interior_dofs = 0
   if ( par_environment%am_i_l1_task() ) then
     par_fe_space_get_block_number_interior_dofs = this%blocks_dof_import(block_id)%get_number_interior_dofs()
   end if
end function par_fe_space_get_block_number_interior_dofs

function par_fe_space_get_block_number_interface_dofs ( this, block_id )
   implicit none
   class(par_fe_space_t), intent(in) :: this
   integer(ip)          , intent(in) :: block_id
   integer(ip)                       :: par_fe_space_get_block_number_interface_dofs
   type(par_environment_t), pointer  :: par_environment
   par_environment => this%get_par_environment()
   par_fe_space_get_block_number_interface_dofs = 0
   if ( par_environment%am_i_l1_task() ) then
        par_fe_space_get_block_number_interface_dofs = this%blocks_dof_import(block_id)%get_number_interface_dofs()
   end if
end function par_fe_space_get_block_number_interface_dofs

  ! Although in principle this%fe_space_type_per_field(:) was though to be
  ! private member variable, I had to make it visible to the exterior
  ! via a raw pointer it as type(mlbddc_coarse_t) requires it in order to construct 
  ! the type(par_fe_space_t) instance that it aggregrates. Perhaps there is a 
  ! better/cleaner solution, but at the present moment, this is the only solution 
  ! that comes into my mind and lets me advance
  function par_fe_space_get_fe_space_type (this)
    implicit none
    class(par_fe_space_t), target, intent(in) :: this
    integer(ip), pointer :: par_fe_space_get_fe_space_type(:)
    par_fe_space_get_fe_space_type => this%fe_space_type_per_field
  end function par_fe_space_get_fe_space_type

function par_fe_space_get_number_fe_objects ( this )
  implicit none
  class(par_fe_space_t), intent(in) :: this
  integer(ip) :: par_fe_space_get_number_fe_objects
  par_fe_space_get_number_fe_objects = this%triangulation%get_number_objects()
end function par_fe_space_get_number_fe_objects 


function par_fe_space_compute_raw_interface_data_by_continuity (  this, &
                                                                      field_id, &
                                                                      offset, &
                                                                      ubound_num_itfc_couplings, &
                                                                      dofs_lid, &
                                                                      raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_lid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: istat
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id, elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_interior, dof_lid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts, local_part_id, ipart

  integer(igp)              :: max_elem_gid
  integer(ip)               :: max_part_id
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  integer(ip) , allocatable :: dofs_max_part_id(:)
  logical     , allocatable :: touched_neighbours(:)
  integer(ip), allocatable  :: parts_visited(:)

  type(par_context_t)          , pointer :: l1_context
  type(par_environment_t)      , pointer :: par_environment
  type(par_triangulation_t), pointer :: par_triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator
  type(itfc_fe_vef_iterator_t)           :: itfc_vef_iterator
  type(fe_vef_accessor_t)                :: vef
  type(fe_accessor_t)                    :: fe
  type(i1p_t)              , allocatable :: elem2dof(:)


  par_environment   => this%get_par_environment()
  par_triangulation => this%get_par_triangulation()
  cell_import       => par_triangulation%get_cell_import()
  assert ( par_environment%am_i_l1_task() )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( this%number_dofs_per_block(this%field_blocks(field_id)), local_idof, __FILE__, __LINE__ )
  call memalloc ( this%number_dofs_per_block(this%field_blocks(field_id)), lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, __FILE__, __LINE__ )

  call memalloc ( cell_import%get_number_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  call memalloc ( cell_import%get_number_neighbours(), &
                  parts_visited, &
                  __FILE__, __LINE__ )
  
  allocate ( elem2dof(this%number_fields), stat=istat ) 
  check (istat==0)
  
  l1_context => par_environment%get_l1_context()
  mypart_id = l1_context%get_rank() + 1
  
  current_col  = offset + 1
  local_idof   = 0
  
  itfc_vef_iterator = this%create_itfc_fe_vef_iterator()

  ! Traverse vefs on the interface
  do while ( .not. itfc_vef_iterator%has_finished() )
     call itfc_vef_iterator%current(vef)
     touched_neighbours = .false.
     num_parts = 0
     max_part_id = mypart_id
     max_elem_gid = 0

     num_dofs_current_vef = 0
     ! Identify the total set of dofs in current vef
     do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        !if ( finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
        part_id = fe%get_mypart()
        elem_gid = fe%get_gid()
        ivef = fe%find_lpos_vef_lid(vef%get_lid())
        call fe%get_elem2dof( elem2dof )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof =  own_dofs_on_vef_iterator%get_current()
           dof_lid = elem2dof(field_id)%p(idof)
           if ( dof_lid <= 0 ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           if ( elem_gid >= max_elem_gid ) then
              max_elem_gid = elem_gid
              if ( local_idof(dof_lid) == 0 ) then
                 num_dofs_current_vef = num_dofs_current_vef + 1    
                 lst_dofs_current_vef (num_dofs_current_vef) = dof_lid
              end if
              local_idof(dof_lid) = idof
           end if
           if ( part_id /= mypart_id ) then 
              local_part_id = cell_import%get_local_neighbour_id(part_id)
              if ( .not. touched_neighbours(local_part_id) ) then
                 touched_neighbours (local_part_id) = .true.
                 num_parts = num_parts + 1
                 parts_visited (num_parts) = part_id
                 max_part_id = max(part_id, max_part_id)
              end if
           end if
           call own_dofs_on_vef_iterator%next()
        end do
        !end if
     end do

     init_col = current_col
     do idof=1, num_dofs_current_vef
        dof_lid = lst_dofs_current_vef(idof)
        do ipart=1, num_parts
           part_id = parts_visited(ipart)
           dofs_lid ( current_col ) = dof_lid 
           dofs_max_part_id ( current_col-offset ) = max_part_id
           raw_interface_data(neighbor_part_id_row, current_col) = part_id
           raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_gid(max_elem_gid, &
                                                                                                local_idof(dof_lid), &
                                                                                                field_id)
           raw_interface_data(owner_flag_row, current_col) = num_parts + 1
           current_col = current_col + 1
        end do
     end do
     call itfc_vef_iterator%next()
  end do

  deallocate(elem2dof, stat=istat ) 
  check (istat==0)
  
  ! Free touch arrays
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( parts_visited, __FILE__, __LINE__ )
  call memfree ( touched_neighbours, __FILE__, __LINE__ )

  call this%raw_interface_data_by_continuity_decide_owner (offset, &
                                                           current_col-1, &
                                                           raw_interface_data,&
                                                           dofs_max_part_id,&
                                                           dofs_lid)

  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )

  num_itfc_couplings = current_col-1 
end function par_fe_space_compute_raw_interface_data_by_continuity

subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner ( this, &
                                                                        offset, &
                                                                        num_cols, &
                                                                        raw_interface_data, &
                                                                        dofs_max_part_id,  &
                                                                        dofs_lid)
  implicit none
  class(par_fe_space_t), intent(in)    :: this
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: num_cols
  integer(igp)         , intent(inout) :: raw_interface_data(:,:)
  integer(ip)          , intent(inout) :: dofs_max_part_id(:)
  integer(ip)          , intent(inout) :: dofs_lid(:)

  integer(igp)                 :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)
  integer(ip) , allocatable    :: perm(:)
  integer(ip) , allocatable    :: aux(:)
  integer(ip)                  :: start_col, end_col, col, mypart_id, ipart_max, j, size
  type(par_environment_t), pointer :: par_environment
  type(par_context_t)    , pointer :: l1_context


  !do col=1,num_cols
  !  write(*,"(10i10)") col, dofs_lid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  !end do 
  !write(*,*) '============================================================================='

  if ( num_cols-offset == 0 ) return
  
  call memalloc ( num_cols-offset, aux, __FILE__, __LINE__ )
  call memalloc ( num_cols-offset, perm, __FILE__, __LINE__ )
  do col=1, num_cols-offset
     perm(col) = col
  end do

  ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
                                       num_rows_raw_interface_data, &
                                       num_cols-offset, &
                                       raw_interface_data(1:,offset+1:num_cols), &
                                       perm, &
                                       l1, &
                                       l2)

  aux = dofs_max_part_id(1:num_cols-offset)
  do col=1, num_cols-offset
     dofs_max_part_id(col) = aux(perm(col))
  end do

  aux = dofs_lid(offset+1:num_cols)
  do col=1, num_cols-offset
     dofs_lid(offset+col) = aux(perm(col))
  end do

  call memfree ( perm, __FILE__, __LINE__ )
  call memfree ( aux, __FILE__, __LINE__ )

  par_environment => this%get_par_environment()
  l1_context => par_environment%get_l1_context()
  mypart_id = l1_context%get_rank() + 1

  col = offset + 1
  do while ( col <= num_cols ) 
     if ( raw_interface_data ( owner_flag_row, col ) == 2 ) then
        start_col = col
        do while  (raw_interface_data ( owner_flag_row, col ) == 2)
           col = col + 1
           if ( col > num_cols ) exit
        end do
        end_col = col - 1

        ipart_max = dofs_max_part_id(start_col-offset)
        size = end_col - start_col + 1
        if ( mypart_id == ipart_max ) then
           do j= start_col, start_col + size/2 -1
              raw_interface_data ( owner_flag_row, j) = owner
           end do
           do j= start_col + size/2,  end_col
              raw_interface_data ( owner_flag_row, j) = non_owner
           end do
        else
           do j= start_col, start_col + size/2 -1
              raw_interface_data ( owner_flag_row, j) = non_owner
           end do
           do j= start_col + size/2,  end_col
              raw_interface_data ( owner_flag_row, j) = owner
           end do
        end if
     else
        if ( mypart_id == dofs_max_part_id(col-offset) ) then
           raw_interface_data ( owner_flag_row, col) = owner
        else
           if ( raw_interface_data ( neighbor_part_id_row, col) == dofs_max_part_id(col-offset) ) then
              raw_interface_data ( owner_flag_row, col) = non_owner
           else
              raw_interface_data ( owner_flag_row, col) = uncoupled
           end if
        end if
        col = col +1
     end if

  end do

  !do col=1,num_cols
  !  write(*,"(10i10)") col, dofs_lid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  !end do 

end subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner

function par_fe_space_compute_raw_interface_data_by_face_integ ( this, &
                                                                 fe_space_id, &
                                                                 offset, &
                                                                 ubound_num_itfc_couplings, &
                                                                 dofs_lid, &
                                                                 raw_interface_data) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_lid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_face, dof_lid
  integer(ip)  :: current_col
  integer(igp) :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)
  type(par_context_t)   , pointer :: l1_context


  !assert ( associated (this%par_triangulation) )
  !assert ( par_environment%am_i_l1_task() )

  !l1_context => par_environment%get_l1_context()
  !mypart_id = l1_context%get_rank() + 1 
  !current_col = offset + 1

  !! Traverse vefs on the interface
  !do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
  !   vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)

  !   ! Is current vef_lid a face ?
  !   if ( this%triangulation%vefs(vef_lid)%dime == this%triangulation%num_dims-1 ) then
  !      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
  !         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
  !         if ( this%par_triangulation%elems(elem_lid)%mypart /= mypart_id ) then
  !            part_id = this%par_triangulation%elems(elem_lid)%mypart
  !         end if
  !      end do

  !      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
  !         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
  !         elem_gid = this%par_triangulation%elems(elem_lid)%globalID
  !         finite_element => this%get_finite_element(elem_lid)
  !         ivef = finite_element%cell%find_local_pos_from_vef_id(vef_lid)
  !         do idof_face=1, finite_element%reference_fe_phy(fe_space_id)%p%get_face_integration_coupling_number_nodes_face()
  !            idof = finite_element%reference_fe_phy(fe_space_id)%p%get_face_integration_coupling_node_face(idof_face,ivef)
  !            dof_lid = finite_element%elem2dof(fe_space_id)%p(idof)
  !            dofs_lid ( current_col ) = dof_lid 
  !            raw_interface_data(neighbor_part_id_row, current_col) = part_id
  !            raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_gid(elem_gid, idof, fe_space_id)
  !            if ( mypart_id == this%par_triangulation%elems(elem_lid)%mypart ) then
  !               raw_interface_data(owner_flag_row,current_col) = owner
  !            else
  !               raw_interface_data(owner_flag_row,current_col) = non_owner
  !            end if
  !            current_col = current_col + 1
  !         end do
  !      end do
  !   end if
  !end do

  !num_itfc_couplings = current_col-offset-1

  !if ( num_itfc_couplings > 0 ) then
  !   ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  !   ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  !   call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
  !                                        num_rows_raw_interface_data, &
  !                                        num_itfc_couplings, &
  !                                        raw_interface_data(1:,offset+1:current_col-1), &
  !                                        dofs_lid(offset+1:current_col-1), &
  !                                        l1, &
  !                                        l2)
  !end if                                        
  !!do current_col=1,num_itfc_couplings 
  !!  write(*,"(10i10)") current_col, dofs_lid(current_col), raw_interface_data(:,current_col)
  !!end do 

end function par_fe_space_compute_raw_interface_data_by_face_integ


function par_fe_space_create_assembler(this, &
     diagonal_blocks_symmetric_storage,&
     diagonal_blocks_symmetric, & 
     diagonal_blocks_sign)
  implicit none
  class(par_fe_space_t)             , intent(in) :: this
  logical                           , intent(in) :: diagonal_blocks_symmetric_storage(:)
  logical                           , intent(in) :: diagonal_blocks_symmetric(:)
  integer(ip)                       , intent(in) :: diagonal_blocks_sign(:)
  class(matrix_array_assembler_t)   , pointer    :: par_fe_space_create_assembler

  ! Locals
  class(matrix_t), pointer :: matrix
  class(array_t) , pointer :: array
  type(par_environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if (this%number_blocks == 1) then
     allocate ( par_sparse_matrix_array_assembler_t :: par_fe_space_create_assembler )
     allocate ( par_sparse_matrix_t :: matrix )
     allocate ( par_scalar_array_t  :: array )
     select type(matrix)
        class is(par_sparse_matrix_t)
        call matrix%create(par_environment, &
             this%blocks_dof_import(1), &
             diagonal_blocks_symmetric_storage(1),&
             diagonal_blocks_symmetric(1),&
             diagonal_blocks_sign(1))
        class default
        check(.false.)
     end select
     select type(array)
        class is(par_scalar_array_t)
        call array%create(par_environment, &
             this%blocks_dof_import(1))
        class default
        check(.false.)
     end select
  else
     check(.false.)
  end if
  call par_fe_space_create_assembler%set_matrix(matrix)
  call par_fe_space_create_assembler%set_array(array)
end function par_fe_space_create_assembler


subroutine par_fe_space_symbolic_setup_assembler(this,matrix_array_assembler)
  implicit none
  class(par_fe_space_t)        , intent(in)    :: this
  class(matrix_array_assembler_t) , intent(inout) :: matrix_array_assembler
end subroutine par_fe_space_symbolic_setup_assembler

subroutine par_fe_space_create_dof_values(this, dof_values)
  implicit none
  class(par_fe_space_t)       , intent(in)    :: this
  class(vector_t), allocatable, intent(inout) :: dof_values
  integer(ip) :: istat
  type(par_environment_t), pointer :: par_environment
  
  if (allocated(dof_values)) then
    call dof_values%free()
    deallocate(dof_values, stat=istat); check(istat==0);
  end if
  
  par_environment => this%get_par_environment()
  if (this%number_blocks == 1) then
       allocate ( par_scalar_array_t  :: dof_values )
       select type(dof_values)
       class is(par_scalar_array_t)
          call dof_values%create_and_allocate(par_environment, this%blocks_dof_import(1))
       class default
       check(.false.)
       end select
  else
      check(.false.)
  end if
  
end subroutine par_fe_space_create_dof_values

subroutine par_fe_space_interpolate_dirichlet_values(this, conditions, time)
  implicit none
  class(par_fe_space_t)     , intent(inout) :: this
  class(conditions_t)       , intent(in)    :: conditions 
  real(rp), optional        , intent(in)    :: time
  type(par_environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%interpolate_dirichlet_values(conditions,time)
  end if
end subroutine par_fe_space_interpolate_dirichlet_values

 subroutine par_fe_space_setup_coarse_dofs ( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)                       :: istat, field_id
  type(par_environment_t), pointer  :: par_environment
  type(fe_object_accessor_t)        :: coarse_n_face
  integer(ip)                       :: coarse_dof_lid
  integer(ip)                       :: coarse_n_face_lid

  assert ( this%number_fields == 1 )
  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_task() )   
  
  call this%free_coarse_dofs()
  
  call memalloc ( this%number_fields+1, this%ptr_coarse_dofs_per_field, __FILE__, __LINE__ )
    
  allocate ( this%coarse_dof_gids_per_field(this%number_fields), stat=istat )
  check ( istat == 0 )
  
  allocate ( this%own_coarse_dofs_per_field(this%number_fields), stat=istat )
  check ( istat == 0 )
  
  ! Count how many coarse DoFs there are per field
  this%ptr_coarse_dofs_per_field(1) = 1
  do field_id=1, this%number_fields
    this%ptr_coarse_dofs_per_field(field_id+1) = this%ptr_coarse_dofs_per_field(field_id) + &
                                                 this%coarse_fe_handler%get_num_coarse_dofs(this)
  end do
  
  call memalloc ( this%ptr_coarse_dofs_per_field(this%number_fields+1)-1, &
                  this%lst_coarse_dofs, __FILE__, __LINE__ )
  
  ! Enumerate coarse DoFs and map them to coarse n_faces
  do field_id=1, this%number_fields
      call this%coarse_fe_handler%setup_coarse_dofs(this)
  end do
  
  ! Generate a global numbering for the coarse DoFs
  call coarse_n_face%create(1, this)
  do field_id=1, this%number_fields
   do coarse_dof_lid=1, this%ptr_coarse_dofs_per_field(field_id+1)-this%ptr_coarse_dofs_per_field(field_id)
	    !coarse_n_face_lid = this%coarse_n_face_lids_coarse_dofs_per_field(field_id)%a(coarse_dof_lid)
		   !call coarse_n_face%set_lid(coarse_n_face_lid)
		   !this%coarse_dof_gids_per_field(field_id)%a(coarse_dof_lid) = coarse_n_face%get_gid()
	  end do
  end do
end subroutine par_fe_space_setup_coarse_dofs

subroutine par_fe_space_free_coarse_dofs(this)
    implicit none
    class(par_fe_space_t)           , intent(inout) :: this
    integer(ip)                               :: i, istat 
        
    if (allocated(this%ptr_coarse_dofs_per_field)) then 
      call memfree ( this%ptr_coarse_dofs_per_field, __FILE__, __LINE__ )
    end if
    
    if (allocated(this%lst_coarse_dofs)) then 
      call memfree ( this%lst_coarse_dofs, __FILE__, __LINE__ )
    end if
  
    if (allocated(this%coarse_dof_gids_per_field)) then
      do i=1, size(this%coarse_dof_gids_per_field)
        call this%coarse_dof_gids_per_field(i)%free()
      end do  
      deallocate ( this%coarse_dof_gids_per_field, stat=istat )
      check (istat == 0)  
    end if
  
    if (allocated(this%own_coarse_dofs_per_field)) then
      do i=1, size(this%own_coarse_dofs_per_field)
        call this%own_coarse_dofs_per_field(i)%free()
      end do  
      deallocate ( this%own_coarse_dofs_per_field, stat=istat )
      check (istat == 0)  
    end if
end subroutine par_fe_space_free_coarse_dofs

subroutine par_fe_space_setup_constraint_matrix ( this, block_id, constraint_matrix )
   implicit none
   class(par_fe_space_t)     , intent(in)    :: this
   integer(ip)               , intent(in)        :: block_id
   type(coo_sparse_matrix_t) , intent(inout)     :: constraint_matrix
   
   real(rp)              :: constraint_matrix_entry
   integer(ip)           :: field_id
   integer(ip)           :: num_rows, num_cols 
   integer(ip)           :: row_offset, i, j
   integer(ip)           :: num_dofs_current_row
   type(list_iterator_t) :: dofs_on_current_object
   
   !assert ( this%number_fields == 1 )
   !assert ( block_id == 1 ) 
   !assert ( this%number_blocks == 1 )
   
   !! Free any dynamic memory that constraint_matrix may have inside
   !call constraint_matrix%free()
   
   !num_cols = this%number_dofs_per_block(block_id)

   !num_rows = 0
   !do field_id = 1, this%number_fields
   !  if ( this%field_blocks(field_id) == block_id  ) then
   !      num_rows = num_rows + this%fine_dofs_coarse_dofs_per_field(field_id)%get_num_pointers()
   !  end if
   !end do
   
   !! Create constraint matrix (transposed)
   !call constraint_matrix%create ( num_cols, num_rows )
   
   !! Fill constraint matrix entries (transposed)
   !row_offset = 0
   !do field_id = 1, this%number_fields
   !  if ( this%field_blocks(field_id) == block_id  ) then
   !      do i=1, this%fine_dofs_coarse_dofs_per_field(field_id)%get_num_pointers()
   !          dofs_on_current_object  = this%fine_dofs_coarse_dofs_per_field(field_id)%create_iterator(i)
   !          num_dofs_current_row    = dofs_on_current_object%get_size()
   !          constraint_matrix_entry = 1.0_rp/real(num_dofs_current_row,rp)
   !          do while ( .not. dofs_on_current_object%is_upper_bound() )
   !            j = dofs_on_current_object%get_current()
   !            call constraint_matrix%insert(j, row_offset+i, constraint_matrix_entry)
   !            call dofs_on_current_object%next()
   !          end do
   !      end do
   !      row_offset = row_offset + this%fine_dofs_coarse_dofs_per_field(field_id)%get_num_pointers()
   !  end if
   !end do
   !call constraint_matrix%sort_and_compress()
end subroutine par_fe_space_setup_constraint_matrix
   
subroutine par_fe_space_setup_coarse_fe_space(this)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)                           :: istat
  integer(ip)                           :: number_fields
  integer(ip), allocatable              :: fe_space_type_per_field(:)
  integer(ip), allocatable              :: ptr_dofs_per_fe_and_field(:)
  integer(ip), allocatable              :: coarse_dofs_gids_recv_counts(:)
  integer(ip), allocatable              :: coarse_dofs_gids_displs(:)
  integer(igp), allocatable             :: lst_dofs_gids(:)
  integer(igp), allocatable             :: lst_vefs_gids_dofs_objects(:)
  type(par_environment_t), pointer      :: par_environment
  type(par_triangulation_t), pointer    :: triangulation
  type(coarse_triangulation_t), pointer :: coarse_triangulation
  
  
  par_environment => this%get_par_environment()
  
   ! All MPI tasks (even if they are not involved in the L2 from L1 gather) should also allocate the
   ! allocatable arrays due to the fact that non-allocated allocatable arrays cannot
   ! be passed as actual arguments of dummy arguments that do not have the allocatable attribute 
   ! Otherwise, the code crashes with a segmentation fault.
   call memalloc (0, fe_space_type_per_field, __FILE__, __LINE__)
   call memalloc (0, ptr_dofs_per_fe_and_field, __FILE__, __LINE__)
   call memalloc (0, lst_dofs_gids, __FILE__, __LINE__)
   call memalloc (0, lst_vefs_gids_dofs_objects, __FILE__, __LINE__)
   call memalloc (0, coarse_dofs_gids_recv_counts, __FILE__, __LINE__)
   call memalloc (0, coarse_dofs_gids_displs, __FILE__, __LINE__)

   
  ! L2 tasks gather from L1 tasks all raw data required to set-up the coarse triangulation on L2 tasks
  if ( par_environment%am_i_l1_to_l2_task() ) then
     call this%transfer_number_fields(number_fields) 
     call this%transfer_fe_space_type(number_fields, fe_space_type_per_field)
     call this%gather_ptr_dofs_per_fe_and_field(number_fields, ptr_dofs_per_fe_and_field)
     call this%gather_coarse_dofs_gids_rcv_counts_and_displs (coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs)
     call this%gather_coarse_dofs_gids(coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs, lst_dofs_gids)
     call this%gather_vefs_gids_dofs_objects(coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs, lst_vefs_gids_dofs_objects)
  end if
  

  if ( par_environment%am_i_lgt1_task() ) then
     ! lgt1 MPI tasks (recursively) build coarse triangulation
     allocate  ( this%coarse_fe_space, stat = istat )
     check( istat == 0 )
     triangulation        => this%get_par_triangulation()
     coarse_triangulation => triangulation%get_coarse_triangulation()
     call this%coarse_fe_space%create (coarse_triangulation, &
                                       number_fields, &
                                       fe_space_type_per_field, &
                                       ptr_dofs_per_fe_and_field, &
                                       lst_dofs_gids, &
                                       lst_vefs_gids_dofs_objects)
  else
     ! L1 tasks do not hold any piece of the coarse triangulation
     nullify(this%coarse_fe_space)
  end if

  ! All tasks free raw data (see actual reason on the top part of this subroutine)
  call memfree (fe_space_type_per_field, __FILE__, __LINE__)
  call memfree (ptr_dofs_per_fe_and_field, __FILE__, __LINE__)
  call memfree (lst_dofs_gids, __FILE__, __LINE__)
  call memfree (lst_vefs_gids_dofs_objects, __FILE__, __LINE__)
  call memfree (coarse_dofs_gids_recv_counts, __FILE__, __LINE__)
  call memfree (coarse_dofs_gids_displs, __FILE__, __LINE__)
end subroutine par_fe_space_setup_coarse_fe_space

subroutine par_fe_space_transfer_number_fields ( this, number_fields )
  implicit none
  class(par_fe_space_t)   , intent(in)      :: this
  integer(ip)              , intent(out)     :: number_fields
  integer(ip)                                :: dummy_integer_ip
  type(par_environment_t), pointer           :: par_environment

  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_to_l2_task() )
  if ( par_environment%am_i_l1_to_l2_root() ) then
     call par_environment%l1_to_l2_transfer(input_data=dummy_integer_ip, &
                                            output_data=number_fields)
  else
     number_fields = this%get_number_fields()
     call par_environment%l1_to_l2_transfer(input_data=number_fields, &
                                            output_data=dummy_integer_ip) 
  end if
end subroutine par_fe_space_transfer_number_fields

subroutine par_fe_space_transfer_fe_space_type ( this, number_fields, fe_space_type_per_field )
  implicit none
  class(par_fe_space_t)   , intent(in)    :: this
  integer(ip)             , intent(in)       :: number_fields
  integer(ip), allocatable, intent(inout)    :: fe_space_type_per_field(:)
  integer(ip)                                :: dummy_integer_array_ip(0)
  type(par_environment_t), pointer           :: par_environment

  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_to_l2_task() )
  if ( par_environment%am_i_l1_to_l2_root() ) then
     if ( allocated (fe_space_type_per_field) ) call memfree ( fe_space_type_per_field, __FILE__, __LINE__ )
     call memalloc ( number_fields, fe_space_type_per_field, __FILE__, __LINE__ )
     call par_environment%l1_to_l2_transfer(input_data=dummy_integer_array_ip, &
                                            output_data=fe_space_type_per_field)
  else
     call par_environment%l1_to_l2_transfer(input_data=this%get_fe_space_type(), &
                                            output_data=dummy_integer_array_ip) 
  end if
end subroutine par_fe_space_transfer_fe_space_type

subroutine par_fe_space_gather_ptr_dofs_per_fe_and_field( this, number_fields, ptr_dofs_per_fe_and_field )
  implicit none
  class(par_fe_space_t)   , intent(in)       :: this
  integer(ip)             , intent(in)       :: number_fields
  integer(ip), allocatable, intent(inout)    :: ptr_dofs_per_fe_and_field(:)
  integer(ip)                                :: i, num_local_cells
  integer(ip)                                :: dummy_integer_array(0)
  type(par_environment_t), pointer           :: par_environment
  type(par_triangulation_t), pointer         :: triangulation
  type(coarse_triangulation_t), pointer      :: coarse_triangulation
  
  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_to_l2_task() )
  if ( par_environment%am_i_l1_to_l2_root() ) then
     triangulation => this%get_par_triangulation()
     coarse_triangulation => triangulation%get_coarse_triangulation()
     num_local_cells = coarse_triangulation%get_num_local_cells()
     if (allocated(ptr_dofs_per_fe_and_field)) call memfree ( ptr_dofs_per_fe_and_field, __FILE__, __LINE__ )
     call memalloc (num_local_cells*(number_fields+1), ptr_dofs_per_fe_and_field, __FILE__, __LINE__ )
     call par_environment%l2_from_l1_gather( input_data_size = number_fields, &
                                             input_data      = [((0), i=1,number_fields)], &
                                             output_data     = ptr_dofs_per_fe_and_field(2:))
     ptr_dofs_per_fe_and_field(1) = 1
     do i=1, num_local_cells*number_fields
       ptr_dofs_per_fe_and_field(i+1) = ptr_dofs_per_fe_and_field(i) + ptr_dofs_per_fe_and_field(i+1)
     end do
  else
     call par_environment%l2_from_l1_gather( input_data_size = this%get_number_fields(), &
                                             input_data      = this%ptr_coarse_dofs_per_field, &
                                             output_data     = dummy_integer_array )
  end if
end subroutine par_fe_space_gather_ptr_dofs_per_fe_and_field

  subroutine par_fe_space_gather_coarse_dofs_gids_rcv_counts_and_displs( this, recv_counts, displs )
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    integer(ip) , allocatable , intent(inout) :: recv_counts(:) 
    integer(ip) , allocatable , intent(inout) :: displs(:)
    integer(ip)                               :: i
    integer(ip)                               :: l1_to_l2_size
    integer(ip)                               :: dummy_integer_array(0)
    type(par_environment_t), pointer          :: par_environment

    par_environment => this%get_par_environment()
    assert ( par_environment%am_i_l1_to_l2_task() )
    if ( par_environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = par_environment%get_l1_to_l2_size()
      if ( allocated (recv_counts) ) call memfree ( recv_counts, __FILE__, __LINE__ )
      if ( allocated (displs) ) call memfree ( displs, __FILE__, __LINE__ )
      call memalloc ( l1_to_l2_size, recv_counts, __FILE__, __LINE__ )
      call memalloc ( l1_to_l2_size, displs, __FILE__, __LINE__ )
      call par_environment%l2_from_l1_gather( input_data = 0, &
                                                           output_data = recv_counts ) 
      displs(1) = 0
      do i=2, l1_to_l2_size
        displs(i) = displs(i-1) + recv_counts(i-1)
      end do
    else
      call par_environment%l2_from_l1_gather( input_data  = sum(this%ptr_coarse_dofs_per_field), &
                                                           output_data = dummy_integer_array ) 
    end if
  end subroutine par_fe_space_gather_coarse_dofs_gids_rcv_counts_and_displs
  
  subroutine par_fe_space_gather_coarse_dofs_gids ( this, recv_counts, displs, lst_gids )
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    integer(ip)               , intent(in)    :: recv_counts(:)
    integer(ip)               , intent(in)    :: displs(:)
    integer(igp), allocatable , intent(inout) :: lst_gids(:)
    integer(ip)                               :: l1_to_l2_size
    integer(igp)                              :: dummy_integer_array_igp(0)
    integer(ip)                               :: dummy_integer_array_ip(0)
    type(par_environment_t), pointer          :: par_environment
    integer(ip)                               :: i, spos, epos
    integer(igp), allocatable                 :: buffer(:)
    
    par_environment => this%get_par_environment()
    assert ( par_environment%am_i_l1_to_l2_task() )
    if ( par_environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = par_environment%get_l1_to_l2_size()
      if (allocated(lst_gids)) call memfree ( lst_gids, __FILE__, __LINE__ )
      call memalloc ( displs(l1_to_l2_size), lst_gids, __FILE__, __LINE__ )
      call par_environment%l2_from_l1_gather( input_data_size = 0, &
                                              input_data      = dummy_integer_array_igp, &
                                              recv_counts     = recv_counts, &
                                              displs          = displs, &
                                              output_data     = lst_gids )
    else
      ! Pack dofs_objects_gids_per_field(:) into plain buffer for further data exchange
      call memalloc ( sum(this%ptr_coarse_dofs_per_field), buffer, __FILE__, __LINE__ ) 
      spos = 1
      do i=1, this%get_number_fields()
        epos = spos + this%ptr_coarse_dofs_per_field(i)-1
        buffer(spos:epos) = this%coarse_dof_gids_per_field(i)%a
        spos = epos +1 
      end do
    
      call par_environment%l2_from_l1_gather( input_data_size = size(buffer), &
                                              input_data      = buffer, &
                                              recv_counts     = dummy_integer_array_ip, &
                                              displs          = dummy_integer_array_ip, &
                                              output_data     = dummy_integer_array_igp )
      call memfree ( buffer, __FILE__, __LINE__ )
    end if    
  end subroutine par_fe_space_gather_coarse_dofs_gids

  subroutine par_fe_space_gather_vefs_gids_dofs_objects ( this, recv_counts, displs, vef_gids )
    implicit none
    class(par_fe_space_t)     , intent(in)   :: this
    integer(ip)               , intent(in)    :: recv_counts(:)
    integer(ip)               , intent(in)    :: displs(:)
    integer(igp), allocatable , intent(inout) :: vef_gids(:)
    integer(ip)                               :: l1_to_l2_size
    integer(igp)                              :: dummy_integer_array_igp(0)
    integer(ip)                               :: dummy_integer_array_ip(0)
    type(par_environment_t), pointer          :: par_environment
    integer(ip)                               :: i, j, spos, epos
    integer(igp), allocatable                 :: buffer(:)
    
    par_environment => this%get_par_environment()
    assert ( par_environment%am_i_l1_to_l2_task() )
    if ( par_environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = par_environment%get_l1_to_l2_size()
      if (allocated(vef_gids)) call memfree ( vef_gids, __FILE__, __LINE__ )
      call memalloc ( displs(l1_to_l2_size), vef_gids, __FILE__, __LINE__ )
      call par_environment%l2_from_l1_gather( input_data_size = 0, &
                                                           input_data      = dummy_integer_array_igp, &
                                                           recv_counts     = recv_counts, &
                                                           displs          = displs, &
                                                           output_data     = vef_gids )
    else
      ! Pack vefs_lids_dofs_objects_per_field(:) into plain buffer for further data exchange
      call memalloc ( this%ptr_coarse_dofs_per_field(this%number_fields+1)-1, buffer, __FILE__, __LINE__ )
      do i=1, this%get_number_fields()
        spos = this%ptr_coarse_dofs_per_field(i)
        epos = this%ptr_coarse_dofs_per_field(i+1)-1
        buffer(spos:epos) = this%coarse_dof_gids_per_field(i)%a
      end do
    
      call par_environment%l2_from_l1_gather( input_data_size = size(buffer), &
                                              input_data      = buffer, &
                                              recv_counts     = dummy_integer_array_ip, &
                                              displs          = dummy_integer_array_ip, &
                                              output_data     = dummy_integer_array_igp )
      
      call memfree ( buffer, __FILE__, __LINE__ )
    end if    
  end subroutine par_fe_space_gather_vefs_gids_dofs_objects
  
  function par_fe_space_get_total_number_coarse_dofs ( this )
    implicit none
    class(par_fe_space_t)           , intent(in) :: this
    integer(ip)                               :: par_fe_space_get_total_number_coarse_dofs
    integer(ip)                               :: field_id
    
    par_fe_space_get_total_number_coarse_dofs = 0
    do field_id = 1, this%get_number_fields()
       par_fe_space_get_total_number_coarse_dofs = par_fe_space_get_total_number_coarse_dofs + & 
                                                   this%ptr_coarse_dofs_per_field(field_id)
    end do
  end function par_fe_space_get_total_number_coarse_dofs
  
  function par_fe_space_get_block_number_coarse_dofs ( this, block_id )
    implicit none
    class(par_fe_space_t)           , intent(in)    :: this
    integer(ip)               , intent(in)    :: block_id
    integer(ip)                               :: par_fe_space_get_block_number_coarse_dofs 
    integer(ip)                               :: field_id
    assert ( block_id == 1 )
    par_fe_space_get_block_number_coarse_dofs = 0
    do field_id = 1, this%get_number_fields()
       if ( this%field_blocks(field_id) == block_id ) then
         par_fe_space_get_block_number_coarse_dofs = par_fe_space_get_block_number_coarse_dofs + & 
                                                     this%ptr_coarse_dofs_per_field(field_id)
       end if                                      
    end do
  end function par_fe_space_get_block_number_coarse_dofs
  
  function par_fe_space_get_coarse_fe_handler ( this, field_id ) 
    implicit none
	class(par_fe_space_t), target, intent(in) :: this
	integer(ip)                  , intent(in) :: field_id
	class(l1_coarse_fe_handler_t), pointer :: par_fe_space_get_coarse_fe_handler
	par_fe_space_get_coarse_fe_handler => this%coarse_fe_handler
  end function par_fe_space_get_coarse_fe_handler
  
 function par_fe_space_create_fe_object_iterator (this)
    implicit none
    class(par_fe_space_t), intent(in) :: this
    type(fe_object_iterator_t) :: par_fe_space_create_fe_object_iterator
    call par_fe_space_create_fe_object_iterator%create(1,this)
 end function par_fe_space_create_fe_object_iterator
  
 function par_fe_space_create_fe_vefs_on_object_iterator(this, lid)
    implicit none
    class(par_fe_space_t), intent(in) :: this
    integer(ip)              , intent(in) :: lid
    type(fe_vefs_on_object_iterator_t) :: par_fe_space_create_fe_vefs_on_object_iterator
    call par_fe_space_create_fe_vefs_on_object_iterator%create(lid, this)
 end function par_fe_space_create_fe_vefs_on_object_iterator
