! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine par_fe_space_serial_create_same_reference_fes_on_all_cells( this, &
                                                                       triangulation, &
                                                                       conditions, &
                                                                       reference_fes )
                                                                      
  implicit none
  class(par_fe_space_t)                     , intent(inout)  :: this
  class(base_static_triangulation_t), target, intent(in)     :: triangulation
  class(conditions_t)                       , intent(in)     :: conditions
  type(p_reference_fe_t)                    , intent(in)     :: reference_fes(:)
  assert(.false.)
end subroutine par_fe_space_serial_create_same_reference_fes_on_all_cells

subroutine par_fe_space_serial_create_different_between_cells( this, &
     triangulation, &
     conditions, &
     reference_fes, &
     set_ids_to_reference_fes )
  implicit none
  class(par_fe_space_t)                    , intent(inout) :: this
  class(base_static_triangulation_t), target  , intent(in)    :: triangulation
  class(conditions_t)                         , intent(in)    :: conditions
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  check(.false.)
end subroutine par_fe_space_serial_create_different_between_cells

subroutine par_fe_space_create_same_reference_fes_on_all_cells( this, &
                                                                triangulation, &
                                                                conditions, &
                                                                reference_fes, &
                                                                coarse_fe_handlers, &
                                                                field_blocks, &
                                                                field_coupling )
  implicit none
  class(par_fe_space_t)                     , intent(inout)  :: this
  class(base_static_triangulation_t), target, intent(in)     :: triangulation
  class(conditions_t)                       , intent(in)     :: conditions
  type(p_reference_fe_t)                    , intent(in)     :: reference_fes(:)
  type(p_l1_coarse_fe_handler_t)            , intent(in)     :: coarse_fe_handlers(:)
  integer(ip)                     , optional, intent(in)     :: field_blocks(:)
  logical                         , optional, intent(in)     :: field_coupling(:,:)

  type(environment_t), pointer :: par_environment 
  integer(ip)                  :: field_id

  call this%free()
  
  ! This is a little bit DIRTY. Many type(par_fe_space_t) TBPs require that 
  ! coarse-grid tasks also associate this (superclass') member variable to a 
  ! target
  this%triangulation     => triangulation
  par_environment    => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%create( triangulation, &
                                         conditions, &
                                         reference_fes )
     do field_id=1, this%get_number_fields()
       call this%set_up_strong_dirichlet_bcs_ghost_fes(field_id)
     end do  
  else
     ! This is a little bit DIRTY. mlbddc_t%create() requires that coarse-grid
     ! tasks also know how many fields there are
     this%number_fields = size(reference_fes)
     
     ! This is a little bit DIRTY. par_fe_space_t%create_global_fe_function()
     ! requires that strong_dirichlet_values is created and allocated
     call this%strong_dirichlet_values%create_and_allocate(0)
  end if
 
  call this%allocate_and_fill_coarse_fe_handlers(coarse_fe_handlers)
  
end subroutine par_fe_space_create_same_reference_fes_on_all_cells

subroutine par_fe_space_create_different_between_cells( this, &
                                                                triangulation, &
                                                                conditions, &
                                                                reference_fes, &
                                                                set_ids_to_reference_fes, &
                                                                coarse_fe_handlers )
                                                                
  implicit none
  class(par_fe_space_t)                     , intent(inout)  :: this
  class(base_static_triangulation_t), target, intent(in)     :: triangulation
  class(conditions_t)                       , intent(in)     :: conditions
  type(p_reference_fe_t)                    , intent(in)     :: reference_fes(:)
  integer(ip)                               , intent(in)     :: set_ids_to_reference_fes(:,:)
  type(p_l1_coarse_fe_handler_t)            , intent(in)     :: coarse_fe_handlers(:)

  type(environment_t), pointer :: par_environment
  integer(ip)                  :: field_id

  call this%free()

  ! This is a little bit DIRTY. Many type(par_fe_space_t) TBPs require that
  ! coarse-grid tasks also associate this (superclass') member variable to a
  ! target
  this%triangulation     => triangulation
  par_environment    => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%create( triangulation, &
                                         conditions, &
                                         reference_fes, &
                                         set_ids_to_reference_fes )
     do field_id=1, this%get_number_fields()
       call this%set_up_strong_dirichlet_bcs_ghost_fes(field_id)
     end do  
  else
     ! This is a little bit DIRTY. mlbddc_t%create() requires that coarse-grid
     ! tasks also know how many fields there are
     this%number_fields = size(set_ids_to_reference_fes,1)

     ! This is a little bit DIRTY. par_fe_space_t%create_global_fe_function()
     ! requires that strong_dirichlet_values is created and allocated
     call this%strong_dirichlet_values%create_and_allocate(0)
  end if

  call this%allocate_and_fill_coarse_fe_handlers(coarse_fe_handlers)

end subroutine par_fe_space_create_different_between_cells

subroutine par_fe_space_free( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat
  type(environment_t), pointer :: par_environment
  
  if ( associated (this%triangulation) ) then
     par_environment => this%get_par_environment()
     if ( par_environment%am_i_l1_task() ) then
        do i=1, size(this%blocks_dof_import)
           call this%blocks_dof_import(i)%free()
        end do
        deallocate(this%blocks_dof_import,stat=istat)
        check (istat==0)
        call this%serial_fe_space_t%free()
        call this%free_coarse_dofs()
        nullify(this%coarse_fe_space)
     else
        ! This is a little bit DIRTY. mlbddc%create() requires that the number of
        ! fields is also set on coarse-grid tasks
        this%number_fields = 0
        
        ! This is a little bit DIRTY. par_fe_space_t%create_global_fe_function()
        ! requires that strong_dirichlet_values is created and allocated
        call this%serial_fe_space_t%strong_dirichlet_values%free()
        
        if ( associated(this%coarse_fe_space) ) then
          call this%coarse_fe_space%free()
          deallocate (this%coarse_fe_space, stat=istat)
          check (istat==0)
        end if
        nullify(this%coarse_fe_space)
        
        deallocate(this%blocks_dof_import, stat=istat)
        check (istat==0)
     end if
     nullify(this%triangulation)
     nullify(this%block_layout)
     call this%free_coarse_fe_handlers()
  end if

end subroutine par_fe_space_free

! Required (at least) by type(mlbddc_t)
function par_fe_space_get_par_environment(this)
  implicit none
  class(par_fe_space_t), intent(in) :: this
  type(environment_t), pointer :: par_fe_space_get_par_environment
  assert ( associated(this%triangulation) )
  select type ( par_triangulation => this%triangulation )
    class is ( par_triangulation_t )
      par_fe_space_get_par_environment => par_triangulation%get_par_environment()
    class default
      assert(.false.)
  end select
end function par_fe_space_get_par_environment

function par_fe_space_get_environment(this)
  implicit none
  class(par_fe_space_t), intent(in) :: this
  class(environment_t), pointer :: par_fe_space_get_environment
  par_fe_space_get_environment => this%get_par_environment()
end function par_fe_space_get_environment

subroutine par_fe_space_print ( this )
  class(par_fe_space_t), intent(in) :: this 
  integer(ip) :: i,j
  type(environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%print()
     !do i = 1, this%number_blocks
     !  call this%blocks_dof_import(i)%print(6)
     !end do
  end if
end subroutine par_fe_space_print

subroutine par_fe_space_allocate_and_fill_coarse_fe_handlers ( this, coarse_fe_handlers )
  implicit none
  class(par_fe_space_t)         , intent(inout) :: this
  type(p_l1_coarse_fe_handler_t),  intent(in)   :: coarse_fe_handlers(:)
  integer(ip) :: i, istat

  call this%free_coarse_fe_handlers()
  
  assert(size(coarse_fe_handlers) == this%number_fields)
  allocate( this%coarse_fe_handlers(this%number_fields), stat=istat )

  check ( istat == 0 )
  do i  = 1, this%number_fields
     this%coarse_fe_handlers(i) = coarse_fe_handlers(i)
  end do
end subroutine par_fe_space_allocate_and_fill_coarse_fe_handlers

subroutine par_fe_space_free_coarse_fe_handlers ( this )
  implicit none
  class(par_fe_space_t)          , intent(inout) :: this
  integer(ip) :: istat
  if (allocated(this%coarse_fe_handlers)) then
     deallocate( this%coarse_fe_handlers, stat=istat )
     check ( istat == 0 )
  end if
end subroutine par_fe_space_free_coarse_fe_handlers

subroutine par_fe_space_fill_dof_info( this, block_layout )
  implicit none
  class(par_fe_space_t)       , intent(inout) :: this 
  type(block_layout_t), target, intent(inout) :: block_layout

  integer(ip) :: field_id
  type(environment_t), pointer :: par_environment 
  
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     call this%serial_fe_space_t%fill_dof_info(block_layout)
     do field_id = 1, this%number_fields
        call this%fill_elem2dof_and_count_dofs( field_id )
     end do
     call this%compute_blocks_dof_import()
     ! Step required by the MLBDDC preconditioner
     call this%renumber_dofs_first_interior_then_interface()
  else
     this%block_layout => block_layout
    
     ! This is a little bit DIRTY. par_fe_space_t%create_assembler()
     ! requires that this%blocks_dof_import is allocated 
     allocate ( this%blocks_dof_import(block_layout%get_num_blocks()) )
  end if
end subroutine par_fe_space_fill_dof_info

subroutine par_fe_space_fill_elem2dof_and_count_dofs( this, field_id ) 
  implicit none 
  ! Parameters
  class(par_fe_space_t)  , intent(inout) :: this  
  integer(ip)            , intent(in)    :: field_id

  ! Local variables
  integer(ip) :: ivef, ielem, ivef_in_source_fe
  integer(ip) :: iblock, init_dof_block, current_dof_block
  
  class(fe_iterator_t), allocatable :: fe
  class(fe_iterator_t), allocatable :: source_fe
  type(fe_vef_iterator_t) :: vef

  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t)          :: own_dofs_on_vef_iterator

#ifdef DEBUG
  type(environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_task() )
#endif  
  
  iblock            = this%block_layout%get_block_id(field_id)
  init_dof_block    = this%block_layout%get_block_num_dofs(iblock)
  current_dof_block = init_dof_block

  if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
     call this%create_fe_iterator(fe)
     call this%create_fe_iterator(source_fe)
     call this%create_fe_vef_iterator(vef)
     do while(.not. fe%has_finished())
        if ( fe%is_ghost() ) then
          do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)
            if ( vef%is_at_interface() ) then
            
              ! Find local element around vef_lid in elem_id
              do ielem=1, vef%get_num_cells_around()
                call vef%get_cell_around(ielem, source_fe)
                if ( source_fe%is_local() ) then
                  ivef_in_source_fe = source_fe%find_lpos_vef_lid(vef%get_lid()) 

                  ! Check that the source fe has at least one dof on this vef
                  reference_fe => source_fe%get_reference_fe(field_id)
                  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef_in_source_fe)
                  if (own_dofs_on_vef_iterator%get_size() > 0) then
                    call fe%fill_own_dofs_on_vef_from_source_fe ( ivef, &
                                                                  source_fe, & 
                                                                  ivef_in_source_fe, &
                                                                  field_id )    
                    exit
                  end if
                end if
              end do
            end if
          end do
        end if
        call fe%next() 
     end do
     call this%free_fe_iterator(fe)
     call this%free_fe_iterator(source_fe)
     call this%free_fe_vef_iterator(vef)
  else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
     call this%create_fe_iterator(fe)
     call this%create_fe_vef_iterator(vef)
     do while(.not. fe%has_finished())
        if ( fe%is_ghost() ) then
          do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)
            if ( vef%is_face() .and. vef%is_at_interface() ) then
               call fe%fill_dofs_face_integration_coupling ( ivef, &
                                                             field_id, &
                                                             current_dof_block )
            end if
          end do
        end if
        call fe%next() 
     end do
     call this%free_fe_iterator(fe)
     call this%free_fe_vef_iterator(vef)
  end if

  this%number_dofs_per_field(field_id) = this%number_dofs_per_field(field_id) + (current_dof_block - init_dof_block)
  call this%block_layout%add_to_block_num_dofs(iblock, (current_dof_block - init_dof_block)) 
end subroutine par_fe_space_fill_elem2dof_and_count_dofs

subroutine par_fe_space_renumber_dofs_first_interior_then_interface( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock
  integer(ip), allocatable :: perm_old2new_block(:)
  type(environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
    do iblock=1, this%block_layout%get_num_blocks()
      call memalloc (this%block_layout%get_block_num_dofs(iblock), perm_old2new_block, __FILE__, __LINE__)
      call this%blocks_dof_import(iblock)%fill_first_I_then_G_renumbering(perm_old2new_block)
      call this%renumber_dofs_block(iblock, perm_old2new_block)
      call this%blocks_dof_import(iblock)%renumber_dofs(perm_old2new_block)
      call memfree (perm_old2new_block, __FILE__, __LINE__)
    end do
  end if
end subroutine par_fe_space_renumber_dofs_first_interior_then_interface


subroutine par_fe_space_set_up_strong_dirichlet_bcs_ghost_fes(this, field_id)
  implicit none
  class(par_fe_space_t), intent(inout) :: this 
  integer(ip)          , intent(in)    :: field_id
  
  ! Local variables
  integer(ip) :: ivef, ielem, ivef_in_source_fe
  
  class(fe_iterator_t), allocatable     :: fe
  class(fe_iterator_t), allocatable     :: source_fe
  type(fe_vef_iterator_t) :: vef 
  
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t)          :: own_dofs_on_vef_iterator
  
  if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
     call this%create_fe_iterator(fe)
     call this%create_fe_iterator(source_fe)
     call this%create_fe_vef_iterator(vef)
     do while ( .not. fe%has_finished() )
        if ( fe%is_ghost() ) then
          do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)
            if ( vef%is_at_interface() ) then
              ! Find local element around vef_lid in elem_id
              do ielem=1, vef%get_num_cells_around()
                call vef%get_cell_around(ielem, source_fe)
                if ( source_fe%is_local() ) then
                  ivef_in_source_fe = source_fe%find_lpos_vef_lid(vef%get_lid()) 

                  ! Check that the source fe has at least one dof on this vef
                  reference_fe => source_fe%get_reference_fe(field_id)
                  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef_in_source_fe)
                  if (own_dofs_on_vef_iterator%get_size() > 0) then
                    call fe%fill_own_dofs_on_vef_from_source_fe ( ivef, &
                                                                  source_fe, & 
                                                                  ivef_in_source_fe, &
                                                                  field_id )    
                    exit
                  end if
                end if
              end do
            end if
          end do
          call fe%determine_at_strong_dirichlet_boundary(field_id)  
        end if
        call fe%next() 
     end do
     call this%free_fe_iterator(fe)
     call this%free_fe_iterator(source_fe)
     call this%free_fe_vef_iterator(vef)
  end if   
end subroutine par_fe_space_set_up_strong_dirichlet_bcs_ghost_fes


subroutine par_fe_space_compute_blocks_dof_import ( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)                          :: iblock    
  allocate ( this%blocks_dof_import(this%block_layout%get_num_blocks()) )
  do iblock=1, this%block_layout%get_num_blocks()
     call this%compute_dof_import(iblock)
  end do
end subroutine par_fe_space_compute_blocks_dof_import

subroutine par_fe_space_compute_dof_import ( this, iblock )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: iblock

  ! Local raw data
  integer(igp), allocatable    :: raw_interface_data(:,:)
  integer(ip) , allocatable    :: dofs_lid(:)
  integer(ip)                  :: total_ubound_num_itfc_couplings
  integer(ip)                  :: total_num_itfc_couplings
  integer(ip), allocatable     :: ubound_num_itfc_couplings(:)
  integer(ip)                  :: num_fe_spaces_in_iblock
  integer(ip)                  :: i, field_id
  type(environment_t), pointer :: par_environment
  
  assert ( iblock >= 1 .and. iblock <= this%block_layout%get_num_blocks() )

  num_fe_spaces_in_iblock = 0
  do field_id = 1, this%number_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        num_fe_spaces_in_iblock = num_fe_spaces_in_iblock + 1
     end if
  end do

  call memalloc ( num_fe_spaces_in_iblock, ubound_num_itfc_couplings, __FILE__, __LINE__ )
  total_ubound_num_itfc_couplings = 0 
  ubound_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%number_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
           ubound_num_itfc_couplings (i) = ubound_num_itfc_couplings (i) + &
                                           this%compute_ubound_num_itfc_couplings_by_continuity(field_id)
        else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
           ubound_num_itfc_couplings (i) = ubound_num_itfc_couplings (i) + &
                this%compute_ubound_num_itfc_couplings_by_face_integ(field_id)
        end if
        total_ubound_num_itfc_couplings = total_ubound_num_itfc_couplings + ubound_num_itfc_couplings (i)
        i=i+1                                  
     end if
  end do

  call memalloc ( num_rows_raw_interface_data, &
                  total_ubound_num_itfc_couplings, &
                  raw_interface_data, __FILE__, __LINE__ )

  call memalloc ( total_ubound_num_itfc_couplings, dofs_lid, __FILE__, __LINE__)

  total_num_itfc_couplings = 0
  i = 1
  do field_id = 1, this%number_fields
     if ( this%block_layout%get_block_id(field_id) == iblock ) then
        if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
           total_num_itfc_couplings = &
                this%compute_raw_interface_data_by_continuity(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_lid,&
                                                              raw_interface_data )
        else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
           total_num_itfc_couplings = &
                this%compute_raw_interface_data_by_face_integ(field_id, &
                                                              total_num_itfc_couplings, &
                                                              ubound_num_itfc_couplings(i),&
                                                              dofs_lid,&
                                                              raw_interface_data )      
        end if

        i=i+1                                  
     end if
  end do

  par_environment => this%get_par_environment()
  call this%blocks_dof_import(iblock)%create(par_environment%get_l1_rank()+1, &
                                             par_environment%get_l1_size(), &
                                             this%block_layout%get_block_num_dofs(iblock), &
                                             total_num_itfc_couplings, &
                                             dofs_lid, &
                                             raw_interface_data )

  call memfree ( ubound_num_itfc_couplings, __FILE__, __LINE__ )                
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  call memfree ( dofs_lid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_dof_import

function pfs_compute_ubound_num_itfc_couplings_by_continuity( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_num_itfc_couplings_by_continuity

  integer(ip)  :: mypart_id, part_id, local_part_id
  integer(ip)  :: ivef, ielem

  integer(ip)                            :: result
  logical, allocatable                   :: touched_neighbours(:)

  type(environment_t)      , pointer :: par_environment
  class(base_static_triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(fe_vef_iterator_t)      :: vef
  class(fe_iterator_t), allocatable :: fe
  integer(ip)                  :: result_previous
  
  par_environment   => this%get_par_environment()
  triangulation => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( par_environment%am_i_l1_task() )

  mypart_id = par_environment%get_l1_rank() + 1 

  call memalloc ( cell_import%get_number_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_iterator(fe) 
  result = 0 
  do while(.not. vef%has_finished())
     touched_neighbours = .false.
     do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        part_id = fe%get_my_part()
        if ( part_id /= mypart_id ) then
           local_part_id = cell_import%get_local_neighbour_id(part_id)
           if (.not. touched_neighbours (local_part_id)) then
              ivef = fe%find_lpos_vef_lid(vef%get_lid())
              reference_fe => fe%get_reference_fe(field_id)
              result_previous = result
              result = result + reference_fe%get_number_own_dofs_n_face(ivef)
              if (result>result_previous) touched_neighbours (local_part_id) = .true.
           end if
        end if
     end do
     call vef%next()
  end do
  pfs_compute_ubound_num_itfc_couplings_by_continuity = result
  call this%free_fe_iterator(fe) 
  call this%free_fe_vef_iterator(vef)
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
end function pfs_compute_ubound_num_itfc_couplings_by_continuity


function pfs_compute_ubound_num_itfc_couplings_by_face_integ( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_num_itfc_couplings_by_face_integ

  integer(ip)  :: elem_lid
  integer(ip)  :: ivef_itfc, ielem, vef_lid
  integer(ip) :: result

  !assert ( associated (this%par_triangulation) )
  !assert ( par_environment%am_i_l1_task() )

  !result = 0 
  !! Traverse vefs on the interface
  !do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs 
  !   vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)
  !   ! Is current vef_lid a face ?
  !   if ( this%triangulation%vefs(vef_lid)%dime == this%triangulation%num_dims-1 ) then
  !      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
  !         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
  !         finite_element => this%get_finite_element(elem_lid)
  !         !if ( .not. finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() .and. &
  !         !     .not. finite_element%reference_fe_phy(fe_space_id)%p%get_conformity() ) then
  !         result = result + finite_element%reference_fe_phy(field_id)%p%get_face_integration_coupling_number_nodes_face( )
  !         !end if
  !      end do
  !   end if
  !   new_parfespace_compute_ubound_num_itfc_couplings_by_face_integ = result
  !end do

end function pfs_compute_ubound_num_itfc_couplings_by_face_integ

function par_fe_space_generate_non_consecutive_dof_gid (cell_gid, lpos_dof_elem2dof, field_id) result(dof_gid)
  implicit none
  integer(igp), intent(in) :: cell_gid
  integer(ip) , intent(in) :: lpos_dof_elem2dof
  integer(ip) , intent(in) :: field_id
  integer(igp)             :: dof_gid
  assert ( cell_gid_shift >= 1  )
  assert ( dofs_per_reference_fe_shift >= 1  )
  assert ( number_fields_shift >= 1 )
  assert ( cell_gid < ISHFT(int(1,igp),int(cell_gid_shift,igp) ) ) 
  assert ( lpos_dof_elem2dof < ISHFT(int(1,igp),int(dofs_per_reference_fe_shift,igp) ) )
  assert ( field_id < ISHFT(int(1,igp),int(number_fields_shift,igp) ) )
  dof_gid = (cell_gid-1) + &
            ISHFT(int(lpos_dof_elem2dof-1,igp),int(cell_gid_shift,igp)) + &
            ISHFT(int(field_id-1,igp),int(cell_gid_shift+dofs_per_reference_fe_shift,igp))
end function par_fe_space_generate_non_consecutive_dof_gid


subroutine par_fe_space_compute_boundary_dof_import ( this, &
                                                      fields_to_project, &
                                                      number_subset_strong_dirichlet_dofs, &
                                                      global2subset_strong_dirichlet_dofs, &
                                                      dof_import )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fields_to_project(:)
  integer(ip)          , intent(in)    :: number_subset_strong_dirichlet_dofs
  integer(ip)          , intent(in)    :: global2subset_strong_dirichlet_dofs(this%number_strong_dirichlet_dofs)
  type(dof_import_t)   , intent(inout) :: dof_import

  ! Local raw data
  integer(igp), allocatable    :: raw_interface_data(:,:)
  integer(ip) , allocatable    :: dofs_lid(:)
  integer(ip)                  :: total_ubound_boundary_num_itfc_couplings
  integer(ip)                  :: total_boundary_num_itfc_couplings
  integer(ip), allocatable     :: ubound_boundary_num_itfc_couplings(:)
  integer(ip)                  :: num_fe_spaces_in_subset
  integer(ip)                  :: ifield, field_id
  type(environment_t), pointer :: par_environment
  
  assert ( size(fields_to_project) >= 1 .and. size(fields_to_project) <= this%get_number_fields() )
  
  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_task() )
  
  num_fe_spaces_in_subset = size(fields_to_project)
  
  call memalloc ( num_fe_spaces_in_subset, ubound_boundary_num_itfc_couplings, __FILE__, __LINE__ )
  total_ubound_boundary_num_itfc_couplings = 0 
  ubound_boundary_num_itfc_couplings = 0
  do ifield = 1, num_fe_spaces_in_subset
    field_id = fields_to_project(ifield)
    if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
        ubound_boundary_num_itfc_couplings (ifield) = ubound_boundary_num_itfc_couplings (ifield) + &
                                             this%compute_ubound_boundary_num_itfc_couplings_by_continuity(field_id)
    else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
        check(.false.) ! Not implemented yet
        !ubound_boundary_num_itfc_couplings (ifield) = ubound_boundary_num_itfc_couplings (ifield) + &
        !        this%compute_ubound_boundary_num_itfc_couplings_by_face_integ(field_id)
    end if
    total_ubound_boundary_num_itfc_couplings = total_ubound_boundary_num_itfc_couplings + ubound_boundary_num_itfc_couplings (ifield)
  end do

  call memalloc ( num_rows_raw_interface_data, &
                  total_ubound_boundary_num_itfc_couplings, &
                  raw_interface_data, __FILE__, __LINE__ )

  call memalloc ( total_ubound_boundary_num_itfc_couplings, dofs_lid, __FILE__, __LINE__)

  total_boundary_num_itfc_couplings = 0
  do ifield = 1, num_fe_spaces_in_subset
      field_id = fields_to_project(ifield)
        if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
           total_boundary_num_itfc_couplings = total_boundary_num_itfc_couplings + & 
                this%compute_boundary_raw_interface_data_by_continuity(field_id, &
                                                                       total_boundary_num_itfc_couplings, &
                                                                       ubound_boundary_num_itfc_couplings(field_id),&
                                                                       number_subset_strong_dirichlet_dofs, &
                                                                       global2subset_strong_dirichlet_dofs, &
                                                                       dofs_lid,&
                                                                       raw_interface_data )
        else if ( this%fe_space_type_per_field(field_id) == fe_space_type_dg ) then
          check(.false.) ! Not implemented yet 
          !total_boundary_num_itfc_couplings = total_boundary_num_itfc_couplings + & 
                ! this%compute_raw_interface_data_by_face_integ(field_id, &
                !                                              total_boundary_num_itfc_couplings, &
                !                                              ubound_boundary_num_itfc_couplings(field_id),&
                !                                              dofs_lid,&
                !                                              raw_interface_data )      
        end if
  end do

  par_environment => this%get_par_environment()
  call dof_import%create(par_environment%get_l1_rank()+1, &
                         par_environment%get_l1_size(), &
                         number_subset_strong_dirichlet_dofs, &
                         total_boundary_num_itfc_couplings, &
                         dofs_lid, &
                         raw_interface_data )

  call memfree ( ubound_boundary_num_itfc_couplings, __FILE__, __LINE__ )                
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  call memfree ( dofs_lid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_boundary_dof_import

function pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity( this, field_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)                          :: pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity

  integer(ip)  :: mypart_id, part_id, local_part_id
  integer(ip)  :: ivef, ielem

  integer(ip)                            :: result
  logical, allocatable                   :: touched_neighbours(:)
  logical                                :: vef_active

  type(environment_t)      , pointer :: par_environment
  class(base_static_triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(fe_vef_iterator_t)      :: vef
  class(fe_iterator_t), allocatable :: fe
  
  par_environment   => this%get_par_environment()
  triangulation => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( par_environment%am_i_l1_task() )

  mypart_id = par_environment%get_l1_rank() + 1 

  call memalloc ( cell_import%get_number_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_iterator(fe) 
  result = 0 
  do while(.not. vef%has_finished())
     if ( vef%is_at_boundary() .and. vef%is_at_interface() ) then
        touched_neighbours = .false.
        do ielem=1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem,fe)
           part_id = fe%get_my_part()
           if ( part_id /= mypart_id ) then
              local_part_id = cell_import%get_local_neighbour_id(part_id)
              if (.not. touched_neighbours (local_part_id)) then
                 touched_neighbours (local_part_id) = .true.
                 ivef = fe%find_lpos_vef_lid(vef%get_lid())
                 reference_fe => fe%get_reference_fe(field_id)
                 result = result + reference_fe%get_number_own_dofs_n_face(ivef)
              end if
           end if
        end do
     end if
     call vef%next()
  end do
  pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity = result
  call this%free_fe_iterator(fe) 
  call memfree ( touched_neighbours, __FILE__, __LINE__ )
end function pfs_compute_ubound_boundary_num_itfc_couplings_by_continuity

function par_fe_space_compute_boundary_raw_interface_data_by_continuity (  this, &
                                                                           field_id, &
                                                                           offset, &
                                                                           ubound_num_itfc_couplings, &
                                                                           number_subset_strong_dirichlet_dofs, &
                                                                           global2subset_strong_dirichlet_dofs, &
                                                                           dofs_lid, &
                                                                           raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(in)    :: number_subset_strong_dirichlet_dofs
  integer(ip)          , intent(in)    :: global2subset_strong_dirichlet_dofs(this%number_strong_dirichlet_dofs)
  integer(ip)          , intent(inout) :: dofs_lid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: istat
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id, elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_interior, dof_lid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts, local_part_id, ipart

  integer(igp)              :: max_elem_gid
  integer(ip)               :: max_part_id
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  integer(ip) , allocatable :: dofs_max_part_id(:)
  logical     , allocatable :: touched_neighbours(:)
  integer(ip), allocatable  :: parts_visited(:)

  type(environment_t)      , pointer :: par_environment
  class(base_static_triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable :: fe
  type(i1p_t)              , allocatable :: elem2dof(:)


  par_environment   => this%get_par_environment()
  triangulation     => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( par_environment%am_i_l1_task() )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( number_subset_strong_dirichlet_dofs, local_idof, __FILE__, __LINE__ )
  call memalloc ( number_subset_strong_dirichlet_dofs, lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, __FILE__, __LINE__ )

  call memalloc ( cell_import%get_number_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  call memalloc ( cell_import%get_number_neighbours(), &
                  parts_visited, &
                  __FILE__, __LINE__ )
  
  allocate ( elem2dof(this%number_fields), stat=istat ) 
  check (istat==0)
  
  mypart_id = par_environment%get_l1_rank() + 1
  
  current_col  = offset + 1
  local_idof   = 0

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_iterator(fe) 
  do while(.not. vef%has_finished())
     if ( vef%is_at_boundary() .and. vef%is_at_interface() ) then

        touched_neighbours = .false.
        num_parts = 0
        max_part_id = mypart_id
        max_elem_gid = 0

        num_dofs_current_vef = 0
        ! Identify the total set of dofs in current vef
        do ielem=1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem,fe)
           !if ( finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
           part_id = fe%get_my_part()
           elem_gid = fe%get_gid()
           ivef = fe%find_lpos_vef_lid(vef%get_lid())
           call fe%get_elem2dof( elem2dof )
           reference_fe => fe%get_reference_fe(field_id)
           own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
           do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
              idof =  own_dofs_on_vef_iterator%get_current()
              dof_lid = elem2dof(field_id)%p(idof)
              if ( dof_lid >= 0 ) then
                 call own_dofs_on_vef_iterator%next()
                 cycle
              end if
              dof_lid = global2subset_strong_dirichlet_dofs(-dof_lid)
              assert ( dof_lid > 0 )
              if ( elem_gid >= max_elem_gid ) then
                 max_elem_gid = elem_gid
                 if ( local_idof(dof_lid) == 0 ) then
                    num_dofs_current_vef = num_dofs_current_vef + 1    
                    lst_dofs_current_vef (num_dofs_current_vef) = dof_lid
                 end if
                 local_idof(dof_lid) = idof
              end if
              if ( part_id /= mypart_id ) then 
                 local_part_id = cell_import%get_local_neighbour_id(part_id)
                 if ( .not. touched_neighbours(local_part_id) ) then
                    touched_neighbours (local_part_id) = .true.
                    num_parts = num_parts + 1
                    parts_visited (num_parts) = part_id
                    max_part_id = max(part_id, max_part_id)
                 end if
              end if
              call own_dofs_on_vef_iterator%next()
           end do
           !end if
        end do

        init_col = current_col
        do idof=1, num_dofs_current_vef
           dof_lid = lst_dofs_current_vef(idof)
           do ipart=1, num_parts
              part_id = parts_visited(ipart)
              dofs_lid ( current_col ) = dof_lid 
              dofs_max_part_id ( current_col-offset ) = max_part_id
              raw_interface_data(neighbor_part_id_row, current_col) = part_id
              raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_gid(max_elem_gid, &
                                                                                                   local_idof(dof_lid), &
                                                                                                   field_id)
              raw_interface_data(owner_flag_row, current_col) = num_parts + 1
              current_col = current_col + 1
           end do
        end do
     end if
     call vef%next()
  end do
  call this%free_fe_iterator(fe) 
  deallocate(elem2dof, stat=istat ) 
  check (istat==0)
  
  ! Free touch arrays
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( parts_visited, __FILE__, __LINE__ )
  call memfree ( touched_neighbours, __FILE__, __LINE__ )

  call this%raw_interface_data_by_continuity_decide_owner (offset, &
                                                           current_col-1, &
                                                           raw_interface_data,&
                                                           dofs_max_part_id,&
                                                           dofs_lid)

  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )

  num_itfc_couplings = current_col-1 
end function par_fe_space_compute_boundary_raw_interface_data_by_continuity


function par_fe_space_get_num_dimensions ( this )
  implicit none
  class(par_fe_space_t), intent(in) :: this
  integer(ip)                       :: par_fe_space_get_num_dimensions
  type(environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
     par_fe_space_get_num_dimensions = this%serial_fe_space_t%get_num_dimensions()
  end if
end function par_fe_space_get_num_dimensions

function par_fe_space_get_number_fe_objects ( this )
  implicit none
  class(par_fe_space_t), intent(in) :: this
  integer(ip) :: par_fe_space_get_number_fe_objects
  par_fe_space_get_number_fe_objects = this%triangulation%get_number_objects()
end function par_fe_space_get_number_fe_objects 

function par_fe_space_compute_raw_interface_data_by_continuity (  this, &
                                                                      field_id, &
                                                                      offset, &
                                                                      ubound_num_itfc_couplings, &
                                                                      dofs_lid, &
                                                                      raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_lid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: istat
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id, elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_interior, dof_lid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts, local_part_id, ipart

  integer(igp)              :: max_elem_gid
  integer(ip)               :: max_part_id
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  integer(ip) , allocatable :: dofs_max_part_id(:)
  logical     , allocatable :: touched_neighbours(:)
  integer(ip), allocatable  :: parts_visited(:)

  type(environment_t)      , pointer :: par_environment
  class(base_static_triangulation_t), pointer :: triangulation
  type(cell_import_t)       , pointer :: cell_import
  class(reference_fe_t)        , pointer :: reference_fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable :: fe
  type(i1p_t)              , allocatable :: elem2dof(:)


  par_environment   => this%get_par_environment()
  triangulation     => this%get_triangulation()
  cell_import       => triangulation%get_cell_import()
  assert ( par_environment%am_i_l1_task() )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), local_idof, __FILE__, __LINE__ )
  call memalloc ( this%block_layout%get_block_num_dofs(this%block_layout%get_block_id(field_id)), lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, __FILE__, __LINE__ )

  call memalloc ( cell_import%get_number_neighbours(), &
                  touched_neighbours, &
                  __FILE__, __LINE__ )

  call memalloc ( cell_import%get_number_neighbours(), &
                  parts_visited, &
                  __FILE__, __LINE__ )
  
  allocate ( elem2dof(this%number_fields), stat=istat ) 
  check (istat==0)
  
  mypart_id = par_environment%get_l1_rank() + 1
  
  current_col  = offset + 1
  local_idof   = 0

  ! Traverse vefs on the interface
  call this%create_itfc_fe_vef_iterator(vef)
  call this%create_fe_iterator(fe) 
  do while(.not. vef%has_finished())
     touched_neighbours = .false.
     num_parts = 0
     max_part_id = mypart_id
     max_elem_gid = 0

     num_dofs_current_vef = 0
     ! Identify the total set of dofs in current vef
     do ielem=1, vef%get_num_cells_around()
        call vef%get_cell_around(ielem,fe)
        !if ( finite_element%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
        part_id = fe%get_my_part()
        elem_gid = fe%get_gid()
        ivef = fe%find_lpos_vef_lid(vef%get_lid())
        call fe%get_elem2dof( elem2dof )
        reference_fe => fe%get_reference_fe(field_id)
        own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
        do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
           idof =  own_dofs_on_vef_iterator%get_current()
           dof_lid = elem2dof(field_id)%p(idof)
           if ( dof_lid <= 0 ) then
             call own_dofs_on_vef_iterator%next()
             cycle
           end if
           if ( elem_gid >= max_elem_gid ) then
              max_elem_gid = elem_gid
              if ( local_idof(dof_lid) == 0 ) then
                 num_dofs_current_vef = num_dofs_current_vef + 1    
                 lst_dofs_current_vef (num_dofs_current_vef) = dof_lid
              end if
              local_idof(dof_lid) = idof
           end if
           if ( part_id /= mypart_id ) then 
              local_part_id = cell_import%get_local_neighbour_id(part_id)
              if ( .not. touched_neighbours(local_part_id) ) then
                 touched_neighbours (local_part_id) = .true.
                 num_parts = num_parts + 1
                 parts_visited (num_parts) = part_id
                 max_part_id = max(part_id, max_part_id)
              end if
           end if
           call own_dofs_on_vef_iterator%next()
        end do
        !end if
     end do

     init_col = current_col
     do idof=1, num_dofs_current_vef
        dof_lid = lst_dofs_current_vef(idof)
        do ipart=1, num_parts
           part_id = parts_visited(ipart)
           dofs_lid ( current_col ) = dof_lid 
           dofs_max_part_id ( current_col-offset ) = max_part_id
           raw_interface_data(neighbor_part_id_row, current_col) = part_id
           raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_gid(max_elem_gid, &
                                                                                                local_idof(dof_lid), &
                                                                                                field_id)
           raw_interface_data(owner_flag_row, current_col) = num_parts + 1
           current_col = current_col + 1
        end do
     end do
     call vef%next()
  end do
  call this%free_fe_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  deallocate(elem2dof, stat=istat ) 
  check (istat==0)
  
  ! Free touch arrays
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( parts_visited, __FILE__, __LINE__ )
  call memfree ( touched_neighbours, __FILE__, __LINE__ )

  call this%raw_interface_data_by_continuity_decide_owner (offset, &
                                                           current_col-1, &
                                                           raw_interface_data,&
                                                           dofs_max_part_id,&
                                                           dofs_lid)

  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )

  num_itfc_couplings = current_col-1 
end function par_fe_space_compute_raw_interface_data_by_continuity

subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner ( this, &
                                                                        offset, &
                                                                        num_cols, &
                                                                        raw_interface_data, &
                                                                        dofs_max_part_id,  &
                                                                        dofs_lid)
  implicit none
  class(par_fe_space_t), intent(in)    :: this
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: num_cols
  integer(igp)         , intent(inout) :: raw_interface_data(:,:)
  integer(ip)          , intent(inout) :: dofs_max_part_id(:)
  integer(ip)          , intent(inout) :: dofs_lid(:)

  integer(igp)                 :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)
  integer(ip) , allocatable    :: perm(:)
  integer(ip) , allocatable    :: aux(:)
  integer(ip)                  :: start_col, end_col, col, mypart_id, ipart_max, j, size
  type(environment_t), pointer :: par_environment


  !do col=1,num_cols
  !  write(*,"(10i10)") col, dofs_lid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  !end do 
  !write(*,*) '============================================================================='

  if ( num_cols-offset == 0 ) return
  
  call memalloc ( num_cols-offset, aux, __FILE__, __LINE__ )
  call memalloc ( num_cols-offset, perm, __FILE__, __LINE__ )
  do col=1, num_cols-offset
     perm(col) = col
  end do

  ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
                                       num_rows_raw_interface_data, &
                                       num_cols-offset, &
                                       raw_interface_data(1:,offset+1:num_cols), &
                                       perm, &
                                       l1, &
                                       l2)

  aux = dofs_max_part_id(1:num_cols-offset)
  do col=1, num_cols-offset
     dofs_max_part_id(col) = aux(perm(col))
  end do

  aux = dofs_lid(offset+1:num_cols)
  do col=1, num_cols-offset
     dofs_lid(offset+col) = aux(perm(col))
  end do

  call memfree ( perm, __FILE__, __LINE__ )
  call memfree ( aux, __FILE__, __LINE__ )

  par_environment => this%get_par_environment()
  mypart_id = par_environment%get_l1_rank() + 1

  col = offset + 1
  do while ( col <= num_cols ) 
     if ( raw_interface_data ( owner_flag_row, col ) == 2 ) then
        start_col = col
        do while ( ( raw_interface_data ( owner_flag_row, col ) == 2).and. &
        &          ( raw_interface_data ( neighbor_part_id_row, col ) == raw_interface_data ( neighbor_part_id_row, start_col ) ) )
           col = col + 1
           if ( col > num_cols ) exit
        end do
        end_col = col - 1

        ipart_max = dofs_max_part_id(start_col-offset)
        size = end_col - start_col + 1
        if ( mypart_id == ipart_max ) then
           do j= start_col, start_col + size/2 -1
              raw_interface_data ( owner_flag_row, j) = owner
           end do
           do j= start_col + size/2,  end_col
              raw_interface_data ( owner_flag_row, j) = non_owner
           end do
        else
           do j= start_col, start_col + size/2 -1
              raw_interface_data ( owner_flag_row, j) = non_owner
           end do
           do j= start_col + size/2,  end_col
              raw_interface_data ( owner_flag_row, j) = owner
           end do
        end if
     else
        if ( mypart_id == dofs_max_part_id(col-offset) ) then
           raw_interface_data ( owner_flag_row, col) = owner
        else
           if ( raw_interface_data ( neighbor_part_id_row, col) == dofs_max_part_id(col-offset) ) then
              raw_interface_data ( owner_flag_row, col) = non_owner
           else
              raw_interface_data ( owner_flag_row, col) = uncoupled
           end if
        end if
        col = col +1
     end if

  end do

  !do col=1,num_cols
  !  write(*,"(10i10)") col, dofs_lid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  !end do 

end subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner

function par_fe_space_compute_raw_interface_data_by_face_integ ( this, &
                                                                 fe_space_id, &
                                                                 offset, &
                                                                 ubound_num_itfc_couplings, &
                                                                 dofs_lid, &
                                                                 raw_interface_data) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)          , intent(in)    :: offset
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_lid(:)
  integer(igp)         , intent(inout) :: raw_interface_data(:, :)
  integer(ip)                          :: num_itfc_couplings

  ! Locals
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_face, dof_lid
  integer(ip)  :: current_col
  integer(igp) :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)

  !assert ( associated (this%par_triangulation) )
  !assert ( par_environment%am_i_l1_task() )

  !mypart_id = par_environment%get_l1_rank() + 1 
  !current_col = offset + 1

  !! Traverse vefs on the interface
  !do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
  !   vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)

  !   ! Is current vef_lid a face ?
  !   if ( this%triangulation%vefs(vef_lid)%dime == this%triangulation%num_dims-1 ) then
  !      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
  !         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
  !         if ( this%par_triangulation%elems(elem_lid)%mypart /= mypart_id ) then
  !            part_id = this%par_triangulation%elems(elem_lid)%mypart
  !         end if
  !      end do

  !      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
  !         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
  !         elem_gid = this%par_triangulation%elems(elem_lid)%globalID
  !         finite_element => this%get_finite_element(elem_lid)
  !         ivef = finite_element%cell%find_local_pos_from_vef_id(vef_lid)
  !         do idof_face=1, finite_element%reference_fe_phy(fe_space_id)%p%get_face_integration_coupling_number_nodes_face()
  !            idof = finite_element%reference_fe_phy(fe_space_id)%p%get_face_integration_coupling_node_face(idof_face,ivef)
  !            dof_lid = finite_element%elem2dof(fe_space_id)%p(idof)
  !            dofs_lid ( current_col ) = dof_lid 
  !            raw_interface_data(neighbor_part_id_row, current_col) = part_id
  !            raw_interface_data(dof_gid_row, current_col) = this%generate_non_consecutive_dof_gid(elem_gid, idof, fe_space_id)
  !            if ( mypart_id == this%par_triangulation%elems(elem_lid)%mypart ) then
  !               raw_interface_data(owner_flag_row,current_col) = owner
  !            else
  !               raw_interface_data(owner_flag_row,current_col) = non_owner
  !            end if
  !            current_col = current_col + 1
  !         end do
  !      end do
  !   end if
  !end do

  !num_itfc_couplings = current_col-offset-1

  !if ( num_itfc_couplings > 0 ) then
  !   ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  !   ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  !   call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
  !                                        num_rows_raw_interface_data, &
  !                                        num_itfc_couplings, &
  !                                        raw_interface_data(1:,offset+1:current_col-1), &
  !                                        dofs_lid(offset+1:current_col-1), &
  !                                        l1, &
  !                                        l2)
  !end if                                        
  !!do current_col=1,num_itfc_couplings 
  !!  write(*,"(10i10)") current_col, dofs_lid(current_col), raw_interface_data(:,current_col)
  !!end do 

end function par_fe_space_compute_raw_interface_data_by_face_integ


subroutine par_fe_space_create_dof_values(this, dof_values)
  implicit none
  class(par_fe_space_t)       , intent(in)    :: this
  class(vector_t), allocatable, intent(inout) :: dof_values
  integer(ip) :: istat
  type(environment_t), pointer :: par_environment
  
  if (allocated(dof_values)) then
    call dof_values%free()
    deallocate(dof_values, stat=istat); check(istat==0);
  end if
  
  par_environment => this%get_par_environment()
  if (this%block_layout%get_num_blocks() == 1) then
       allocate ( par_scalar_array_t  :: dof_values )
       select type(dof_values)
       class is(par_scalar_array_t)
          call dof_values%create_and_allocate(par_environment, this%blocks_dof_import(1))
       class default
       check(.false.)
       end select
  else
      check(.false.)
  end if
  
end subroutine par_fe_space_create_dof_values

subroutine par_fe_space_interpolate_dirichlet_values(this, conditions, time, fields_to_interpolate)
  implicit none
  class(par_fe_space_t)     , intent(inout) :: this
  class(conditions_t)       , intent(in)    :: conditions 
  real(rp), optional        , intent(in)    :: time
  integer(ip), optional     , intent(in)    :: fields_to_interpolate(:)
  type(environment_t), pointer :: par_environment
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
    call this%serial_fe_space_t%interpolate_dirichlet_values(conditions,time,fields_to_interpolate)
  end if
end subroutine par_fe_space_interpolate_dirichlet_values

subroutine par_fe_space_project_dirichlet_values_curl_conforming (this, conditions, time, fields_to_project)
  implicit none
  class(par_fe_space_t)       , intent(inout)  :: this
  class(conditions_t)         , intent(in)     :: conditions
  real(rp)       , optional   , intent(in)     :: time
  integer(ip)    , optional   , intent(in)     :: fields_to_project(:) 

  !  Locals
  integer(ip)                  , allocatable :: fields_to_project_(:)  
  integer(ip)                                :: field_id, istat
  integer(ip)                                :: component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: number_components
  logical                      , allocatable :: components_code(:)

  class(reference_fe_t)        , pointer     :: reference_fe

  type(fe_face_iterator_t)          :: fe_face
  class(fe_iterator_t), allocatable :: fe
  
  type(i1p_t), allocatable :: elem2dof(:)

  type(par_sparse_matrix_t)            :: matrix
  type(par_scalar_array_t)             :: rhs
  type(par_scalar_array_t)             :: projected_nodal_values
  type(serial_scalar_array_t), pointer :: projected_nodal_values_serial_scalar_array
  integer(ip), allocatable             :: subset2global_dirichlet_dofs(:) 
  integer(ip), allocatable             :: global2subset_dirichlet_dofs(:) 
  integer(ip), allocatable             :: subset_elem2dof(:) 
  type(iterative_linear_solver_t)      :: iterative_linear_solver

  real(rp), allocatable       :: elmat(:,:)
  real(rp), allocatable       :: elvec(:) 
  integer(ip)                 :: qpoint, n_q_points, ishape, jshape


  type(p_scalar_function_t), allocatable :: function_scalar_components(:)
  real(rp)                 , allocatable :: scalar_function_values(:,:)
  type(vector_field_t)     , allocatable :: vector_function_values(:,:)

  type(parameterlist_t)  :: parameter_list
  integer(ip)            :: FPLError
  integer                :: iparm(64)
  integer(ip)            :: ifield, jfield, idof, idof_subset, idof_global
  integer(ip)            :: number_subset_strong_dirichlet_dofs
  
  type(environment_t), pointer :: par_environment
  type(dof_import_t) :: dof_import
  
  par_environment => this%get_par_environment()
  if ( par_environment%am_i_l1_task() ) then
  
  
     number_components = this%get_number_components()
     assert ( conditions%get_number_components() == number_components )
     call memalloc ( number_components, components_code, __FILE__, __LINE__ )

     call this%allocate_and_fill_fields_to_project_(fields_to_project_, &
                                                    fields_to_project)
  
     call this%allocate_and_fill_offset_component(offset_component)
  
     call memalloc ( this%get_max_number_shape_functions(), &
                     this%get_max_number_shape_functions(), &
                     elmat, __FILE__, __LINE__ )

     call memalloc ( this%get_max_number_shape_functions(), &
                     elvec, __FILE__, __LINE__ )

     call memalloc ( this%get_max_number_shape_functions(), subset_elem2dof, __FILE__, __LINE__ )

     allocate ( vector_function_values(this%get_max_number_face_quadrature_points(),1), & 
                stat=istat); check(istat==0);

     allocate ( scalar_function_values(this%get_max_number_face_quadrature_points(),1), & 
                stat=istat); check(istat==0);

     allocate ( function_scalar_components(this%triangulation%get_num_dimensions()), & 
                stat=istat); check(istat==0);
  
     allocate( elem2dof(this%get_number_fields()), stat=istat); check(istat==0);

     number_subset_strong_dirichlet_dofs = this%allocate_and_fill_global2subset_and_inverse(fields_to_project_, &
                                                                                            global2subset_dirichlet_dofs, &
                                                                                            subset2global_dirichlet_dofs)

     call this%compute_boundary_dof_import( fields_to_project_, &
                                            number_subset_strong_dirichlet_dofs, &
                                            global2subset_dirichlet_dofs, &
                                            dof_import)
  
     ! Create linear system 
     call matrix%create(par_environment, &
                        dof_import, &
                        symmetric_storage=.false.,       &
                        is_symmetric=.false.,            &
                        sign=SPARSE_MATRIX_SIGN_UNKNOWN )

     call rhs%create_and_allocate(par_environment, dof_import) 
     call rhs%init(0.0_rp)

     ! Create data structures
     call projected_nodal_values%create_and_allocate(par_environment, dof_import)
 
     call this%create_fe_face_iterator(fe_face)
     call this%create_fe_iterator(fe) 
     do while ( .not. fe_face%has_finished() )
        if ( fe_face%is_at_boundary() ) then
           if ( fe_face%get_set_id() /= 0 ) then
              call fe_face%update_integration() 
              call fe_face%get_cell_around(1,fe)
              call fe%get_elem2dof(elem2dof)
              call conditions%get_components_code( fe_face%get_set_id(), components_code )
              
              do ifield = 1, size(fields_to_project_)    
                 field_id = fields_to_project_(ifield) 
                 component_id = offset_component(field_id) + 1
                 if (components_code(component_id)) then
                    
                    call this%get_function_scalar_components(fe_face, &
                                                             fe, &
                                                             field_id, &
                                                             component_id, &
                                                             conditions, &
                                                             function_scalar_components)
                 
                    call this%evaluate_vector_function_scalar_components(fe_face, &
                                                                         fe, &
                                                                         field_id, &
                                                                         function_scalar_components, &
                                                                         scalar_function_values, &
                                                                         vector_function_values, &
                                                                         time)
                 
                    call this%project_curl_conforming_compute_elmat_elvec(fe_face, &
                                                                          fe, &
                                                                          field_id, &
                                                                          vector_function_values, &
                                                                          elmat, &
                                                                          elvec)
              
              
                    ! Consecutive DOF re-numbering for the subset of Dirichlet DOFs to be projected 
                    subset_elem2dof = 0
                    do idof = 1, size(elem2dof(field_id)%p)
                       if ( (elem2dof(field_id)%p(idof) < 0) ) then 
                          subset_elem2dof(idof) = global2subset_dirichlet_dofs( -elem2dof(field_id)%p(idof) )
                       end if
                    end do
                 
                    reference_fe => fe%get_reference_fe(field_id)
                    call matrix%insert(num_rows = reference_fe%get_number_shape_functions(),& 
                                      num_cols = reference_fe%get_number_shape_functions(),& 
                                      ia       = subset_elem2dof, &
                                      ja       = subset_elem2dof, &
                                      ioffset  = 0, &
                                      joffset  = 0, & 
                                      val      = elmat)
                    call rhs%add(num_entries = reference_fe%get_number_shape_functions(),& 
                                 ia          = subset_elem2dof, &
                                 ioffset     = 0, &
                                 val         = elvec)
                 end if
              end do
           end if
        end if
        call fe_face%next()
     end do
     call this%free_fe_iterator(fe) 
     call matrix%convert(csr_format)

     call parameter_list%init()
     FPLError = parameter_list%set(key = ils_rtol, value = 1.0e-12_rp)
     FPLError = FPLError + parameter_list%set(key = ils_output_frequency, value = 30)
     assert(FPLError == 0)
     call iterative_linear_solver%create(this%get_environment())
     call iterative_linear_solver%set_type_from_string(cg_name)
     call iterative_linear_solver%set_parameters_from_pl(parameter_list)
     call iterative_linear_solver%set_operators(matrix, .identity. matrix) 
     call iterative_linear_solver%solve(rhs,projected_nodal_values)
     call iterative_linear_solver%free()
     call parameter_list%free()
     
     projected_nodal_values_serial_scalar_array => projected_nodal_values%get_serial_scalar_array()
     
     ! Insert projected nodal values into strong_dirichlet_values array 
     call this%strong_dirichlet_values%insert_subvector(iblock=1, &
                                                        size_indices=number_subset_strong_dirichlet_dofs, &
                                                        indices=subset2global_dirichlet_dofs,             &
                                                        values=projected_nodal_values_serial_scalar_array%get_entries())

     call matrix%free()
     call rhs%free()
     call projected_nodal_values%free()
     call dof_import%free()
     call memfree (elmat, __FILE__, __LINE__)
     call memfree (elvec, __FILE__, __LINE__)
     call memfree (offset_component, __FILE__, __LINE__ )
     deallocate ( function_scalar_components, stat=istat); check(istat==0);
     deallocate ( vector_function_values, stat=istat); check(istat==0);
     deallocate ( scalar_function_values, stat=istat); check(istat==0);
     call memfree ( components_code, __FILE__, __LINE__ )
     call memfree ( subset2global_dirichlet_dofs, __FILE__, __LINE__ )
     call memfree ( global2subset_dirichlet_dofs, __FILE__, __LINE__ ) 
     call memfree ( fields_to_project_, __FILE__, __LINE__ )
     call memfree ( subset_elem2dof, __FILE__, __LINE__ )
     deallocate(elem2dof, stat=istat ); check (istat==0)
  end if
end subroutine par_fe_space_project_dirichlet_values_curl_conforming 

 subroutine par_fe_space_setup_coarse_dofs ( this, parameter_list )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  type(ParameterList_t), intent(in)    :: parameter_list
  integer(ip)                          :: i, istat, field_id
  type(environment_t), pointer         :: par_environment
  integer(ip)                          :: coarse_dof_lid
  integer(ip)                          :: coarse_n_face_lid
  type(fe_object_iterator_t)           :: object
  type(list_iterator_t)                :: own_coarse_dofs_iterator
  integer(ip), allocatable             :: num_coarse_dofs_per_field(:,:), max_num_coarse_dofs_per_field(:)
  integer(ip)                          :: current_coarse_dof, sum_max_num_coarse_dofs, max_max_num_coarse_dofs

  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_task() )   
  
  call this%free_coarse_dofs()
    
  call memalloc ( this%get_number_fe_objects(), this%number_fields, num_coarse_dofs_per_field, __FILE__, __LINE__ )
  
  call memalloc ( this%number_fields, max_num_coarse_dofs_per_field, __FILE__, __LINE__ )
  
  call memalloc ( this%number_fields+1, this%ptr_coarse_dofs_per_field, __FILE__, __LINE__ )
    
  allocate ( this%coarse_dof_gids_per_field(this%number_fields), stat=istat )
  check ( istat == 0 )
  
  allocate ( this%own_coarse_dofs_per_field(this%number_fields), stat=istat )
  check ( istat == 0 )
  
  this%ptr_coarse_dofs_per_field(1) = 1
  sum_max_num_coarse_dofs = 0
  max_max_num_coarse_dofs = 0
  do field_id=1, this%number_fields
    call this%coarse_fe_handlers(field_id)%p%get_num_coarse_dofs(field_id, this, parameter_list, num_coarse_dofs_per_field(:,field_id))
    this%ptr_coarse_dofs_per_field(field_id+1) = this%ptr_coarse_dofs_per_field(field_id)
    do i=1, this%get_number_fe_objects()
      this%ptr_coarse_dofs_per_field(field_id+1) = this%ptr_coarse_dofs_per_field(field_id+1) + &
                                                   num_coarse_dofs_per_field(i, field_id)
    end do  
    
    max_num_coarse_dofs_per_field(field_id) = maxval(num_coarse_dofs_per_field(:,field_id))
    max_max_num_coarse_dofs = max(max_max_num_coarse_dofs,max_num_coarse_dofs_per_field(field_id))
    sum_max_num_coarse_dofs = sum_max_num_coarse_dofs + max_num_coarse_dofs_per_field(field_id)
    call par_environment%l1_max(max_num_coarse_dofs_per_field(field_id))
  end do
  
  call memalloc ( this%ptr_coarse_dofs_per_field(this%number_fields+1)-1, &
                  this%lst_coarse_dofs, __FILE__, __LINE__ )
  
  ! Enumerate coarse DoFs and map them to coarse n_faces
  current_coarse_dof = 1 
  coarse_dof_lid = 1
  do field_id=1, this%number_fields
     call this%own_coarse_dofs_per_field(field_id)%create(this%get_number_fe_objects())
     do i=1, this%get_number_fe_objects()
       call this%own_coarse_dofs_per_field(field_id)%sum_to_pointer_index(i,num_coarse_dofs_per_field(i,field_id))
     end do     
     call this%own_coarse_dofs_per_field(field_id)%calculate_header()
     call this%own_coarse_dofs_per_field(field_id)%allocate_list_from_pointer()
     
     do coarse_n_face_lid=1, this%own_coarse_dofs_per_field(field_id)%get_num_pointers()
       own_coarse_dofs_iterator = this%own_coarse_dofs_per_field(field_id)%create_iterator(coarse_n_face_lid)
       do while ( .not. own_coarse_dofs_iterator%is_upper_bound() )
         call own_coarse_dofs_iterator%set_current(coarse_dof_lid)
         call own_coarse_dofs_iterator%next()
         coarse_dof_lid = coarse_dof_lid + 1
         this%lst_coarse_dofs(current_coarse_dof) = current_coarse_dof
         current_coarse_dof = current_coarse_dof + 1
       end do         
     end do
     
  end do
  
  ! Generate a global numbering for the coarse DoFs
  do field_id=1, this%number_fields
     call this%coarse_dof_gids_per_field(field_id)%create(this%ptr_coarse_dofs_per_field(field_id+1)-&
                                                          this%ptr_coarse_dofs_per_field(field_id)) 
  
     call this%create_fe_object_iterator(object)
     do while ( .not. object%has_finished() )
       own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(field_id)
       do while (.not. own_coarse_dofs_iterator%is_upper_bound())
         this%coarse_dof_gids_per_field(field_id)%a(own_coarse_dofs_iterator%get_current()-this%ptr_coarse_dofs_per_field(field_id)+1) = &
               this%generate_coarse_dof_gid(object%get_gid(),field_id, &
                                            own_coarse_dofs_iterator%get_distance_to_lower_bound(), &
                                            max_max_num_coarse_dofs, & ! max_num_coarse_dofs_per_field(field_id), &
                                            sum_max_num_coarse_dofs)
         call own_coarse_dofs_iterator%next()
       end do
       call object%next()
     end do
     call this%free_fe_object_iterator(object)
  end do
  
  call memfree ( num_coarse_dofs_per_field, __FILE__, __LINE__ )
  call memfree ( max_num_coarse_dofs_per_field, __FILE__, __LINE__ )
end subroutine par_fe_space_setup_coarse_dofs

function par_fe_space_generate_coarse_dof_gid(object_gid, field_id, &
                                              current_coarse_dof, &
                                              max_num_coarse_dofs_per_object_and_field, &
                                              max_num_coarse_dofs_per_object ) result(coarse_dof_gid)
  implicit none
  integer(igp)         , intent(in) :: object_gid
  integer(ip)          , intent(in) :: field_id
  integer(ip)          , intent(in) :: current_coarse_dof
  integer(ip)          , intent(in) :: max_num_coarse_dofs_per_object
  integer(ip)          , intent(in) :: max_num_coarse_dofs_per_object_and_field
  integer(igp) :: coarse_dof_gid
  !coarse_dof_gid = object_gid*int(max_num_coarse_dofs_per_object,igp) - (int(max_num_coarse_dofs_per_object,igp)-int(current_coarse_dof,igp))
  coarse_dof_gid = (object_gid-1)*int(max_num_coarse_dofs_per_object,igp) &
                 + int((field_id-1)*max_num_coarse_dofs_per_object_and_field,igp)  &
                 + int(current_coarse_dof,igp)

end function par_fe_space_generate_coarse_dof_gid

subroutine par_fe_space_free_coarse_dofs(this)
    implicit none
    class(par_fe_space_t)           , intent(inout) :: this
    integer(ip)                               :: i, istat 
        
    if (allocated(this%ptr_coarse_dofs_per_field)) then 
      call memfree ( this%ptr_coarse_dofs_per_field, __FILE__, __LINE__ )
    end if
    
    if (allocated(this%lst_coarse_dofs)) then 
      call memfree ( this%lst_coarse_dofs, __FILE__, __LINE__ )
    end if
  
    if (allocated(this%coarse_dof_gids_per_field)) then
      do i=1, size(this%coarse_dof_gids_per_field)
        call this%coarse_dof_gids_per_field(i)%free()
      end do  
      deallocate ( this%coarse_dof_gids_per_field, stat=istat )
      check (istat == 0)  
    end if
  
    if (allocated(this%own_coarse_dofs_per_field)) then
      do i=1, size(this%own_coarse_dofs_per_field)
        call this%own_coarse_dofs_per_field(i)%free()
      end do  
      deallocate ( this%own_coarse_dofs_per_field, stat=istat )
      check (istat == 0)  
    end if
end subroutine par_fe_space_free_coarse_dofs
   
subroutine par_fe_space_setup_coarse_fe_space(this, parameter_list)
  implicit none
  class(par_fe_space_t), intent(inout)  :: this
  type(parameterlist_t) , intent(in)    :: parameter_list
  integer(ip)                           :: istat
  integer(ip)                           :: number_fields
  integer(ip), allocatable              :: fe_space_type_per_field(:)
  integer(ip), allocatable              :: ptr_dofs_per_fe_and_field(:)
  integer(ip), allocatable              :: coarse_dofs_gids_recv_counts(:)
  integer(ip), allocatable              :: coarse_dofs_gids_displs(:)
  integer(igp), allocatable             :: lst_dofs_gids(:)
  integer(igp), allocatable             :: lst_vefs_gids_dofs_objects(:)
  type(environment_t), pointer      :: par_environment
  class(base_static_triangulation_t), pointer    :: triangulation
  type(coarse_triangulation_t), pointer :: coarse_triangulation
  
  
  par_environment => this%get_par_environment()
  
  if ( par_environment%am_i_l1_task() ) then
    call this%setup_coarse_dofs(parameter_list)
  end if  
  
   ! All MPI tasks (even if they are not involved in the L2 from L1 gather) should also allocate the
   ! allocatable arrays due to the fact that non-allocated allocatable arrays cannot
   ! be passed as actual arguments of dummy arguments that do not have the allocatable attribute 
   ! Otherwise, the code crashes with a segmentation fault.
   call memalloc (0, fe_space_type_per_field, __FILE__, __LINE__)
   call memalloc (0, ptr_dofs_per_fe_and_field, __FILE__, __LINE__)
   call memalloc (0, lst_dofs_gids, __FILE__, __LINE__)
   call memalloc (0, lst_vefs_gids_dofs_objects, __FILE__, __LINE__)
   call memalloc (0, coarse_dofs_gids_recv_counts, __FILE__, __LINE__)
   call memalloc (0, coarse_dofs_gids_displs, __FILE__, __LINE__)

   
  ! L2 tasks gather from L1 tasks all raw data required to set-up the coarse triangulation on L2 tasks
  if ( par_environment%am_i_l1_to_l2_task() ) then
     call this%transfer_number_fields(number_fields) 
     call this%transfer_fe_space_type(number_fields, fe_space_type_per_field)
     call this%gather_ptr_dofs_per_fe_and_field(number_fields, ptr_dofs_per_fe_and_field)
     call this%gather_coarse_dofs_gids_rcv_counts_and_displs (coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs)
     call this%gather_coarse_dofs_gids(coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs, lst_dofs_gids)
     call this%gather_vefs_gids_dofs_objects(coarse_dofs_gids_recv_counts, coarse_dofs_gids_displs, lst_vefs_gids_dofs_objects)
  end if
  

  if ( par_environment%am_i_lgt1_task() ) then
     ! lgt1 MPI tasks (recursively) build coarse triangulation
     if ( .not. associated(this%coarse_fe_space) ) then
        allocate  ( this%coarse_fe_space, stat = istat )
        check( istat == 0 )
     end if
     triangulation        => this%get_triangulation()
     coarse_triangulation => triangulation%get_coarse_triangulation()
     call this%coarse_fe_space%create (coarse_triangulation, &
                                       number_fields, &
                                       fe_space_type_per_field, &
                                       ptr_dofs_per_fe_and_field, &
                                       lst_dofs_gids, &
                                       lst_vefs_gids_dofs_objects)
  else
     ! L1 tasks do not hold any piece of the coarse triangulation
     nullify(this%coarse_fe_space)
  end if

  ! All tasks free raw data (see actual reason on the top part of this subroutine)
  call memfree (fe_space_type_per_field, __FILE__, __LINE__)
  call memfree (ptr_dofs_per_fe_and_field, __FILE__, __LINE__)
  call memfree (lst_dofs_gids, __FILE__, __LINE__)
  call memfree (lst_vefs_gids_dofs_objects, __FILE__, __LINE__)
  call memfree (coarse_dofs_gids_recv_counts, __FILE__, __LINE__)
  call memfree (coarse_dofs_gids_displs, __FILE__, __LINE__)
end subroutine par_fe_space_setup_coarse_fe_space

subroutine par_fe_space_transfer_number_fields ( this, number_fields )
  implicit none
  class(par_fe_space_t)   , intent(in)      :: this
  integer(ip)              , intent(out)     :: number_fields
  integer(ip)                                :: dummy_integer_ip
  type(environment_t), pointer           :: par_environment

  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_to_l2_task() )
  if ( par_environment%am_i_l1_to_l2_root() ) then
     call par_environment%l1_to_l2_transfer(input_data=dummy_integer_ip, &
                                            output_data=number_fields)
  else
     number_fields = this%get_number_fields()
     call par_environment%l1_to_l2_transfer(input_data=number_fields, &
                                            output_data=dummy_integer_ip) 
  end if
end subroutine par_fe_space_transfer_number_fields

subroutine par_fe_space_transfer_fe_space_type ( this, number_fields, fe_space_type_per_field )
  implicit none
  class(par_fe_space_t)   , intent(in)    :: this
  integer(ip)             , intent(in)       :: number_fields
  integer(ip), allocatable, intent(inout)    :: fe_space_type_per_field(:)
  integer(ip)                                :: dummy_integer_array_ip(0)
  type(environment_t), pointer           :: par_environment

  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_to_l2_task() )
  if ( par_environment%am_i_l1_to_l2_root() ) then
     if ( allocated (fe_space_type_per_field) ) call memfree ( fe_space_type_per_field, __FILE__, __LINE__ )
     call memalloc ( number_fields, fe_space_type_per_field, __FILE__, __LINE__ )
     call par_environment%l1_to_l2_transfer(input_data=dummy_integer_array_ip, &
                                            output_data=fe_space_type_per_field)
  else
     call par_environment%l1_to_l2_transfer(input_data=this%get_fe_space_type(), &
                                            output_data=dummy_integer_array_ip) 
  end if
end subroutine par_fe_space_transfer_fe_space_type

subroutine par_fe_space_gather_ptr_dofs_per_fe_and_field( this, number_fields, ptr_dofs_per_fe_and_field )
  implicit none
  class(par_fe_space_t)   , intent(inout)    :: this
  integer(ip)             , intent(in)       :: number_fields
  integer(ip), allocatable, intent(inout)    :: ptr_dofs_per_fe_and_field(:)
  integer(ip)                                :: i, num_local_cells
  integer(ip)                                :: dummy_integer_array(0)
  type(environment_t), pointer           :: par_environment
  class(base_static_triangulation_t), pointer         :: triangulation
  type(coarse_triangulation_t), pointer      :: coarse_triangulation
  
  par_environment => this%get_par_environment()
  assert ( par_environment%am_i_l1_to_l2_task() )
  if ( par_environment%am_i_l1_to_l2_root() ) then
     triangulation => this%get_triangulation()
     coarse_triangulation => triangulation%get_coarse_triangulation()
     num_local_cells = coarse_triangulation%get_num_local_cells()
     if (allocated(ptr_dofs_per_fe_and_field)) call memfree ( ptr_dofs_per_fe_and_field, __FILE__, __LINE__ )
     call memalloc (num_local_cells*(number_fields+1), ptr_dofs_per_fe_and_field, __FILE__, __LINE__ )
     call par_environment%l2_from_l1_gather( input_data_size = number_fields, &
                                             input_data      = [((0), i=1,number_fields)], &
                                             output_data     = ptr_dofs_per_fe_and_field(2:))
     ptr_dofs_per_fe_and_field(1) = 1
     do i=1, num_local_cells*number_fields
       ptr_dofs_per_fe_and_field(i+1) = ptr_dofs_per_fe_and_field(i) + ptr_dofs_per_fe_and_field(i+1)
     end do
  else
     do i=1, this%number_fields
       this%ptr_coarse_dofs_per_field(i) = this%ptr_coarse_dofs_per_field(i+1)-this%ptr_coarse_dofs_per_field(i) 
     end do
  
     call par_environment%l2_from_l1_gather( input_data_size = this%get_number_fields(), &
                                             input_data      = this%ptr_coarse_dofs_per_field, &
                                             output_data     = dummy_integer_array )
     do i=this%number_fields,1,-1
       this%ptr_coarse_dofs_per_field(i) = this%ptr_coarse_dofs_per_field(i+1)-this%ptr_coarse_dofs_per_field(i) 
     end do
  end if
end subroutine par_fe_space_gather_ptr_dofs_per_fe_and_field

  subroutine par_fe_space_gather_coarse_dofs_gids_rcv_counts_and_displs( this, recv_counts, displs )
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    integer(ip) , allocatable , intent(inout) :: recv_counts(:) 
    integer(ip) , allocatable , intent(inout) :: displs(:)
    integer(ip)                               :: i
    integer(ip)                               :: l1_to_l2_size
    integer(ip)                               :: dummy_integer_array(0)
    type(environment_t), pointer          :: par_environment

    par_environment => this%get_par_environment()
    assert ( par_environment%am_i_l1_to_l2_task() )
    if ( par_environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = par_environment%get_l1_to_l2_size()
      if ( allocated (recv_counts) ) call memfree ( recv_counts, __FILE__, __LINE__ )
      if ( allocated (displs) ) call memfree ( displs, __FILE__, __LINE__ )
      call memalloc ( l1_to_l2_size, recv_counts, __FILE__, __LINE__ )
      call memalloc ( l1_to_l2_size, displs, __FILE__, __LINE__ )
      call par_environment%l2_from_l1_gather( input_data = 0, &
                                              output_data = recv_counts ) 
      displs(1) = 0
      do i=2, l1_to_l2_size
        displs(i) = displs(i-1) + recv_counts(i-1)
      end do
    else
      call par_environment%l2_from_l1_gather( input_data  = this%ptr_coarse_dofs_per_field(this%number_fields+1)-1, &
                                              output_data = dummy_integer_array ) 
    end if
  end subroutine par_fe_space_gather_coarse_dofs_gids_rcv_counts_and_displs
  
  subroutine par_fe_space_gather_coarse_dofs_gids ( this, recv_counts, displs, lst_gids )
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    integer(ip)               , intent(in)    :: recv_counts(:)
    integer(ip)               , intent(in)    :: displs(:)
    integer(igp), allocatable , intent(inout) :: lst_gids(:)
    integer(ip)                               :: l1_to_l2_size
    integer(igp)                              :: dummy_integer_array_igp(0)
    integer(ip)                               :: dummy_integer_array_ip(0)
    type(environment_t), pointer          :: par_environment
    integer(ip)                               :: i, spos, epos
    integer(igp), allocatable                 :: buffer(:)
    
    par_environment => this%get_par_environment()
    assert ( par_environment%am_i_l1_to_l2_task() )
    if ( par_environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = par_environment%get_l1_to_l2_size()
      if (allocated(lst_gids)) call memfree ( lst_gids, __FILE__, __LINE__ )
      call memalloc ( displs(l1_to_l2_size), lst_gids, __FILE__, __LINE__ )
      call par_environment%l2_from_l1_gather( input_data_size = 0, &
                                              input_data      = dummy_integer_array_igp, &
                                              recv_counts     = recv_counts, &
                                              displs          = displs, &
                                              output_data     = lst_gids )
    else
      ! Pack dofs_objects_gids_per_field(:) into plain buffer for further data exchange
      call memalloc ( this%ptr_coarse_dofs_per_field(this%number_fields+1)-1, buffer, __FILE__, __LINE__ ) 
      do i=1, this%get_number_fields()
        spos = this%ptr_coarse_dofs_per_field(i)
        epos = this%ptr_coarse_dofs_per_field(i+1)-1
        buffer(spos:epos) = this%coarse_dof_gids_per_field(i)%a
        spos = epos +1 
      end do
    
      call par_environment%l2_from_l1_gather( input_data_size = size(buffer), &
                                              input_data      = buffer, &
                                              recv_counts     = dummy_integer_array_ip, &
                                              displs          = dummy_integer_array_ip, &
                                              output_data     = dummy_integer_array_igp )
      call memfree ( buffer, __FILE__, __LINE__ )
    end if    
  end subroutine par_fe_space_gather_coarse_dofs_gids

  subroutine par_fe_space_gather_vefs_gids_dofs_objects ( this, recv_counts, displs, vef_gids )
    implicit none
    class(par_fe_space_t)     , intent(in)   :: this
    integer(ip)               , intent(in)    :: recv_counts(:)
    integer(ip)               , intent(in)    :: displs(:)
    integer(igp), allocatable , intent(inout) :: vef_gids(:)
    integer(ip)                               :: l1_to_l2_size
    integer(igp)                              :: dummy_integer_array_igp(0)
    integer(ip)                               :: dummy_integer_array_ip(0)
    type(environment_t), pointer          :: par_environment
    integer(ip)                               :: i, j, spos, epos
    integer(igp), allocatable                 :: buffer(:)
    type(fe_object_iterator_t)                :: object
    type(list_iterator_t)                     :: own_coarse_dofs_iterator
    
    par_environment => this%get_par_environment()
    assert ( par_environment%am_i_l1_to_l2_task() )
    if ( par_environment%am_i_l1_to_l2_root() ) then
      l1_to_l2_size = par_environment%get_l1_to_l2_size()
      if (allocated(vef_gids)) call memfree ( vef_gids, __FILE__, __LINE__ )
      call memalloc ( displs(l1_to_l2_size), vef_gids, __FILE__, __LINE__ )
      call par_environment%l2_from_l1_gather( input_data_size = 0, &
                                                           input_data      = dummy_integer_array_igp, &
                                                           recv_counts     = recv_counts, &
                                                           displs          = displs, &
                                                           output_data     = vef_gids )
    else
      ! Pack vefs_lids_dofs_objects_per_field(:) into plain buffer for further data exchange
      call memalloc ( this%ptr_coarse_dofs_per_field(this%number_fields+1)-1, buffer, __FILE__, __LINE__ )
      do i=1, this%get_number_fields()
        spos = this%ptr_coarse_dofs_per_field(i)
        call this%create_fe_object_iterator(object)
        do while ( .not. object%has_finished() )
          own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(i)
          do while (.not. own_coarse_dofs_iterator%is_upper_bound())
            buffer(spos) = object%get_gid() 
            spos = spos +1
            call own_coarse_dofs_iterator%next()
          end do
          call object%next()
        end do
        call this%free_fe_object_iterator(object)
      end do
    
      call par_environment%l2_from_l1_gather( input_data_size = size(buffer), &
                                              input_data      = buffer, &
                                              recv_counts     = dummy_integer_array_ip, &
                                              displs          = dummy_integer_array_ip, &
                                              output_data     = dummy_integer_array_igp )
      
      call memfree ( buffer, __FILE__, __LINE__ )
    end if    
  end subroutine par_fe_space_gather_vefs_gids_dofs_objects
  
  function par_fe_space_get_total_number_coarse_dofs ( this )
    implicit none
    class(par_fe_space_t)           , intent(in) :: this
    integer(ip)                               :: par_fe_space_get_total_number_coarse_dofs
    integer(ip)                               :: field_id
    par_fe_space_get_total_number_coarse_dofs = 0
    do field_id = 1, this%get_number_fields()
       par_fe_space_get_total_number_coarse_dofs = par_fe_space_get_total_number_coarse_dofs + & 
                                                   this%ptr_coarse_dofs_per_field(field_id+1)-this%ptr_coarse_dofs_per_field(field_id)
    end do
  end function par_fe_space_get_total_number_coarse_dofs
  
  function par_fe_space_get_block_number_coarse_dofs ( this, block_id )
    implicit none
    class(par_fe_space_t)           , intent(in)    :: this
    integer(ip)               , intent(in)    :: block_id
    integer(ip)                               :: par_fe_space_get_block_number_coarse_dofs 
    integer(ip)                               :: field_id
    assert ( block_id == 1 )
    par_fe_space_get_block_number_coarse_dofs = 0
    do field_id = 1, this%get_number_fields()
       if ( this%block_layout%get_block_id(field_id) == block_id ) then
         par_fe_space_get_block_number_coarse_dofs = par_fe_space_get_block_number_coarse_dofs + & 
                                                     this%ptr_coarse_dofs_per_field(field_id+1)-this%ptr_coarse_dofs_per_field(field_id)
       end if                                      
    end do
  end function par_fe_space_get_block_number_coarse_dofs
  
 function par_fe_space_get_coarse_fe_handler ( this, field_id ) 
    implicit none
	   class(par_fe_space_t), target, intent(in) :: this
	   integer(ip)                  , intent(in) :: field_id
	   class(l1_coarse_fe_handler_t), pointer :: par_fe_space_get_coarse_fe_handler
	   par_fe_space_get_coarse_fe_handler => this%coarse_fe_handlers(field_id)%p
  end function par_fe_space_get_coarse_fe_handler
  
 subroutine par_fe_space_create_fe_object_iterator (this,fe_object)
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    type(fe_object_iterator_t), intent(inout) :: fe_object
    call fe_object%create(this)
 end subroutine par_fe_space_create_fe_object_iterator
 
 subroutine par_fe_space_free_fe_object_iterator (this,fe_object)
    implicit none
    class(par_fe_space_t)     , intent(in)    :: this
    type(fe_object_iterator_t), intent(inout) :: fe_object
    call fe_object%free()
 end subroutine par_fe_space_free_fe_object_iterator
