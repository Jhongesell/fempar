! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

function hpafeci_is_strong_dirichlet_dof ( this, dof_lid )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t), intent(in) :: this
  integer(ip)                          , intent(in) :: dof_lid
  logical :: hpafeci_is_strong_dirichlet_dof
  hpafeci_is_strong_dirichlet_dof = (dof_lid < 0 .and. dof_lid >= -this%fe_space%num_dirichlet_dofs )
end function hpafeci_is_strong_dirichlet_dof

!function hpafefi_compute_fe_facet_permutation_index (this,first_fe,second_fe) result (fe_facet_permutation_index)
!  implicit none
!  class(hp_adaptive_fe_facet_iterator_t), intent(inout) :: this
!  class(fe_cell_iterator_t)                 , intent(inout) :: first_fe
!  class(fe_cell_iterator_t)                 , intent(inout) :: second_fe
!  integer(ip)                                          :: fe_facet_permutation_index
!  ! WARNING: This procedure assumes the problem is meshed with a single octree.
!  ! All facets of an octree have the same orientation. Thus, fe_facet_permutation_index
!  ! can be straightforwardly set to 1.
!  !
!  ! On a forest of octrees, the interface facets can have different orientations.
!  ! In this case, one may compute the face permutation index following the steps:
!  !  1.- Extract from the first FE the ivef and the vef_lid of the first proper vertex.
!  !  2.- Extract from the second FE the ivef of the vertex that has this vef_lid.
!  !  3.- Extract relative rotation with dimension dependents lookup_tables.
!  !        relative_rotation_nD(ivef_first_fe,ivef_second_fe)
!  !    
!  !    2D: reshape( [ 1, 2, 2, 1 ] , [ 2, 2] )
!  !    
!  !    3D: reshape( [1, 2, 3, 4, 3, 1, 4, 2, 2, 4, 1, 3, 4, 3, 2, 1] , [4, 4] )
!  !    
!  assert( .not. this%is_ghost() .and. this%get_num_cells_around() == 2 )
!  fe_facet_permutation_index = 1
!end function hpafefi_compute_fe_facet_permutation_index

subroutine serial_hp_adaptive_fe_space_create_fe_cell_iterator ( this, fe )
  implicit none
  class(serial_hp_adaptive_fe_space_t), intent(in)  :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(hp_adaptive_fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine serial_hp_adaptive_fe_space_create_fe_cell_iterator

subroutine shpafs_set_up_strong_dirichlet_bcs( this )
  implicit none
  class(serial_hp_adaptive_fe_space_t), intent(inout) :: this
  integer(ip) :: i
  
  call serial_fe_space_set_up_strong_dirichlet_bcs(this)
  this%num_dirichlet_dofs = this%get_num_fixed_dofs()  
end subroutine shpafs_set_up_strong_dirichlet_bcs

subroutine shpafs_fill_facet_gids ( this )
  implicit none
  class(serial_hp_adaptive_fe_space_t), intent(inout) :: this 
  class(triangulation_t), pointer     :: triangulation
  type(std_vector_integer_ip_t)     , pointer     :: facet_gids
  type(fe_vef_iterator_t)                         :: fe_vef
  triangulation => this%get_triangulation()
  call this%facet_gids%resize(0)
  call this%create_fe_vef_iterator(fe_vef)
  do while ( .not. fe_vef%has_finished() )
    if ( is_fe_face() ) then
      call this%facet_gids%push_back(fe_vef%get_gid())
    end if
    call fe_vef%next()
  end do
  call this%free_fe_vef_iterator(fe_vef)
  
  contains
  
    function is_fe_face()
      implicit none
      logical :: is_fe_face
      is_fe_face = fe_vef%is_facet() .and. ( ( .not. fe_vef%is_proper() ) .or.                         &
                                            ( fe_vef%is_proper() .and. ( fe_vef%is_at_boundary() .or. &
                                                                         fe_vef%get_num_cells_around() > 1 ) ) )
    end function is_fe_face
  
end subroutine shpafs_fill_facet_gids

subroutine serial_hp_adaptive_fe_space_generate_global_dof_numbering( this, block_layout )
  implicit none
  class(serial_hp_adaptive_fe_space_t), intent(inout) :: this 
  type(block_layout_t), target        , intent(inout) :: block_layout
  logical :: perform_numbering
  integer(ip) :: block_id, field_id
  type(block_layout_t), pointer :: p_block_layout
  
  p_block_layout => this%get_block_layout()
  perform_numbering = .not. associated(p_block_layout) 
  if (.not. perform_numbering) perform_numbering = .not. (p_block_layout == block_layout)
  
  if ( perform_numbering ) then
    call this%set_block_layout(block_layout)
    ! Initialize number DoFs per field
    call this%allocate_num_dofs_x_field()
    do field_id=1, this%get_num_fields()
      call this%set_field_num_dofs(field_id, 0)
    end do
  
    ! Initialize number DoFs per block
    do block_id=1, this%get_num_blocks()
      call this%set_block_num_dofs(block_id, 0)
    end do
  
    ! Generate field-wise/block-wise global DoF identifiers
    do field_id = 1, this%get_num_fields()
      call this%fill_fe_dofs_and_count_dofs( field_id )
    end do
  
    call this%setup_hanging_node_constraints()
  else
    call block_layout%copy_num_dofs_x_block(this%block_layout)
  end if  
end subroutine serial_hp_adaptive_fe_space_generate_global_dof_numbering

subroutine serial_hp_adaptive_fe_space_fill_fe_dofs_and_count_dofs( this, field_id ) 
  implicit none
  ! Parameters
  class(serial_hp_adaptive_fe_space_t), intent(inout) :: this 
  integer(ip)                         ,  intent(in)   :: field_id

  ! Local variables
  integer(ip) :: ivef, vef_lid
  integer(ip) :: iblock, init_dof_block, current_dof_block, previous_dof_block
  integer(ip) :: init_fixed_dof, current_fixed_dof, previous_fixed_dof
  integer(ip), allocatable :: visited_proper_vef_to_cell_map(:,:)
  integer(ip), allocatable :: visited_improper_vef_to_cell_map(:,:)
  
  class(fe_cell_iterator_t) , allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t) :: vef
  integer(ip), pointer :: field_blocks(:)
  integer(ip), pointer :: fe_space_type_x_field(:)

  logical :: all_improper_cells_around_void, is_owner
  integer(ip) :: source_cell_id
  integer(ip) :: source_vef_lid  
  integer(ip) :: icell_improper_around

  field_blocks            => this%get_field_blocks()
  fe_space_type_x_field => this%get_fe_space_type()
  iblock            = field_blocks(field_id)
  init_dof_block    = this%get_block_num_dofs(iblock)
  current_dof_block = init_dof_block
  
  init_fixed_dof    = this%num_fixed_dofs
  current_fixed_dof = init_fixed_dof

  call this%create_fe_cell_iterator(fe)
  if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
     call memalloc ( 2, this%p4est_triangulation%get_num_proper_vefs(), visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
     call memalloc ( 2, this%p4est_triangulation%get_num_improper_vefs(), visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
     visited_proper_vef_to_cell_map = -1
     visited_improper_vef_to_cell_map = -1
     
     call this%create_fe_vef_iterator(vef)
     call this%create_fe_cell_iterator(source_fe)
     call this%create_fe_cell_iterator(coarser_fe)
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
           do ivef = 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              
              all_improper_cells_around_void=.true.
              do icell_improper_around=1, vef%get_num_improper_cells_around()
                call vef%get_improper_cell_around(icell_improper_around,coarser_fe)
                if (.not. coarser_fe%is_void(field_id)) then 
                   all_improper_cells_around_void=.false.
                   exit
                end if
              end do
              
              if ( vef%is_proper() .or. all_improper_cells_around_void ) then

                 vef_lid = abs(fe%get_vef_gid(ivef))
                 is_owner = .false.
                 if ( vef%is_proper()) then
                   is_owner = ( visited_proper_vef_to_cell_map   ( 1, vef_lid ) == -1 )
                 else
                   is_owner = ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 )
                 end if

                 if ( is_owner ) then
                    previous_dof_block = current_dof_block
                    call fe%generate_own_dofs_vef ( ivef, field_id, current_dof_block, free_dofs_loop=.true.  )
                    if (previous_dof_block < current_dof_block) then
                      if ( vef%is_proper()) then
                        visited_proper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                        visited_proper_vef_to_cell_map ( 2, vef_lid ) = ivef
                      else
                        visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                        visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
                      end if
                    end if
                 else 
                    if ( vef%is_proper()) then
                      source_cell_id = visited_proper_vef_to_cell_map(1,vef_lid)
                      source_vef_lid = visited_proper_vef_to_cell_map(2,vef_lid)
                    else
                      source_cell_id = visited_improper_vef_to_cell_map(1,vef_lid)
                      source_vef_lid = visited_improper_vef_to_cell_map(2,vef_lid)
                    end if
                    call source_fe%set_gid(source_cell_id)
                    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
                 end if
              else 
                 assert ( fe%get_vef_gid(ivef) < 0 )
                 vef_lid = abs(fe%get_vef_gid(ivef))
                 if ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 ) then
                    previous_fixed_dof = current_fixed_dof
                    call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.  )
                    if (previous_fixed_dof < current_fixed_dof) then
                      visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                      visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
                    end if
                 else 
                    call source_fe%set_gid(visited_improper_vef_to_cell_map(1,vef_lid))
                    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                         source_fe, &
                         visited_improper_vef_to_cell_map(2,vef_lid), &
                         field_id) 
                 end if
              end if   
           end do
          end if 
          call fe%determine_has_fixed_dofs(field_id)
          call fe%determine_has_hanging_dofs(field_id)
          call fe%next()
        end do
        call this%free_fe_cell_iterator(source_fe)
        call this%free_fe_cell_iterator(coarser_fe)
        call this%free_fe_vef_iterator(vef)
        call memfree ( visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
        call memfree ( visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
  else    
     ! TODO: this code is a verbatim copy of the one of its parent.
     !       we should better split the parent into additional TBPs
     !       to avoid code replication
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
        end if
        call fe%next()
     end do
  end if
  call this%free_fe_cell_iterator(fe)

  call this%set_field_num_dofs(field_id,current_dof_block - init_dof_block)
  call this%set_block_num_dofs(iblock, this%get_block_num_dofs(iblock) + & 
                                          this%get_field_num_dofs(field_id))
  this%num_hanging_dofs = current_fixed_dof - init_fixed_dof
  ! this%num_fixed_dofs = this%num_hanging_dofs + this%num_dirichlet_dof
  this%num_fixed_dofs = current_fixed_dof
end subroutine serial_hp_adaptive_fe_space_fill_fe_dofs_and_count_dofs

subroutine shpafs_setup_hanging_node_constraints ( this )
  implicit none
  class(serial_hp_adaptive_fe_space_t), intent(inout) :: this 
  class(fe_cell_iterator_t), allocatable :: fe
  class(fe_cell_iterator_t), allocatable :: coarser_fe
  type(fe_vef_iterator_t) :: fe_vef, fe_vef_bis, coarser_vef
  type(list_iterator_t) :: fe_own_dofs_on_vef_iterator
  type(list_iterator_t) :: fe_dofs_on_vef_iterator 
  type(list_iterator_t) :: coarser_fe_dofs_on_vef_iterator
  integer(ip) :: improper_vef_lid
  integer(ip) :: block_id, field_id
  class(reference_fe_t), pointer :: reference_fe, coarser_reference_fe
  integer(ip), pointer :: fe_dofs(:), coarser_fe_fe_dofs(:)
  integer(ip) :: istat, i, icell, min_cell_gid
  integer(ip) :: improper_dof_lid, hanging_dof_lid
  integer(ip) :: improper_vef_ivef, coarser_fe_ivef, coarse_fe_subvef
  integer(ip), pointer :: field_blocks(:)
  integer(ip) :: qpoint, ishape_fe, ishape_coarser_fe
  type(interpolation_t), pointer :: h_refinement_interpolation
  integer(ip), pointer :: h_refinement_subedge_permutation(:,:,:)
  integer(ip), pointer :: h_refinement_subfacet_permutation(:,:,:)
  real(rp) :: coefficient
  integer(ip) :: num_cell_vertices, num_cell_edges, num_cell_faces
  integer(ip) :: num_subedges_x_edge, num_subfaces_x_face
  integer(ip) :: vef_lid, facet_lid
  type(list_t), pointer :: facets_n_face
  type(list_iterator_t) :: facets_n_face_iterator
  type(list_iterator_t) :: dofs_n_facet_iterator
  integer(ip) :: facet_dof

  field_blocks => this%get_field_blocks()
    
  ! Re-size to 0 to force re-initialization during second resize (to the actual/correct size)
  call this%ptr_constraining_free_dofs%resize(0)
  call this%ptr_constraining_dirichlet_dofs%resize(0)
  call this%ptr_constraining_free_dofs%resize(this%num_hanging_dofs+1,0)
  call this%ptr_constraining_dirichlet_dofs%resize(this%num_hanging_dofs+1,0)
  call this%constraining_free_dofs%resize(this%num_hanging_dofs)
  call this%constraining_free_dofs_coefficients%resize(this%num_hanging_dofs)
  call this%constraining_dirichlet_dofs%resize(this%num_hanging_dofs)
  call this%constraining_dirichlet_dofs_coefficients%resize(this%num_hanging_dofs)
  call this%constraints_independent_term%resize(this%num_hanging_dofs)

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_vef_iterator(fe_vef)
  call this%create_fe_vef_iterator(fe_vef_bis)
  call this%create_fe_vef_iterator(coarser_vef)
  
  reference_fe => fe%get_reference_fe(1)
  num_cell_vertices = reference_fe%get_num_vertices()
  if  (this%p4est_triangulation%get_num_dims() == 3) then
    num_cell_edges       = reference_fe%get_num_n_faces_of_dim(1)
    num_subfaces_x_face  = 4
    num_subedges_x_edge  = 2 
  else
    num_cell_edges       = 0
    num_subfaces_x_face  = 2
  end if  
  num_cell_faces = reference_fe%get_num_facets()
  
  allocate(fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);
  allocate(coarser_fe_fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);

  ! Computation of constraints     
  do improper_vef_lid = 1, this%p4est_triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)

     do field_id=1, this%get_num_fields()
        
        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( .not. fe%is_void(field_id) ) exit
        end do
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)
        
        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. coarser_fe%is_void(field_id) ) exit
        end do
        if ( coarser_fe%is_void(field_id) ) cycle
        coarser_fe_ivef = fe_vef%get_improper_cell_around_ivef(icell)
        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)
        
        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe  => coarser_fe%get_reference_fe(field_id)
        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           improper_dof_lid = fe_dofs(fe_own_dofs_on_vef_iterator%get_current())

           if ( fe%is_free_dof(improper_dof_lid) ) exit

           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs

           coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) ) then
                call this%ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, &
                                                              this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid+1)+1)
              else
                call this%ptr_constraining_free_dofs%set(hanging_dof_lid+1, &
                                                         this%ptr_constraining_free_dofs%get(hanging_dof_lid+1)+1)
              end if
              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do
   
  call this%p4est_triangulation%std_vector_transform_length_to_header(this%ptr_constraining_free_dofs)
  call this%constraining_free_dofs%resize(this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)
  call this%constraining_free_dofs_coefficients%resize(this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)
  
  call this%p4est_triangulation%std_vector_transform_length_to_header(this%ptr_constraining_dirichlet_dofs)
  call this%constraining_dirichlet_dofs%resize(this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)
  call this%constraining_dirichlet_dofs_coefficients%resize(this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)
  
  ! Computation of constraints     
  do improper_vef_lid = 1, this%p4est_triangulation%get_num_improper_vefs()
     call fe_vef%set_gid(-improper_vef_lid)

     do field_id=1, this%get_num_fields()
        
        ! Retrieve all data related to the current improper vef 
        ! and one of the cells that owns it
        do icell = 1,fe_vef%get_num_cells_around()
           call fe_vef%get_cell_around(icell,fe)
           if ( .not. fe%is_void(field_id) ) exit
        end do
        if ( fe%is_void(field_id) ) cycle
        improper_vef_ivef = fe%get_vef_lid_from_gid(fe_vef%get_gid())
        call fe%get_field_fe_dofs(field_id,fe_dofs)
        
        ! Retrieve all data related to the first improper cell around current improper vef
        do icell = 1,fe_vef%get_num_improper_cells_around()
           call fe_vef%get_improper_cell_around(icell,coarser_fe)
           if ( .not. coarser_fe%is_void(field_id) ) exit
        end do
        if ( coarser_fe%is_void(field_id) ) cycle
        coarser_fe_ivef  = fe_vef%get_improper_cell_around_ivef(icell)
        coarse_fe_subvef = fe_vef%get_improper_cell_around_subvef(icell)
        call coarser_fe%get_field_fe_dofs(field_id,coarser_fe_fe_dofs)
        call coarser_fe%get_vef(coarser_fe_ivef,coarser_vef)

        reference_fe => fe%get_reference_fe(field_id)
        coarser_reference_fe => coarser_fe%get_reference_fe(field_id)
        
        select type(coarser_reference_fe)
        type is (hex_lagrangian_reference_fe_t)
           h_refinement_subedge_permutation => coarser_reference_fe%get_h_refinement_subedget_permutation()
           h_refinement_subfacet_permutation => coarser_reference_fe%get_h_refinement_subfacet_permutation()
        class default
          assert(.false.)
        end select
        
        block_id = field_blocks(field_id)
        fe_own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(improper_vef_ivef)
        fe_dofs_on_vef_iterator = reference_fe%create_dofs_on_n_face_iterator(improper_vef_ivef)
        do while (.not. fe_own_dofs_on_vef_iterator%is_upper_bound() )
           ishape_fe = fe_own_dofs_on_vef_iterator%get_current()
           improper_dof_lid = fe_dofs(ishape_fe)
           assert ( fe%is_fixed_dof(improper_dof_lid) )
           improper_dof_lid = abs(improper_dof_lid)
           hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs
           
           call fe_dofs_on_vef_iterator%begin() 
           do while (.not. fe_dofs_on_vef_iterator%is_upper_bound() )
             if ( fe_dofs_on_vef_iterator%get_current() == ishape_fe ) exit
             call fe_dofs_on_vef_iterator%next() 
           end do
           assert (.not. fe_dofs_on_vef_iterator%is_upper_bound() )
           
           if ( fe_vef%get_dim() == 0 ) then ! vef is a corner (2D/3D)
              if ( coarser_vef%get_dim()  == 1 .and. this%p4est_triangulation%get_num_dims() == 3) then
                 qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices,num_subedges_x_edge,1)
              else
                 qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges,num_subfaces_x_face,1)
              end if
           else if ( fe_vef%get_dim()  == 1 .and. this%p4est_triangulation%get_num_dims() == 3 .and. coarse_fe_subvef > 0 ) then 
              qpoint = h_refinement_subedge_permutation(coarser_fe_ivef-num_cell_vertices, &
                                                        coarse_fe_subvef, &
                                                        fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
           else if ( fe_vef%get_dim()  == 1 .and. this%p4est_triangulation%get_num_dims() == 3 .and. coarse_fe_subvef < 0 ) then
              assert ( fe_vef%get_num_cells_around() == 2 )
              ! Go over cells around fe_vef(), and find the one with the minimum global identifier
              call fe_vef%get_cell_around(1,fe)
              min_cell_gid=fe%get_gid()
              call fe_vef%get_cell_around(2,fe)
              min_cell_gid=min(fe%get_gid(),min_cell_gid)
              call fe%set_gid(min_cell_gid)
              
              call fe%get_field_fe_dofs(field_id,fe_dofs)
              
              reference_fe  => fe%get_reference_fe(field_id)    
              facets_n_face => reference_fe%get_facets_n_face()      
                            
              ! Go over faces around fe_vef in cell with minimum global identifier
              facet_loop: do facet_lid = reference_fe%get_first_facet_id(), &
                                         reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1
                  call fe_vef_bis%set_gid(fe%get_vef_gid(facet_lid))
                  if (.not. fe_vef_bis%is_proper()) then
                    facets_n_face_iterator = facets_n_face%create_iterator(facet_lid)
                    do while (.not. facets_n_face_iterator%is_upper_bound())
                      if (fe%get_vef_gid(facets_n_face_iterator%get_current()) == fe_vef%get_gid() ) then
                        exit facet_loop
                      end if
                      call facets_n_face_iterator%next()
                    end do 
                  end if
              end do facet_loop
              
              assert(facet_lid<=reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1)
              
              ! Go over DoFs on facet, and locate the facet dof LID corresponding to the edge DoF 
              facet_dof=1
              dofs_n_facet_iterator = reference_fe%create_dofs_n_face_iterator(facet_lid)
              do while (.not. dofs_n_facet_iterator%is_upper_bound())
                if (fe_dofs(dofs_n_facet_iterator%get_current()) == -improper_dof_lid) then
                  exit
                end if  
                call dofs_n_facet_iterator%next()
                facet_dof = facet_dof+1
              end do 
              assert (.not. dofs_n_facet_iterator%is_upper_bound())
                            
              qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges,&
                                                         abs(coarse_fe_subvef),&
                                                         facet_dof)              
           else if (fe_vef%get_dim() == this%p4est_triangulation%get_num_dims()-1) then ! vef is a face (2D/3D)
              qpoint = h_refinement_subfacet_permutation(coarser_fe_ivef-num_cell_vertices-num_cell_edges, &
                                                        coarse_fe_subvef, &
                                                        fe_dofs_on_vef_iterator%get_distance_to_lower_bound())
           end if
           
           coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
           do while (.not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
              ishape_coarser_fe = coarser_fe_dofs_on_vef_iterator%get_current() 
              
              ! Evaluate coefficient
              select type(coarser_reference_fe)
                type is (hex_lagrangian_reference_fe_t)
                call coarser_reference_fe%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient) 
              class default
                assert(.false.)
              end select
              
              ! Set dependency and coefficient into the corresponding std_vector data structure
              if ( fe%is_strong_dirichlet_dof( coarser_fe_fe_dofs(ishape_coarser_fe) ) ) then
                call this%constraining_dirichlet_dofs%set(this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                                                          coarser_fe_fe_dofs(ishape_coarser_fe))
                call this%constraining_dirichlet_dofs_coefficients%set(this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid),&
                                                                       coefficient)
                call this%ptr_constraining_dirichlet_dofs%set(hanging_dof_lid, &
                                                              this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)+1)
              else
                call this%constraining_free_dofs%set(this%ptr_constraining_free_dofs%get(hanging_dof_lid),&
                                                     coarser_fe_fe_dofs(ishape_coarser_fe))
                call this%constraining_free_dofs_coefficients%set(this%ptr_constraining_free_dofs%get(hanging_dof_lid),&
                                                                  coefficient)
                call this%ptr_constraining_free_dofs%set(hanging_dof_lid, &
                                                         this%ptr_constraining_free_dofs%get(hanging_dof_lid)+1)
              end if
              
              call coarser_fe_dofs_on_vef_iterator%next()
           end do
           call fe_own_dofs_on_vef_iterator%next() 
        end do
     end do
  end do
  
  do i=this%ptr_constraining_free_dofs%size(),2,-1
    call this%ptr_constraining_free_dofs%set(i, this%ptr_constraining_free_dofs%get(i-1))
  end do
  call this%ptr_constraining_free_dofs%set(1,1)
  
  do i=this%ptr_constraining_dirichlet_dofs%size(),2,-1
    call this%ptr_constraining_dirichlet_dofs%set(i, this%ptr_constraining_dirichlet_dofs%get(i-1))
  end do
  call this%ptr_constraining_dirichlet_dofs%set(1,1)
  
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(fe_vef)
  call this%free_fe_vef_iterator(fe_vef_bis)
  call this%free_fe_vef_iterator(coarser_vef)
end subroutine shpafs_setup_hanging_node_constraints 

!! Assembly of local matrices for hp-adaptivity


subroutine hpafeci_assembly_array ( this,  &
                                        elvec, &
                                        assembler )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elvec(:)
  class(assembler_t), intent(inout) :: assembler
  massert(.false.,'hpafeci_assembly_array not implemented yet')
end subroutine hpafeci_assembly_array

subroutine hpafeci_assembly_matrix ( this,  &
                                         elmat, &
                                         assembler )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elmat(:,:)
  class(assembler_t), intent(inout) :: assembler
  massert(.false.,'hpafeci_assembly_matrix not implemented yet')
end subroutine hpafeci_assembly_matrix

subroutine hpafeci_assembly_matrix_array ( this,  &
                                               elmat, &
                                               elvec, &
                                               assembler )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elmat(:,:)
  real(rp)                       , intent(in)    :: elvec(:)
  class(assembler_t), intent(inout) :: assembler
  
  logical :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do

  if ( no_hanging_node_constraints ) then
     call this%fe_cell_iterator_t%assembly(elmat,elvec,assembler)
  else  
     ! update scratch data in fe_space_t
     call this%update_scratch_data()
     ! "apply constraints"
     call this%apply_constraints ( elmat, elvec )
     ! impose strong dirichlet bc's
     call assembler%assembly_matrix( this%fe_space%num_fields,        &
                                               this%fe_space%get_field_blocks(),    &
                                               this%fe_space%get_field_coupling(),  &
                                               this%num_cell_dofs_x_field,         &
                                               this%num_cell_dofs_x_field,         &
                                               this%fe_dofs,                      &
                                               this%fe_dofs,                      &
                                               this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,         &
                                              this%fe_space%get_field_blocks(),    &
                                              this%fe_space%get_field_coupling(),  &
                                              this%num_cell_dofs_x_field,          &
                                              this%fe_dofs,                       &
                                              this%extended_elvec%a )
  end if
  
end subroutine hpafeci_assembly_matrix_array

subroutine hpafeci_assembly_matrix_array_with_strong_bcs(this,fe_function,elmat,elvec,assembler)
  implicit none
  class(hp_adaptive_fe_cell_iterator_t), intent(inout)    :: this
  type(fe_function_t), intent(in) :: fe_function
  real(rp), intent(in) :: elmat(:,:)
  real(rp), intent(inout) :: elvec(:)
  class(assembler_t) , intent(inout) :: assembler

  logical :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do

  if ( no_hanging_node_constraints ) then
     call this%fe_cell_iterator_t%assembly(fe_function,elmat,elvec,assembler)
  else  
     ! update scratch data in fe_space_t
     call this%update_scratch_data()
     ! "apply constraints"
     call this%apply_constraints ( elmat, elvec )
     ! impose strong dirichlet bc's
     call this%hpafeci_impose_strong_dirichlet_bcs ( fe_function )
     ! call assembler%assembly()
     call assembler%assembly_matrix( this%fe_space%num_fields,        &
                                               this%fe_space%get_field_blocks(),    &
                                               this%fe_space%get_field_coupling(),  &
                                               this%num_cell_dofs_x_field,         &
                                               this%num_cell_dofs_x_field,         &
                                               this%fe_dofs,                      &
                                               this%fe_dofs,                      &
                                               this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,         &
                                              this%fe_space%get_field_blocks(),    &
                                              this%fe_space%get_field_coupling(),  &
                                              this%num_cell_dofs_x_field,          &
                                              this%fe_dofs,                       &
                                              this%extended_elvec%a )
  end if
  
end subroutine hpafeci_assembly_matrix_array_with_strong_bcs
 
  subroutine hpafeci_impose_strong_dirichlet_bcs ( this, fe_function )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t), intent(inout)    :: this
  type(fe_function_t) , intent(in)    :: fe_function
  
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp)                   , pointer :: strong_dirichlet_values_entries(:)
  integer(ip) :: ifield, i_lid, i_gid, i_gid_hanging, k_lid, k_gid, pos, spos, epos
  real(rp) :: weight
  
  strong_dirichlet_values         => fe_function%get_fixed_dof_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
     do ifield=1, this%get_num_fields() 
        do i_lid=1, this%num_cell_dofs_x_field(ifield)
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           ! i is a hanging DoF?
           if ( this%is_hanging_dof(i_gid) ) then
              ! Traverse constraining dirichlet DoFs of i
              i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
              spos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging)
              epos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging+1)-1
              do pos=spos, epos 
                 k_gid = this%fe_space%constraining_dirichlet_dofs%get(pos)
                 weight = this%fe_space%constraining_dirichlet_dofs_coefficients%get(pos)
                 ! add the hanging dof column * weighting * dirichlet dof value * -1 to the RHS (for extended elvec)
                 this%extended_elvec%a(:) = this%extended_elvec%a(:)-weight*this%extended_elmat%a(:,i_lid)*strong_dirichlet_values_entries(abs(k_gid))
              end do
           ! i is dirichlet dof, proceed as usual
           else if ( this%is_strong_dirichlet_dof(i_gid) ) then
              this%extended_elvec%a(:) = this%extended_elvec%a(:)-this%extended_elmat%a(:,i_lid)*strong_dirichlet_values_entries(abs(i_gid))
           end if
        end do
     end do

   end subroutine hpafeci_impose_strong_dirichlet_bcs
   
