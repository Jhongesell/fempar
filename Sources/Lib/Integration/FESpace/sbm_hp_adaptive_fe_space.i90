! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!function hpafefi_compute_fe_facet_permutation_index (this,first_fe,second_fe) result (fe_facet_permutation_index)
!  implicit none
!  class(hp_adaptive_fe_facet_iterator_t), intent(inout) :: this
!  class(fe_cell_iterator_t)                 , intent(inout) :: first_fe
!  class(fe_cell_iterator_t)                 , intent(inout) :: second_fe
!  integer(ip)                                          :: fe_facet_permutation_index
!  ! WARNING: This procedure assumes the problem is meshed with a single octree.
!  ! All facets of an octree have the same orientation. Thus, fe_facet_permutation_index
!  ! can be straightforwardly set to 1.
!  !
!  ! On a forest of octrees, the interface facets can have different orientations.
!  ! In this case, one may compute the face permutation index following the steps:
!  !  1.- Extract from the first FE the ivef and the vef_lid of the first proper vertex.
!  !  2.- Extract from the second FE the ivef of the vertex that has this vef_lid.
!  !  3.- Extract relative rotation with dimension dependents lookup_tables.
!  !        relative_rotation_nD(ivef_first_fe,ivef_second_fe)
!  !    
!  !    2D: reshape( [ 1, 2, 2, 1 ] , [ 2, 2] )
!  !    
!  !    3D: reshape( [1, 2, 3, 4, 3, 1, 4, 2, 2, 4, 1, 3, 4, 3, 2, 1] , [4, 4] )
!  !    
!  assert( .not. this%is_ghost() .and. this%get_num_cells_around() == 2 )
!  fe_facet_permutation_index = 1
!end function hpafefi_compute_fe_facet_permutation_index

subroutine serial_hp_adaptive_fe_space_create_fe_cell_iterator ( this, fe )
  implicit none
  class(serial_hp_adaptive_fe_space_t), intent(in)  :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(hp_adaptive_fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine serial_hp_adaptive_fe_space_create_fe_cell_iterator

subroutine serial_hp_adaptive_fe_space_fill_fe_dofs_and_count_dofs( this, field_id ) 
  implicit none
  ! Parameters
  class(serial_hp_adaptive_fe_space_t), intent(inout) :: this 
  integer(ip)                         ,  intent(in)   :: field_id

  ! Local variables
  integer(ip) :: ivef, vef_lid
  integer(ip) :: iblock, init_dof_block, current_dof_block, previous_dof_block
  integer(ip) :: init_fixed_dof, current_fixed_dof, previous_fixed_dof
  integer(ip), allocatable :: visited_proper_vef_to_cell_map(:,:)
  integer(ip), allocatable :: visited_improper_vef_to_cell_map(:,:)
  
  class(fe_cell_iterator_t) , allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t) :: vef
  integer(ip), pointer :: field_blocks(:)
  integer(ip), pointer :: fe_space_type_x_field(:)

  logical :: all_improper_cells_around_void, is_owner
  integer(ip) :: source_cell_id
  integer(ip) :: source_vef_lid  
  integer(ip) :: icell_improper_around

  field_blocks            => this%get_field_blocks()
  fe_space_type_x_field => this%get_fe_space_type()
  iblock            = field_blocks(field_id)
  init_dof_block    = this%get_block_num_dofs(iblock)
  current_dof_block = init_dof_block
  
  init_fixed_dof    = this%num_fixed_dofs
  current_fixed_dof = init_fixed_dof

  call this%create_fe_cell_iterator(fe)
  if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
     call memalloc ( 2, this%p4est_triangulation%get_num_proper_vefs(), visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
     call memalloc ( 2, this%p4est_triangulation%get_num_improper_vefs(), visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
     visited_proper_vef_to_cell_map = -1
     visited_improper_vef_to_cell_map = -1
     
     call this%create_fe_vef_iterator(vef)
     call this%create_fe_cell_iterator(source_fe)
     call this%create_fe_cell_iterator(coarser_fe)
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
           do ivef = 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              
              all_improper_cells_around_void=.true.
              do icell_improper_around=1, vef%get_num_improper_cells_around()
                call vef%get_improper_cell_around(icell_improper_around,coarser_fe)
                if (.not. coarser_fe%is_void(field_id)) then 
                   all_improper_cells_around_void=.false.
                   exit
                end if
              end do
              
              if ( vef%is_proper() .or. all_improper_cells_around_void ) then

                 vef_lid = abs(fe%get_vef_gid(ivef))
                 is_owner = .false.
                 if ( vef%is_proper()) then
                   is_owner = ( visited_proper_vef_to_cell_map   ( 1, vef_lid ) == -1 )
                 else
                   is_owner = ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 )
                 end if

                 if ( is_owner ) then
                    previous_dof_block = current_dof_block
                    call fe%generate_own_dofs_vef ( ivef, field_id, current_dof_block, free_dofs_loop=.true.  )
                    if (previous_dof_block < current_dof_block) then
                      if ( vef%is_proper()) then
                        visited_proper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                        visited_proper_vef_to_cell_map ( 2, vef_lid ) = ivef
                      else
                        visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                        visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
                      end if
                    end if
                 else 
                    if ( vef%is_proper()) then
                      source_cell_id = visited_proper_vef_to_cell_map(1,vef_lid)
                      source_vef_lid = visited_proper_vef_to_cell_map(2,vef_lid)
                    else
                      source_cell_id = visited_improper_vef_to_cell_map(1,vef_lid)
                      source_vef_lid = visited_improper_vef_to_cell_map(2,vef_lid)
                    end if
                    call source_fe%set_gid(source_cell_id)
                    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
                 end if
              else 
                 assert ( fe%get_vef_gid(ivef) < 0 )
                 vef_lid = abs(fe%get_vef_gid(ivef))
                 if ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 ) then
                    previous_fixed_dof = current_fixed_dof
                    call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.  )
                    if (previous_fixed_dof < current_fixed_dof) then
                      visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                      visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
                    end if
                 else 
                    call source_fe%set_gid(visited_improper_vef_to_cell_map(1,vef_lid))
                    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                         source_fe, &
                         visited_improper_vef_to_cell_map(2,vef_lid), &
                         field_id) 
                 end if
              end if   
           end do
          end if 
          call fe%determine_has_fixed_dofs(field_id)
          call fe%determine_has_hanging_dofs(field_id)
          call fe%next()
        end do
        call this%free_fe_cell_iterator(source_fe)
        call this%free_fe_cell_iterator(coarser_fe)
        call this%free_fe_vef_iterator(vef)
        call memfree ( visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
        call memfree ( visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
  else    
     ! TODO: this code is a verbatim copy of the one of its parent.
     !       we should better split the parent into additional TBPs
     !       to avoid code replication
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
        end if
        call fe%next()
     end do
  end if
  call this%free_fe_cell_iterator(fe)

  call this%set_field_num_dofs(field_id,current_dof_block - init_dof_block)
  call this%set_block_num_dofs(iblock, this%get_block_num_dofs(iblock) + & 
                                          this%get_field_num_dofs(field_id))
  this%num_hanging_dofs = current_fixed_dof - init_fixed_dof
  ! this%num_fixed_dofs = this%num_hanging_dofs + this%num_dirichlet_dof
  this%num_fixed_dofs = current_fixed_dof
end subroutine serial_hp_adaptive_fe_space_fill_fe_dofs_and_count_dofs

!! Assembly of local matrices for hp-adaptivity
subroutine hpafeci_assembly_array ( this,  &
                                        elvec, &
                                        assembler )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elvec(:)
  class(assembler_t), intent(inout) :: assembler
  massert(.false.,'hpafeci_assembly_array not implemented yet')
end subroutine hpafeci_assembly_array

subroutine hpafeci_assembly_matrix ( this,  &
                                         elmat, &
                                         assembler )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elmat(:,:)
  class(assembler_t), intent(inout) :: assembler
  massert(.false.,'hpafeci_assembly_matrix not implemented yet')
end subroutine hpafeci_assembly_matrix

subroutine hpafeci_assembly_matrix_array ( this,  &
                                               elmat, &
                                               elvec, &
                                               assembler )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elmat(:,:)
  real(rp)                       , intent(in)    :: elvec(:)
  class(assembler_t), intent(inout) :: assembler
  
  logical :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do

  if ( no_hanging_node_constraints ) then
     call this%fe_cell_iterator_t%assembly(elmat,elvec,assembler)
  else  
     ! update scratch data in fe_space_t
     call this%update_scratch_data()
     ! "apply constraints"
     call this%apply_constraints ( elmat, elvec )
     ! impose strong dirichlet bc's
     call assembler%assembly_matrix( this%fe_space%num_fields,        &
                                               this%fe_space%get_field_blocks(),    &
                                               this%fe_space%get_field_coupling(),  &
                                               this%num_cell_dofs_x_field,         &
                                               this%num_cell_dofs_x_field,         &
                                               this%fe_dofs,                      &
                                               this%fe_dofs,                      &
                                               this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,         &
                                              this%fe_space%get_field_blocks(),    &
                                              this%fe_space%get_field_coupling(),  &
                                              this%num_cell_dofs_x_field,          &
                                              this%fe_dofs,                       &
                                              this%extended_elvec%a )
  end if
  
end subroutine hpafeci_assembly_matrix_array

subroutine hpafeci_assembly_matrix_array_with_strong_bcs(this,fe_function,elmat,elvec,assembler)
  implicit none
  class(hp_adaptive_fe_cell_iterator_t), intent(inout)    :: this
  type(fe_function_t), intent(in) :: fe_function
  real(rp), intent(in) :: elmat(:,:)
  real(rp), intent(inout) :: elvec(:)
  class(assembler_t) , intent(inout) :: assembler

  logical :: no_hanging_node_constraints
  integer(ip) :: ifield
  
  no_hanging_node_constraints = .true.
  do ifield=1, this%fe_space%num_fields
     if ( this%has_hanging_dofs(ifield) ) then
        no_hanging_node_constraints = .false.
        exit
     end if
  end do

  if ( no_hanging_node_constraints ) then
     call this%fe_cell_iterator_t%assembly(fe_function,elmat,elvec,assembler)
  else  
     ! update scratch data in fe_space_t
     call this%update_scratch_data()
     ! "apply constraints"
     call this%apply_constraints ( elmat, elvec )
     ! impose strong dirichlet bc's
     call this%hpafeci_impose_strong_dirichlet_bcs ( fe_function )
     ! call assembler%assembly()
     call assembler%assembly_matrix( this%fe_space%num_fields,        &
                                               this%fe_space%get_field_blocks(),    &
                                               this%fe_space%get_field_coupling(),  &
                                               this%num_cell_dofs_x_field,         &
                                               this%num_cell_dofs_x_field,         &
                                               this%fe_dofs,                      &
                                               this%fe_dofs,                      &
                                               this%extended_elmat%a )
     call assembler%assembly_array( this%fe_space%num_fields,         &
                                              this%fe_space%get_field_blocks(),    &
                                              this%fe_space%get_field_coupling(),  &
                                              this%num_cell_dofs_x_field,          &
                                              this%fe_dofs,                       &
                                              this%extended_elvec%a )
  end if
  
end subroutine hpafeci_assembly_matrix_array_with_strong_bcs
 
  subroutine hpafeci_impose_strong_dirichlet_bcs ( this, fe_function )
  implicit none
  class(hp_adaptive_fe_cell_iterator_t), intent(inout)    :: this
  type(fe_function_t) , intent(in)    :: fe_function
  
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp)                   , pointer :: strong_dirichlet_values_entries(:)
  integer(ip) :: ifield, i_lid, i_gid, i_gid_hanging, k_lid, k_gid, pos, spos, epos
  real(rp) :: weight
  
  strong_dirichlet_values         => fe_function%get_fixed_dof_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
     do ifield=1, this%get_num_fields() 
        do i_lid=1, this%num_cell_dofs_x_field(ifield)
           i_gid = this%fe_dofs(ifield)%p(i_lid)
           ! i is a hanging DoF?
           if ( this%is_hanging_dof(i_gid) ) then
              ! Traverse constraining dirichlet DoFs of i
              i_gid_hanging = abs(i_gid) - this%fe_space%num_dirichlet_dofs
              spos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging)
              epos = this%fe_space%ptr_constraining_dirichlet_dofs%get(i_gid_hanging+1)-1
              do pos=spos, epos 
                 k_gid = this%fe_space%constraining_dirichlet_dofs%get(pos)
                 weight = this%fe_space%constraining_dirichlet_dofs_coefficients%get(pos)
                 ! add the hanging dof column * weighting * dirichlet dof value * -1 to the RHS (for extended elvec)
                 this%extended_elvec%a(:) = this%extended_elvec%a(:)-weight*this%extended_elmat%a(:,i_lid)*strong_dirichlet_values_entries(abs(k_gid))
              end do
           ! i is dirichlet dof, proceed as usual
           else if ( this%is_strong_dirichlet_dof(i_gid) ) then
              this%extended_elvec%a(:) = this%extended_elvec%a(:)-this%extended_elmat%a(:,i_lid)*strong_dirichlet_values_entries(abs(i_gid))
           end if
        end do
     end do

   end subroutine hpafeci_impose_strong_dirichlet_bcs
   
