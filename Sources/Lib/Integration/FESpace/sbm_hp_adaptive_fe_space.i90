! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!function hpafefi_compute_fe_facet_permutation_index (this,first_fe,second_fe) result (fe_facet_permutation_index)
!  implicit none
!  class(hp_adaptive_fe_facet_iterator_t), intent(inout) :: this
!  class(fe_cell_iterator_t)                 , intent(inout) :: first_fe
!  class(fe_cell_iterator_t)                 , intent(inout) :: second_fe
!  integer(ip)                                          :: fe_facet_permutation_index
!  ! WARNING: This procedure assumes the problem is meshed with a single octree.
!  ! All facets of an octree have the same orientation. Thus, fe_facet_permutation_index
!  ! can be straightforwardly set to 1.
!  !
!  ! On a forest of octrees, the interface facets can have different orientations.
!  ! In this case, one may compute the face permutation index following the steps:
!  !  1.- Extract from the first FE the ivef and the vef_lid of the first proper vertex.
!  !  2.- Extract from the second FE the ivef of the vertex that has this vef_lid.
!  !  3.- Extract relative rotation with dimension dependents lookup_tables.
!  !        relative_rotation_nD(ivef_first_fe,ivef_second_fe)
!  !    
!  !    2D: reshape( [ 1, 2, 2, 1 ] , [ 2, 2] )
!  !    
!  !    3D: reshape( [1, 2, 3, 4, 3, 1, 4, 2, 2, 4, 1, 3, 4, 3, 2, 1] , [4, 4] )
!  !    
!  assert( .not. this%is_ghost() .and. this%get_num_cells_around() == 2 )
!  fe_facet_permutation_index = 1
!end function hpafefi_compute_fe_facet_permutation_index

subroutine serial_hp_adaptive_fe_space_fill_fe_dofs_and_count_dofs( this, field_id ) 
  implicit none
  ! Parameters
  class(serial_hp_adaptive_fe_space_t), intent(inout) :: this 
  integer(ip)                         ,  intent(in)   :: field_id

  ! Local variables
  integer(ip) :: ivef, vef_lid
  integer(ip) :: iblock, init_dof_block, current_dof_block, previous_dof_block
  integer(ip) :: init_fixed_dof, current_fixed_dof, previous_fixed_dof
  integer(ip), allocatable :: visited_proper_vef_to_cell_map(:,:)
  integer(ip), allocatable :: visited_improper_vef_to_cell_map(:,:)
  
  class(fe_cell_iterator_t) , allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t) :: vef
  integer(ip), pointer :: field_blocks(:)
  integer(ip), pointer :: fe_space_type_x_field(:)

  logical :: all_improper_cells_around_void, is_owner
  integer(ip) :: source_cell_id
  integer(ip) :: source_vef_lid  
  integer(ip) :: icell_improper_around

  field_blocks            => this%get_field_blocks()
  fe_space_type_x_field => this%get_fe_space_type()
  iblock            = field_blocks(field_id)
  init_dof_block    = this%get_block_num_dofs(iblock)
  current_dof_block = init_dof_block
  
  init_fixed_dof    = this%num_fixed_dofs
  current_fixed_dof = init_fixed_dof

  call this%create_fe_cell_iterator(fe)
  if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
     call memalloc ( 2, this%p4est_triangulation%get_num_proper_vefs(), visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
     call memalloc ( 2, this%p4est_triangulation%get_num_improper_vefs(), visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
     visited_proper_vef_to_cell_map = -1
     visited_improper_vef_to_cell_map = -1
     
     call this%create_fe_vef_iterator(vef)
     call this%create_fe_cell_iterator(source_fe)
     call this%create_fe_cell_iterator(coarser_fe)
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
           do ivef = 1, fe%get_num_vefs()
              call fe%get_vef(ivef,vef)
              
              all_improper_cells_around_void=.true.
              do icell_improper_around=1, vef%get_num_improper_cells_around()
                call vef%get_improper_cell_around(icell_improper_around,coarser_fe)
                if (.not. coarser_fe%is_void(field_id)) then 
                   all_improper_cells_around_void=.false.
                   exit
                end if
              end do
              
              if ( vef%is_proper() .or. all_improper_cells_around_void ) then

                 vef_lid = abs(fe%get_vef_gid(ivef))
                 is_owner = .false.
                 if ( vef%is_proper()) then
                   is_owner = ( visited_proper_vef_to_cell_map   ( 1, vef_lid ) == -1 )
                 else
                   is_owner = ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 )
                 end if

                 if ( is_owner ) then
                    previous_dof_block = current_dof_block
                    call fe%generate_own_dofs_vef ( ivef, field_id, current_dof_block, free_dofs_loop=.true.  )
                    if (previous_dof_block < current_dof_block) then
                      if ( vef%is_proper()) then
                        visited_proper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                        visited_proper_vef_to_cell_map ( 2, vef_lid ) = ivef
                      else
                        visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                        visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
                      end if
                    end if
                 else 
                    if ( vef%is_proper()) then
                      source_cell_id = visited_proper_vef_to_cell_map(1,vef_lid)
                      source_vef_lid = visited_proper_vef_to_cell_map(2,vef_lid)
                    else
                      source_cell_id = visited_improper_vef_to_cell_map(1,vef_lid)
                      source_vef_lid = visited_improper_vef_to_cell_map(2,vef_lid)
                    end if
                    call source_fe%set_gid(source_cell_id)
                    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
                 end if
              else 
                 assert ( fe%get_vef_gid(ivef) < 0 )
                 vef_lid = abs(fe%get_vef_gid(ivef))
                 if ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 ) then
                    previous_fixed_dof = current_fixed_dof
                    call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.  )
                    if (previous_fixed_dof < current_fixed_dof) then
                      visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                      visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
                    end if
                 else 
                    call source_fe%set_gid(visited_improper_vef_to_cell_map(1,vef_lid))
                    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                         source_fe, &
                         visited_improper_vef_to_cell_map(2,vef_lid), &
                         field_id) 
                 end if
              end if   
           end do
          end if 
          call fe%determine_has_fixed_dofs(field_id)
          call fe%determine_has_hanging_dofs(field_id)
          call fe%next()
        end do
        call this%free_fe_cell_iterator(source_fe)
        call this%free_fe_cell_iterator(coarser_fe)
        call this%free_fe_vef_iterator(vef)
        call memfree ( visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
        call memfree ( visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
  else    
     ! TODO: this code is a verbatim copy of the one of its parent.
     !       we should better split the parent into additional TBPs
     !       to avoid code replication
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
        end if
        call fe%next()
     end do
  end if
  call this%free_fe_cell_iterator(fe)

  call this%set_field_num_dofs(field_id,current_dof_block - init_dof_block)
  call this%set_block_num_dofs(iblock, this%get_block_num_dofs(iblock) + & 
                                          this%get_field_num_dofs(field_id))
  this%num_hanging_dofs = current_fixed_dof - init_fixed_dof
  ! this%num_fixed_dofs = this%num_hanging_dofs + this%num_dirichlet_dof
  this%num_fixed_dofs = current_fixed_dof
end subroutine serial_hp_adaptive_fe_space_fill_fe_dofs_and_count_dofs
