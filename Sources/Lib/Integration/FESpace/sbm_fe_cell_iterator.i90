! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine fe_cell_iterator_create ( this, fe_space )
  implicit none
  class(fe_cell_iterator_t)            , intent(inout) :: this
  class(serial_fe_space_t), target, intent(in)    :: fe_space
  integer(ip) :: istat
  call this%free()
  this%fe_space => fe_space
  call this%fe_space%triangulation%create_cell_iterator(this%cell)
  call memalloc ( this%fe_space%num_fields, this%num_cell_dofs_x_field, __FILE__, __LINE__ )
  allocate( this%cell_integrators(this%fe_space%num_fields), stat=istat ); check(istat==0);
  allocate( this%fe_dofs(this%fe_space%num_fields), stat=istat); check(istat==0);
end subroutine fe_cell_iterator_create

subroutine fe_cell_iterator_free (this)
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: istat
  if ( associated(this%fe_space) ) then
    if ( associated(this%fe_space%triangulation) ) then
      call this%fe_space%triangulation%free_cell_iterator(this%cell)
    end if
  end if
  nullify(this%fe_space)
  if ( allocated(this%num_cell_dofs_x_field) ) then
    call memfree ( this%num_cell_dofs_x_field, __FILE__, __LINE__ )
  end if
  if ( allocated(this%fe_dofs) ) then
    deallocate ( this%fe_dofs, stat=istat ); check(istat==0);
  end if
  if ( allocated(this%cell_integrators) ) then
    deallocate ( this%cell_integrators, stat=istat ); check(istat==0);
  end if
  nullify(this%cell_map)
end subroutine fe_cell_iterator_free

subroutine fe_cell_iterator_free_final(this)
  implicit none
  type(fe_cell_iterator_t), intent(inout) :: this
  assert ( .not. allocated(this%cell) )
  assert ( .not. associated(this%fe_space))
  assert ( .not. associated(this%cell_map))
end subroutine fe_cell_iterator_free_final

function fe_cell_iterator_count_own_dofs_cell ( this, field_id )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_cell 
  
  ! Local variables
  integer(ip) :: ivef
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  
  reference_fe => this%get_reference_fe(field_id)
  ivef = this%get_num_vefs()+1
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  fe_cell_iterator_count_own_dofs_cell = own_dofs_on_vef_iterator%get_size() 
end function fe_cell_iterator_count_own_dofs_cell

subroutine fe_cell_iterator_generate_own_dofs_cell ( this, field_id, current_dof )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: current_dof

  ! Local variables
  integer(ip) :: ivef
  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( field_id>= 1 .and. field_id <= this%fe_space%num_fields )
  ivef = this%get_num_vefs()+1
  
  reference_fe => this%get_reference_fe(field_id)
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())-1
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    current_dof = current_dof + 1
    this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) = current_dof
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_cell

subroutine fe_cell_iterator_generate_own_dofs_vef ( this, ivef, field_id, current_dof, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: free_dofs_loop

  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())-1
  
  reference_fe => this%get_reference_fe(field_id)
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    if ( this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) == 0 ) then
      current_dof = current_dof + 1
      if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
        this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) = current_dof
      else                       ! A fixed dofs loop is surrounding this call 
        this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) = -current_dof
      end if
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_vef

function fe_cell_iterator_count_own_dofs_vef ( this, ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(in) :: this
  integer(ip)          , intent(in) :: ivef
  integer(ip)          , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_count_own_dofs_vef

  integer(ip) :: base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%fe_space%num_fields )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())-1
  
  reference_fe => this%get_reference_fe(field_id)
  
  fe_cell_iterator_count_own_dofs_vef = 0
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while (.not. own_dofs_on_vef_iterator%is_upper_bound())
    if ( this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+own_dofs_on_vef_iterator%get_current()) == 0 ) then
      fe_cell_iterator_count_own_dofs_vef = fe_cell_iterator_count_own_dofs_vef + 1
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end function fe_cell_iterator_count_own_dofs_vef

subroutine fe_cell_iterator_generate_own_dofs_vef_component_wise ( this, ivef, field_id, current_dof, components_code, free_dofs_loop )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: ivef
  integer(ip)          , intent(in)    :: field_id
  integer(ip)          , intent(inout) :: current_dof
  logical              , intent(in)    :: components_code(:)
  logical              , intent(in)    :: free_dofs_loop
  integer(ip) :: base_pos_lst_dofs_gids, component_id, local_within_ref_fe_dof_id
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  
  assert ( ivef >=1 .and. ivef <= this%get_num_vefs() )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  
  ! Determine position in lst_dofs_gids of the first dof associated to the
  ! field "field_id" within the current fe
  base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())-1

  reference_fe => this%get_reference_fe(field_id)
  
  assert ( size(components_code) == reference_fe%get_num_field_components() )
  
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within current fe
  own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
  do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
    local_within_ref_fe_dof_id  = own_dofs_on_vef_iterator%get_current()
    if ( this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) == 0 ) then
      component_id = reference_fe%get_component_node(local_within_ref_fe_dof_id)
      if ( components_code(component_id) ) then 
       current_dof = current_dof +1 
       if ( free_dofs_loop ) then ! A free dofs loop is surrounding this call 
         this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) = current_dof
       else
         this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+local_within_ref_fe_dof_id) = -current_dof
       end if
      end if  
    end if
    call own_dofs_on_vef_iterator%next()
  end do
end subroutine fe_cell_iterator_generate_own_dofs_vef_component_wise

subroutine fe_cell_iterator_fetch_own_dofs_vef_from_source_fe ( this, target_ivef, source_fe, source_ivef, field_id )
  implicit none
  class(fe_cell_iterator_t) , intent(inout) :: this
  integer(ip)          , intent(in)    :: target_ivef
  class(fe_cell_iterator_t) , intent(in)    :: source_fe
  integer(ip)          , intent(in)    :: source_ivef
  integer(ip)          , intent(in)    :: field_id

  class(reference_fe_t), pointer :: reference_fe_source 
  integer(ip)                    :: base_pos_lst_dofs_gids_source
  type(list_iterator_t)          :: own_dofs_on_vef_iterator_target
  
  class(reference_fe_t), pointer :: reference_fe_target 
  integer(ip)                    :: base_pos_lst_dofs_gids_target
  
  integer(ip)                    :: source_dof_LID_cell, target_dof_LID_cell
  integer(ip)                    :: target_dof_LID_vef
  integer(ip)                    :: source_dof_LID_vef
  integer(ip)                    :: permutation_index
  integer(ip)                    :: source_ivef_dim

  assert ( target_ivef <= this%get_num_vefs() )
  assert ( source_ivef <= source_fe%get_num_vefs() )
  assert ( field_id <= this%get_num_fields() )
  
  reference_fe_target => this%get_reference_fe(field_id)
  base_pos_lst_dofs_gids_target = this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())-1
  
  reference_fe_source => source_fe%get_reference_fe(field_id)
  base_pos_lst_dofs_gids_source = this%fe_space%ptr_dofs_x_fe(field_id, source_fe%get_gid())-1
  source_ivef_dim = reference_fe_source%get_n_face_dim(source_ivef)
  ! Iterate over all DoFs associated to field "field_id" on top of the vef
  ! with local identifier ivef within target fe
  own_dofs_on_vef_iterator_target = reference_fe_target%create_own_dofs_on_n_face_iterator(target_ivef)
  if ( own_dofs_on_vef_iterator_target%get_size() > 0 ) then
       assert (reference_fe_source%check_compatibility_of_n_faces(reference_fe_target,target_ivef,source_ivef))
       permutation_index = reference_fe_target%compute_permutation_index( reference_fe_source, &
                                                                          target_ivef, &
                                                                          source_ivef, &
                                                                          this%get_vef_gids(), &
                                                                          source_fe%get_vef_gids())
      
      do while (.not. own_dofs_on_vef_iterator_target%is_upper_bound())
        target_dof_LID_vef = own_dofs_on_vef_iterator_target%get_distance_to_lower_bound()
        source_dof_LID_vef = reference_fe_source%permute_dof_LID_n_face(target_dof_LID_vef, &
                                                                    source_ivef_dim, & 
                                                                    permutation_index)
        target_dof_LID_cell = own_dofs_on_vef_iterator_target%get_current()
        source_dof_LID_cell = reference_fe_source%translate_dof_lid_n_face_to_dof_lid_cell(source_dof_LID_vef, source_ivef)
        this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids_target+target_dof_LID_cell) = &                                                      
            this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids_source+source_dof_LID_cell)
        call own_dofs_on_vef_iterator_target%next()
      end do
  end if
end subroutine fe_cell_iterator_fetch_own_dofs_vef_from_source_fe

subroutine fe_cell_iterator_generate_dofs_facet_integration_coupling ( this, ivef, field_id, dof_count )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip)         , intent(in)      :: ivef
  integer(ip)         , intent(in)      :: field_id
  integer(ip)         , intent(inout)   :: dof_count

  ! Local variables
  integer(ip)                    :: idof, base_pos_lst_dofs_gids
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t)          :: facet_integration_coupling_dofs 
  
  reference_fe => this%get_reference_fe(field_id)
  assert ( reference_fe%get_n_face_dim(ivef) == reference_fe%get_num_dims()-1 )
  
  if ( reference_fe%get_continuity() ) then
    facet_integration_coupling_dofs = reference_fe%create_dofs_on_n_face_iterator(ivef)
    base_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())-1
    do while (.not. facet_integration_coupling_dofs%is_upper_bound())
      idof = facet_integration_coupling_dofs%get_current()
      dof_count = dof_count +1 
      this%fe_space%lst_dofs_gids(base_pos_lst_dofs_gids+idof) = dof_count
      call facet_integration_coupling_dofs%next()
    end do
  end if
end subroutine fe_cell_iterator_generate_dofs_facet_integration_coupling

! Renumbers the DoF identifiers corresponding to all fields mapped to block with identifier block_id
subroutine fe_cell_iterator_renum_dofs_block ( this, block_id, perm_old2new )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t)      , intent(inout) :: this
  integer(ip)               , intent(in)    :: block_id
  ! No way to know the size of perm_old2new() within the local scope
  ! of class(fe_cell_iterator_t). This is why I used an assumed-size dummy
  ! argument in this context. This will be solved in the future whenever
  ! class(fe_cell_iterator_t) also has access to the whole mesh-like container.
  integer(ip)               , intent(in)    :: perm_old2new(*)
  integer(ip)                            :: field_id
  assert ( block_id >= 1 .and. block_id <= this%fe_space%get_num_blocks() )
  do field_id=1, this%fe_space%get_num_fields()
    if ( this%fe_space%block_layout%get_block_id(field_id) == block_id ) then
      call this%renum_dofs_field( field_id, perm_old2new )
    end if
  end do 
end subroutine fe_cell_iterator_renum_dofs_block

! Renumbers the DoF identifiers corresponding to field with identifier field_id
subroutine fe_cell_iterator_renum_dofs_field ( this, field_id, perm_old2new )
  implicit none
  ! Parameters
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)         , intent(in) :: field_id
  ! No way to know the size of perm_old2new() within the local scope
  ! of class(fe_cell_iterator_t). This is why I used an assumed-size dummy
  ! argument in this context. This will be solved in the future whenever
  ! class(fe_cell_iterator_t) also has access to the whole mesh-like container.
  integer(ip)         , intent(in) :: perm_old2new(*)
  integer(ip) :: i, start_pos_lst_dofs_gids, end_pos_lst_dofs_gids
  
  start_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(field_id,this%get_gid())
  
  if ( field_id == this%fe_space%get_num_fields() ) then
    end_pos_lst_dofs_gids = this%fe_space%ptr_dofs_x_fe(1, this%get_gid()+1)-1
  else  
    end_pos_lst_dofs_gids   = this%fe_space%ptr_dofs_x_fe(field_id+1, this%get_gid())-1
  end if  
  
  assert ( field_id >= 1 .and. field_id <= this%fe_space%get_num_fields() )
  do i = start_pos_lst_dofs_gids, end_pos_lst_dofs_gids
    if ( this%fe_space%lst_dofs_gids(i) > 0 ) then
      this%fe_space%lst_dofs_gids(i) = perm_old2new(this%fe_space%lst_dofs_gids(i))
    end if
  end do
end subroutine fe_cell_iterator_renum_dofs_field

subroutine fe_cell_iterator_update_scratch_data( this)
  implicit none
  class(fe_cell_iterator_t), intent(inout)    :: this 
  integer(ip) :: field_id
  do field_id = 1, this%get_num_fields()-1
    this%num_cell_dofs_x_field(field_id) = this%fe_space%ptr_dofs_x_fe(field_id+1, this%get_gid())- &
                                      this%fe_space%ptr_dofs_x_fe(field_id  , this%get_gid())
  end do
  this%num_cell_dofs_x_field(field_id) = this%fe_space%ptr_dofs_x_fe(1, this%get_gid()+1)- &
                                    this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())
                                    
  call this%get_fe_dofs(this%fe_dofs)
end subroutine fe_cell_iterator_update_scratch_data



subroutine fe_cell_iterator_update_integration( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this 
  integer(ip) :: field_id
  type(point_t)            , pointer :: coordinates(:)
  type(quadrature_t)       , pointer :: quadrature
  type(cell_integrator_t), pointer :: cell_integrator
  
  integer(ip) :: istat

  call this%update_cell_map()
  coordinates => this%cell_map%get_coordinates()
  call this%get_coordinates(coordinates)

  quadrature => this%get_quadrature()
  call this%cell_map%update(quadrature)
  call this%update_cell_integrators()
  do field_id = 1, this%get_num_fields()
     call this%cell_integrators(field_id)%p%update(this%cell_map)
  end do
  
end subroutine fe_cell_iterator_update_integration

function fe_cell_iterator_get_fe_space(this)
  implicit none
  class(fe_cell_iterator_t), target, intent(in) :: this
  class(serial_fe_space_t), pointer :: fe_cell_iterator_get_fe_space
  fe_cell_iterator_get_fe_space => this%fe_space
end function fe_cell_iterator_get_fe_space

function fe_cell_iterator_get_num_fields(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_num_fields
  fe_cell_iterator_get_num_fields = this%fe_space%num_fields
end function fe_cell_iterator_get_num_fields

function fe_cell_iterator_get_fe_space_type(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip)                      :: fe_cell_iterator_get_fe_space_type
  class(reference_fe_t), pointer   :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  if ( reference_fe%get_conformity() .and. reference_fe%get_continuity()  ) then
    fe_cell_iterator_get_fe_space_type = fe_space_type_cg
  else if ( reference_fe%get_conformity() .and. .not. reference_fe%get_continuity() ) then
    fe_cell_iterator_get_fe_space_type = fe_space_type_dg_conforming
  else 
    fe_cell_iterator_get_fe_space_type = fe_space_type_dg
  end if
end function fe_cell_iterator_get_fe_space_type

function fe_cell_iterator_get_field_type(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  character(:), pointer :: fe_cell_iterator_get_field_type
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_field_type => reference_fe%get_field_type()
end function fe_cell_iterator_get_field_type

function fe_cell_iterator_get_field_blocks(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip), pointer             :: fe_cell_iterator_get_field_blocks(:)
  fe_cell_iterator_get_field_blocks => this%fe_space%block_layout%get_field_id_to_block_id()
end function fe_cell_iterator_get_field_blocks


function fe_cell_iterator_get_num_dofs(this)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_num_dofs
  fe_cell_iterator_get_num_dofs = this%fe_space%ptr_dofs_x_fe(1, this%get_gid()+1)- &
                                this%fe_space%ptr_dofs_x_fe(1, this%get_gid())
end function fe_cell_iterator_get_num_dofs


function fe_cell_iterator_get_num_dofs_field(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip), intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_num_dofs_field
  
  if ( field_id < this%fe_space%num_fields ) then
     fe_cell_iterator_get_num_dofs_field = this%fe_space%ptr_dofs_x_fe(field_id+1, this%get_gid())- &
                                   this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())
  else                                
     fe_cell_iterator_get_num_dofs_field = this%fe_space%ptr_dofs_x_fe(1, this%get_gid()+1)- &
                                   this%fe_space%ptr_dofs_x_fe(this%fe_space%num_fields, this%get_gid())
  end if
end function fe_cell_iterator_get_num_dofs_field


subroutine fe_cell_iterator_get_field_fe_dofs( this, field_id, fe_dofs )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  integer(ip)         , intent(in)    :: field_id
  integer(ip), pointer, intent(inout) :: fe_dofs(:)
  integer(ip) :: spos, epos
 
  spos = this%fe_space%ptr_dofs_x_fe(field_id  ,this%get_gid())
  if ( field_id == this%fe_space%get_num_fields() ) then
     epos = this%fe_space%ptr_dofs_x_fe(1,this%get_gid()+1)-1
  else
     epos = this%fe_space%ptr_dofs_x_fe(field_id+1,this%get_gid())-1
  end if
  fe_dofs => this%fe_space%lst_dofs_gids(spos:epos)
end subroutine fe_cell_iterator_get_field_fe_dofs

subroutine fe_cell_iterator_get_fe_dofs( this, fe_dofs )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  type(i1p_t)         , intent(inout) :: fe_dofs(:)
  integer(ip) :: field_id, j, spos, epos
  
  assert ( size(fe_dofs) == this%fe_space%num_fields )
  do field_id = 1, this%get_num_fields()-1
    spos = this%fe_space%ptr_dofs_x_fe(field_id  ,this%get_gid())
    epos = this%fe_space%ptr_dofs_x_fe(field_id+1,this%get_gid())-1
    fe_dofs(field_id)%p => this%fe_space%lst_dofs_gids(spos:epos)
  end do
  spos = this%fe_space%ptr_dofs_x_fe(field_id  , this%get_gid())
  epos = this%fe_space%ptr_dofs_x_fe(1         , this%get_gid()+1)-1
  fe_dofs(field_id)%p => this%fe_space%lst_dofs_gids(spos:epos)
  
end subroutine fe_cell_iterator_get_fe_dofs

function fe_cell_iterator_get_order( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_order
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_order = reference_fe%get_order()
end function fe_cell_iterator_get_order

function fe_cell_iterator_get_max_order_single_field( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)         , intent(in) :: field_id
  integer(ip) :: fe_cell_iterator_get_max_order_single_field
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_get_max_order_single_field = reference_fe%get_max_order()
end function fe_cell_iterator_get_max_order_single_field

function fe_cell_iterator_get_max_order_all_fields( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_max_order_all_fields
  integer(ip) :: field_id
  fe_cell_iterator_get_max_order_all_fields = -1
  do field_id=1, this%get_num_fields()
   if ( fe_cell_iterator_get_max_order_all_fields < this%get_max_order_single_field(field_id) ) then
        fe_cell_iterator_get_max_order_all_fields = this%get_max_order_single_field(field_id)
   end if
  end do
end function fe_cell_iterator_get_max_order_all_fields

function fe_cell_iterator_at_strong_dirichlet_boundary ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(in) :: this
  integer(ip)            , intent(in) :: field_id
  logical                             :: fe_cell_iterator_at_strong_dirichlet_boundary
  fe_cell_iterator_at_strong_dirichlet_boundary = this%fe_space%at_strong_dirichlet_boundary_x_fe(field_id,this%get_gid())
end function fe_cell_iterator_at_strong_dirichlet_boundary

subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_single_field ( this, field_id )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip)            , intent(in)    :: field_id
  integer(ip), pointer :: fe_dofs(:)
  call this%get_field_fe_dofs(field_id, fe_dofs)
  this%fe_space%at_strong_dirichlet_boundary_x_fe(field_id,this%get_gid()) = .false.
  if (any(fe_dofs(:)<0)) this%fe_space%at_strong_dirichlet_boundary_x_fe(field_id,this%get_gid()) = .true.
end subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_single_field

subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_all_fields ( this )
  implicit none
  class(fe_cell_iterator_t)   , intent(inout) :: this
  integer(ip) :: field_id
  do field_id=1, this%get_num_fields()
    call this%determine_at_strong_dirichlet_boundary(field_id)
  end do
end subroutine fe_cell_iterator_set_at_strong_dirichlet_boundary_all_fields


function fe_cell_iterator_compute_volume ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  real(rp) :: fe_cell_iterator_compute_volume
  integer(ip)                 :: q_poin, num_quadrature_points
  
  type(quadrature_t), pointer :: quadrature
  
  quadrature => this%get_quadrature()
  
  num_quadrature_points = quadrature%get_num_quadrature_points()
  fe_cell_iterator_compute_volume = 0.0_rp
  do q_poin = 1, num_quadrature_points
     fe_cell_iterator_compute_volume = fe_cell_iterator_compute_volume + &
          &                          this%get_det_jacobian(q_poin) * &
          &                          quadrature%get_weight(q_poin)
  end do
end function fe_cell_iterator_compute_volume

function fe_cell_iterator_get_quadrature_degree ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_quadrature_degree
  if ( allocated(this%fe_space%cell_quadratures_degree) ) then
     fe_cell_iterator_get_quadrature_degree = this%fe_space%cell_quadratures_degree(this%get_gid())
  end if
  if ( .not. allocated(this%fe_space%cell_quadratures_degree) .or. &
       fe_cell_iterator_get_quadrature_degree == fe_space_default_quadrature_degree_flag ) then
     fe_cell_iterator_get_quadrature_degree = this%get_default_quadrature_degree()
  end if
end function fe_cell_iterator_get_quadrature_degree

function fe_cell_iterator_get_default_quadrature_degree ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip) :: fe_cell_iterator_get_default_quadrature_degree
  integer(ip) :: reference_fe_id
  assert( allocated(this%fe_space%max_order_reference_fe_id_x_cell) )
  reference_fe_id = this%fe_space%max_order_reference_fe_id_x_cell(this%get_gid())
  fe_cell_iterator_get_default_quadrature_degree = & 
    this%fe_space%reference_fes(reference_fe_id)%p%get_default_quadrature_degree()
end function fe_cell_iterator_get_default_quadrature_degree

subroutine fe_cell_iterator_set_quadrature_degree ( this, quadrature_degree )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)         , intent(in)    :: quadrature_degree
  assert ( quadrature_degree >= -1 )
  if ( .not. allocated ( this%fe_space%cell_quadratures_degree) ) then
     call this%fe_space%allocate_cell_quadratures_degree()
     call this%fe_space%clear_cell_quadratures_degree()
  end if
  this%fe_space%cell_quadratures_degree(this%get_gid()) = quadrature_degree
end subroutine fe_cell_iterator_set_quadrature_degree

function fe_cell_iterator_get_quadrature ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(quadrature_t), pointer      :: fe_cell_iterator_get_quadrature
  integer(ip) :: cell_quadratures_key, cell_quadratures_position
  integer(ip) :: istat
  
  cell_quadratures_key = this%fe_space%generate_cell_quadratures_position_key(this%get_reference_fe_geo_id(),&
                                                                          this%get_quadrature_degree())
  
  call this%fe_space%cell_quadratures_and_maps_position%get(key=cell_quadratures_key, &
                                                          val=cell_quadratures_position, &
                                                          stat=istat)
  assert ( .not. istat == key_not_found )
  fe_cell_iterator_get_quadrature => this%fe_space%cell_quadratures(cell_quadratures_position)
end function fe_cell_iterator_get_quadrature

function fe_cell_iterator_get_cell_map ( this )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(cell_map_t), pointer :: fe_cell_iterator_get_cell_map
  fe_cell_iterator_get_cell_map => this%cell_map
end function fe_cell_iterator_get_cell_map

!==================================================================================================
subroutine fe_cell_iterator_update_cell_map ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip) :: cell_maps_position, cell_maps_key
  integer(ip) :: istat
  
  cell_maps_key = this%fe_space%generate_cell_quadratures_position_key(this%get_reference_fe_geo_id(),&
                                                                   this%get_quadrature_degree())
  
  call this%fe_space%cell_quadratures_and_maps_position%get(key=cell_maps_key, &
                                                          val=cell_maps_position, &
                                                          stat=istat)
  
  assert ( .not. istat == key_not_found )
  this%cell_map => this%fe_space%cell_maps(cell_maps_position)
  
end subroutine fe_cell_iterator_update_cell_map

!==================================================================================================
subroutine fe_cell_iterator_update_cell_integrators ( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout)   :: this
  integer(ip) :: cell_integrators_position_key
  integer(ip) :: cell_integrators_position
  integer(ip) :: istat, field_id
  do field_id = 1, this%get_num_fields()
     cell_integrators_position_key = &
           this%fe_space%generate_cell_integrators_position_key(this%get_reference_fe_geo_id(), &
                                                                  this%get_quadrature_degree(), &
                                                                  this%fe_space%field_cell_to_ref_fes(field_id, this%get_gid()))  
     call this%fe_space%cell_integrators_position%get(key=cell_integrators_position_key, &
                                                           val=cell_integrators_position, &
                                                           stat=istat)
     assert ( .not. istat == key_not_found )
     this%cell_integrators(field_id)%p => this%fe_space%cell_integrators(cell_integrators_position) 
  end do  
end subroutine fe_cell_iterator_update_cell_integrators


!==================================================================================================
subroutine fe_cell_iterator_set_cell_map ( this, cell_map )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  type(cell_map_t), target, intent(in) :: cell_map
  this%cell_map => cell_map
end subroutine fe_cell_iterator_set_cell_map

!==================================================================================================
subroutine fe_cell_iterator_set_cell_integrator ( this, field_id, cell_integrator )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  integer(ip)              , intent(in) :: field_id
  type(cell_integrator_t), target, intent(in) :: cell_integrator
  this%cell_integrators(field_id)%p => cell_integrator
end subroutine fe_cell_iterator_set_cell_integrator

!==================================================================================================
function fe_cell_iterator_get_quadrature_points_coordinates(this)
  implicit none
  class(fe_cell_iterator_t)   , target, intent(in) :: this
  type(point_t), pointer :: fe_cell_iterator_get_quadrature_points_coordinates(:)
  fe_cell_iterator_get_quadrature_points_coordinates => this%cell_map%get_quadrature_points_coordinates()
end function fe_cell_iterator_get_quadrature_points_coordinates

!==================================================================================================
function fe_cell_iterator_get_det_jacobian ( this, i )
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)    , intent(in) :: i
  real(rp) :: fe_cell_iterator_get_det_jacobian
  fe_cell_iterator_get_det_jacobian = this%cell_map%get_det_jacobian(i)
end function fe_cell_iterator_get_det_jacobian

!==================================================================================================
function fe_cell_iterator_get_cell_integrator ( this, field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  type(cell_integrator_t), pointer :: fe_cell_iterator_get_cell_integrator
  fe_cell_iterator_get_cell_integrator => this%cell_integrators(field_id)%p
end function fe_cell_iterator_get_cell_integrator

subroutine fe_cell_iterator_get_fe_vef(this, ivef, fe_vef)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  integer(ip)            , intent(in)    :: ivef
  type(fe_vef_iterator_t), intent(inout) :: fe_vef
  call fe_vef%set_gid( this%cell%get_vef_gid(ivef))
end subroutine fe_cell_iterator_get_fe_vef

function fe_cell_iterator_get_reference_fe(this, field_id)
  implicit none
  class(fe_cell_iterator_t), target   , intent(in)    :: this
  integer(ip)                    , intent(in)    :: field_id
  class(reference_fe_t), pointer :: fe_cell_iterator_get_reference_fe
  fe_cell_iterator_get_reference_fe => this%fe_space%reference_fes(this%fe_space%field_cell_to_ref_fes(field_id,this%get_gid()))%p
end function fe_cell_iterator_get_reference_fe

function fe_cell_iterator_get_max_order_reference_fe(this)
  implicit none
  class(fe_cell_iterator_t),  intent(in)      :: this
  class(reference_fe_t), pointer         :: fe_cell_iterator_get_max_order_reference_fe
  class(reference_fe_t), pointer         :: reference_fe
  integer(ip)                            :: max_order
  integer(ip)                            :: field_id
  max_order = -1
  do field_id=1, this%get_num_fields()
    reference_fe => this%get_reference_fe(field_id)
    if ( reference_fe%get_max_order() > max_order ) then
      max_order = reference_fe%get_max_order()
      fe_cell_iterator_get_max_order_reference_fe => reference_fe
    end if
  end do
end function fe_cell_iterator_get_max_order_reference_fe

function fe_cell_iterator_get_max_order_reference_fe_id(this)
  implicit none
  class(fe_cell_iterator_t),  intent(in)      :: this
  integer(ip)                            :: fe_cell_iterator_get_max_order_reference_fe_id
  class(reference_fe_t), pointer         :: reference_fe
  integer(ip)                            :: max_order
  integer(ip)                            :: field_id
  max_order = -1
  fe_cell_iterator_get_max_order_reference_fe_id = -1
  do field_id=1, this%get_num_fields()
    reference_fe => this%get_reference_fe(field_id)
    if ( reference_fe%get_max_order() >= max_order ) then
      max_order = reference_fe%get_max_order()
      fe_cell_iterator_get_max_order_reference_fe_id = this%get_reference_fe_id(field_id)
    end if
  end do
end function fe_cell_iterator_get_max_order_reference_fe_id

function fe_cell_iterator_get_reference_fe_id(this, field_id)
  implicit none
  class(fe_cell_iterator_t), target   , intent(in)    :: this
  integer(ip)                    , intent(in)    :: field_id
  integer(ip) :: fe_cell_iterator_get_reference_fe_id
  fe_cell_iterator_get_reference_fe_id = this%fe_space%field_cell_to_ref_fes(field_id,this%get_gid())
end function fe_cell_iterator_get_reference_fe_id

function fe_cell_iterator_is_void(this, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  integer(ip),          intent(in)    :: field_id
  logical                             :: fe_cell_iterator_is_void
  class(reference_fe_t), pointer :: reference_fe
  reference_fe => this%get_reference_fe(field_id)
  fe_cell_iterator_is_void =  .false.
  select type (reference_fe)
    class is (void_reference_fe_t)
      fe_cell_iterator_is_void =  .true.
  end select
end function fe_cell_iterator_is_void

function fe_cell_iterator_create_own_dofs_on_vef_iterator ( this, ivef, field_id ) result(list_iterator)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  integer(ip)                , intent(in) :: ivef
  integer(ip)                , intent(in) :: field_id
  type(list_iterator_t)                   :: list_iterator
  class(reference_fe_t), pointer          :: reference_fe
  
  reference_fe => this%get_reference_fe(field_id)
  list_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
end function fe_cell_iterator_create_own_dofs_on_vef_iterator

subroutine fe_cell_iterator_impose_strong_dirichlet_bcs ( this, fe_function, elmat, elvec )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  type(fe_function_t) , intent(in)    :: fe_function
  real(rp)            , intent(in)    :: elmat(:,:)
  real(rp)            , intent(inout) :: elvec(:)
  
  integer(ip) :: idof, elmat_col, field_id, spos
  
  class(reference_fe_t)      , pointer :: reference_fe
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp)                   , pointer :: strong_dirichlet_values_entries(:)
  
  strong_dirichlet_values         => fe_function%get_fixed_dof_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
  
  elmat_col = 0
  do field_id = 1, this%fe_space%get_num_fields()
    if ( this%at_strong_dirichlet_boundary(field_id) ) then
      reference_fe => this%get_reference_fe(field_id)
      spos = this%fe_space%ptr_dofs_x_fe(field_id, this%get_gid())
      do idof = 1, reference_fe%get_num_shape_functions()
        elmat_col = elmat_col + 1
        if ( this%fe_space%lst_dofs_gids(spos+idof-1) < 0 ) then
          elvec = elvec - elmat(:,elmat_col)*strong_dirichlet_values_entries(-this%fe_space%lst_dofs_gids(spos+idof-1))
        end if
      end do
    end if
  end do
  
end subroutine fe_cell_iterator_impose_strong_dirichlet_bcs

subroutine fe_cell_iterator_assembly_array ( this,  &
                                        elvec, &
                                        assembler )
  implicit none
  class(fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elvec(:)
  class(assembler_t), intent(inout) :: assembler
  
  call this%update_scratch_data()
  call assembler%assembly_array( this%fe_space%num_fields,         &
                                              this%fe_space%get_field_blocks(),    &
                                              this%fe_space%get_field_coupling(),  &
                                              this%num_cell_dofs_x_field,          &
                                              this%fe_dofs,                       &
                                              elvec )
  
end subroutine fe_cell_iterator_assembly_array

subroutine fe_cell_iterator_assembly_matrix ( this,  &
                                         elmat, &
                                         assembler )
  implicit none
  class(fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elmat(:,:)
  class(assembler_t), intent(inout) :: assembler
  
  call this%update_scratch_data()
  call assembler%assembly_matrix( this%fe_space%num_fields,        &
                                               this%fe_space%get_field_blocks(),   &
                                               this%fe_space%get_field_coupling(), &
                                               this%num_cell_dofs_x_field,         &
                                               this%num_cell_dofs_x_field,         &
                                               this%fe_dofs,                      &
                                               this%fe_dofs,                      &
                                               elmat )
  
end subroutine fe_cell_iterator_assembly_matrix

subroutine fe_cell_iterator_assembly_matrix_array ( this,  &
                                               elmat, &
                                               elvec, &
                                               assembler )
  implicit none
  class(fe_cell_iterator_t)           , intent(inout) :: this
  real(rp)                       , intent(in)    :: elmat(:,:)
  real(rp)                       , intent(in)    :: elvec(:)
  class(assembler_t), intent(inout) :: assembler
  
  call this%update_scratch_data()
  call assembler%assembly_matrix( this%fe_space%num_fields,        &
                                               this%fe_space%get_field_blocks(),   &
                                               this%fe_space%get_field_coupling(), &
                                               this%num_cell_dofs_x_field,         &
                                               this%num_cell_dofs_x_field,         &
                                               this%fe_dofs,                      &
                                               this%fe_dofs,                      &
                                               elmat )
  call assembler%assembly_array( this%fe_space%num_fields,         &
                                              this%fe_space%get_field_blocks(),    &
                                              this%fe_space%get_field_coupling(),  &
                                              this%num_cell_dofs_x_field,          &
                                              this%fe_dofs,                       &
                                              elvec )
  
end subroutine fe_cell_iterator_assembly_matrix_array

subroutine fe_cell_iterator_assembly_matrix_array_with_strong_bcs ( this,        &
                                                               fe_function, &
                                                               elmat,       &
                                                               elvec,       &
                                                               assembler )
  implicit none
  class(fe_cell_iterator_t)           , intent(inout) :: this
  type(fe_function_t)            , intent(in)    :: fe_function
  real(rp)                       , intent(in)    :: elmat(:,:)
  real(rp)                       , intent(inout) :: elvec(:)
  class(assembler_t), intent(inout) :: assembler
  
  call this%impose_strong_dirichlet_bcs(fe_function,elmat,elvec)
  call this%fe_cell_iterator_assembly_matrix_array(elmat,elvec,assembler)
  
end subroutine fe_cell_iterator_assembly_matrix_array_with_strong_bcs

subroutine fe_cell_iterator_first_local_non_void(this,field_id)
 implicit none
 class(fe_cell_iterator_t), intent(inout) :: this
 integer(ip),          intent(in)    :: field_id
 class(base_static_triangulation_t), pointer :: base_static_triangulation
 ! Find the first local elem non void in this field
 ! If all local elems are void, then position the iterator at the end ( this%has_finished() == .true. )
 call this%first()
 do while( .not. this%has_finished())
   if (this%is_local()) then
     if ( .not. this%is_void(field_id) ) exit
   end if
   call this%next()
 end do
end subroutine fe_cell_iterator_first_local_non_void

function fe_cell_iterator_get_boundary_quadrature(this) result (quadrature)
  implicit none
  class(fe_cell_iterator_t),  intent(in) :: this
  type(quadrature_t), pointer      :: quadrature
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_quadrature

function fe_cell_iterator_get_boundary_piecewise_cell_map(this) result (cell_map)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(piecewise_cell_map_t), pointer :: cell_map
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_piecewise_cell_map

function fe_cell_iterator_get_boundary_cell_map(this) result (cell_map)
  implicit none
  class(fe_cell_iterator_t), intent(in) :: this
  type(cell_map_t), pointer :: cell_map
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_cell_map

function fe_cell_iterator_get_boundary_cell_integrator(this, field_id) result (cell_int)
  implicit none
  class(fe_cell_iterator_t), intent(in)   :: this
  integer(ip)         , intent(in)   :: field_id
  type(cell_integrator_t), pointer :: cell_int
  mcheck(.false.,'This TPB cannot be called from this class')
end function fe_cell_iterator_get_boundary_cell_integrator

subroutine fe_cell_iterator_update_boundary_integration( this )
  implicit none
  class(fe_cell_iterator_t), intent(inout) :: this
  mcheck(.false.,'This TPB cannot be called from this class')
end subroutine fe_cell_iterator_update_boundary_integration












subroutine fe_cell_iterator_get_values_scalar (this, values, field_id)
  implicit none
  class(fe_cell_iterator_t)   , intent(in)    :: this
  real(rp), allocatable        , intent(inout) :: values(:,:)
  integer(ip)     , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_values(values)
end subroutine fe_cell_iterator_get_values_scalar

subroutine fe_cell_iterator_get_values_vector (this, values, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: values(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_values(values)
end subroutine fe_cell_iterator_get_values_vector

subroutine fe_cell_iterator_get_gradients_scalar (this, gradients, field_id)
  implicit none
  class(fe_cell_iterator_t)              , intent(in)    :: this
  type(vector_field_t),        allocatable, intent(inout) :: gradients(:,:)
  integer(ip)     , optional              , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_gradients(gradients)
end subroutine fe_cell_iterator_get_gradients_scalar

subroutine fe_cell_iterator_get_gradients_vector (this, gradients, field_id)
  implicit none
  class(fe_cell_iterator_t)           , intent(in)     :: this
  type(tensor_field_t),     allocatable, intent(inout)  :: gradients(:,:)
  integer(ip)     , optional           , intent(in)     :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_gradients(gradients)
end subroutine fe_cell_iterator_get_gradients_vector

subroutine fe_cell_iterator_get_divergences_vector (this, divergences, field_id)
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp), allocatable     , intent(inout) :: divergences(:,:)
  integer(ip)  , optional   , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_divergences(divergences)
end subroutine fe_cell_iterator_get_divergences_vector

subroutine fe_cell_iterator_get_curls_vector (this, curls, field_id)
  implicit none
  class(fe_cell_iterator_t)       , intent(in)    :: this
  type(vector_field_t), allocatable, intent(inout) :: curls(:,:)
  integer(ip)     , optional       , intent(in)    :: field_id
  integer(ip) :: field_id_
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%get_curls(curls)
end subroutine fe_cell_iterator_get_curls_vector

!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_scalar ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  real(rp), allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_vector ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_vector
!=================================================================================================
subroutine fe_cell_iterator_evaluate_fe_function_tensor ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(tensor_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_fe_function_tensor
!=================================================================================================
subroutine fe_cell_iterator_evaluate_gradient_fe_function_scalar ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(vector_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_gradient_fe_function_scalar
!=================================================================================================
subroutine fe_cell_iterator_evaluate_gradient_fe_function_vector ( this,                     &
                                                         nodal_values,             &
                                                         quadrature_points_values, &
                                                         field_id )
  implicit none
  class(fe_cell_iterator_t), intent(in)    :: this
  real(rp)                , intent(in)    :: nodal_values(:)
  type(tensor_field_t)    , allocatable   , intent(inout) :: quadrature_points_values(:)
  integer(ip), optional   , intent(in)    :: field_id
  integer(ip)                             :: field_id_
  type(cell_integrator_t), pointer :: cell_integrator
  field_id_=1; if (present(field_id)) field_id_ = field_id
  call this%cell_integrators(field_id_)%p%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine fe_cell_iterator_evaluate_gradient_fe_function_vector





