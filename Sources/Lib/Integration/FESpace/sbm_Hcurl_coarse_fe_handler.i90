! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine Hcurl_l1_free( this ) 
implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  integer(ip) :: coarse_edge, istat 
  
   ! Free all allocated data 
   if (allocated(this%number_fine_edges_per_coarse_edge))  call memfree(this%number_fine_edges_per_coarse_edge, __FILE__, __LINE__ )
   if (allocated(this%perm_sorted_edges))                  call memfree(this%perm_sorted_edges, __FILE__, __LINE__ )
   if (allocated(this%tangent_size))                       call memfree(this%tangent_size, __FILE__, __LINE__ )
   if (allocated(this%dofs_new_basis))                     call memfree(this%dofs_new_basis, __FILE__, __LINE__ )
   if (allocated(this%vertices_in_edge))                   call memfree(this%vertices_in_edge, __FILE__, __LINE__ )
   call this%coupled_vefs_added%free()
   
   ! Free local change basis matrices 
   do coarse_edge=1, this%number_coarse_edges
   call this%coarse_edge_nodes_order(coarse_edge)%free()
   call this%change_basis_matrix%G(coarse_edge)%free() 
   end do 
   !if (allocated(this%change_basis_matrix%G))              deallocate(this%change_basis_matrix%G, stat=istat); check(istat==0); 
   !if (allocated(this%coarse_edge_nodes_order))            deallocate(this%coarse_edge_nodes_order, stat=istat); check(istat==0); 
   
   call this%change_basis_matrix%B%free() 
end subroutine Hcurl_l1_free

subroutine Hcurl_l1_get_num_coarse_dofs(this, par_fe_space, parameter_list, num_coarse_dofs)
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  integer(ip)                           , intent(inout) :: num_coarse_dofs(:)
  
  integer(ip)                            :: field_id
  integer(ip)                            :: ivef_within_cell
  integer(ip)                            :: ivef_within_object
  integer(ip)                            :: icell_around
  integer(ip)                            :: idof, dof_lid
  logical                                :: dofs_on_vef
  type(environment_t), pointer           :: par_environment
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator
  integer(ip), pointer                   :: elem2dof(:)
  logical                                :: use_vertices, use_edges, use_faces
  
  par_environment => par_fe_space%get_par_environment()
  assert ( associated ( par_environment ) )
  assert ( par_environment%am_i_l1_task() )
  assert ( size(num_coarse_dofs) == par_fe_space%get_number_fe_objects() )
  
  call this%get_coarse_space_use_vertices_edges_faces(parameter_list,& 
                                                      use_vertices, &
                                                      use_edges, &
                                                      use_faces)
  
  ! To think where field_id should come from? Temporarily let us assume that we have
  ! a single-field PDE problem
  field_id = 1

  ! First, count how many coarse_dofs there are on the interface of my subdomain
  num_coarse_dofs = 0
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vef)
  do while ( .not. object%has_finished() )
     select case ( object%get_dimension() )
     case (0)
       if (.not. use_vertices) then
         call object%next(); cycle
       end if  
     case (1)
       if (.not. use_edges) then
         call object%next(); cycle
       end if  
     case (2)
       if (.not. use_faces) then
         call object%next(); cycle
       end if  
     end select
    
     dofs_on_vef = .false.
     do ivef_within_object=1, object%get_num_vefs()
        call object%get_vef(ivef_within_object,vef)

        do icell_around=1, vef%get_num_cells_around()
           call vef%get_cell_around(icell_around,fe)
           if ( fe%is_ghost() ) then 
           
              call fe%get_field_elem2dof(field_id, elem2dof)
              ivef_within_cell = fe%find_lpos_vef_lid(vef%get_lid())

              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof    = own_dofs_on_vef_iterator%get_current()
                 dof_lid = elem2dof(idof)
                 if ( dof_lid > 0 ) then
                    dofs_on_vef = .true.
                    exit
                 end if
                 call own_dofs_on_vef_iterator%next()
              end do
           
           end if
        end do
        
        if ( dofs_on_vef ) then
           ! It must be thought for more general cases (vectors, tensor product...)
           num_coarse_dofs(object%get_lid()) = num_coarse_dofs(object%get_lid()) + 2
           exit
        end if

     end do
     call object%next()
  end do
  call par_fe_space%free_fe_vef_iterator(vef)
  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
end subroutine Hcurl_l1_get_num_coarse_dofs

subroutine Hcurl_l1_setup_constraint_matrix(this, par_fe_space, parameter_list, constraint_matrix) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  type(coo_sparse_matrix_t)             , intent(inout) :: constraint_matrix
  type(environment_t), pointer           :: par_environment
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_coarse_dofs_iterator
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 
  integer(ip)                            :: off
  integer(ip) :: field_id
  integer(ip) :: num_rows, num_cols
  integer(ip) :: iface_within_object, ivef_within_cell, ivef_within_object, idof, dof_lid, coarse_dof_lid
  real(rp) :: coarse_edge_size 

  class(base_static_triangulation_t), pointer :: triangulation

  ! Face integration-related data types
  type(quadrature_t)     , pointer     :: quad
  type(face_map_t)       , pointer     :: face_map
  type(fe_map_t)         , pointer     :: face_map_face_map 
  type(face_integrator_t), pointer     :: face_int
  type(vector_field_t)                 :: shape_trial
  integer(ip)            , pointer     :: elem2dof(:)
  type(i1p_t)        , allocatable     :: test_elem2dof(:)

  integer(ip)  :: istat, i
  integer(ip)  :: qpoint, num_quad_points
  real(rp)     :: factor

  integer(ip)                 :: fine_edge, coarse_edge, icdof 
  type(serial_scalar_array_t) :: first_moment_constraint_in_edges 
  real(rp), pointer           :: first_moment_constraint_in_edges_entries(:)
  
  par_environment => par_fe_space%get_par_environment()
  assert (associated(par_environment))
  assert (par_environment%am_i_l1_task())

  triangulation => par_fe_space%get_triangulation()
  allocate (test_elem2dof(1), stat=istat); check(istat==0);

  ! To-think where field_id should come from? Temporarily let us assume that we have
  ! a single-field PDE problem
  field_id = 1

  ! Free any dynamic memory that constraint_matrix may have inside
  call constraint_matrix%free()
  call this%compute_first_order_moment_in_edges(par_fe_space, first_moment_constraint_in_edges)
  first_moment_constraint_in_edges_entries => first_moment_constraint_in_edges%get_entries()
  num_rows = par_fe_space%number_dofs_per_field(field_id)
  num_cols = par_fe_space%ptr_coarse_dofs_per_field(field_id+1)- &
       par_fe_space%ptr_coarse_dofs_per_field(field_id) 

  ! Create constraint matrix (transposed)
  call constraint_matrix%create ( num_rows, num_cols )
 
  ! Fill constraint matrix entries (transposed)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vef)

  coarse_edge = 0
  do while ( .not. object%has_finished() )
        if ( object%get_dimension () == 1) then
		   coarse_edge      = coarse_edge + 1
		   coarse_edge_size = 0.0_rp
		   do i=1, this%number_fine_edges_per_coarse_edge(coarse_edge)
		   coarse_edge_size = coarse_edge_size + abs(this%tangent_size(coarse_edge,i))
		   end do 
	      own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(field_id)
          coarse_dof_lid = own_coarse_dofs_iterator%get_current()
		   fine_edge   = 0
           do ivef_within_object=1, object%get_num_vefs()
              call object%get_vef(ivef_within_object,vef)
			  if (vef%get_dimension() == 1) then 
			  fine_edge = fine_edge + 1
              call vef%get_cell_around(1,fe)
              call fe%get_field_elem2dof(field_id, elem2dof)
              ivef_within_cell = fe%find_lpos_vef_lid(vef%get_lid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof    = own_dofs_on_vef_iterator%get_current()
                 dof_lid = elem2dof(idof)
                 if ( dof_lid > 0 ) then
				    ! Average of the tangent component over the Coarse Edge
                      call constraint_matrix%insert(dof_lid, coarse_dof_lid, this%tangent_size(coarse_edge,fine_edge)/coarse_edge_size )	
					! First order moment of the tangent component over the Coarse Edge
					  call constraint_matrix%insert(dof_lid, coarse_dof_lid+1, -first_moment_constraint_in_edges_entries(dof_lid)/coarse_edge_size )
                end if
                 call own_dofs_on_vef_iterator%next()
              end do
			  end if 
           end do 
	 end if
     call object%next()
  end do
    
  call first_moment_constraint_in_edges%free() 
  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef)
  deallocate (test_elem2dof, stat=istat); check(istat==0);
  call constraint_matrix%sort_and_compress()

end subroutine Hcurl_l1_setup_constraint_matrix

subroutine Hcurl_l1_apply_weighting_operator_and_comm(this, W, x, y) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  real(rp),            allocatable,       intent(in)    :: W(:) 
  type(par_scalar_array_t)  , intent(inout) :: x
  type(par_scalar_array_t)  , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_local
  type(serial_scalar_array_t), pointer :: y_local
  real(rp), pointer :: x_local_entries(:)
  real(rp), pointer :: y_local_entries(:)

     x_local         => x%get_serial_scalar_array()
     x_local_entries => x_local%get_entries()
     y_local         => y%get_serial_scalar_array()
     y_local_entries => y_local%get_entries()
     
	call this%apply_inverse_local_change_basis( x_local, x_local )
    y_local_entries = x_local_entries*W 
   	call y%comm()
	call this%apply_global_change_basis( y, y )
   	
end subroutine Hcurl_l1_apply_weighting_operator_and_comm

subroutine Hcurl_l1_apply_transpose_weighting_operator(this, W, x, y) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  real(rp),            allocatable,       intent(in)    :: W(:) 
  type(par_scalar_array_t)  , intent(inout) :: x
  type(par_scalar_array_t)  , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_local
  type(serial_scalar_array_t), pointer :: y_local
  real(rp), pointer :: x_local_entries(:)
  real(rp), pointer :: y_local_entries(:)

     x_local         => x%get_serial_scalar_array()
     x_local_entries => x_local%get_entries()
     y_local         => y%get_serial_scalar_array()
     y_local_entries => y_local%get_entries()
	
	call this%apply_global_change_basis_transpose( x, x )
    y_local_entries = x_local_entries*W 
	call this%apply_inverse_local_change_basis_transpose( y_local, y_local ) 

end subroutine Hcurl_l1_apply_transpose_weighting_operator
! -------------------------------------------------------------------------------------------------
!
!                                 Non overriding procedures 
!
! -------------------------------------------------------------------------------------------------
subroutine Hcurl_l1_setup_change_basis_tools( this, par_fe_space ) 
implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                  , intent(inout)    :: par_fe_space
  
  ! Define renumbering s.t. Wire Dofs [E,E^c]
  call this%compute_wire_dof_renumbering( par_fe_space )
  ! Sort fine edges in a coarse edge and give coarse unique orientation 
  call this%set_orientation_and_sort_fine_edges(par_fe_space)
  ! Compute the change basis arrays 
  call this%compute_change_basis_matrix( par_fe_space )
  
end subroutine Hcurl_l1_setup_change_basis_tools

subroutine Hcurl_l1_allocate_and_fill_local_to_wire_dof_numbering(this, par_fe_space ) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space

  integer(ip) :: idof 

    ! The new basis functions introduced in Edges will be 
    call memalloc ( this%number_edge_wire_dofs, this%dofs_new_basis, __FILE__, __LINE__ )
    do idof=1, this%number_edge_wire_dofs
    this%dofs_new_basis(idof) = idof
	end do 
 
end subroutine Hcurl_l1_allocate_and_fill_local_to_wire_dof_numbering
  
subroutine Hcurl_l1_compute_change_basis_matrix(this, par_fe_space)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(inout) :: par_fe_space
  
  real(rp) , allocatable                                :: edge_elmat(:,:)

  call this%compute_edge_discrete_gradient_elmat(par_fe_space, edge_elmat)  
  call this%fill_edge_local_change_of_basis(par_fe_space, edge_elmat)
  call this%fill_coupled_to_edges_local_change_of_basis(par_fe_space, edge_elmat)
  if ( this%order > 1 ) call this%fill_face_coupled_to_edges_local_change_of_basis(par_fe_space) 
  
  call memfree(edge_elmat, __FILE__, __LINE__ ) 

end subroutine Hcurl_l1_compute_change_basis_matrix

subroutine Hcurl_l1_compute_edge_discrete_gradient_elmat(this, par_fe_space, elmat)
  ! This subroutine computes the elemental 1D Discrete Gradient (phi',phi)_e matrix in a 
  ! reference edge. As the integration to be performed is not edge size-dependent Elemental 
  ! matrix in edges can be re-used for every edge just taking into acount the tangent direction.  
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(inout) :: elmat(:,:) 

  ! Local variables required by Wire edges moments integration
  class(reference_fe_t), pointer         :: ref_fe 
  type(hex_lagrangian_reference_fe_t)    :: fe_1D, fe_1D_reduced_order 
  type(quadrature_t)                     :: edge_quadrature
  type(interpolation_t)                  :: interpolation_1D, interpolation_1D_reduced_order 
  real(rp)                               :: shape_test, factor 
  type(vector_field_t)                   :: grad_shape_trial 
  integer(ip)                            :: ishape, jshape, qpoint 
  integer(ip)                            :: field_id 

  field_id = 1
  ref_fe => par_fe_space%get_reference_fe(field_id) 

  ! Create a 1D scalar lagrangian reference FE of order k
  call fe_1D%create(topology          = ref_fe%get_topology(),          &
                    number_dimensions = 1,                              &
                    order             = ref_fe%get_order(),             &
                    field_type        = field_type_scalar,              &
                    continuity        = .true. )

  ! Create a 1D scalar lagrangian reference FE of order k-1
  call fe_1D_reduced_order%create(topology          = ref_fe%get_topology(),  &
                                  number_dimensions = 1,                      &
                                  order             = ref_fe%get_order()-1,   &
                                  field_type        = field_type_scalar,      &
                                  continuity        = .true. )

  select type(ref_fe)
     class is (nedelec_reference_fe_t)  
     call ref_fe%create_edge_quadrature( edge_quadrature )
     class DEFAULT
     assert(.false.) 
  end select

  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )
  call fe_1D_reduced_order%create_interpolation( edge_quadrature, interpolation_1D_reduced_order )

  ! IDEA: perform edge integrations ONLY over the elementary edge 
  ! REAL 1D CELL integration ( Phi'*inv(J)'*Phi*|J| )_e = +-( Phi', Phi)_e 
  ! The sign will be solved later when assembling to the Wire scheme  
  call memalloc( fe_1D_reduced_order%get_number_shape_functions(), fe_1D%get_number_shape_functions(), elmat, __FILE__, __LINE__ ) 
  elmat = 0.0_rp 
  do qpoint = 1, edge_quadrature%number_quadrature_points
     factor = edge_quadrature%get_weight(qpoint) 
     do ishape = 1, fe_1D_reduced_order%get_number_shape_functions() 
        call fe_1D_reduced_order%get_value(interpolation_1D_reduced_order, ishape, qpoint, shape_test)
        do jshape = 1, fe_1D%get_number_shape_functions() 
           call fe_1D%get_gradient(interpolation_1D, jshape, qpoint, grad_shape_trial)
           elmat(ishape, jshape) = elmat(ishape, jshape) + grad_shape_trial%get(1) * shape_test * factor
        end do
     end do
  end do
  
  ! Free data 
  call fe_1D%free() 
  call fe_1D_reduced_order%free()
  call interpolation_1D%free() 
  call interpolation_1D_reduced_order%free()
  call edge_quadrature%free()

end subroutine Hcurl_l1_compute_edge_discrete_gradient_elmat

subroutine Hcurl_l1_fill_edge_local_change_of_basis(this, par_fe_space, elmat)
  ! Fill change of basis local to Coarse EDGES, G_Ee
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(in)    :: elmat(:,:) 

  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef_within_object
  integer(ip)                            :: ivef_within_object
  integer(ip)                            :: coarse_edge, fine_edge 
  integer(ip), pointer                   :: dofs_new_basis(:) 
  integer(ip), allocatable               :: dofs_wire_edge_old_basis(:)
  integer(ip)                            :: offset_wire_edge_dofs 

  integer(ip) :: idof, jdof, istat 
  real(rp)    :: factor 

  allocate( this%change_basis_matrix%G(this%number_coarse_edges), stat=istat); check(istat==0)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call memalloc( this%order, dofs_wire_edge_old_basis, __FILE__, __LINE__ )

  coarse_edge = 0
  offset_wire_edge_dofs = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
        coarse_edge = coarse_edge + 1
		if (coarse_edge>1) offset_wire_edge_dofs = offset_wire_edge_dofs + this%number_fine_edges_per_coarse_edge(coarse_edge-1)*this%order 

        ! Create local Edge change of basis matrix 
        call this%change_basis_matrix%G(coarse_edge)%create(num_rows_and_cols= this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
                                                            symmetric_storage=.false.,                  &
                                                            is_symmetric     =.false.,                  &
                                                            sign             = SPARSE_MATRIX_SIGN_UNKNOWN )

        fine_edge = 0
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then 
              fine_edge = fine_edge + 1  
			  call this%get_wire_basis_dofs_from_vef(par_fe_space, vef_within_object, dofs_wire_edge_old_basis)
              dofs_new_basis  => this%get_dof_list_new_basis( coarse_edge, fine_edge ) 
              factor = 1.0_rp !/abs(this%tangent_size(coarse_edge, fine_edge))
              ! Fill local Edge change of basis matrix
              if ( this%is_first_edge(coarse_edge, fine_edge) ) then 
                 ! First fine edge, Starting Nodal Lagrangian shape function must not be taken into account
                 do jdof = 1, this%order ! Loop over all nedelec-like dofs in the fine edge   
                    if (this%tangent_size(coarse_edge, fine_edge) > 0) then 
                       call this%change_basis_matrix%G(coarse_edge)%insert(nz       = this%order,                                       & 
                                                                           ia       = dofs_wire_edge_old_basis - offset_wire_edge_dofs, &
                                                                           ja       = dofs_new_basis(jdof),                             &
                                                                           val      = elmat(:, jdof+1)*factor   )
                    elseif (this%tangent_size(coarse_edge, fine_edge) < 0) then 
                       do idof = 1, this%order  
                          call this%change_basis_matrix%G(coarse_edge)%insert(ia       = dofs_wire_edge_old_basis(idof)- offset_wire_edge_dofs, &
                                                                              ja       = dofs_new_basis(jdof),                                  &
                                                                              val      = -elmat(this%order+1-idof, jdof+1)*factor )
                       end do
                    else 
                       assert(.false.) ! The fine edge has not been assigned a tangent sign 
                    end if
                 end do

              elseif ( (.not. this%is_first_edge(coarse_edge, fine_edge)) .and. (.not. this%is_last_edge(coarse_edge, fine_edge)) ) then  
                 ! If given directions coincide, assembly is performed directly 
                 if (this%tangent_size(coarse_edge, fine_edge) > 0) then 
                    call this%change_basis_matrix%G(coarse_edge)%insert(num_rows = this%order,                                      & 
                                                                        num_cols = this%order+1,                                    & 
                                                                        ia       = dofs_wire_edge_old_basis- offset_wire_edge_dofs, &
                                                                        ja       = dofs_new_basis,                                  &
                                                                        ioffset  = 0,                                               &
                                                                        joffset  = 0,                                               & 
                                                                        val      = elmat*factor)

                 elseif (this%tangent_size(coarse_edge, fine_edge) < 0) then 
                    ! If fine edge direction does not coincide with coarse edge direction, assembly is rearranged: swap row-order (Nedelec dofs are
                    ! assigned along the tangent direction from start-end of the local edge ) + sign flip for the opposite tangent 			 
                    do idof = 1, this%order ! Loop over all nedelec-like dofs in the fine edge    
                       call this%change_basis_matrix%G(coarse_edge)%insert(nz       = this%order+1,                                          & 
                                                                           ia       = dofs_wire_edge_old_basis(idof)- offset_wire_edge_dofs, &
                                                                           ja       = dofs_new_basis,                                        &
                                                                           val      = -elmat( (this%order+1)-idof,:)*factor   )
                    end do
                 end if

              else  
                 ! Last fine edge, Nodal Lagrangian Ending shape function must not be taken into account
                 do jdof = 1, this%order ! Loop over all nedelec-like dofs in the fine edge   
                    if (this%tangent_size(coarse_edge, fine_edge) > 0) then 
                       call this%change_basis_matrix%G(coarse_edge)%insert(nz       = this%order,                                      & 
                                                                           ia       = dofs_wire_edge_old_basis- offset_wire_edge_dofs, &
                                                                           ja       = dofs_new_basis(jdof),                            &
                                                                           val      = elmat(:, jdof)*factor )
                    elseif (this%tangent_size(coarse_edge, fine_edge) < 0) then 
                       do idof = 1, this%order  
                          call this%change_basis_matrix%G(coarse_edge)%insert(ia       = dofs_wire_edge_old_basis(idof)- offset_wire_edge_dofs,  &
                                                                              ja       = dofs_new_basis(jdof),                                   &
                                                                              val      = -elmat(this%order+1-idof, jdof )*factor )
                       end do
                    end if
                 end do
              end if
              
			  ! Last column is filled with +- edge sizes depending on local-coarse orientation  
			  do idof=1, this%order 
              call this%change_basis_matrix%G(coarse_edge)%insert(ia       = dofs_wire_edge_old_basis(idof)-offset_wire_edge_dofs,           &
                                                                  ja       = this%number_fine_edges_per_coarse_edge(coarse_edge)*this%order, &  ! Last DOF 
                                                                  val      = this%tangent_size(coarse_edge,fine_edge)/abs(this%tangent_size(coarse_edge,fine_edge)) )
              end do
			  
           end if
        end do
		
        call this%change_basis_matrix%G(coarse_edge)%convert(csr_format)
	   ! call this%change_basis_matrix%G(coarse_edge)%print_matrix_market(6)
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object) 
  call memfree(dofs_wire_edge_old_basis) 

end subroutine Hcurl_l1_fill_edge_local_change_of_basis

subroutine Hcurl_l1_fill_coupled_to_edges_local_change_of_basis(this, par_fe_space, elmat)
! Fill remaining change of basis part, E^c faces and edges not contained in the Coarse Edge 
! but coupled to it by the Discrete Gradient 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
type(par_fe_space_t)                  , intent(in)    :: par_fe_space
real(rp), allocatable                 , intent(in)    :: elmat(:,:) 

type(fe_object_iterator_t)                :: object
type(fe_vef_iterator_t)                   :: vef_within_object
type(fe_vef_iterator_t)                   :: vertex, edge 
class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
class(fe_iterator_t), allocatable         :: fe
integer(ip)                               :: ivef_within_object, ivef_within_cell 
integer(ip)                               :: vertex_within_cell_id
integer(ip)                               :: vertex_within_edge_id
integer(ip)                               :: ielem, edge_id, interior_node_id  
integer(ip)                               :: coarse_edge, fine_edge, node_id
type(list_t), pointer                     :: vertices_of_line
type(list_iterator_t)                     :: vertices_of_line_iterator
integer(ip)                               :: inode, start_node, end_node 
integer(ip)                               :: edge_direction, new_basis_dof 
integer(ip), allocatable                  :: dofs_wire_edge_old_basis(:) 
integer(ip)                               :: idof, istat
integer(ip)                               :: dummy_val,i
integer(ip)                               :: factor 

  ! Create local Coupled to Edge change of basis matrix 
  call this%change_basis_matrix%B%create(num_rows = this%number_total_wire_dofs - this%number_edge_wire_dofs,  &
    									 num_cols = this%number_edge_wire_dofs                                 )
		
  call memalloc( this%order, dofs_wire_edge_old_basis, __FILE__, __LINE__ )
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vertex) 
  call par_fe_space%create_fe_vef_iterator(edge)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  
  coarse_edge = 0
  ! Find Coupled edges and assembly Discrete Gradient in a first loop 
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then ! Only sort coarse edges
        coarse_edge = coarse_edge + 1
        fine_edge = 0
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
		   			   
           if ( vef_within_object%get_dimension() == 0 .and. (.not. vef_within_object%is_at_boundary()) ) then  ! Only act if an interior vertex is found  	
			  do ielem = 1, vef_within_object%get_num_cells_around()
              call vef_within_object%get_cell_around(ielem, fe)      
			    if ( fe%is_local() ) then 
                ref_fe_geo => fe%get_reference_fe_geo()
                ivef_within_cell = fe%find_lpos_vef_lid(vef_within_object%get_lid())     
				interior_node_id = vef_within_object%get_lid() 
				! Loop over edges in the element to find coupled edges 
				do edge_id = ref_fe_geo%get_first_n_face_id_of_dimension(1), & 
                ref_fe_geo%get_first_n_face_id_of_dimension(1) + ref_fe_geo%get_number_n_faces_of_dimension(1)-1
			    
				! Need global ID to check if it has been added 
				call fe%get_vef(edge_id, edge) 			
				if ( edge%is_at_interface() ) then 
				
				call this%coupled_vefs_added%get( key=edge%get_lid(), val=dummy_val, stat=istat); 
				if (  .not. istat==key_found ) then  
                vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
                vertices_of_line_iterator = vertices_of_line%create_iterator(edge_id)
                vertex_within_edge_id     = 1
				
                   do while( .not. vertices_of_line_iterator%is_upper_bound() )
                   vertex_within_cell_id = vertices_of_line_iterator%get_current()
                   call fe%get_vef(vertex_within_cell_id, vertex )
                   node_id = vertex%get_lid() 
				   if (node_id == interior_node_id) then
				   ! A coupled edge has been found  
				   if (vertex_within_edge_id==1) edge_direction = 0 ! Effluent
				   if (vertex_within_edge_id==2) edge_direction = 1 ! Affluent  
				   
                   ! Assembly its part to the Discrete Gradient for the coupled EDGE  
				   factor  = 1.0_rp !/abs(this%tangent_size(1,1))
				   new_basis_dof       =  this%get_new_basis_dof_from_node_id(coarse_edge, interior_node_id) 
				   call this%get_wire_basis_dofs_from_vef(par_fe_space, edge, dofs_wire_edge_old_basis)		

				 if ( edge_direction == 1) then  ! Affluent edge 
                    call this%change_basis_matrix%B%insert(nz       = this%order,                                            & 
                                                           ia       = dofs_wire_edge_old_basis - this%number_edge_wire_dofs, &
                                                           ja       = new_basis_dof,                                         &
                                                           val      = elmat(:, this%order+1)*factor )

                 elseif ( edge_direction == 0) then ! Effluent edge 
                    ! If edge is effluent to the coarse edge, assembly is rearranged: swap row-order (Nedelec dofs are
                    ! assigned along the tangent direction from start-end of the local edge ) + sign flip for the opposite tangent 			 
                    do idof = 1, this%order ! Loop over all nedelec-like dofs in the fine edge    
                       call this%change_basis_matrix%B%insert(ia       = dofs_wire_edge_old_basis(idof) - this%number_edge_wire_dofs,  &
                                                              ja       = new_basis_dof,                                                &
                                                              val      = -elmat( (this%order+1)-idof, this%order+1)*factor   )
                    end do
                 end if

				   call this%coupled_vefs_added%put( key=edge%get_lid(), val=1, stat=istat) 
				   exit 
				   end if 
                   vertex_within_edge_id = vertex_within_edge_id + 1
                   call vertices_of_line_iterator%next() 
                   end do ! Loop over vertices in the edge 
				   				   				  				   
				   end if 
			         end if ! Checker interface vef 
				   end do 
			    end if 
			  end do 
			  
           end if
        end do
     end if
     call object%next()
  end do

  call this%change_basis_matrix%B%convert(csr_format)
  ! call this%change_basis_matrix%B%print_matrix_market(6) 
    
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(vertex)
  call par_fe_space%free_fe_vef_iterator(edge)
  call memfree(dofs_wire_edge_old_basis)
  
end subroutine Hcurl_l1_fill_coupled_to_edges_local_change_of_basis

subroutine Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis( this, par_fe_space )
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)       :: this
type(par_fe_space_t)                  , intent(inout)    :: par_fe_space 

class(reference_fe_t), pointer         :: ref_fe 
class(fe_iterator_t), allocatable      :: fe
type(fe_face_iterator_t)               :: fe_face 
type(hex_nedelec_reference_fe_t)       :: Nedelec_fe_2D
type(hex_lagrangian_reference_fe_t)    :: Lagrangian_fe_2D
type(interpolation_t)                  :: Lagrangian_interpolation
type(interpolation_t)                  :: Nedelec_interpolation
real(rp), allocatable                  :: elmat(:,:) 
integer(ip)                            :: field_id 

       field_id = 1
       call par_fe_space%initialize_fe_face_integration()
	   call par_fe_space%create_fe_face_iterator(fe_face)
       call par_fe_space%create_fe_iterator(fe) 
       
	   ref_fe => par_fe_space%get_reference_fe(field_id) 
	   call Nedelec_fe_2D%create(topology          = ref_fe%get_topology(), &
                                 number_dimensions = 2,                     &
                                 order             = this%order-1,          &
                                 field_type        = field_type_vector,     &
                                 continuity        = .false. )
		   
	   call Lagrangian_fe_2D%create(topology          = ref_fe%get_topology(), &
                                    number_dimensions = 2,                     &
                                    order             = this%order,            &
                                    field_type        = field_type_scalar,     &
                                    continuity        = .true. )
	   	   
	   call memalloc( 2*this%order*(this%order-1), (this%order+1)*(this%order+1), elmat, __FILE__, __LINE__ )
	   	   
	   call Lagrangian_fe_2D%create_interpolation( fe_face%get_quadrature(), Lagrangian_interpolation )
	   call Nedelec_fe_2D%create_interpolation( fe_face%get_quadrature(), Nedelec_interpolation )
	   	  
	   do while ( .not. fe_face%is_at_interface() ) 
	   call fe_face%next() 
	   end do
	   
       call this%compute_face_discrete_gradient_elmat(fe_face,                       &
													  Nedelec_fe_2D,                 &
													  Lagrangian_fe_2D,              &
													  Nedelec_interpolation,         &
													  Lagrangian_interpolation,      &
													  elmat)                       
	   
	    ! Free 
	   call Lagrangian_fe_2D%free() 
	   call Nedelec_fe_2D%free() 	  
	   call Nedelec_interpolation%free() 
	   call Lagrangian_interpolation%free() 
	   
	   call par_fe_space%free_fe_iterator(fe)
	   call par_fe_space%free_fe_vef_iterator(fe_face)	  
  
	   call memfree(elmat, __FILE__, __LINE__ ) 
end subroutine Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis 

subroutine Hcurl_l1_compute_face_discrete_gradient_elmat(this, fe_face, Nedelec_fe_2D, Lagrangian_fe_2D, Nedelec_interpolation, Lagrangian_interpolation, elmat)
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)       :: this
type(fe_face_iterator_t)              , intent(inout)    :: fe_face
type(hex_nedelec_reference_fe_t)      , intent(in)       :: Nedelec_fe_2D
type(hex_lagrangian_reference_fe_t)   , intent(in)       :: Lagrangian_fe_2D
type(interpolation_t)                 , intent(in)       :: Lagrangian_interpolation
type(interpolation_t)                 , intent(in)       :: Nedelec_interpolation
real(rp), allocatable                 , intent(inout)    :: elmat(:,:) 

    integer(ip) :: ielem 
    type(quadrature_t)       , pointer     :: quad
    type(fe_map_t)           , pointer     :: fe_map
    type(face_map_t)         , pointer     :: face_map
	type(fe_map_t)           , pointer     :: face_map_face_map
	
    integer(ip)                            :: qpoin, number_qpoints, idof 
    real(rp)                               :: factor

    type(vector_field_t)                   :: normal, v_shape_test, gradv_shape_trial
    integer(ip) :: ishape, jshape, qpoint, iface

	   call fe_face%update_integration()
       quad              => fe_face%get_quadrature()
       number_qpoints    =  quad%get_number_quadrature_points()
       face_map          => fe_face%get_face_map()
	   face_map_face_map => face_map%get_face_map()
	   	     
	   elmat = 0.0_rp 
	   do qpoint = 1, number_qpoints
	   factor = face_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)
	   call face_map_face_map%get_normal(qpoint, normal)
	   do ishape = 1, 2*this%order*(this%order-1)
	   call Nedelec_fe_2D%get_value(Nedelec_interpolation, ishape, qpoint, v_shape_test)
	      do jshape = 1, (this%order + 1)*(this%order+1)   
		  call Lagrangian_fe_2D%get_gradient(Lagrangian_interpolation, jshape, qpoint, gradv_shape_trial)
	      elmat(ishape,jshape) = elmat(ishape, jshape) + 1.0_rp/sqrt(face_map%get_det_jacobian(qpoint))*factor*cross_product(gradv_shape_trial,normal)*v_shape_test
	      end do 
	   end do 
	   end do 
      		
end subroutine Hcurl_l1_compute_face_discrete_gradient_elmat

subroutine Hcurl_l1_compute_first_order_moment_in_edges(this, par_fe_space, constraint_in_edges)
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
type(par_fe_space_t)                  , intent(in)    :: par_fe_space 
type(serial_scalar_array_t)           , intent(inout) :: constraint_in_edges

type(fe_object_iterator_t)             :: object
type(fe_vef_iterator_t)                :: vef_within_object
integer(ip)                            :: ivef_within_object
integer(ip)                 :: field_id, idof, offcomponent_coarse_edge 
integer(ip)                 :: coarse_edge, fine_edge 
real(rp),    allocatable    :: elvec(:) 
integer(ip), pointer        :: dofs_new_basis(:) 
type(serial_scalar_array_t) :: x_new_local_edge 
type(serial_scalar_array_t) :: x_old_local_edge 
real(rp)                    :: factor 

! Direct solver data
type(direct_solver_t)        :: direct_solver 
integer                      :: FPLError
type(parameterlist_t)        :: parameter_list
integer                      :: iparm(64)
  
  field_id = 1
  call constraint_in_edges%create_and_allocate( par_fe_space%get_block_number_dofs(field_id) )
  call constraint_in_edges%init(0.0_rp) 

  ! Elemental vector int(Phi), lack of lenght (Jacobian), computed in h=[-1,1] elemental edge   
  call this%compute_edge_elvec( par_fe_space, elvec ) 

  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  ! Loop on fine edges and assemble the elemental vector, C_new 
  coarse_edge = 0
  offcomponent_coarse_edge = this%number_interior_dofs 
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
        coarse_edge = coarse_edge + 1	
		if (coarse_edge>1) offcomponent_coarse_edge = offcomponent_coarse_edge + this%number_fine_edges_per_coarse_edge(coarse_edge-1)*this%order
        fine_edge = 0
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then 
              fine_edge = fine_edge + 1  
              dofs_new_basis  => this%get_dof_list_new_basis( coarse_edge, fine_edge ) 
              factor = abs(this%tangent_size(coarse_edge,fine_edge))/2.0_rp 
              ! Fill local Edge average (new basis) 
              if ( this%is_first_edge(coarse_edge, fine_edge) ) then 
                 ! First fine edge, Starting Nodal Lagrangian shape function must not be taken into account
                 do idof = 1, this%order    
                       call constraint_in_edges%add( i    = offcomponent_coarse_edge + dofs_new_basis(idof),  &
                                                        val  = elvec(idof+1)*factor  )
                 end do

              elseif ( (.not. this%is_first_edge(coarse_edge, fine_edge)) .and. (.not. this%is_last_edge(coarse_edge, fine_edge)) ) then  
                    do idof = 1, this%order+1  
                       call constraint_in_edges%add(i    = offcomponent_coarse_edge + dofs_new_basis(idof),  &
                                                       val  = elvec(idof)*factor  )
					end do 
              else  
                 ! Last fine edge, Nodal Lagrangian Ending shape function must not be taken into account
                  do idof = 1, this%order    
                       call constraint_in_edges%add( i    = offcomponent_coarse_edge + dofs_new_basis(idof),  &
                                                        val  = elvec(idof)*factor  )
                 end do
              end if

           end if
        end do
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object) 
  
  ! Change of basis for the assembled vector: C_new*inv(G) = C_old --> SOLVE G^t C_old = C_new 
  	iparm      = 0 ! Init all entries to zero
    iparm(1)   = 1 ! no solver default
    iparm(2)   = 2 ! fill-in reordering from METIS
    iparm(8)   = 2 ! numbers of iterative refinement steps
    iparm(10)  = 8 ! perturb the pivot elements with 1E-8
    iparm(11)  = 1 ! use scaling 
	iparm(12)  = 2 ! Solve transposed system 
    iparm(13)  = 1 ! use maximum weighted matching algorithm 
    iparm(21)  = 1 ! 1x1 + 2x2 pivots
 
  	 ! Create direct solver
    call parameter_list%init()
    FPLError =            parameter_list%set(key = direct_solver_type     ,   value = pardiso_mkl)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type,   value = pardiso_mkl_uns)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level, value = 0); 
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm); assert(FPLError == 0)  
    call direct_solver%set_type_from_pl(parameter_list)
    call direct_solver%set_parameters_from_pl(parameter_list)
    call direct_solver%set_matrix(this%change_basis_matrix%G(1))
	
	 ! Apply local inverse to each Coarse Edge  
	 offcomponent_coarse_edge = this%number_interior_dofs 
     do coarse_edge = 1, this%number_coarse_edges
	 if (coarse_edge>1) offcomponent_coarse_edge = offcomponent_coarse_edge + this%number_fine_edges_per_coarse_edge(coarse_edge-1)*this%order

	 call constraint_in_edges%create_view(offcomponent_coarse_edge + 1,                                                              & 
								          offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								          x_new_local_edge )
	 
	 call x_old_local_edge%create_and_allocate(this%order*this%number_fine_edges_per_coarse_edge(coarse_edge))
	 call x_old_local_edge%init(0.0_rp) 
		 
	 ! Get transpose of the local Edge change of basis matrix 
	    call direct_solver%update_matrix( this%change_basis_matrix%G(coarse_edge), same_nonzero_pattern=.false.) 
        call direct_solver%solve( x_new_local_edge, x_old_local_edge)		
		
		! Assign values 		
		call x_new_local_edge%copy(x_old_local_edge)
				
		call x_old_local_edge%free()
		call x_new_local_edge%free()
	 end do 
	 call direct_solver%free() 
	 
call memfree(elvec, __FILE__, __LINE__ )
end subroutine Hcurl_l1_compute_first_order_moment_in_edges

subroutine Hcurl_l1_compute_edge_elvec(this, par_fe_space, elvec)
  ! This subroutine computes the elemental 1D integration of Lagrangian 
  ! shape functions over a reference 1D element 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(inout) :: elvec(:) 
  
  class(reference_fe_t), pointer         :: ref_fe 
  type(hex_lagrangian_reference_fe_t)    :: fe_1D
  type(quadrature_t)                     :: edge_quadrature
  type(interpolation_t)                  :: interpolation_1D 
  real(rp)                               :: shape_test, factor 
  integer(ip)                            :: ishape, qpoint 
  integer(ip)                            :: field_id 

  field_id = 1
  ref_fe => par_fe_space%get_reference_fe(field_id) 

  ! Create a 1D scalar lagrangian reference FE of order k
  call fe_1D%create(topology          = ref_fe%get_topology(),          &
                    number_dimensions = 1,                              &
                    order             = ref_fe%get_order(),             &
                    field_type        = field_type_scalar,              &
                    continuity        = .true. )

  select type(ref_fe)
     class is (nedelec_reference_fe_t)  
     call ref_fe%create_edge_quadrature( edge_quadrature )
     class DEFAULT
     assert(.false.) 
  end select

  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )
 
  call memalloc( fe_1D%get_number_shape_functions(), elvec, __FILE__, __LINE__ ) 
  elvec = 0.0_rp 
  do qpoint = 1, edge_quadrature%number_quadrature_points
     factor = edge_quadrature%get_weight(qpoint) 
     do ishape = 1, fe_1D%get_number_shape_functions() 
        call fe_1D%get_value(interpolation_1D, ishape, qpoint, shape_test)
           elvec(ishape) = elvec(ishape) + shape_test * factor 
     end do
  end do

  ! Free data 
  call fe_1D%free() 
  call interpolation_1D%free() 
  call edge_quadrature%free()

end subroutine Hcurl_l1_compute_edge_elvec
! -------------------------------------------------------------------------------------------------
!
!                                 Change of basis matrix applications 
!
! -------------------------------------------------------------------------------------------------
subroutine Hcurl_l1_apply_global_change_basis(this, x_new, x_old)
! Thanks to structure of change basis, it can be applied locally without 
! further consideration and obtain the fully assembled local parts of the global
! change of basis 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
type(par_scalar_array_t)                 , intent(in)     :: x_new
type(par_scalar_array_t)                 , intent(inout)  :: x_old

type(serial_scalar_array_t)  , pointer   :: x_new_local
type(serial_scalar_array_t)  , pointer   :: x_old_local
type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
type(serial_scalar_array_t)  :: B_times_x_new
type(serial_scalar_array_t)  :: G_times_x_new 

! Local auxiliar variables 
integer(ip) :: offcomponent_coarse_edge, coarse_edge
integer(ip) :: idof 

     x_old_local         => x_old%get_serial_scalar_array()
     x_new_local         => x_new%get_serial_scalar_array()
	 
	 ! First part of the application: x_old_Ec = B*x_new_E + x_new_Ec   	  
	  call x_new_local%create_view( this%number_interior_dofs + 1,                              & 
								    this%number_interior_dofs + this%number_edge_wire_dofs,     &
									x_new_local_edge )
	  
	  call x_old_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1, & 
								    this%number_interior_dofs + this%number_total_wire_dofs,    &
									x_old_local_Ec )
	  
	  call x_new_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1, & 
								    this%number_interior_dofs + this%number_total_wire_dofs,    &
									x_new_local_Ec )

	  call B_times_x_new%create_and_allocate( this%number_total_wire_dofs - this%number_edge_wire_dofs)
	  call B_times_x_new%init(0.0_rp)
	  
	  ! Apply local change basis to built DoF 
        call this%change_basis_matrix%B%apply(x_new_local_edge, B_times_x_new)
		
	  ! Assign values to the vector associated to [E^c] in the new basis  
	  call x_old_local_Ec%axpby(1.0_rp, B_times_x_new, 1.0_rp) 

	  call x_new_local_edge%free()
	  call x_old_local_Ec%free()
	  call x_new_local_Ec%free() 
	  call B_times_x_new%free() 
	  
     ! Second part of the application: x_old_E = G*x_new_E, application Edge by Edge 
	 offcomponent_coarse_edge = this%number_interior_dofs 
     do coarse_edge = 1, this%number_coarse_edges
	 if (coarse_edge>1) offcomponent_coarse_edge = offcomponent_coarse_edge + this%number_fine_edges_per_coarse_edge(coarse_edge-1)*this%order
	 call x_old_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_old_local_edge )

	 call x_new_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_new_local_edge )
	 
	   ! Apply local change basis to built DoF
	   call G_times_x_new%create_and_allocate( this%order*this%number_fine_edges_per_coarse_edge(coarse_edge) ) 
       call this%change_basis_matrix%G(coarse_edge)%apply(x_new_local_edge, G_times_x_new)
       call x_old_local_edge%copy(G_times_x_new) 
	    
		call x_old_local_edge%free()
		call x_new_local_edge%free()
		call G_times_x_new%free()
	 end do 
	 	
end subroutine Hcurl_l1_apply_global_change_basis

subroutine Hcurl_l1_apply_global_change_basis_transpose(this, x_old, x_new)
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
type(par_scalar_array_t)                 , intent(in)     :: x_old
type(par_scalar_array_t)                 , intent(inout)  :: x_new

type(serial_scalar_array_t), pointer  :: x_old_local 
type(serial_scalar_array_t), pointer  :: x_new_local
type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
type(serial_scalar_array_t)  :: Bt_times_x_old
type(serial_scalar_array_t)  :: Gt_times_x_old 

! Local auxiliar variables 
integer(ip) :: offcomponent_coarse_edge, coarse_edge
integer(ip) :: idof 
	 
     x_old_local         => x_old%get_serial_scalar_array()
     x_new_local         => x_new%get_serial_scalar_array()
	 
	 ! Nullify non-owned dofs to perform the global Q'*x computation locally 
	 call x_new%nullify_non_owned_dofs() 
	 
	 ! First part of the application: x_new_Ec = x_old_Ec (do-nothing)  
	 
     ! Second part of the application: x_new_E =  G^t x_old_E + B^t*x_old_Ec	
	  offcomponent_coarse_edge = this%number_interior_dofs
	    do coarse_edge = 1, this%number_coarse_edges
	 if (coarse_edge>1) offcomponent_coarse_edge = offcomponent_coarse_edge + this%number_fine_edges_per_coarse_edge(coarse_edge-1)*this%order
	 
	 call x_old_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_old_local_edge )

	 call x_new_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_new_local_edge )
	 
	   ! Apply local change basis to built DoF
	   call Gt_times_x_old%create_and_allocate( this%order*this%number_fine_edges_per_coarse_edge(coarse_edge) ) 
       call this%change_basis_matrix%G(coarse_edge)%apply_transpose(x_old_local_edge, Gt_times_x_old)
       call x_new_local_edge%copy(Gt_times_x_old) 
	    
		call x_old_local_edge%free()
		call x_new_local_edge%free()
		call Gt_times_x_old%free()
	 end do 

 	  call x_old_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1, & 
								    this%number_interior_dofs + this%number_total_wire_dofs,    &
									x_old_local_Ec )
		  	  
	  call x_new_local%create_view( this%number_interior_dofs + 1,                              & 
								    this%number_interior_dofs + this%number_edge_wire_dofs,     &
									x_new_local_edge )
	  
	  call Bt_times_x_old%create_and_allocate(this%number_edge_wire_dofs)
	  call Bt_times_x_old%init(0.0_rp)
	  
	  ! Apply local change basis to built DoF 
      call this%change_basis_matrix%B%apply_transpose(x_old_local_Ec, Bt_times_x_old) 
	  call x_new_local_edge%axpby(1.0_rp, Bt_times_x_old, 1.0_rp) 

	  ! Assemble all local contributions to the full Q'*x product 
	  call x_new%comm() 
	  
	  call x_new_local_edge%free()
	  call x_old_local_Ec%free()
	  call Bt_times_x_old%free() 
	  	 	
end subroutine Hcurl_l1_apply_global_change_basis_transpose

subroutine Hcurl_l1_apply_inverse_local_change_basis(this, x_old_local, x_new_local) 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
type(serial_scalar_array_t)              , intent(in)     :: x_old_local
type(serial_scalar_array_t)              , intent(inout)  :: x_new_local

type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
type(serial_scalar_array_t)  :: B_times_x_new
type(serial_scalar_array_t)  :: inv_G_times_x_old  

! Direct solver data
type(direct_solver_t)        :: direct_solver 
integer                      :: FPLError
type(parameterlist_t)        :: parameter_list
integer                      :: iparm(64)
! Local auxiliar variables 
integer(ip) :: offcomponent_coarse_edge, coarse_edge

    iparm      = 0 ! Init all entries to zero	
	 ! Create direct solver to update iterates 
    call parameter_list%init()
    FPLError =            parameter_list%set(key = direct_solver_type     ,   value = pardiso_mkl)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type,   value = pardiso_mkl_uns)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level, value = 0)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm); assert(FPLError == 0)  
    call direct_solver%set_type_from_pl(parameter_list)
    call direct_solver%set_parameters_from_pl(parameter_list)
    call direct_solver%set_matrix(this%change_basis_matrix%G(1))
	
	 ! Apply local inverse to each Coarse Edge  
	 offcomponent_coarse_edge = this%number_interior_dofs 
     do coarse_edge = 1, this%number_coarse_edges
	 if (coarse_edge>1) offcomponent_coarse_edge = offcomponent_coarse_edge + this%number_fine_edges_per_coarse_edge(coarse_edge-1)*this%order
	 
	 call x_old_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_old_local_edge )

	 call x_new_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_new_local_edge )
	 
	    call inv_G_times_x_old%create_and_allocate(this%order*this%number_fine_edges_per_coarse_edge(coarse_edge)) 
		call inv_G_times_x_old%init(0.0_rp) 

	    call direct_solver%update_matrix( this%change_basis_matrix%G(coarse_edge), same_nonzero_pattern=.false.) 
        call direct_solver%solve( x_old_local_edge , inv_G_times_x_old )
		call x_new_local_edge%copy(inv_G_times_x_old)
		
		call x_old_local_edge%free()
		call x_new_local_edge%free()
		call inv_G_times_x_old%free()

	 end do 
	 call direct_solver%free() 
	 
	 ! Second part of the application:   	  
	  call x_new_local%create_view( this%number_interior_dofs + 1,                             & 
								    this%number_interior_dofs + this%number_edge_wire_dofs   , &
									x_new_local_edge )
	  
	  call x_new_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1 , & 
								    this%number_interior_dofs + this%number_total_wire_dofs    , &
									x_new_local_Ec )

	  call B_times_x_new%create_and_allocate( this%number_total_wire_dofs - this%number_edge_wire_dofs)
	  
	  ! Apply local change basis to built DoF 
		call this%change_basis_matrix%B%apply(x_new_local_edge, B_times_x_new)

	  ! Assign values to the vector associated to [E^c] in the new basis 
	  call x_new_local_Ec%axpby(-1.0_rp, B_times_x_new, 1.0_rp)

	  call x_new_local_edge%free()
	  call x_new_local_Ec%free() 
	  call B_times_x_new%free()
	  
end subroutine Hcurl_l1_apply_inverse_local_change_basis 

subroutine Hcurl_l1_apply_inverse_local_change_basis_transpose(this, x_new_local, x_old_local) 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
type(serial_scalar_array_t)              , intent(in)     :: x_new_local
type(serial_scalar_array_t)              , intent(inout)  :: x_old_local

type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
type(serial_scalar_array_t)  :: Bt_times_x_old
type(serial_scalar_array_t)  :: inv_Gt_application 

! Direct solver data
type(direct_solver_t)        :: direct_solver 
integer                      :: FPLError
type(parameterlist_t)        :: parameter_list
integer                      :: iparm(64)
! Local auxiliar variables 
integer(ip) :: offcomponent_coarse_edge, coarse_edge

 ! First step, do-nothing for the Ec part 

 ! Second step, apply local inverses transposed	  
      call x_old_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1  , & 
								    this%number_interior_dofs + this%number_total_wire_dofs     , &
									x_old_local_Ec )	  
		  
	  call x_old_local%create_view( this%number_interior_dofs + 1,                             & 
								    this%number_interior_dofs + this%number_edge_wire_dofs   , &
									x_old_local_edge )
	  	  
	  call Bt_times_x_old%create_and_allocate(this%number_edge_wire_dofs)
	  
	  ! Apply local change basis to built DoF 
	  call this%change_basis_matrix%B%apply_transpose(x_old_local_Ec, Bt_times_x_old)
	  ! Assign values to the vector associated to [E^c] in the new basis 
	  call x_old_local_edge%axpby(-1.0_rp, Bt_times_x_old, 1.0_rp)
	  
	  call x_old_local_edge%free()
	  call x_old_local_Ec%free()
	  call Bt_times_x_old%free()

	iparm      = 0 ! Init all entries to zero
    iparm(1)   = 1 ! no solver default
    iparm(2)   = 2 ! fill-in reordering from METIS
    iparm(8)   = 2 ! numbers of iterative refinement steps
    iparm(10)  = 8 ! perturb the pivot elements with 1E-8
    iparm(11)  = 1 ! use scaling 
	iparm(12)  = 2 ! Solve transposed system 
    iparm(13)  = 1 ! use maximum weighted matching algorithm 
    iparm(21)  = 1 ! 1x1 + 2x2 pivots
		
	 ! Create direct solver to update iterates 
    call parameter_list%init()
    FPLError =            parameter_list%set(key = direct_solver_type     ,   value = pardiso_mkl)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type,   value = pardiso_mkl_uns)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level, value = 0)
    FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm); assert(FPLError == 0)  
    call direct_solver%set_type_from_pl(parameter_list)
    call direct_solver%set_parameters_from_pl(parameter_list)
    call direct_solver%set_matrix(this%change_basis_matrix%G(1))
	
	 ! Apply local inverse to each Coarse Edge  
	 offcomponent_coarse_edge = this%number_interior_dofs 
     do coarse_edge = 1, this%number_coarse_edges
	 if (coarse_edge>1) offcomponent_coarse_edge = offcomponent_coarse_edge + this%number_fine_edges_per_coarse_edge(coarse_edge-1)*this%order
	 
	 call x_old_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_old_local_edge )

	 call x_new_local%create_view(offcomponent_coarse_edge + 1,                                                              & 
								  offcomponent_coarse_edge + this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
								  x_new_local_edge )
	 
	    call inv_Gt_application%create_and_allocate(this%order*this%number_fine_edges_per_coarse_edge(coarse_edge)) 
		call inv_Gt_application%init(0.0_rp) 
		
	    call direct_solver%update_matrix( this%change_basis_matrix%G(coarse_edge), same_nonzero_pattern=.false.) 
        call direct_solver%solve( x_new_local_edge , inv_Gt_application )
		call x_old_local_edge%copy(inv_Gt_application)
		
		call x_old_local_edge%free()
		call x_new_local_edge%free()
		call inv_Gt_application%free()
	 end do 
	 call direct_solver%free() 
	 	  
end subroutine Hcurl_l1_apply_inverse_local_change_basis_transpose 
! ---------------------------------------------------------------------------
!
!               Orientation for FINE edges in a COARSE Edge 
!
! ----------------------------------------------------------------------------
subroutine Hcurl_l1_set_orientation_and_sort_fine_edges( this, par_fe_space )
  ! This subroutine returns a permutation of fine edges (VEFS) contained in coarse edges such that they 
  ! are sorted following a path from the beginning to an end. The criteria to define origin and end of 
  ! the path is minimum in coordinates {x} ( recursive {y} {z} if needed). The path defines a unique 
  ! orientation for the coarse edge, local edges with different orientation are found through the process 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space

  type(fe_object_iterator_t)                :: object
  type(fe_vef_iterator_t)                   :: vef_within_object
  type(fe_vef_iterator_t)                   :: vertex 
  class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
  class(fe_iterator_t), allocatable         :: fe
  integer(ip)                               :: ivef_within_object, ivef_within_cell 
  integer(ip)                               :: vertex_within_cell_id
  integer(ip)                               :: vertex_within_edge_id
  integer(ip)                               :: coarse_edge, node_id
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  type(hash_table_ip_ip_t)                  :: nodes_visited 
  integer(ip)                               :: i, iedge, istat, inode, start_node, end_node 
  type(point_t)                             :: tangent_vector 
  type(point_t), allocatable                :: cell_coordinates(:)
  type(point_t), allocatable, target        :: node_coordinates(:,:) 
  type(point_t), pointer                    :: start_coords, end_coords
  integer(ip)                               :: dummy_val, found_nodes

    ! Initialize own data
  call memalloc(this%number_coarse_edges , maxval(this%number_fine_edges_per_coarse_edge ), this%perm_sorted_edges, __FILE__, __LINE__ ) 
  call memalloc(this%number_coarse_edges , maxval(this%number_fine_edges_per_coarse_edge ), this%tangent_size, __FILE__, __LINE__ ) 
  this%perm_sorted_edges = 0
  this%tangent_size      = 0.0_rp 
  call memalloc( this%number_coarse_edges, maxval(this%number_fine_edges_per_coarse_edge), 2, this%vertices_in_edge, __FILE__, __LINE__ )
  this%vertices_in_edge = 0
  allocate( this%coarse_edge_nodes_order(this%number_coarse_edges), stat=istat); check(istat==0) 
  
  ! Iterators creation 
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vertex) 
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  allocate(cell_coordinates( fe%cell%get_num_nodes() ) , stat=istat); check(istat==0) 
    
  coarse_edge = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then ! Only sort coarse edges
        coarse_edge = coarse_edge + 1
        call nodes_visited%init( this%number_fine_edges_per_coarse_edge(coarse_edge) + 1 )
		call this%coarse_edge_nodes_order(coarse_edge)%init( this%number_fine_edges_per_coarse_edge(coarse_edge)+1 )
        allocate( node_coordinates( this%number_fine_edges_per_coarse_edge(coarse_edge), 2 ), stat=istat)

        iedge = 0
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then    ! Only act if a fine edge has been found 
              iedge = iedge + 1
              call vef_within_object%get_cell_around(1,fe)       ! Do not care local or ghost 
              ref_fe_geo => fe%get_reference_fe_geo()
              ivef_within_cell          = fe%find_lpos_vef_lid(vef_within_object%get_lid())     
              vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
              vertices_of_line_iterator = vertices_of_line%create_iterator(ivef_within_cell)
              vertex_within_edge_id     = 1
			  
              do while( .not. vertices_of_line_iterator%is_upper_bound() )
                 vertex_within_cell_id = vertices_of_line_iterator%get_current()
                 call fe%get_vef(vertex_within_cell_id, vertex )
                 node_id = vertex%get_lid() 
                 call fe%cell%get_coordinates(cell_coordinates)		
                 ! Build hash table to identify start-end node 
                 call nodes_visited%put(key=node_id, val=1, stat=istat)
                 if (istat == was_stored) call nodes_visited%del(key=node_id, stat=istat) 
                 ! Store nodes in a list 
                 this%vertices_in_edge( coarse_edge, iedge, vertex_within_edge_id )  = node_id 
                 node_coordinates( iedge, vertex_within_edge_id)   = cell_coordinates(vertex_within_cell_id) 
                 if (vertex_within_edge_id == 2) then 
                    tangent_vector = node_coordinates(iedge,2) - node_coordinates(iedge,1)
                    this%tangent_size(coarse_edge, iedge) = tangent_vector%nrm2() 
                 end if
                 vertex_within_edge_id = vertex_within_edge_id + 1
                 call vertices_of_line_iterator%next() 
              end do
			  
           end if
        end do

		call this%define_coarse_edge_orientation( coarse_edge, start_node, end_node, nodes_visited, node_coordinates )	
		call this%build_fine_edges_oriented_path( coarse_edge, start_node )

        call nodes_visited%free()
        deallocate( node_coordinates, stat=istat);  check(istat==0)
     end if
     call object%next()
  end do
  
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(vertex)
  deallocate( cell_coordinates, stat=istat ); check(istat==0) 

end subroutine Hcurl_l1_set_orientation_and_sort_fine_edges

subroutine Hcurl_l1_define_coarse_edge_orientation( this, coarse_edge, start_node, end_node, nodes_visited, node_coordinates) 
   ! Define unique orientation for the edge, from the lowest x(i)_start --> x(i)_end recursively 
   ! A switch between the start and the end is performed if x(i)_start > x(i)_end 
implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout)   :: this
  integer(ip)                           , intent(in)      :: coarse_edge 
  integer(ip)                           , intent(inout)   :: start_node
  integer(ip)                           , intent(inout)   :: end_node 
  type(hash_table_ip_ip_t)              , intent(in)      :: nodes_visited 
  type(point_t), allocatable, target    , intent(in)      :: node_coordinates(:,:)
 
  integer(ip)                 :: found_nodes, iedge, inode, node_id
  integer(ip)                 :: buffer_node, dummy_val, istat 
  type(point_t), pointer      :: start_coords
  type(point_t), pointer      :: end_coords
  

        ! Return potential start-end node and assign direction (decide which one is the origin) 
        found_nodes = 0
        do while ( found_nodes < 2 ) 
           do iedge = 1,this%number_fine_edges_per_coarse_edge(coarse_edge)
              do inode = 1,2
                 node_id = this%vertices_in_edge(coarse_edge, iedge, inode)
                 call nodes_visited%get( key=node_id, val=dummy_val, stat=istat ) 
                 if (istat==key_found .and. found_nodes==0) then 
                    start_node = node_id; found_nodes = 1
                    start_coords => node_coordinates(iedge, inode)
                 elseif (istat==key_found .and. found_nodes==1) then 
                    end_node   = node_id; found_nodes = 2
                    end_coords => node_coordinates(iedge, inode) 
                 end if
              end do
           end do
        end do

          if  ( end_coords%get(1) < start_coords%get(1)  ) then 
           buffer_node=start_node; start_node = end_node; end_node=buffer_node;   
        elseif ( end_coords%get(1) == start_coords%get(1) ) then  
           if ( end_coords%get(2) < start_coords%get(2)  ) then 
              buffer_node=start_node; start_node = end_node; end_node=buffer_node; 
           elseif ( end_coords%get(2) == start_coords%get(2) ) then
              if ( end_coords%get(3) < start_coords%get(3) ) then 
                 buffer_node=start_node; start_node = end_node; end_node=buffer_node; 
              elseif ( end_coords%get(3) > start_coords%get(3) ) then
			     ! Do-nothing
			  else 
                 ! If {x,y,z-coords} are equal it must be the same point 
                 assert(.false.) 
              end if
           end if
        end if
	
end subroutine Hcurl_l1_define_coarse_edge_orientation

subroutine Hcurl_l1_build_fine_edges_oriented_path( this, coarse_edge, start_node ) 
implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  integer(ip)                           , intent(in)    :: coarse_edge 
  integer(ip)                           , intent(in)    :: start_node 
  
  type(hash_table_ip_ip_t)                  :: edges_visited 
  integer(ip)                               :: iedge, inode
  integer(ip)                               :: local_edge, istat
  integer(ip)                               :: following_node, orientation_index
  logical                                   :: following_edge_is_found 
  integer(ip), allocatable                  :: perm(:) 

        call memalloc( 2, perm, __FILE__, __LINE__ ) 
		perm(1) = 2; perm(2) = 1; 
		
        local_edge        = 0
        following_node    = 0
		orientation_index = 1 ! The GLOBAL EDGE orientation is fixed from START-->END  
		following_node    = start_node 
		call edges_visited%init( this%number_fine_edges_per_coarse_edge(coarse_edge) )
        do while (local_edge .ne. this%number_fine_edges_per_coarse_edge(coarse_edge) )
           following_edge_is_found = .false. 
           do iedge = 1,this%number_fine_edges_per_coarse_edge(coarse_edge)
              do inode = 1,2
                  if ( (this%vertices_in_edge(coarse_edge, iedge, inode) == following_node) ) then
				    call edges_visited%put( key=iedge, val=1, stat=istat) 
				    if (.not. istat == was_stored) then ! Edge has not been assigned yet and proceed
                    local_edge = local_edge + 1
                    this%perm_sorted_edges(coarse_edge, iedge ) = local_edge
                    ! Fine edge has changed orientation (start-end) and the sign must be adjusted 
                    if ( inode .ne. orientation_index ) this%tangent_size(coarse_edge, iedge) = -this%tangent_size(coarse_edge, iedge)  
                    following_edge_is_found = .true. 
					call this%coarse_edge_nodes_order(coarse_edge)%put( key=following_node, val=local_edge, stat=istat)
					following_node = this%vertices_in_edge(coarse_edge, iedge, perm(inode)) ; exit 
					end if 					
                 end if
              end do
              if (following_edge_is_found) exit 
           end do
        end do
		
		call edges_visited%free() 
		call memfree(perm, __FILE__, __LINE__) 
end subroutine Hcurl_l1_build_fine_edges_oriented_path

! -------------------------------------------------------------------------------------------
! 
!             Getters for DoFs in different numberings 
!
! -------------------------------------------------------------------------------------------
subroutine Hcurl_l1_get_wire_basis_dofs_from_vef(this, par_fe_space, vef, dof_list) 
implicit none 
! This function returns dofs associated to a local VEF in the local 
! wire numbering. Interface does not contain sets of consecutive dofs 
! on its vefs, extract one-by-one info 
class(Hcurl_l1_coarse_fe_handler_t)           , intent(in)       :: this
type(par_fe_space_t)                          , intent(in)       :: par_fe_space 
type(fe_vef_iterator_t)                       , intent(in)       :: vef
integer(ip),  allocatable                     , intent(inout)    :: dof_list(:)

class(fe_iterator_t) , allocatable     :: fe
type(list_iterator_t)                  :: own_dofs_on_vef_iterator 
integer(ip)                            :: field_id, ivef_within_cell 
integer(ip)            , pointer       :: elem2dof(:)
integer(ip)                            :: start_dof, end_dof, idof, dof_lid
	 
     field_id = 1
	 idof     = 0
     call par_fe_space%create_fe_iterator(fe) 
	 
     call vef%get_cell_around(1,fe)
     call fe%get_field_elem2dof(field_id, elem2dof)
     ivef_within_cell = fe%find_lpos_vef_lid( vef%get_lid() )
     own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
     
	 dof_list = 0
	 do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
	    idof = idof + 1
		dof_list(idof) = elem2dof(own_dofs_on_vef_iterator%get_current()) - this%number_interior_dofs
        call own_dofs_on_vef_iterator%next()
      end do

	 call par_fe_space%free_fe_iterator(fe) 
end subroutine Hcurl_l1_get_wire_basis_dofs_from_vef

function Hcurl_l1_get_dof_list_new_basis(this, coarse_edge, fine_edge) result( dof_list ) 
! This function returns the list of dofs associated to the new basis in the fine_edge-th edge (sorted from one origin)
! of the coarse_edge-th Edge of the subdomain. 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip)                                   , intent(in)       :: fine_edge 
integer(ip),  pointer                                            :: dof_list(:) 

integer(ip) :: start_dof, end_dof 

assert( coarse_edge .le. this%number_coarse_edges ) 
assert( fine_edge .le. this%number_fine_edges_per_coarse_edge(coarse_edge) )

! Consecutive number for Nodal Lagrangian DOFs in a coarse EDGE
if (this%perm_sorted_edges(coarse_edge, fine_edge)==1 ) then 
start_dof = 1
end_dof   = this%order
elseif (this%perm_sorted_edges(coarse_edge, fine_edge)==this%number_fine_edges_per_coarse_edge(coarse_edge) ) then 
start_dof = this%order + (this%perm_sorted_edges(coarse_edge, fine_edge)-2)*this%order
end_dof   = start_dof + this%order-1
else 
start_dof = this%order + (this%perm_sorted_edges(coarse_edge, fine_edge)-2)*this%order
end_dof   = start_dof + this%order
end if

dof_list => this%dofs_new_basis(start_dof:end_dof) 

end function Hcurl_l1_get_dof_list_new_basis

function Hcurl_l1_get_new_basis_dof_from_node_id(this, coarse_edge, node_id ) result(dof_in_new_basis) 
! Taking the node_id for an interior vertex of a Coarse Edge, it returns its associated 
! DOF in the new basis numbering 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip)                                   , intent(in)       :: node_id 
integer(ip)      :: dof_in_new_basis 

integer(ip)      :: pos_in_edge, i, order, istat 

! Get local ordering in coarse edge 
call this%coarse_edge_nodes_order(coarse_edge)%get( key=node_id, val=pos_in_edge, stat=istat);

! Locate local DOF depending on locar basis order ( sorted START-END ) 
dof_in_new_basis = (pos_in_edge-1)*this%order

! Put it on the new basis Dof list with other Coarse Edges in the subdomain 
do i=1, coarse_edge-1 
dof_in_new_basis = dof_in_new_basis + this%order*this%number_fine_edges_per_coarse_edge(i) 
end do 

end function Hcurl_l1_get_new_basis_dof_from_node_id

! ----------------------------------------------------------------------------------
! 
!             Sorted fine edges logical getters
! 
! ----------------------------------------------------------------------------------
function Hcurl_l1_is_first_edge(this, coarse_edge, fine_edge) result( is_first_edge ) 
! This function asks for first edge in the sorted fine edges chain 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip)                                   , intent(in)       :: fine_edge 
logical      :: is_first_edge

is_first_edge = .false. 
if (this%perm_sorted_edges(coarse_edge, fine_edge) == 1) is_first_edge = .true. 
end function Hcurl_l1_is_first_edge

function Hcurl_l1_is_last_edge(this, coarse_edge, fine_edge) result( is_last_edge ) 
! This function asks for last Edge in the sorted fine edges chain 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip)                                   , intent(in)       :: fine_edge 
logical      :: is_last_edge

is_last_edge = .false. 
if (this%perm_sorted_edges(coarse_edge, fine_edge) & 
	 == this%number_fine_edges_per_coarse_edge(coarse_edge) ) is_last_edge = .true. 
end function Hcurl_l1_is_last_edge

! ----------------------------------------------------------------------------------
!
!                      Delegated from par_fe_space 
! 
! ----------------------------------------------------------------------------------
subroutine Hcurl_l1_renumber_interface_dofs_first_E_then_Ec(this, par_fe_space, iblock, perm_old2new) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)     , intent(inout)  :: this
  type(par_fe_space_t)                    , intent(in)     :: par_fe_space 
  integer(ip)                             , intent(in)     :: iblock 
  integer(ip) , allocatable               , intent(inout)  :: perm_old2new(:)

  class(fe_iterator_t), allocatable      :: fe
  integer(ip)                            :: field_id
  class(reference_fe_t), pointer         :: reference_fe 
  integer(ip)                            :: idof, current_dof  
  integer(ip)         , allocatable      :: perm_new2wire(:)

  field_id = par_fe_space%field_blocks(iblock)  
  call par_fe_space%create_fe_iterator(fe)
  reference_fe => fe%get_reference_fe(field_id)
  this%order = fe%get_order(field_id) 

  assert( reference_fe%get_number_dimensions()==3 ) 

  call memalloc ( par_fe_space%number_dofs_per_block(iblock), perm_new2wire, __FILE__, __LINE__ ) 
  perm_new2wire = 0

  current_dof = 1
  do idof = 1, par_fe_space%get_block_number_interior_dofs(iblock) 
     perm_new2wire(idof) = current_dof  
     current_dof = current_dof + 1
  end do
  this%number_interior_dofs = current_dof - 1
 
  call this%fill_dofs_in_coarse_edges_renumbering( current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire ) 
  this%number_edge_wire_dofs = (current_dof-1) - this%number_interior_dofs

  call this%fill_dofs_coupled_to_coarse_edges_renumbering( current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire )
  this%number_total_wire_dofs = (current_dof-1) - this%number_interior_dofs

  ! Last, remaining interface dofs that are not coupled to edges are filled 
  do idof = 1, par_fe_space%get_block_number_dofs(iblock)
     if (perm_new2wire(idof) == 0) then 
        perm_new2wire(idof) = current_dof   
        current_dof = current_dof + 1
     end if
  end do

  ! By composition of permutations, perm_old2wire = perm_new2wire(perm_old2new)
  do idof=1, par_fe_space%get_block_number_dofs(iblock) 
     perm_old2new(idof) = perm_new2wire(perm_old2new(idof))
  end do

  call par_fe_space%free_fe_iterator(fe)
  call memfree(perm_new2wire, __FILE__, __LINE__)

end subroutine Hcurl_l1_renumber_interface_dofs_first_E_then_Ec

subroutine Hcurl_l1_fill_dofs_in_coarse_edges_renumbering( this, current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)       , intent(inout)  :: this
  integer(ip)                               , intent(inout)  :: current_dof 
  integer(ip)                               , intent(in)     :: iblock 
  type(par_fe_space_t)                      , intent(in)     :: par_fe_space 
  integer(ip) , allocatable                 , intent(inout)  :: perm_old2new(:)
  integer(ip) , allocatable                 , intent(inout)  :: perm_new2wire(:) 

  ! Iterators 
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef_within_object, vef_within_cell 
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 

  integer(ip)            , pointer       :: elem2dof(:)
  integer(ip)                            :: field_id, ielem
  integer(ip)                            :: ivef_within_cell, ivef_within_object
  integer(ip)                            :: ivef_within_edge_adjacent_cell
  integer(ip)                            :: idof, istat

  ! Edge sorting related variables 
  type(fe_vef_iterator_t)                   :: vertex 
  class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  integer(ip)                               :: vertex_within_cell_id, vertex_within_edge_id 
  integer(ip) , allocatable                 :: vertices_in_edge(:,:) 
  type(hash_table_ip_ip_t)                  :: nodes_visited 
  integer(ip)                               :: start_node, end_node
  type(point_t), allocatable                :: cell_coordinates(:)
  type(point_t), allocatable, target        :: node_coordinates(:,:) 
  integer(ip)                               :: fine_edge, node_id, num_fine_edges 
  integer(ip)  , allocatable                :: perm_sorted_edges(:) 
  logical      , allocatable                :: follows_coarse_edge_orientation(:)  
  integer(ip)                               :: starting_dof, dofs_per_edge, dofs_in_vef_counter


  field_id = par_fe_space%field_blocks(iblock)  
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call par_fe_space%create_fe_vef_iterator(vef_within_cell)
  call par_fe_space%create_fe_vef_iterator(vertex)

  allocate(cell_coordinates( fe%cell%get_num_nodes() ) , stat=istat); check(istat==0) 

  this%number_coarse_edges = 0	 
  ! In a first loop we add all DOFs belonging to COARSE EDGES (E)
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
        this%number_coarse_edges = this%number_coarse_edges + 1
        num_fine_edges = object%get_num_vefs()/2
        ! To assign number of fine edges within coarse edge 
        call memalloc( num_fine_edges, 2, vertices_in_edge, __FILE__, __LINE__ )
        call nodes_visited%init( num_fine_edges )
        allocate( node_coordinates( num_fine_edges, 2 ), stat=istat)

        fine_edge = 0
        do ivef_within_object=1, object%get_num_vefs()

           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then  ! Only act if a fine edge has been found 
              fine_edge = fine_edge + 1
              call vef_within_object%get_cell_around(1,fe) 

              ! Build hash table to identify potential start-end node 
              ref_fe_geo                => fe%get_reference_fe_geo()
              vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
              ivef_within_cell          = fe%find_lpos_vef_lid(vef_within_object%get_lid())     
              vertices_of_line_iterator = vertices_of_line%create_iterator(ivef_within_cell)
              vertex_within_edge_id     = 1
              do while( .not. vertices_of_line_iterator%is_upper_bound() )
                 vertex_within_cell_id = vertices_of_line_iterator%get_current()
                 call fe%get_vef(vertex_within_cell_id, vertex )
                 node_id = vertex%get_lid() 
                 call fe%cell%get_coordinates(cell_coordinates)		
                 call nodes_visited%put(key=node_id, val=1, stat=istat)
                 if (istat == was_stored) call nodes_visited%del(key=node_id, stat=istat) 
                 ! Store nodes in a list 
                 vertices_in_edge( fine_edge, vertex_within_edge_id )  = node_id 
                 node_coordinates( fine_edge, vertex_within_edge_id)   = cell_coordinates(vertex_within_cell_id) 
                 vertex_within_edge_id = vertex_within_edge_id + 1
                 call vertices_of_line_iterator%next() 
              end do
           end if
        end do
        assert( fine_edge == num_fine_edges ) 

        ! Here I can already sort the EDGE, all related info to coarse edge is found 
        call memalloc( fine_edge, perm_sorted_edges, __FILE__, __LINE__ ) 
        call memalloc( fine_edge, follows_coarse_edge_orientation, __FILE__, __LINE__ ) 
        call this%set_coarse_edge_orientation( fine_edge, start_node, end_node, nodes_visited, vertices_in_edge, node_coordinates )	
        call this%sort_fine_edges_within_coarse_edge( fine_edge, start_node, vertices_in_edge, perm_sorted_edges, follows_coarse_edge_orientation )

        ! Assign local-edge sorted DoF numbering  
        fine_edge     = 0
        starting_dof  = current_dof 
        dofs_per_edge = this%order 
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then  ! Only act if a fine edge has been found 
              fine_edge = fine_edge + 1		  
              call vef_within_object%get_cell_around(1,fe) 
              call fe%get_field_elem2dof(field_id, elem2dof)
              ivef_within_cell = fe%find_lpos_vef_lid(vef_within_object%get_lid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              dofs_in_vef_counter = 0
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )			     
                 idof    = own_dofs_on_vef_iterator%get_current()
                 if (perm_new2wire(perm_old2new(elem2dof(idof))) .eq. 0) then
                    dofs_in_vef_counter = dofs_in_vef_counter + 1
                    if ( follows_coarse_edge_orientation(fine_edge) ) then 
                       perm_new2wire(perm_old2new(elem2dof(idof))) = starting_dof + dofs_per_edge*( perm_sorted_edges(fine_edge) - 1 ) + (dofs_in_vef_counter-1)  
                    elseif ( .not. follows_coarse_edge_orientation(fine_edge) ) then 
                       perm_new2wire(perm_old2new(elem2dof(idof))) = starting_dof + dofs_per_edge*( perm_sorted_edges(fine_edge) - 1 ) + (dofs_per_edge - dofs_in_vef_counter)
                    end if
                    current_dof = current_dof + 1
                 end if
                 call own_dofs_on_vef_iterator%next()
              end do
           end if
        end do

        call nodes_visited%free()
        deallocate( node_coordinates, stat=istat);  check(istat==0)
        call memfree( vertices_in_edge, __FILE__, __LINE__ )
        call memfree( perm_sorted_edges, __FILE__, __LINE__ )
        call memfree( follows_coarse_edge_orientation, __FILE__, __LINE__ )
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_vef_iterator(vef_within_cell)
  call par_fe_space%free_fe_vef_iterator(vertex)

end subroutine Hcurl_l1_fill_dofs_in_coarse_edges_renumbering

subroutine Hcurl_l1_fill_dofs_coupled_to_coarse_edges_renumbering( this, current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)       , intent(inout)  :: this
  integer(ip)                               , intent(inout)  :: current_dof 
  integer(ip)                               , intent(in)     :: iblock 
  type(par_fe_space_t)                      , intent(in)     :: par_fe_space 
  integer(ip) , allocatable                 , intent(inout)  :: perm_old2new(:)
  integer(ip) , allocatable                 , intent(inout)  :: perm_new2wire(:) 

  ! Iterators 
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef_within_object, vef_within_cell 
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 

  integer(ip),  pointer       :: elem2dof(:)
  integer(ip) :: field_id 
  integer(ip) :: iedge_coarse, ielem  
  integer(ip) :: idof, istat
  integer(ip) :: ivef_within_object, ivef_within_cell 
  integer(ip) :: ivef_within_edge_adjacent_cell 

  field_id = par_fe_space%field_blocks(iblock)  
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call par_fe_space%create_fe_vef_iterator(vef_within_cell)

  ! Save information about the visited vefs 
  call this%coupled_vefs_added%init(this%number_edge_wire_dofs/this%order)
  call memalloc( this%number_coarse_edges, this%number_fine_edges_per_coarse_edge, __FILE__, __LINE__ )
  this%number_fine_edges_per_coarse_edge = 0

  iedge_coarse = 0   
  call object%first() 
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
        iedge_coarse = iedge_coarse + 1
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object,vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then ! Only check edge-container elements 
              call this%coupled_vefs_added%put( key=vef_within_object%get_lid(), val=1, stat=istat)
              this%number_fine_edges_per_coarse_edge( iedge_coarse ) = this%number_fine_edges_per_coarse_edge( iedge_coarse ) + 1
              ! Take local fes 
              do ielem = 1, vef_within_object%get_num_cells_around() 
                 call vef_within_object%get_cell_around(ielem,fe)
                 if ( fe%is_local() ) then 
                    ! Loop over all vefs on fe and count the interface dofs, vefs_in_cell all vefs in the cell containing vef_in_object 	   
                    do ivef_within_edge_adjacent_cell=1, fe%get_num_vefs()
                       call fe%get_vef(ivef_within_edge_adjacent_cell, vef_within_cell )
                       if ( vef_within_cell%is_at_interface() ) then ! Only interested in interface wire numbering 
                          call fe%get_field_elem2dof(field_id, elem2dof)
                          ivef_within_cell = fe%find_lpos_vef_lid(vef_within_cell%get_lid())
                          own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
                          ! Loop over interface dofs contained in the interface vef and assign numbering 
                          do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                             idof    = own_dofs_on_vef_iterator%get_current()
                             if (elem2dof(idof)>0) then 
                                if ( perm_new2wire(perm_old2new(elem2dof(idof))) .eq. 0 ) then
                                   perm_new2wire(perm_old2new(elem2dof(idof))) = current_dof 
                                   current_dof = current_dof + 1
                                end if
                             end if
                             call own_dofs_on_vef_iterator%next()
                          end do

                       end if
                    end do
                 end if
              end do

           end if
        end do
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_vef_iterator(vef_within_cell)

end subroutine Hcurl_l1_fill_dofs_coupled_to_coarse_edges_renumbering

subroutine Hcurl_l1_set_coarse_edge_orientation( number_fine_edges, start_node, end_node, nodes_visited, vertices_in_edge, node_coordinates) 
  ! Define unique orientation for the edge, from the lowest x(i)_start --> x(i)_end recursively 
  ! A switch between the start and the end is performed if x(i)_start > x(i)_end 
  implicit none 
  integer(ip)                           , intent(in)      :: number_fine_edges 
  integer(ip)                           , intent(inout)   :: start_node
  integer(ip)                           , intent(inout)   :: end_node 
  type(hash_table_ip_ip_t)              , intent(in)      :: nodes_visited 
  integer(ip)  , allocatable            , intent(in)      :: vertices_in_edge(:,:)
  type(point_t), allocatable, target    , intent(in)      :: node_coordinates(:,:)

  integer(ip)                 :: found_nodes, iedge, inode, node_id
  integer(ip)                 :: buffer_node, dummy_val, istat 
  type(point_t), pointer      :: start_coords
  type(point_t), pointer      :: end_coords

  ! Return potential start-end node and assign direction (decide which one is the origin) 
  found_nodes = 0
  do while ( found_nodes < 2 ) 
     do iedge = 1, number_fine_edges
        do inode = 1,2
           node_id = vertices_in_edge( iedge, inode)
           call nodes_visited%get( key=node_id, val=dummy_val, stat=istat ) 
           if (istat==key_found .and. found_nodes==0) then 
              start_node = node_id; found_nodes = 1
              start_coords => node_coordinates(iedge, inode)
           elseif (istat==key_found .and. found_nodes==1) then 
              end_node   = node_id; found_nodes = 2
              end_coords => node_coordinates(iedge, inode) 
           end if
        end do
     end do
  end do

  if  ( end_coords%get(1) < start_coords%get(1)  ) then 
     buffer_node=start_node; start_node = end_node; end_node=buffer_node;   
  elseif ( end_coords%get(1) == start_coords%get(1) ) then  
     if ( end_coords%get(2) < start_coords%get(2)  ) then 
        buffer_node=start_node; start_node = end_node; end_node=buffer_node; 
     elseif ( end_coords%get(2) == start_coords%get(2) ) then
        if ( end_coords%get(3) < start_coords%get(3) ) then 
           buffer_node=start_node; start_node = end_node; end_node=buffer_node; 
        elseif ( end_coords%get(3) > start_coords%get(3) ) then
           ! Do-nothing
        else 
           ! If {x,y,z-coords} are equal it must be the same point 
           assert(.false.) 
        end if
     end if
  end if

end subroutine Hcurl_l1_set_coarse_edge_orientation

subroutine Hcurl_l1_sort_fine_edges_within_coarse_edge( number_fine_edges, start_node, vertices_in_edge, perm_sorted_fine_edges, follows_coarse_edge_orientation ) 
  implicit none 
  integer(ip)                           , intent(in)      :: number_fine_edges 
  integer(ip)                           , intent(in)      :: start_node 
  integer(ip)  , allocatable            , intent(in)      :: vertices_in_edge(:,:)
  integer(ip)  , allocatable            , intent(inout)   :: perm_sorted_fine_edges(:)
  logical      , allocatable            , intent(inout)   :: follows_coarse_edge_orientation(:) 

  type(hash_table_ip_ip_t)                  :: edges_visited 
  integer(ip)                               :: iedge, inode
  integer(ip)                               :: local_edge, istat
  integer(ip)                               :: following_node, orientation_index
  logical                                   :: following_edge_is_found 
  integer(ip), allocatable                  :: perm(:) 

  call memalloc( 2, perm, __FILE__, __LINE__ ) 
  perm(1) = 2; perm(2) = 1; 

  local_edge        = 0
  following_node    = 0
  orientation_index = 1 ! The GLOBAL EDGE orientation is fixed from START-->END  
  following_node    = start_node 
  follows_coarse_edge_orientation = .true. 
  call edges_visited%init( number_fine_edges )
  do while (local_edge .ne. number_fine_edges )
     following_edge_is_found = .false. 
     do iedge = 1,number_fine_edges
        do inode = 1,2
           if ( (vertices_in_edge( iedge, inode) == following_node) ) then
              call edges_visited%put( key=iedge, val=1, stat=istat) 
              if (.not. istat == was_stored) then ! Edge has not been assigned yet and proceed
                 local_edge = local_edge + 1
                 perm_sorted_fine_edges( iedge ) = local_edge
                 ! Fine edge has changed orientation (start-end) and the sign must be adjusted 
                 if ( inode .ne. orientation_index ) follows_coarse_edge_orientation(iedge) = .false. 
                 following_edge_is_found = .true. 
                 following_node = vertices_in_edge(iedge, perm(inode)) ; exit 
              end if
           end if
        end do
        if (following_edge_is_found) exit 
     end do
  end do

  call edges_visited%free() 
  call memfree(perm, __FILE__, __LINE__) 
end subroutine Hcurl_l1_sort_fine_edges_within_coarse_edge
