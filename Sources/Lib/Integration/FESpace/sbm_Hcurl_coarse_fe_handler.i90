! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
subroutine Hcurl_l1_free( this ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  integer(ip) :: coarse_edge, istat 

  ! Free local change basis matrices 
  do coarse_edge=1, this%subedges_per_coarse_edge%get_size() 
     call this%change_basis_matrix%G(coarse_edge)%free() 
  end do
  call this%change_basis_matrix%B%free()
  if (allocated(this%change_basis_matrix%G))              deallocate(this%change_basis_matrix%G, stat=istat); check(istat==0); 

  call this%fine_edge_direction%free() 
  call this%subedges_per_coarse_edge%free() 	
  call this%sorted_fine_edges_in_coarse_subedge%free()

end subroutine Hcurl_l1_free

subroutine Hcurl_l1_get_num_coarse_dofs(this, par_fe_space, parameter_list, num_coarse_dofs)
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  integer(ip)                           , intent(inout) :: num_coarse_dofs(:)

  integer(ip)                            :: field_id
  type(environment_t), pointer           :: par_environment
  type(fe_object_iterator_t)             :: object
  integer(ip)                            :: coarse_edge 

  type(list_iterator_t)     :: coarse_subedge_iterator
  integer(ip)               :: edge_continuity_algorithm 
  integer(ip)               :: number_fine_edges_in_subedge 

  par_environment => par_fe_space%get_par_environment()
  assert ( associated ( par_environment ) )
  assert ( par_environment%am_i_l1_task() )
  assert ( size(num_coarse_dofs) == par_fe_space%get_number_fe_objects() )

  ! To think where field_id should come from? Temporarily let us assume that we have
  ! a single-field PDE problem
  field_id = 1
  num_coarse_dofs = 0
  call par_fe_space%create_fe_object_iterator(object)

  call this%get_BDDC_edge_continuity_algorithm_case( parameter_list, edge_continuity_algorithm ) 

  coarse_edge = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() .eq. 1 ) then     
        coarse_edge = coarse_edge + 1       
        coarse_subedge_iterator =  this%subedges_per_coarse_edge%create_iterator(coarse_edge) 

        do while ( .not. coarse_subedge_iterator%is_upper_bound() )
           number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )
 
           select case ( edge_continuity_algorithm ) 
           case (tangential_average) 
              num_coarse_dofs(object%get_lid()) = num_coarse_dofs(object%get_lid()) + 1
           case (tangential_average_and_first_order_moment) 
              if ( number_fine_edges_in_subedge == 1 .and. this%order == 1) then 
                 num_coarse_dofs(object%get_lid()) = num_coarse_dofs(object%get_lid()) + 1 
              else 
                 num_coarse_dofs(object%get_lid()) = num_coarse_dofs(object%get_lid()) + 2 
              end if
           case (all_dofs_in_coarse_edges) 
              num_coarse_dofs(object%get_lid()) = num_coarse_dofs(object%get_lid()) + this%order*number_fine_edges_in_subedge   
           end select
		   
           call coarse_subedge_iterator%next()
        end do

		end if
		 
     call object%next()
  end do
 
  call par_fe_space%free_fe_object_iterator(object)
end subroutine Hcurl_l1_get_num_coarse_dofs

subroutine Hcurl_l1_setup_constraint_matrix(this, par_fe_space, parameter_list, constraint_matrix) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  type(coo_sparse_matrix_t)             , intent(inout) :: constraint_matrix
  type(environment_t), pointer           :: par_environment
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_coarse_dofs_iterator
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 
  integer(ip) :: field_id
  integer(ip) :: num_rows, num_cols
  integer(ip) ::  ivef_within_cell, ivef_within_object, idof, dof_lid, coarse_dof_lid
  integer(ip)            , pointer     :: elem2dof(:)

  integer(ip)                    :: edge_continuity_algorithm 
  type(serial_scalar_array_t)    :: first_moment_constraint_in_edges 
  real(rp), pointer              :: first_moment_constraint_in_edges_entries(:)
  integer(ip)                    :: coarse_edge, fine_edge, icdof, vef_local_dof 
  real(rp)                       :: edge_length, sign_factor 

  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: number_fine_edges_in_subedge 
  integer(ip)               :: orientation, istat  
  integer(ip)               :: isubedge_coarse

  par_environment => par_fe_space%get_par_environment()
  assert (associated(par_environment))
  assert (par_environment%am_i_l1_task())

  ! To-think where field_id should come from? Temporarily let us assume that we have
  ! a single-field PDE problem
  field_id = 1

  call this%get_BDDC_edge_continuity_algorithm_case( parameter_list, edge_continuity_algorithm ) 
  if ( edge_continuity_algorithm == tangential_average_and_first_order_moment ) then 
     call this%compute_first_order_moment_in_edges(par_fe_space, first_moment_constraint_in_edges)
     first_moment_constraint_in_edges_entries => first_moment_constraint_in_edges%get_entries()
  end if

  ! Free any dynamic memory that constraint_matrix may have inside
  call constraint_matrix%free()
  num_rows = par_fe_space%number_dofs_per_field(field_id)
  num_cols = par_fe_space%ptr_coarse_dofs_per_field(field_id+1)- &
       par_fe_space%ptr_coarse_dofs_per_field(field_id) 

  ! Create constraint matrix (transposed)
  call constraint_matrix%create ( num_rows, num_cols )

  ! Fill constraint matrix entries (transposed)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vef)

  coarse_edge = 0
  isubedge_coarse = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dimension () == 1) then
        coarse_edge = coarse_edge + 1

		own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(field_id)	
		if (.not. own_coarse_dofs_iterator%is_upper_bound() ) coarse_dof_lid = own_coarse_dofs_iterator%get_current()
		
		coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator(coarse_edge)       		
        do while ( .not. coarse_subedge_iterator%is_upper_bound() ) 
			
           isubedge_coarse = isubedge_coarse + 1
           fine_edge = 0
           fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator( coarse_subedge_iterator%get_current() ) 
           number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

           do while ( .not. fine_edge_iterator%is_upper_bound() ) 
              call vef%set_lid( fine_edge_iterator%get_current() )
              fine_edge = fine_edge + 1; sign_factor = 1.0_rp
              edge_length = this%compute_edge_length(par_fe_space, vef)
              
              call this%fine_edge_direction%get(key=fine_edge_iterator%get_current(), val=orientation, stat=istat); check(istat==key_found)
              if ( orientation == opposite_to_coarse_edge ) sign_factor = -sign_factor

              call vef%get_cell_around(1,fe)
              call fe%get_field_elem2dof(field_id, elem2dof)
              ivef_within_cell = fe%find_lpos_vef_lid(vef%get_lid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              vef_local_dof = 0
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof          = own_dofs_on_vef_iterator%get_current()
                 dof_lid       = elem2dof(idof)
                 if ( dof_lid > 0 ) then

                    select case ( edge_continuity_algorithm ) 
                    case (tangential_average) 
                       call constraint_matrix%insert(dof_lid, coarse_dof_lid, sign_factor )	
                    case (tangential_average_and_first_order_moment) 					  
                       call constraint_matrix%insert(dof_lid, coarse_dof_lid, sign_factor )	
                       if ( (number_fine_edges_in_subedge .gt. 1) .or. (this%order .gt. 1) ) then 
                          call constraint_matrix%insert(dof_lid, coarse_dof_lid+1, -first_moment_constraint_in_edges_entries(dof_lid) )	
                       end if
                    case (all_dofs_in_coarse_edges) 
                       icdof = this%order*( fine_edge - 1 ) + vef_local_dof 
                       call constraint_matrix%insert(dof_lid, coarse_dof_lid+icdof, 1.0_rp )	
                    end select

                    vef_local_dof = vef_local_dof + 1
                 end if

                 call own_dofs_on_vef_iterator%next()
              end do
              call fine_edge_iterator%next() 
           end do

           select case ( edge_continuity_algorithm ) 
           case (tangential_average) 
              coarse_dof_lid = coarse_dof_lid + 1
           case (tangential_average_and_first_order_moment) 					  
              coarse_dof_lid = coarse_dof_lid + 1
              if ( (number_fine_edges_in_subedge .gt. 1) .or. (this%order .gt. 1) ) coarse_dof_lid = coarse_dof_lid + 1
           case (all_dofs_in_coarse_edges) 
              coarse_dof_lid = coarse_dof_lid + this%order*number_fine_edges_in_subedge
           end select

           call coarse_subedge_iterator%next() 
        end do
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef)
  call constraint_matrix%sort_and_compress() 
  if ( edge_continuity_algorithm == tangential_average_and_first_order_moment )  call first_moment_constraint_in_edges%free() 
  
end subroutine Hcurl_l1_setup_constraint_matrix

subroutine Hcurl_l1_apply_weighting_operator_and_comm(this, W, x, y) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  real(rp),            allocatable,       intent(in)    :: W(:) 
  type(par_scalar_array_t)  , intent(inout) :: x
  type(par_scalar_array_t)  , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_local
  type(serial_scalar_array_t), pointer :: y_local
  real(rp), pointer :: x_local_entries(:)
  real(rp), pointer :: y_local_entries(:)

  x_local         => x%get_serial_scalar_array()
  x_local_entries => x_local%get_entries()
  y_local         => y%get_serial_scalar_array()
  y_local_entries => y_local%get_entries()

  call this%apply_inverse_local_change_basis( x_local, x_local )
  y_local_entries = x_local_entries*W 
  call y%comm()
  call this%apply_global_change_basis( y, y )

end subroutine Hcurl_l1_apply_weighting_operator_and_comm

subroutine Hcurl_l1_apply_transpose_weighting_operator(this, W, x, y) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  real(rp),            allocatable,       intent(in)    :: W(:) 
  type(par_scalar_array_t)  , intent(inout) :: x
  type(par_scalar_array_t)  , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_local
  type(serial_scalar_array_t), pointer :: y_local
  real(rp), pointer :: x_local_entries(:)
  real(rp), pointer :: y_local_entries(:)

  x_local         => x%get_serial_scalar_array()
  x_local_entries => x_local%get_entries()
  y_local         => y%get_serial_scalar_array()
  y_local_entries => y_local%get_entries()

  call this%apply_global_change_basis_transpose( x, x ) 
  y_local_entries = x_local_entries*W 
  call this%apply_inverse_local_change_basis_transpose( y_local, y_local )  

end subroutine Hcurl_l1_apply_transpose_weighting_operator
! -------------------------------------------------------------------------------------------------
!
!                                 Non overriding procedures 
!
! -------------------------------------------------------------------------------------------------
subroutine Hcurl_l1_compute_change_basis_matrix(this, par_fe_space)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(inout) :: par_fe_space

  type(environment_t), pointer   :: p_env
  real(rp) , allocatable         :: edge_elmat(:,:)

  p_env => par_fe_space%get_par_environment() 

  if ( p_env%am_I_l1_task() ) then 
     call this%compute_edge_discrete_gradient_elmat(par_fe_space, edge_elmat)  
     call this%fill_edge_local_change_of_basis(par_fe_space, edge_elmat)
     call this%fill_edge_coupled_to_edges_local_change_of_basis(par_fe_space, edge_elmat)
     if ( this%order > 1 ) call this%fill_face_coupled_to_edges_local_change_of_basis(par_fe_space) 

     call this%change_basis_matrix%B%convert(csr_format) 
     ! call this%change_basis_matrix%B%print_matrix_market(6)
     call memfree(edge_elmat, __FILE__, __LINE__ ) 
  end if

end subroutine Hcurl_l1_compute_change_basis_matrix

subroutine Hcurl_l1_compute_edge_discrete_gradient_elmat(this, par_fe_space, elmat)
  ! This subroutine computes the elemental 1D Discrete Gradient (phi',phi)_e matrix in a 
  ! reference edge. As the integration to be performed is not edge size-dependent Elemental 
  ! matrix in edges can be re-used for every edge just taking into acount the tangent direction.  
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(inout) :: elmat(:,:) 

  ! Local variables required by Wire edges moments integration
  class(reference_fe_t), pointer         :: ref_fe 
  type(hex_lagrangian_reference_fe_t)    :: fe_1D, fe_1D_reduced_order
  type(hex_nedelec_reference_fe_t)       :: fe 
  type(quadrature_t)                     :: edge_quadrature
  type(interpolation_t)                  :: interpolation_1D, interpolation_1D_reduced_order 
  real(rp)                               :: shape_test, factor 
  type(vector_field_t)                   :: grad_shape_trial 
  integer(ip)                            :: ishape, jshape, qpoint 
  integer(ip)                            :: field_id 

  field_id = 1
  ref_fe => par_fe_space%get_reference_fe(field_id) 

  ! Create a 1D scalar lagrangian reference FE of order k
  call fe_1D%create(topology          = topology_hex,          &
                    number_dimensions = 1,                     &
                    order             = ref_fe%get_order(),    &
                    field_type        = field_type_scalar,     &
                    continuity        = .true. )

  ! Create a 1D scalar lagrangian reference FE of order k-1
  call fe_1D_reduced_order%create(topology          = topology_hex,           &
                                  number_dimensions = 1,                      &
                                  order             = ref_fe%get_order()-1,   &
                                  field_type        = field_type_scalar,      &
                                  continuity        = .true. )

  ! Create a dim-D scalar hex lagrangian reference FE of order k
  call fe%create(topology          = topology_hex,                     &
                 number_dimensions = ref_fe%get_number_dimensions() ,  &
                 order             = ref_fe%get_order(),               &
                 field_type        = field_type_scalar,                &
                 continuity        = .false. )

  call fe%create_edge_quadrature( edge_quadrature )
  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )
  call fe_1D_reduced_order%create_interpolation( edge_quadrature, interpolation_1D_reduced_order )

  ! IDEA: perform edge integrations ONLY over the elementary edge 
  ! REAL 1D CELL integration ( Phi'*inv(J)'*Phi*|J| )_e = +-( Phi', Phi)_e 
  ! The sign will be solved later when assembling to the Discrete Gradient   
  call memalloc( fe_1D_reduced_order%get_number_shape_functions(), fe_1D%get_number_shape_functions(), elmat, __FILE__, __LINE__ ) 
  elmat = 0.0_rp 
  do qpoint = 1, edge_quadrature%number_quadrature_points
     factor = edge_quadrature%get_weight(qpoint) 
     do ishape = 1, fe_1D_reduced_order%get_number_shape_functions() 
        call fe_1D_reduced_order%get_value(interpolation_1D_reduced_order, ishape, qpoint, shape_test)
        do jshape = 1, fe_1D%get_number_shape_functions() 
           call fe_1D%get_gradient(interpolation_1D, jshape, qpoint, grad_shape_trial)
           elmat(ishape, jshape) = elmat(ishape, jshape) + grad_shape_trial%get(1) * shape_test * factor
        end do
     end do
  end do

  ! Free data 
  call fe_1D%free() 
  call fe_1D_reduced_order%free()
  call fe%free()
  call interpolation_1D%free() 
  call interpolation_1D_reduced_order%free()
  call edge_quadrature%free()

end subroutine Hcurl_l1_compute_edge_discrete_gradient_elmat

subroutine Hcurl_l1_fill_edge_local_change_of_basis(this, par_fe_space, elmat)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(in)    :: elmat(:,:) 

  type(fe_vef_iterator_t)                :: vef
  integer(ip)                            :: ivef
  integer(ip), allocatable               :: dofs_new_basis(:) 
  integer(ip), allocatable               :: dofs_old_basis(:)
  integer(ip)                            :: offset_wire_edge_dofs 

  type(list_iterator_t) :: coarse_subedge_iterator
  type(list_iterator_t) :: fine_edge_iterator 
  integer(ip)           :: orientation 

  integer(ip) :: isubedge, idof, jdof, istat 
  real(rp)    :: edge_length, sign_factor, factor   
  integer(ip) :: local_edge, number_fine_edges_in_subedge

  allocate( this%change_basis_matrix%G(this%subedges_per_coarse_edge%get_size()), stat=istat); check(istat==0)
  call par_fe_space%create_fe_vef_iterator(vef)
  call memalloc( this%order, dofs_old_basis, __FILE__, __LINE__ )
  call memalloc( this%order+1, dofs_new_basis, __FILE__, __LINE__ )

  ! Start list iterators 
  offset_wire_edge_dofs   = 0
  coarse_subedge_iterator =  this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     isubedge = coarse_subedge_iterator%get_current()
     number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

     call this%change_basis_matrix%G(isubedge)%create(num_rows_and_cols= this%order*number_fine_edges_in_subedge, &
          symmetric_storage=.false.,                  &
          is_symmetric     =.false.,                  &
          sign             = SPARSE_MATRIX_SIGN_UNKNOWN )

     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator( coarse_subedge_iterator%get_current() )
     local_edge = 0
     do while ( .not. fine_edge_iterator%is_upper_bound() )
        local_edge = local_edge + 1
        call vef%set_lid( fine_edge_iterator%get_current() )	 	 
        edge_length = this%compute_edge_length(par_fe_space, vef)
        factor = 1.0_rp/edge_length 

        call this%get_dofs_from_vef(par_fe_space, vef, dofs_old_basis)
        call this%get_new_basis_dofs_from_vef( par_fe_space, local_edge, number_fine_edges_in_subedge, vef, dofs_new_basis )
        call this%fine_edge_direction%get(key=fine_edge_iterator%get_current(), val=orientation, stat=istat); check(istat==key_found) 
		
        ! First fine edge, Starting Nodal Lagrangian shape function must not be taken into account
        do jdof = 1, this%order+1 ! Loop over all nedelec-like dofs in the fine edge   
           if ( dofs_new_basis(jdof) > 0 ) then 
              if ( orientation == same_as_coarse_edge ) then 
                 call this%change_basis_matrix%G(isubedge)%insert(nz       = this%order,                                 & 
                                                                  ia       = dofs_old_basis-offset_wire_edge_dofs,       &
                                                                  ja       = dofs_new_basis(jdof)-offset_wire_edge_dofs, &
                                                                  val      = elmat(:, jdof) * factor )
              elseif ( orientation == opposite_to_coarse_edge ) then 
                 do idof = 1, this%order 
                    call this%change_basis_matrix%G(isubedge)%insert(ia       = dofs_old_basis(idof)- offset_wire_edge_dofs, &
                                                                     ja       = dofs_new_basis(jdof)-offset_wire_edge_dofs,  &
                                                                     val      = -elmat(this%order+1-idof, jdof) * factor )
                 end do
              end if
           end if
        end do

        ! Last column is filled with +- edge sizes depending on local-coarse orientation 
        do idof=1, this%order 
           if ( orientation == same_as_coarse_edge )     sign_factor =  1.0_rp 
           if ( orientation == opposite_to_coarse_edge ) sign_factor = -1.0_rp 
           call this%change_basis_matrix%G(isubedge)%insert(ia       = dofs_old_basis(idof)-offset_wire_edge_dofs,   &
                                                            ja       = this%order*number_fine_edges_in_subedge,      &  ! Last DOF 
                                                            val      = sign_factor*edge_length ) 
        end do

        call fine_edge_iterator%next() 
     end do

     call this%change_basis_matrix%G(coarse_subedge_iterator%get_current())%convert(csr_format)
     ! call this%change_basis_matrix%G(coarse_subedge_iterator%get_current())%print_matrix_market(6)
     offset_wire_edge_dofs = offset_wire_edge_dofs + this%order*number_fine_edges_in_subedge

     call coarse_subedge_iterator%next()
  end do

  call par_fe_space%free_fe_vef_iterator(vef) 
  call memfree(dofs_old_basis) 
  call memfree(dofs_new_basis) 

end subroutine Hcurl_l1_fill_edge_local_change_of_basis

subroutine Hcurl_l1_fill_edge_coupled_to_edges_local_change_of_basis(this, par_fe_space, elmat)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(in)    :: elmat(:,:) 

  type(fe_vef_iterator_t)                   :: edge, interior_edge
  type(fe_vef_iterator_t)                   :: vertex, interior_vertex 
  class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
  class(fe_iterator_t), allocatable         :: fe
  integer(ip)                               :: ivef_within_cell 
  integer(ip)                               :: vertex_within_cell_id
  integer(ip)                               :: vertex_within_edge_id
  integer(ip)                               :: ielem, edge_id, interior_node_id  
  integer(ip)                               :: coarse_edge, fine_edge, node_id
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  integer(ip)                               :: inode, start_node, end_node 
  integer(ip)                               :: new_basis_dof, new_basis_dof2
  integer(ip), allocatable                  :: dofs_old_basis(:) 
  integer(ip)                               :: idof, istat
  integer(ip)                               :: dummy_val, i
  real(rp)                                  :: factor, edge_length 
  logical(ip)                               :: is_affluent 
  type(hash_table_ip_ip_t)                  :: coupled_vefs_added_to_node

  type(list_iterator_t) :: coarse_subedge_iterator
  type(list_iterator_t) :: fine_edge_iterator 
  integer(ip)           :: orientation, local_edge
  integer(ip)           :: isubedge, number_fine_edges_in_subedge 
  integer(ip)           :: offset_wire_edge_dofs

  call this%change_basis_matrix%B%create(num_rows = this%number_total_wire_dofs - this%number_edge_wire_dofs,  &
                                         num_cols = this%number_edge_wire_dofs                                 )

  call memalloc( this%order, dofs_old_basis, __FILE__, __LINE__ )
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vertex) 
  call par_fe_space%create_fe_vef_iterator(interior_vertex)
  call par_fe_space%create_fe_vef_iterator(edge)
  call par_fe_space%create_fe_vef_iterator(interior_edge)
  dummy_val = 0

  offset_wire_edge_dofs   = 0
  coarse_subedge_iterator =  this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     isubedge = coarse_subedge_iterator%get_current()
     number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )
     fine_edge_iterator           = this%sorted_fine_edges_in_coarse_subedge%create_iterator( coarse_subedge_iterator%get_current() )
     do while ( fine_edge_iterator%get_distance_to_upper_bound() > 1 )
        call interior_edge%set_lid( fine_edge_iterator%get_current() )
        call this%find_edge_downstream_vertex(par_fe_space, interior_edge, interior_vertex )		
        call this%get_dofs_from_vef(par_fe_space, interior_edge, dofs_old_basis)
        new_basis_dof = dofs_old_basis(this%order) 

        call coupled_vefs_added_to_node%init( interior_vertex%get_num_cells_around() )
        call coupled_vefs_added_to_node%put( key = interior_edge%get_lid(), val=dummy_val, stat=istat); check(istat==now_stored) 

        do ielem = 1, interior_vertex%get_num_cells_around()
           call interior_vertex%get_cell_around(ielem, fe)      

           if ( fe%is_local() ) then 
              ref_fe_geo => fe%get_reference_fe_geo()
              ivef_within_cell = fe%find_lpos_vef_lid(interior_vertex%get_lid())     
              interior_node_id = interior_vertex%get_lid() 
              ! Loop over edges in the element to find coupled edges 
              do edge_id = ref_fe_geo%get_first_n_face_id_of_dimension(1), & 
                   ref_fe_geo%get_first_n_face_id_of_dimension(1) + ref_fe_geo%get_number_n_faces_of_dimension(1)-1

                 ! Need global ID to check if it has been added 
                 call fe%get_vef(edge_id, edge) 			
                 if ( edge%is_at_interface() ) then 
                    call coupled_vefs_added_to_node%get( key=edge%get_lid(), val=dummy_val, stat=istat)
                    if (  (.not. istat==key_found) ) then  
                       vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
                       vertices_of_line_iterator = vertices_of_line%create_iterator(edge_id)
                       vertex_within_edge_id     = 1

                       do while( .not. vertices_of_line_iterator%is_upper_bound() )
                          vertex_within_cell_id = vertices_of_line_iterator%get_current()
                          call fe%get_vef(vertex_within_cell_id, vertex )
                          node_id = vertex%get_lid() 
                          if (node_id == interior_node_id) then
                             ! A coupled edge has been found  
                             if (vertex_within_edge_id==1) is_affluent = .false.
                             if (vertex_within_edge_id==2) is_affluent = .true.   

                             call this%get_dofs_from_vef(par_fe_space, edge, dofs_old_basis)   
                             factor = 1.0_rp/this%compute_edge_length(par_fe_space, edge)

                             if ( is_affluent ) then  ! Affluent edge 
                                call this%change_basis_matrix%B%insert(nz       = this%order,                                  & 
                                                                       ia       = dofs_old_basis - this%number_edge_wire_dofs, &
                                                                       ja       = new_basis_dof,                               &
                                                                       val      = elmat(:, this%order+1)*factor)

                             elseif ( .not. is_affluent ) then ! Effluent edge 		 
                                do idof = 1, this%order 
                                   call this%change_basis_matrix%B%insert(ia       = dofs_old_basis(idof) - this%number_edge_wire_dofs,  &
                                                                          ja       = new_basis_dof,                                                &
                                                                          val      = -elmat( (this%order+1)-idof, this%order+1)*factor   )
                                end do
                             end if

                             call coupled_vefs_added_to_node%put( key=edge%get_lid(), val=dummy_val, stat=istat)
                          end if
                          vertex_within_edge_id = vertex_within_edge_id + 1
                          call vertices_of_line_iterator%next() 
                       end do ! Loop over vertices in the edge 

                    end if
                 end if ! Checker interface vef 
              end do
           end if
        end do ! Elems around node 
        call coupled_vefs_added_to_node%free() 

        call fine_edge_iterator%next() 
     end do
     call coarse_subedge_iterator%next()
  end do

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(vertex)
  call par_fe_space%free_fe_vef_iterator(interior_vertex)
  call par_fe_space%free_fe_vef_iterator(edge)
  call par_fe_space%free_fe_vef_iterator(interior_edge)
  call memfree(dofs_old_basis)

end subroutine Hcurl_l1_fill_edge_coupled_to_edges_local_change_of_basis

subroutine Hcurl_l1_find_edge_downstream_vertex( this, par_fe_space, vef, vertex ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this		
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(fe_vef_iterator_t)               , intent(in)    :: vef 
  type(fe_vef_iterator_t)               , intent(inout) :: vertex 

  class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
  class(fe_iterator_t), allocatable         :: fe 
  integer(ip)           :: ivef_within_cell, vertex_within_cell_id 
  type(list_t), pointer :: vertices_of_line
  type(list_iterator_t) :: vertices_of_line_iterator
  integer(ip)           :: orientation, istat

  call par_fe_space%create_fe_iterator(fe)

  call vef%get_cell_around(1, fe)
  ivef_within_cell = fe%find_lpos_vef_lid(vef%get_lid()) 		
  ref_fe_geo => fe%get_reference_fe_geo()
  vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
  vertices_of_line_iterator = vertices_of_line%create_iterator(ivef_within_cell)
  call this%fine_edge_direction%get( key=vef%get_lid(), val=orientation, stat=istat); check(istat==key_found)

  if (orientation == same_as_coarse_edge ) then 
     call vertices_of_line_iterator%next() 
  end if
  vertex_within_cell_id = vertices_of_line_iterator%get_current()
  call fe%get_vef(vertex_within_cell_id, vertex )

  call par_fe_space%free_fe_iterator(fe)

end subroutine Hcurl_l1_find_edge_downstream_vertex

subroutine hex_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis( this, par_fe_space )
  implicit none 
  class(hex_Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                      , intent(inout)    :: par_fe_space 

  class(reference_fe_t), pointer         :: ref_fe 
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable      :: fe
  type(fe_face_iterator_t)               :: fe_face 
  integer(ip)            , pointer       :: elem2dof(:)
  type(list_t), pointer                  :: nodes_in_edge
  type(list_iterator_t)                  :: nodes_in_edge_iterator
  type(hex_nedelec_reference_fe_t)       :: Nedelec_fe_2D
  type(hex_lagrangian_reference_fe_t)    :: Lagrangian_fe_3D
  type(interpolation_t)                  :: Lagrangian_interpolation
  type(interpolation_t)                  :: Nedelec_interpolation
  real(rp), allocatable                  :: elmat(:,:) 
  integer(ip)                            :: field_id, ielem, iface_around_edge
  integer(ip)                            :: fine_edge, vef_lid, inode
  integer(ip)                            :: ivef_within_fe
  integer(ip)                            :: node_within_cell_id

  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: number_fine_edges_in_subedge 
  integer(ip)               :: orientation, istat  
  integer(ip)               :: isubedge_coarse
  integer(ip)               :: number_nedelec_dofs_per_face 


  field_id = 1
  call par_fe_space%initialize_fe_face_integration()
  call par_fe_space%create_fe_face_iterator(fe_face)
  call par_fe_space%create_fe_iterator(fe) 
  call par_fe_space%create_fe_vef_iterator(vef)
  number_nedelec_dofs_per_face = 2*this%order*(this%order-1)
  
  ref_fe => par_fe_space%get_reference_fe(field_id)
  call Nedelec_fe_2D%create(topology          = topology_hex,          &
                            number_dimensions = 2,                     &
                            order             = this%order-1,          &
                            field_type        = field_type_vector,     &
                            continuity        = .false. )

  call Lagrangian_fe_3D%create(topology          = topology_hex,         &
                               number_dimensions = 3,                    &
                               order             = this%order,           &
                               field_type        = field_type_scalar,    &
                               continuity        = .true. )

  call memalloc( number_nedelec_dofs_per_face, this%order+1, elmat, __FILE__, __LINE__ )	   	 
  call Nedelec_fe_2D%create_interpolation( fe_face%get_quadrature(), Nedelec_interpolation )

  coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator(coarse_subedge_iterator%get_current())
     fine_edge = 0

     do while ( .not. fine_edge_iterator%is_upper_bound() ) 
        call vef%set_lid( fine_edge_iterator%get_current() )
        fine_edge = fine_edge + 1

        do ielem = 1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem, fe)      
           if ( fe%is_local() ) then 				

              ivef_within_fe = fe%find_lpos_vef_lid( vef%get_lid() )				
              do iface_around_edge = 1,2 
                 call this%find_interface_fe_face_around_edge( fe, ivef_within_fe, iface_around_edge, fe_face ) 
                 if (fe_face%is_at_interface() ) then 

                    nodes_in_edge          => Lagrangian_fe_3D%get_nodes_n_face() 
                    nodes_in_edge_iterator = nodes_in_edge%create_iterator(ivef_within_fe)
				    
                    call Lagrangian_fe_3D%create_face_interpolation( fe%find_lpos_vef_lid(fe_face%get_lid())-ref_fe%get_first_face_id()+1   ,&
                                                                     fe_face%get_quadrature()                                               ,&
                                                                     Lagrangian_interpolation                                                )

                    call this%compute_face_discrete_gradient_elmat(fe,                        &
                                                                   fe_face,                   &
                                                                   Nedelec_fe_2D,             &
                                                                   Lagrangian_fe_3D,          &
                                                                   Nedelec_interpolation,     &
                                                                   Lagrangian_interpolation,  &
                                                                   nodes_in_edge_iterator,    &
                                                                   elmat)

                    call this%assemble_face_coupled_to_edges_B_elmat( par_fe_space,                           &
                                                                      elmat,                                  & 
                                                                      fe_face,                                & 
                                                                      fine_edge,                              & 
                                                                      coarse_subedge_iterator%get_current(),  & 
                                                                      vef )

                 end if
              end do
           end if
        end do

        call fine_edge_iterator%next() 
     end do

     call coarse_subedge_iterator%next()
  end do

  ! Free 
  call Lagrangian_fe_3D%free() 
  call Nedelec_fe_2D%free() 	  
  call Nedelec_interpolation%free() 
  call Lagrangian_interpolation%free() 

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(fe_face)	  
  call par_fe_space%free_fe_vef_iterator(vef) 

  call memfree(elmat, __FILE__, __LINE__ ) 
end subroutine hex_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis

subroutine tet_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis( this, par_fe_space )
  implicit none 
  class(tet_Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                      , intent(inout)    :: par_fe_space 

  class(reference_fe_t), pointer         :: ref_fe 
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable      :: fe
  type(fe_face_iterator_t)               :: fe_face 
  integer(ip)            , pointer       :: elem2dof(:)
  type(list_t), pointer                  :: nodes_in_edge
  type(list_iterator_t)                  :: nodes_in_edge_iterator
  type(tet_lagrangian_reference_fe_t)    :: ref_fe_2D
  type(tet_lagrangian_reference_fe_t)    :: Lagrangian_fe_3D
  type(interpolation_t)                  :: Lagrangian_interpolation
  type(interpolation_t)                  :: ref_fe_interpolation
  real(rp), allocatable                  :: elmat(:,:) 
  integer(ip)                            :: field_id, ielem, iface_around_edge
  integer(ip)                            :: fine_edge, vef_lid, inode
  integer(ip)                            :: ivef_within_fe
  integer(ip)                            :: node_within_cell_id

  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: number_fine_edges_in_subedge 
  integer(ip)               :: orientation, istat  
  integer(ip)               :: isubedge_coarse


  field_id = 1
  call par_fe_space%initialize_fe_face_integration()
  call par_fe_space%create_fe_face_iterator(fe_face)
  call par_fe_space%create_fe_iterator(fe) 
  call par_fe_space%create_fe_vef_iterator(vef)

  ref_fe => par_fe_space%get_reference_fe(field_id) 
  call ref_fe_2D%create(topology          = topology_tet,          &
                        number_dimensions = 2,                     &
                        order             = this%order-1,          &
                        field_type        = field_type_scalar,     &
                        continuity        = .true. )
	
  call Lagrangian_fe_3D%create(topology          = topology_tet,          &
                               number_dimensions = 3,                     &
                               order             = this%order,            &
                               field_type        = field_type_scalar,     &
                               continuity        = .true. )

  call memalloc( this%order*(this%order-1), this%order+1, elmat, __FILE__, __LINE__ )	   	 
  call ref_fe_2D%create_interpolation( fe_face%get_quadrature(), ref_fe_interpolation )
  
  coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator(coarse_subedge_iterator%get_current())
     fine_edge = 0

     do while ( .not. fine_edge_iterator%is_upper_bound() ) 
        call vef%set_lid( fine_edge_iterator%get_current() )
        fine_edge = fine_edge + 1

        do ielem = 1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem, fe)      
           if ( fe%is_local() ) then 				

              ivef_within_fe = fe%find_lpos_vef_lid( vef%get_lid() )				
              do iface_around_edge = 1,2 
                 call this%find_interface_fe_face_around_edge( fe, ivef_within_fe, iface_around_edge, fe_face ) 
                 if (fe_face%is_at_interface() ) then 

                    nodes_in_edge          => Lagrangian_fe_3D%get_nodes_n_face() 
                    nodes_in_edge_iterator = nodes_in_edge%create_iterator(ivef_within_fe)

                    call Lagrangian_fe_3D%create_face_interpolation( fe%find_lpos_vef_lid(fe_face%get_lid())-ref_fe%get_first_face_id()+1   ,&
                                                                     fe_face%get_quadrature()                                               ,&
                                                                     Lagrangian_interpolation                                                )

                    call this%compute_face_discrete_gradient_elmat(fe,                        &
                                                                   fe_face,                   &
                                                                   ref_fe_2D,                 &
                                                                   Lagrangian_fe_3D,          &
                                                                   ref_fe_interpolation,      &
                                                                   Lagrangian_interpolation,  &
                                                                   nodes_in_edge_iterator,    &
                                                                   elmat)

                    call this%assemble_face_coupled_to_edges_B_elmat( par_fe_space,                           &
                                                                      elmat,                                  & 
                                                                      fe_face,                                & 
                                                                      fine_edge,                              & 
                                                                      coarse_subedge_iterator%get_current(),  & 
                                                                      vef )

                 end if
              end do
           end if
        end do

        call fine_edge_iterator%next() 
     end do

     call coarse_subedge_iterator%next()
  end do

  ! Free 
  call ref_fe_2D%free()
  call Lagrangian_fe_3D%free()   
  call ref_fe_interpolation%free() 
  call Lagrangian_interpolation%free() 

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(fe_face)	  
  call par_fe_space%free_fe_vef_iterator(vef) 

  call memfree(elmat, __FILE__, __LINE__ ) 
end subroutine tet_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis

! ***********************************************************************************************************

subroutine hex_Hcurl_l1_find_interface_fe_face_around_edge( this, fe, ivef, iface_around_edge, fe_face)
  implicit none 
  class(hex_Hcurl_l1_coarse_fe_handler_t)   , intent(in)   :: this
  type(fe_iterator_t)                   , intent(in)       :: fe
  integer(ip)                           , intent(in)       :: ivef 
  integer(ip)                           , intent(in)       :: iface_around_edge 
  type(fe_face_iterator_t)              , intent(inout)    :: fe_face

  integer(ip)              :: face_lid
  integer(ip), allocatable :: faces_around_edge(:,:)

  call memalloc( 12, 2, faces_around_edge, __FILE__, __LINE__ ) 
  faces_around_edge(1,1) = 23; faces_around_edge(1,2) = 21; 
  faces_around_edge(2,1) = 21; faces_around_edge(2,2) = 24;
  faces_around_edge(3,1) = 23; faces_around_edge(3,2) = 22; 
  faces_around_edge(4,1) = 24; faces_around_edge(4,2) = 22; 
  faces_around_edge(5,1) = 21; faces_around_edge(5,2) = 25;
  faces_around_edge(6,1) = 21; faces_around_edge(6,2) = 26; 
  faces_around_edge(7,1) = 22; faces_around_edge(7,2) = 25; 
  faces_around_edge(8,1) = 22; faces_around_edge(8,2) = 26;
  faces_around_edge(9,1) = 23; faces_around_edge(9,2) = 25; 
  faces_around_edge(10,1) = 23; faces_around_edge(10,2) = 26; 
  faces_around_edge(11,1) = 24; faces_around_edge(11,2) = 25;
  faces_around_edge(12,1) = 24; faces_around_edge(12,2) = 26; 

  ! Local fe_faces around EDGE 
  face_lid = fe%get_vef_lid( faces_around_edge(ivef-8, iface_around_edge) )
  call fe_face%set_lid( face_lid )

  call memfree( faces_around_edge, __FILE__, __LINE__ )
end subroutine hex_Hcurl_l1_find_interface_fe_face_around_edge

subroutine tet_Hcurl_l1_find_interface_fe_face_around_edge( this, fe, ivef, iface_around_edge, fe_face)
  implicit none 
  class(tet_Hcurl_l1_coarse_fe_handler_t)   , intent(in)   :: this
  type(fe_iterator_t)                   , intent(in)       :: fe
  integer(ip)                           , intent(in)       :: ivef 
  integer(ip)                           , intent(in)       :: iface_around_edge 
  type(fe_face_iterator_t)              , intent(inout)    :: fe_face

  integer(ip)              :: face_lid
  integer(ip), allocatable :: faces_around_edge(:,:)

  call memalloc( 12, 2, faces_around_edge, __FILE__, __LINE__ ) 
  faces_around_edge(1,1) = 11; faces_around_edge(1,2) = 12; 
  faces_around_edge(2,1) = 11; faces_around_edge(2,2) = 13;
  faces_around_edge(3,1) = 11; faces_around_edge(3,2) = 14; 
  faces_around_edge(4,1) = 12; faces_around_edge(4,2) = 13; 
  faces_around_edge(5,1) = 12; faces_around_edge(5,2) = 14;
  faces_around_edge(6,1) = 13; faces_around_edge(6,2) = 14; 

  ! Local fe_faces around EDGE 
  face_lid = fe%get_vef_lid( faces_around_edge(ivef-4, iface_around_edge) )
  call fe_face%set_lid( face_lid )

  call memfree( faces_around_edge, __FILE__, __LINE__ )
end subroutine tet_Hcurl_l1_find_interface_fe_face_around_edge

subroutine hex_Hcurl_l1_compute_face_discrete_gradient_elmat(this, fe, fe_face, ref_fe_2D, Lagrangian_fe_3D, ref_fe_interpolation, Lagrangian_interpolation_ref, nodes_in_edge_iterator, elmat)
  implicit none 
  class(hex_Hcurl_l1_coarse_fe_handler_t)   , intent(in)   :: this
  type(fe_iterator_t)                   , intent(inout)    :: fe 
  type(fe_face_iterator_t)              , intent(inout)    :: fe_face
  class(lagrangian_reference_fe_t)      , intent(in)       :: ref_fe_2D
  class(lagrangian_reference_fe_t)      , intent(in)       :: Lagrangian_fe_3D
  type(interpolation_t)                 , intent(in)       :: ref_fe_interpolation
  type(interpolation_t)                 , intent(in)       :: Lagrangian_interpolation_ref
  type(list_iterator_t)                 , intent(inout)    :: nodes_in_edge_iterator
  real(rp), allocatable                 , intent(inout)    :: elmat(:,:) 

  integer(ip) :: ielem 
  type(quadrature_t)       , pointer     :: quad
  type(fe_map_t)           , pointer     :: fe_map
  type(face_map_t)         , pointer     :: face_map
  type(fe_map_t)           , pointer     :: face_map_face_map
  type(interpolation_t)                  :: Lagrangian_interpolation_phy 
  type(vector_field_t)                   :: cross_product_gradv_shape_trial_normal
  type(vector_field_t)                   :: cross_product_gradv_shape_trial_normal_proj
  type(vector_field_t)                   :: col_jacobian

  integer(ip)                            :: number_qpoints, idof, i 
  real(rp)                               :: factor
  type(vector_field_t)                   :: normal, v_shape_test, gradv_shape_trial
  integer(ip)                            :: ishape, jshape, qpoint
  integer(ip)                            :: number_nedelec_dofs_per_face 
  
  call fe%update_integration() 	
  call fe_face%update_integration()

  quad              => fe_face%get_quadrature()
  number_qpoints    =  quad%get_number_quadrature_points()
  face_map          => fe_face%get_face_map()
  face_map_face_map => face_map%get_face_map()

  elmat = 0.0_rp 
  call cross_product_gradv_shape_trial_normal_proj%init(0.0_rp)

  call Lagrangian_interpolation_phy%copy(Lagrangian_interpolation_ref) 
  call Lagrangian_fe_3D%update_interpolation( fe%get_fe_map(),              &
       Lagrangian_interpolation_ref, &
       Lagrangian_interpolation_phy )

  number_nedelec_dofs_per_face = 2*this%order*(this%order-1)
  do qpoint = 1, number_qpoints
     factor = face_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)
     call face_map_face_map%get_normal(qpoint, normal)
     ! Trick to have normals pointing to the same direction in different faces 
     do i=1, SPACE_DIM
        call normal%set(i, abs(normal%get(i)))
     end do

     do ishape = 1, number_nedelec_dofs_per_face
        call ref_fe_2D%get_value(ref_fe_interpolation, ishape, qpoint, v_shape_test)
        ! WARNING: Update 2D interpolation for the Nedelec test functions ( J**{-T} will only work in HEX structured meshes! )
        do i=1, Lagrangian_fe_3D%get_number_dimensions()-1
           call face_map_face_map%get_jacobian_column(i,qpoint,col_jacobian)
           call v_shape_test%set(i, v_shape_test%get(i)/col_jacobian%nrm2() )
        end do

        call nodes_in_edge_iterator%begin() 
        do jshape = 1, nodes_in_edge_iterator%get_size() 
           call Lagrangian_fe_3D%get_gradient(Lagrangian_interpolation_phy, nodes_in_edge_iterator%get_current(), qpoint, gradv_shape_trial)
           cross_product_gradv_shape_trial_normal = cross_product(gradv_shape_trial,normal)			         
           ! Multiply the transpose of the jacobian with normalized columns by u^n
           ! This is required to transform u^n in a vector contained within the face
           do i=1,Lagrangian_fe_3D%get_number_dimensions()-1
              call face_map_face_map%get_jacobian_normalized_column(i,qpoint,col_jacobian)
              call cross_product_gradv_shape_trial_normal_proj%set(i, col_jacobian*cross_product_gradv_shape_trial_normal)
           end do
           elmat(ishape,jshape) = elmat(ishape, jshape) + factor*cross_product_gradv_shape_trial_normal_proj*v_shape_test
           call nodes_in_edge_iterator%next() 
        end do
     end do
  end do

  call Lagrangian_interpolation_phy%free() 

end subroutine hex_Hcurl_l1_compute_face_discrete_gradient_elmat

subroutine tet_Hcurl_l1_compute_face_discrete_gradient_elmat(this, fe, fe_face, ref_fe_2D, Lagrangian_fe_3D, ref_fe_interpolation, Lagrangian_interpolation_ref, nodes_in_edge_iterator, elmat)
  implicit none 
  class(tet_Hcurl_l1_coarse_fe_handler_t)   , intent(in)   :: this
  type(fe_iterator_t)                   , intent(inout)    :: fe 
  type(fe_face_iterator_t)              , intent(inout)    :: fe_face
  class(lagrangian_reference_fe_t)      , intent(in)       :: ref_fe_2D
  class(lagrangian_reference_fe_t)      , intent(in)       :: Lagrangian_fe_3D
  type(interpolation_t)                 , intent(in)       :: ref_fe_interpolation
  type(interpolation_t)                 , intent(in)       :: Lagrangian_interpolation_ref
  type(list_iterator_t)                 , intent(inout)    :: nodes_in_edge_iterator
  real(rp), allocatable                 , intent(inout)    :: elmat(:,:) 

  integer(ip) :: ielem 
  type(quadrature_t)       , pointer     :: quad
  type(fe_map_t)           , pointer     :: fe_map
  type(face_map_t)         , pointer     :: face_map
  type(fe_map_t)           , pointer     :: face_map_face_map
  type(interpolation_t)                  :: Lagrangian_interpolation_phy 

  integer(ip)                            :: number_qpoints, idof
  real(rp)                               :: factor
  type(vector_field_t)                   :: gradv_shape_trial
  real(rp)                               :: v_shape_test
  type(vector_field_t)                   :: tangent
  integer(ip)                            :: ishape, jshape, qpoint
  
  integer(ip) :: direction, c, number_scalar_test_functions 
  real(rp)    :: face_area 

  call fe%update_integration() 	
  call fe_face%update_integration()

  quad              => fe_face%get_quadrature()
  number_qpoints    =  quad%get_number_quadrature_points()
  face_map          => fe_face%get_face_map()
  face_map_face_map => face_map%get_face_map()

  elmat = 0.0_rp 

  call Lagrangian_interpolation_phy%copy(Lagrangian_interpolation_ref) 
  call Lagrangian_fe_3D%update_interpolation( fe%get_fe_map(),              &
                                              Lagrangian_interpolation_ref, &
                                              Lagrangian_interpolation_phy )
  
  number_scalar_test_functions = this%order*(this%order-1)/2
  do qpoint = 1, number_qpoints
     factor = face_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)
	 face_area = 0.5_rp*face_map%get_det_jacobian(qpoint)
     
	 do direction=1,2
	 c = (direction-1)*number_scalar_test_functions 
	 face_area = 0.5_rp*face_map_face_map%get_det_jacobian(qpoint)
	 call face_map_face_map%get_jacobian_column(direction,qpoint,tangent)
	 WRITE(*,*) 'TANGENT', tangent%get(1), tangent%get(2), tangent%get(3) 
     do ishape = 1, number_scalar_test_functions 
        call ref_fe_2D%get_value(ref_fe_interpolation, ishape, qpoint, v_shape_test)
        call nodes_in_edge_iterator%begin() 
        do jshape = 1, nodes_in_edge_iterator%get_size() 
           call Lagrangian_fe_3D%get_gradient(Lagrangian_interpolation_phy, nodes_in_edge_iterator%get_current(), qpoint, gradv_shape_trial)		         
           elmat(ishape+c,jshape) = elmat(ishape+c, jshape) + 1.0_rp/face_area * factor*gradv_shape_trial*v_shape_test*tangent 
           call nodes_in_edge_iterator%next() 
        end do
     end do
	 end do 
  end do
   
  call Lagrangian_interpolation_phy%free() 

end subroutine tet_Hcurl_l1_compute_face_discrete_gradient_elmat

! ****************************************************************************************************************************************
subroutine Hcurl_l1_assemble_face_coupled_to_edges_B_elmat( this, par_fe_space, elmat, fe_face, fine_edge, coarse_edge, vef)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                  , intent(in)       :: par_fe_space 
  real(rp), allocatable                 , intent(in)       :: elmat(:,:) 
  type(fe_face_iterator_t)              , intent(in)       :: fe_face
  integer(ip)                           , intent(in)       :: fine_edge
  integer(ip)                           , intent(in)       :: coarse_edge 
  type(fe_vef_iterator_t)               , intent(in)       :: vef

  integer(ip)                            :: number_nedelec_dofs_per_face
  integer(ip)                            :: idof, jdof
  integer(ip), allocatable               :: dofs_face_old_basis(:)
  integer(ip), allocatable               :: dofs_new_basis(:) 
  integer(ip)                            :: number_fine_edges_in_subedge 
  integer(ip)                            :: fine_edge_direction, istat

  number_nedelec_dofs_per_face =  size(elmat,1) 
  
  call memalloc( number_nedelec_dofs_per_face, dofs_face_old_basis, __FILE__, __LINE__ ) 
  call this%get_dofs_from_vef(par_fe_space, fe_face, dofs_face_old_basis)

  call memalloc( this%order+1, dofs_new_basis, __FILE__, __LINE__ )
  number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_edge )
  call this%get_new_basis_dofs_from_vef( par_fe_space, fine_edge, number_fine_edges_in_subedge, vef, dofs_new_basis )

  call this%fine_edge_direction%get( key=vef%get_lid(), val=fine_edge_direction, stat=istat); check(istat==key_found) 
  do jdof = 1, this%order+1
     if ( dofs_new_basis(jdof) > 0) then 

        select case ( fine_edge_direction ) 
        case ( same_as_coarse_edge ) 

           call this%change_basis_matrix%B%insert(nz       = number_nedelec_dofs_per_face,                        & 
                                                  ia       = dofs_face_old_basis - this%number_edge_wire_dofs,    &
                                                  ja       = dofs_new_basis(jdof),                                &
                                                  val      = elmat(:, jdof) )
        case (opposite_to_coarse_edge ) 			   
           do idof = 1, number_nedelec_dofs_per_face 
              call this%change_basis_matrix%B%insert(ia       = dofs_face_old_basis(idof) - this%number_edge_wire_dofs,   &
                                                     ja       = dofs_new_basis(jdof),                                     &
                                                     val      = -elmat( number_nedelec_dofs_per_face+1-idof, jdof)  )  
           end do
        end select

     end if
  end do

  call memfree( dofs_face_old_basis, __FILE__, __LINE__ )
  call memfree( dofs_new_basis, __FILE__, __LINE__ )
end subroutine Hcurl_l1_assemble_face_coupled_to_edges_B_elmat

subroutine Hcurl_l1_compute_first_order_moment_in_edges(this, par_fe_space, constraint_in_edges)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space 
  type(serial_scalar_array_t)           , intent(inout) :: constraint_in_edges

  type(fe_vef_iterator_t)     :: vef
  integer(ip)                 :: ivef
  integer(ip)                 :: field_id, idof
  real(rp),    allocatable    :: elvec(:) 
  integer(ip), allocatable    :: dofs_new_basis(:) 
  real(rp)                    :: factor 

  integer(ip)               :: offcomponent 
  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: number_fine_edges_in_subedge 
  integer(ip)               :: local_vef 

  field_id = 1
  call constraint_in_edges%create_and_allocate( par_fe_space%get_block_number_dofs(field_id) )
  call constraint_in_edges%init(0.0_rp) 

  ! Elemental vector int(Phi), lack of lenght (Jacobian), computed in h=[-1,1] elemental edge   
  call this%compute_edge_lagrangian_average_elvec( par_fe_space, elvec ) 

  call par_fe_space%create_fe_vef_iterator(vef)

  ! Loop on fine edges and assemble the elemental vector, C_new  
  call memalloc( this%order+1, dofs_new_basis, __FILE__, __LINE__ )

  offcomponent = this%number_interior_dofs 
  coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )
     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator(coarse_subedge_iterator%get_current())

     local_vef = 0
     do while ( .not. fine_edge_iterator%is_upper_bound() )
        local_vef = local_vef + 1
        call vef%set_lid( fine_edge_iterator%get_current() ) 

        call this%get_new_basis_dofs_from_vef( par_fe_space, local_vef, number_fine_edges_in_subedge, vef, dofs_new_basis ) 

        factor = this%compute_edge_length(par_fe_space, vef)/2.0_rp 
        do idof = 1, this%order+1    
           if ( dofs_new_basis(idof) > 0 ) then 
              call constraint_in_edges%add( i    = offcomponent + dofs_new_basis(idof),  &
                                            val  = elvec(idof)*factor  )
           end if
        end do

        call fine_edge_iterator%next() 
     end do

     call coarse_subedge_iterator%next()
  end do

  call memfree(elvec, __FILE__, __LINE__ )
  call memfree(dofs_new_basis, __FILE__, __LINE__ )
  call par_fe_space%free_fe_vef_iterator(vef) 

  ! Change of basis for the assembled vector: C_new*inv(G) = C_old --> SOLVE G^t C_old = C_new 
  call this%apply_inverse_local_change_basis_transpose( constraint_in_edges, constraint_in_edges )

end subroutine Hcurl_l1_compute_first_order_moment_in_edges

subroutine Hcurl_l1_compute_edge_lagrangian_average_elvec(this, par_fe_space, elvec)
  ! This subroutine computes the elemental 1D integration of Lagrangian 
  ! shape functions over a reference 1D element 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(inout) :: elvec(:) 

  class(reference_fe_t), pointer         :: ref_fe 
  type(hex_nedelec_reference_fe_t)       :: fe 
  type(hex_lagrangian_reference_fe_t)    :: fe_1D
  type(quadrature_t)                     :: edge_quadrature
  type(interpolation_t)                  :: interpolation_1D 
  real(rp)                               :: shape_test, factor 
  integer(ip)                            :: ishape, qpoint 
  integer(ip)                            :: field_id 

  field_id = 1
  ref_fe => par_fe_space%get_reference_fe(field_id) 

  ! Create a 1D scalar lagrangian reference FE of order k
  call fe_1D%create(topology          = ref_fe%get_topology(),          &
                    number_dimensions = 1,                              &
                    order             = ref_fe%get_order(),             &
                    field_type        = field_type_scalar,              &
                    continuity        = .true. )

  call fe%create(topology          = topology_hex,                   &
                 number_dimensions = 1,                              &
                 order             = ref_fe%get_order(),             &
                 field_type        = field_type_scalar,              &
                 continuity        = .false. )

  call fe%create_edge_quadrature( edge_quadrature )
  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )

  call memalloc( fe_1D%get_number_shape_functions(), elvec, __FILE__, __LINE__ ) 
  elvec = 0.0_rp 
  do qpoint = 1, edge_quadrature%number_quadrature_points
     factor = edge_quadrature%get_weight(qpoint) 
     do ishape = 1, fe_1D%get_number_shape_functions() 
        call fe_1D%get_value(interpolation_1D, ishape, qpoint, shape_test)
        elvec(ishape) = elvec(ishape) + shape_test * factor 
     end do
  end do

  ! Free data   
  call fe%free()
  call fe_1D%free() 
  call interpolation_1D%free() 
  call edge_quadrature%free()

end subroutine Hcurl_l1_compute_edge_lagrangian_average_elvec
! -------------------------------------------------------------------------------------------------
!
!                                 Change of basis matrix applications 
!
! -------------------------------------------------------------------------------------------------
subroutine Hcurl_l1_apply_global_change_basis(this, x_new, x_old)
  ! Thanks to structure of change basis, it can be applied locally without 
  ! further consideration and obtain the fully assembled local parts of the global
  ! change of basis 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
  type(par_scalar_array_t)                 , intent(in)     :: x_new
  type(par_scalar_array_t)                 , intent(inout)  :: x_old

  type(serial_scalar_array_t)  , pointer   :: x_new_local
  type(serial_scalar_array_t)  , pointer   :: x_old_local
  type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
  type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
  type(serial_scalar_array_t)  :: B_times_x_new
  type(serial_scalar_array_t)  :: G_times_x_new 

  type(list_iterator_t)     :: coarse_subedge_iterator
  integer(ip)               :: number_fine_edges_in_subedge 
  integer(ip)               :: offcomponent_coarse_edge

  x_old_local         => x_old%get_serial_scalar_array()
  x_new_local         => x_new%get_serial_scalar_array()

  ! First part of the application: x_old_Ec = B*x_new_E + x_new_Ec   	  
  call x_new_local%create_view( this%number_interior_dofs + 1,                              & 
       this%number_interior_dofs + this%number_edge_wire_dofs,     &
       x_new_local_edge )

  call x_old_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1, & 
       this%number_interior_dofs + this%number_total_wire_dofs,    &
       x_old_local_Ec )

  call x_new_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1, & 
       this%number_interior_dofs + this%number_total_wire_dofs,    &
       x_new_local_Ec )

  call B_times_x_new%create_and_allocate( this%number_total_wire_dofs - this%number_edge_wire_dofs)
  call B_times_x_new%init(0.0_rp)

  ! Apply local change basis to built DoF 
  call this%change_basis_matrix%B%apply(x_new_local_edge, B_times_x_new)

  ! Assign values to the vector associated to [E^c] in the new basis  
  call x_old_local_Ec%axpby(1.0_rp, B_times_x_new, 1.0_rp) 

  call x_new_local_edge%free()
  call x_old_local_Ec%free()
  call x_new_local_Ec%free() 
  call B_times_x_new%free() 

  ! Second part of the application: x_old_E = G*x_new_E, application Edge by Edge 
  offcomponent_coarse_edge = this%number_interior_dofs 
  coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )  
     number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

     call x_old_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_old_local_edge )

     call x_new_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_new_local_edge )

     ! Apply local change basis to built DoF
     call G_times_x_new%create_and_allocate( this%order*number_fine_edges_in_subedge ) 
     call this%change_basis_matrix%G(coarse_subedge_iterator%get_current())%apply(x_new_local_edge, G_times_x_new)
     call x_old_local_edge%copy(G_times_x_new) 

     call x_old_local_edge%free()
     call x_new_local_edge%free()
     call G_times_x_new%free()

     offcomponent_coarse_edge = offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge
     call coarse_subedge_iterator%next() 
  end do

end subroutine Hcurl_l1_apply_global_change_basis

subroutine Hcurl_l1_apply_global_change_basis_transpose(this, x_old, x_new)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
  type(par_scalar_array_t)                 , intent(in)     :: x_old
  type(par_scalar_array_t)                 , intent(inout)  :: x_new

  type(serial_scalar_array_t), pointer  :: x_old_local 
  type(serial_scalar_array_t), pointer  :: x_new_local
  type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
  type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
  type(serial_scalar_array_t)  :: Bt_times_x_old
  type(serial_scalar_array_t)  :: Gt_times_x_old 

  type(list_iterator_t)     :: coarse_subedge_iterator
  integer(ip)               :: number_fine_edges_in_subedge
  integer(ip)               :: offcomponent_coarse_edge

  x_old_local         => x_old%get_serial_scalar_array()
  x_new_local         => x_new%get_serial_scalar_array()

  ! Nullify non-owned dofs to perform the global Q'*x computation locally 
  call x_new%nullify_non_owned_dofs() 

  ! First part of the application: x_new_Ec = x_old_Ec (do-nothing)  

  ! Second part of the application: x_new_E =  G^t x_old_E + B^t*x_old_Ec	
  offcomponent_coarse_edge = this%number_interior_dofs
  coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )  
     number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

     call x_old_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_old_local_edge )

     call x_new_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_new_local_edge )

     ! Apply local change basis to built DoF
     call Gt_times_x_old%create_and_allocate( this%order*number_fine_edges_in_subedge ) 
     call this%change_basis_matrix%G(coarse_subedge_iterator%get_current())%apply_transpose(x_old_local_edge, Gt_times_x_old)
     call x_new_local_edge%copy(Gt_times_x_old) 

     call x_old_local_edge%free()
     call x_new_local_edge%free()
     call Gt_times_x_old%free()

     offcomponent_coarse_edge = offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge
     call coarse_subedge_iterator%next() 
  end do

  call x_old_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1, & 
       this%number_interior_dofs + this%number_total_wire_dofs,    &
       x_old_local_Ec )

  call x_new_local%create_view( this%number_interior_dofs + 1,                              & 
       this%number_interior_dofs + this%number_edge_wire_dofs,     &
       x_new_local_edge )

  call Bt_times_x_old%create_and_allocate(this%number_edge_wire_dofs)
  call Bt_times_x_old%init(0.0_rp)

  ! Apply local change basis to built DoF 
  call this%change_basis_matrix%B%apply_transpose(x_old_local_Ec, Bt_times_x_old) 
  call x_new_local_edge%axpby(1.0_rp, Bt_times_x_old, 1.0_rp) 

  ! Assemble all local contributions to the full Q'*x product 
  call x_new%comm() 

  call x_new_local_edge%free()
  call x_old_local_Ec%free()
  call Bt_times_x_old%free() 

end subroutine Hcurl_l1_apply_global_change_basis_transpose

subroutine Hcurl_l1_apply_inverse_local_change_basis(this, x_old_local, x_new_local) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
  type(serial_scalar_array_t)              , intent(in)     :: x_old_local
  type(serial_scalar_array_t)              , intent(inout)  :: x_new_local

  type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
  type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
  type(serial_scalar_array_t)  :: B_times_x_new
  type(serial_scalar_array_t)  :: inv_G_times_x_old  

  ! Direct solver data
  type(direct_solver_t)        :: direct_solver 
  integer                      :: FPLError
  type(parameterlist_t)        :: parameter_list
  integer                      :: iparm(64)

  type(list_iterator_t)     :: coarse_subedge_iterator
  integer(ip)               :: number_fine_edges_in_subedge
  integer(ip)               :: offcomponent_coarse_edge

  iparm      = 0 ! Init all entries to zero	
  ! Create direct solver to update iterates 
  call parameter_list%init()
  FPLError =            parameter_list%set(key = direct_solver_type     ,   value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type,   value = pardiso_mkl_uns)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level, value = 0)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm); assert(FPLError == 0)  
  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(this%change_basis_matrix%G(1))

  ! Apply local inverse to each Coarse Edge  
  offcomponent_coarse_edge = this%number_interior_dofs 
  coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )  
     number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

     call x_old_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_old_local_edge )

     call x_new_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_new_local_edge )

     call inv_G_times_x_old%create_and_allocate(this%order*number_fine_edges_in_subedge) 
     call inv_G_times_x_old%init(0.0_rp) 

     call direct_solver%update_matrix( this%change_basis_matrix%G(coarse_subedge_iterator%get_current()), same_nonzero_pattern=.false.) 
     call direct_solver%solve( x_old_local_edge , inv_G_times_x_old )
     call x_new_local_edge%copy(inv_G_times_x_old)

     call x_old_local_edge%free()
     call x_new_local_edge%free()
     call inv_G_times_x_old%free()

     offcomponent_coarse_edge = offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge
     call coarse_subedge_iterator%next() 
  end do
  call direct_solver%free() 

  ! Second part of the application:   	  
  call x_new_local%create_view( this%number_interior_dofs + 1,                             & 
       this%number_interior_dofs + this%number_edge_wire_dofs   , &
       x_new_local_edge )

  call x_new_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1 , & 
       this%number_interior_dofs + this%number_total_wire_dofs    , &
       x_new_local_Ec )

  call B_times_x_new%create_and_allocate( this%number_total_wire_dofs - this%number_edge_wire_dofs)

  ! Apply local change basis to built DoF 
  call this%change_basis_matrix%B%apply(x_new_local_edge, B_times_x_new)

  ! Assign values to the vector associated to [E^c] in the new basis 
  call x_new_local_Ec%axpby(-1.0_rp, B_times_x_new, 1.0_rp)

  call x_new_local_edge%free()
  call x_new_local_Ec%free() 
  call B_times_x_new%free()

end subroutine Hcurl_l1_apply_inverse_local_change_basis

subroutine Hcurl_l1_apply_inverse_local_change_basis_transpose(this, x_new_local, x_old_local) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
  type(serial_scalar_array_t)              , intent(in)     :: x_new_local
  type(serial_scalar_array_t)              , intent(inout)  :: x_old_local

  type(serial_scalar_array_t)  :: x_new_local_edge, x_new_local_Ec
  type(serial_scalar_array_t)  :: x_old_local_edge, x_old_local_Ec 
  type(serial_scalar_array_t)  :: Bt_times_x_old
  type(serial_scalar_array_t)  :: inv_Gt_application 

  ! Direct solver data
  type(direct_solver_t)        :: direct_solver 
  integer                      :: FPLError
  type(parameterlist_t)        :: parameter_list
  integer                      :: iparm(64)

  type(list_iterator_t)     :: coarse_subedge_iterator
  integer(ip)               :: number_fine_edges_in_subedge
  integer(ip)               :: offcomponent_coarse_edge

  ! First step, do-nothing for the Ec part 

  ! Second step, apply local inverses transposed	  
  call x_old_local%create_view( this%number_interior_dofs + this%number_edge_wire_dofs + 1  , & 
       this%number_interior_dofs + this%number_total_wire_dofs     , &
       x_old_local_Ec )	  

  call x_old_local%create_view( this%number_interior_dofs + 1,                             & 
       this%number_interior_dofs + this%number_edge_wire_dofs   , &
       x_old_local_edge )

  call Bt_times_x_old%create_and_allocate(this%number_edge_wire_dofs)

  ! Apply local change basis to built DoF 
  call this%change_basis_matrix%B%apply_transpose(x_old_local_Ec, Bt_times_x_old)
  ! Assign values to the vector associated to [E^c] in the new basis 
  call x_old_local_edge%axpby(-1.0_rp, Bt_times_x_old, 1.0_rp)

  call x_old_local_edge%free()
  call x_old_local_Ec%free()
  call Bt_times_x_old%free()

  iparm      = 0 ! Init all entries to zero
  iparm(1)   = 1 ! no solver default
  iparm(2)   = 2 ! fill-in reordering from METIS
  iparm(8)   = 2 ! numbers of iterative refinement steps
  iparm(10)  = 8 ! perturb the pivot elements with 1E-8
  iparm(11)  = 1 ! use scaling 
  iparm(12)  = 2 ! Solve transposed system 
  iparm(13)  = 1 ! use maximum weighted matching algorithm 
  iparm(21)  = 1 ! 1x1 + 2x2 pivots

  ! Create direct solver to update iterates 
  call parameter_list%init()
  FPLError =            parameter_list%set(key = direct_solver_type     ,   value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type,   value = pardiso_mkl_uns)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level, value = 0)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm); assert(FPLError == 0)  
  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(this%change_basis_matrix%G(1))

  ! Apply local inverse to each Coarse Edge  
  offcomponent_coarse_edge = this%number_interior_dofs 
  coarse_subedge_iterator = this%subedges_per_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )  
     number_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

     call x_old_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_old_local_edge )

     call x_new_local%create_view(offcomponent_coarse_edge + 1,                                       & 
          offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge, &
          x_new_local_edge )

     call inv_Gt_application%create_and_allocate(this%order*number_fine_edges_in_subedge) 
     call inv_Gt_application%init(0.0_rp) 

     call direct_solver%update_matrix( this%change_basis_matrix%G(coarse_subedge_iterator%get_current()), same_nonzero_pattern=.false.) 
     call direct_solver%solve( x_new_local_edge, inv_Gt_application )
     call x_old_local_edge%copy(inv_Gt_application)

     call x_old_local_edge%free()
     call x_new_local_edge%free()
     call inv_Gt_application%free()

     offcomponent_coarse_edge = offcomponent_coarse_edge + this%order*number_fine_edges_in_subedge
     call coarse_subedge_iterator%next()
  end do
  call direct_solver%free() 

end subroutine Hcurl_l1_apply_inverse_local_change_basis_transpose
! -------------------------------------------------------------------------------------------
! 
!             Getters for DoFs in different numberings 
!
! -------------------------------------------------------------------------------------------
subroutine Hcurl_l1_get_dofs_from_vef(this, par_fe_space, vef, dof_list) 
  implicit none 
  ! This function returns dofs associated to a local VEF in the local 
  ! wire numbering. Interface does not contain sets of consecutive dofs 
  ! on its vefs, extract one-by-one info 
  class(Hcurl_l1_coarse_fe_handler_t)           , intent(in)       :: this
  type(par_fe_space_t)                          , intent(in)       :: par_fe_space 
  class(fe_vef_iterator_t)                      , intent(in)       :: vef
  integer(ip),  allocatable                     , intent(inout)    :: dof_list(:)

  class(fe_iterator_t) , allocatable     :: fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 
  integer(ip)                            :: field_id, ivef_within_cell 
  integer(ip)            , pointer       :: elem2dof(:)
  integer(ip)                            :: start_dof, end_dof, idof, dof_lid

  field_id = 1
  idof     = 0
  call par_fe_space%create_fe_iterator(fe) 

  call vef%get_cell_around(1,fe)
  call fe%get_field_elem2dof(field_id, elem2dof)
  ivef_within_cell = fe%find_lpos_vef_lid( vef%get_lid() )
  own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)

  dof_list = 0
  do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
     idof = idof + 1
     dof_list(idof) = elem2dof(own_dofs_on_vef_iterator%get_current()) - this%number_interior_dofs
     call own_dofs_on_vef_iterator%next()
  end do

  call par_fe_space%free_fe_iterator(fe) 
end subroutine Hcurl_l1_get_dofs_from_vef

subroutine Hcurl_l1_get_new_basis_dofs_from_vef( this, par_fe_space, local_vef, number_vefs, vef, vef2dof ) 
  class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
  type(par_fe_space_t)                          , intent(in)       :: par_fe_space
  integer(ip)                                   , intent(in)       :: local_vef 
  integer(ip)                                   , intent(in)       :: number_vefs 
  type(fe_vef_iterator_t)                       , intent(in)       :: vef 
  integer(ip), allocatable                      , intent(inout)    :: vef2dof(:)

  integer(ip),  allocatable       :: dof_list(:)
  integer(ip) :: idof, orientation, istat 

  call memalloc( this%order, dof_list, __FILE__, __LINE__ ) 
  call this%get_dofs_from_vef( par_fe_space, vef, dof_list )
  call this%fine_edge_direction%get( key=vef%get_lid(), val=orientation, stat=istat ); check(istat==key_found) 
  
    vef2dof = 0
  if ( orientation == same_as_coarse_edge) then 
  
  do idof=1, this%order
     vef2dof(idof) =  dof_list(idof)-1  
  end do
  vef2dof(this%order+1) = dof_list(this%order) 
  
  elseif ( orientation == opposite_to_coarse_edge) then 
  
    do idof= 1,this%order
     vef2dof(this%order+2-idof) = dof_list(idof)  
    end do
    vef2dof(1) = dof_list(this%order)-1
  
  end if 
  
  if ( local_vef==1 )             vef2dof(1) = 0
  if ( local_vef==number_vefs)    vef2dof(this%order+1) = 0
  
  call memfree(dof_list, __FILE__, __LINE__ )
end subroutine Hcurl_l1_get_new_basis_dofs_from_vef

! ----------------------------------------------------------------------------------
!
!                      Delegated from par_fe_space 
! 
! ----------------------------------------------------------------------------------
subroutine Hcurl_l1_renumber_interface_dofs_first_E_then_Ec(this, par_fe_space, iblock, perm_old2new) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)     , intent(inout)  :: this
  type(par_fe_space_t)                    , intent(in)     :: par_fe_space 
  integer(ip)                             , intent(in)     :: iblock 
  integer(ip) , allocatable               , intent(inout)  :: perm_old2new(:)

  class(fe_iterator_t), allocatable      :: fe
  integer(ip)                            :: field_id
  class(reference_fe_t), pointer         :: reference_fe 
  integer(ip)                            :: idof, current_dof  
  integer(ip)         , allocatable      :: perm_new2wire(:)

  field_id = par_fe_space%field_blocks(iblock)  
  call par_fe_space%create_fe_iterator(fe)
  reference_fe => fe%get_reference_fe(field_id)
  this%order = fe%get_order(field_id) 

  if ( reference_fe%get_number_dimensions()==2 ) then 
     ! Change of basis is only needed in 3D 
     return 
  end if

  call memalloc ( par_fe_space%number_dofs_per_block(iblock), perm_new2wire, __FILE__, __LINE__ ) 
  perm_new2wire = 0

  current_dof = 1
  do idof = 1, par_fe_space%get_block_number_interior_dofs(iblock) 
     perm_new2wire(idof) = current_dof  
     current_dof = current_dof + 1
  end do
  this%number_interior_dofs = current_dof - 1

  call this%count_and_fill_coarse_subedges_and_owned_fine_edges( par_fe_space )
  call this%fill_dofs_in_coarse_edges_renumbering( current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire )
  this%number_edge_wire_dofs = (current_dof-1) - this%number_interior_dofs

  call this%fill_dofs_coupled_to_coarse_edges_renumbering( current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire )
  this%number_total_wire_dofs = (current_dof-1) - this%number_interior_dofs

  ! Last, remaining interface dofs that are not coupled to edges are filled 
  do idof = 1, par_fe_space%get_block_number_dofs(iblock)
     if (perm_new2wire(idof) == 0) then 
        perm_new2wire(idof) = current_dof   
        current_dof = current_dof + 1
     end if
  end do

  do idof=1, par_fe_space%get_block_number_dofs(iblock) 
     perm_old2new(idof) = perm_new2wire(perm_old2new(idof))
  end do

  call par_fe_space%free_fe_iterator(fe)
  call memfree(perm_new2wire, __FILE__, __LINE__)

end subroutine Hcurl_l1_renumber_interface_dofs_first_E_then_Ec

subroutine Hcurl_l1_fill_dofs_in_coarse_edges_renumbering( this, current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)       , intent(inout)  :: this
  integer(ip)                               , intent(inout)  :: current_dof 
  integer(ip)                               , intent(in)     :: iblock 
  type(par_fe_space_t)                      , intent(in)     :: par_fe_space 
  integer(ip) , allocatable                 , intent(inout)  :: perm_old2new(:)
  integer(ip) , allocatable                 , intent(inout)  :: perm_new2wire(:) 

  ! Iterators 
  type(list_iterator_t)                  :: fine_edges_iterator
  type(fe_vef_iterator_t)                :: vef
  integer(ip)                            :: ivef_within_cell
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 

  integer(ip)            , pointer       :: elem2dof(:)
  integer(ip)                            :: field_id
  integer(ip)                            :: fine_edge_direction
  integer(ip)                            :: idof, istat
  integer(ip)                            :: first_dof_in_edge, own_dof 
  
  call par_fe_space%create_fe_iterator(fe) 
  call par_fe_space%create_fe_vef_iterator(vef) 
  field_id = par_fe_space%field_blocks(iblock)

  fine_edges_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator() 
  do while ( .not. fine_edges_iterator%is_upper_bound() )

     call vef%set_lid( fine_edges_iterator%get_current() ) 
     call vef%get_cell_around(1,fe)
     call fe%get_field_elem2dof(field_id, elem2dof)
     ivef_within_cell = fe%find_lpos_vef_lid( vef%get_lid() )
     own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)

	 first_dof_in_edge = current_dof 
     do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )			     
        idof     = own_dofs_on_vef_iterator%get_current()
		 
		if (elem2dof(idof) .gt. 0 ) then 
        if (perm_new2wire(perm_old2new(elem2dof(idof))) .eq. 0) then
           call this%fine_edge_direction%get( key=vef%get_lid(), val=fine_edge_direction, stat=istat); check(istat==key_found) 
           select case ( fine_edge_direction ) 
           case ( same_as_coarse_edge ) 
              perm_new2wire(perm_old2new(elem2dof(idof))) = current_dof 
           case ( opposite_to_coarse_edge ) 
              perm_new2wire(perm_old2new(elem2dof(idof))) = (first_dof_in_edge + (this%order-1) ) - (current_dof - first_dof_in_edge) 
           end select
           current_dof = current_dof + 1
        end if
        end if 
		call own_dofs_on_vef_iterator%next()
     end do
     
     call fine_edges_iterator%next() 	  
  end do

  call fine_edges_iterator%free() 
  call par_fe_space%free_fe_iterator(fe) 
  call par_fe_space%free_fe_vef_iterator(vef) 

end subroutine Hcurl_l1_fill_dofs_in_coarse_edges_renumbering

subroutine Hcurl_l1_fill_dofs_coupled_to_coarse_edges_renumbering( this, current_dof, iblock, par_fe_space, perm_old2new, perm_new2wire) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)       , intent(inout)  :: this
  integer(ip)                               , intent(inout)  :: current_dof 
  integer(ip)                               , intent(in)     :: iblock 
  type(par_fe_space_t)                      , intent(in)     :: par_fe_space 
  integer(ip) , allocatable                 , intent(inout)  :: perm_old2new(:)
  integer(ip) , allocatable                 , intent(inout)  :: perm_new2wire(:) 

  ! Iterators 
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef_within_object, vef_within_cell 
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 

  integer(ip),  pointer       :: elem2dof(:)
  integer(ip) :: field_id 
  integer(ip) :: iedge_coarse, ielem  
  integer(ip) :: idof, istat
  integer(ip) :: ivef_within_object, ivef_within_cell 
  integer(ip) :: ivef_within_edge_adjacent_cell 

  field_id = par_fe_space%field_blocks(iblock)  
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call par_fe_space%create_fe_vef_iterator(vef_within_cell)

  iedge_coarse = 0   
  call object%first() 
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
        iedge_coarse = iedge_coarse + 1
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object,vef_within_object)
           ! Check corners&edge -container elements 
           do ielem = 1, vef_within_object%get_num_cells_around() 
              call vef_within_object%get_cell_around(ielem,fe)
              if ( fe%is_local() ) then 
                 ! Loop over all vefs on fe and count the interface dofs, vefs_in_cell all vefs in the cell containing vef_in_object 	   
                 do ivef_within_edge_adjacent_cell=1, fe%get_num_vefs()
                    call fe%get_vef(ivef_within_edge_adjacent_cell, vef_within_cell )
                    if ( vef_within_cell%is_at_interface() ) then ! Only interested in interface wire numbering 
                       call fe%get_field_elem2dof(field_id, elem2dof)
                       ivef_within_cell = fe%find_lpos_vef_lid(vef_within_cell%get_lid())
                       own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
                       ! Loop over interface dofs contained in the interface vef and assign numbering 
                       do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                          idof    = own_dofs_on_vef_iterator%get_current()

                          if (elem2dof(idof)>0) then 
                             if ( perm_new2wire(perm_old2new(elem2dof(idof))) .eq. 0 ) then
                                perm_new2wire(perm_old2new(elem2dof(idof))) = current_dof 
                                current_dof = current_dof + 1
                             end if
                          end if
                          call own_dofs_on_vef_iterator%next()
                       end do

                    end if
                 end do
              end if
           end do

        end do
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_vef_iterator(vef_within_cell)

end subroutine Hcurl_l1_fill_dofs_coupled_to_coarse_edges_renumbering

function Hcurl_l1_compute_edge_length(this, par_fe_space, vef) result(edge_length) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(fe_vef_iterator_t)               , intent(in)    :: vef 
  real(rp)   :: edge_length  


  class(fe_iterator_t), allocatable         :: fe 
  type(fe_vef_iterator_t)                   :: vertex 
  class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
  integer(ip)                               :: ivef_within_cell, istat
  integer(ip)                               :: vertex_within_edge_id, vertex_within_cell_id 
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  type(point_t), allocatable                :: cell_coordinates(:)
  type(point_t), allocatable                :: node_coordinates(:)
  type(point_t)                             :: tangent_vector

  assert( vef%get_dimension() == 1 ) 
  edge_length = 0.0_rp 
  call par_fe_space%create_fe_iterator(fe) 
  call par_fe_space%create_fe_vef_iterator(vertex) 
  allocate(cell_coordinates( fe%cell%get_num_nodes() ) , stat=istat); check(istat==0)
  allocate(node_coordinates(2), stat=istat); check(istat==0) 

  call vef%get_cell_around(1,fe)  
  ref_fe_geo => fe%get_reference_fe_geo()

  ivef_within_cell          = fe%find_lpos_vef_lid(vef%get_lid())     
  vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
  vertices_of_line_iterator = vertices_of_line%create_iterator(ivef_within_cell)

  vertex_within_edge_id     = 0
  do while( .not. vertices_of_line_iterator%is_upper_bound() )
     vertex_within_edge_id = vertex_within_edge_id + 1
     vertex_within_cell_id = vertices_of_line_iterator%get_current()
     call fe%get_vef(vertex_within_cell_id, vertex )
     call fe%cell%get_coordinates(cell_coordinates)		
     node_coordinates(vertex_within_edge_id)   = cell_coordinates(vertex_within_cell_id) 
     call vertices_of_line_iterator%next() 
  end do

  tangent_vector = node_coordinates(2) - node_coordinates(1)
  edge_length = tangent_vector%nrm2() 
 
  call par_fe_space%free_fe_vef_iterator(vertex) 
  call par_fe_space%free_fe_iterator(fe) 
  deallocate( cell_coordinates , stat=istat); check(istat==0) 
  deallocate( node_coordinates,  stat=istat); check(istat==0) 

end function Hcurl_l1_compute_edge_length

subroutine Hcurl_l1_get_BDDC_edge_continuity_algorithm_case( parameter_list, algorithm )
  implicit none
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  integer(ip)                           , intent(out)   :: algorithm

  character(len=*), parameter :: bddc_edge_continuity_algorithm_key     = 'bddc_edge_continuity_algorithm'
  integer(ip) :: FPLError

  assert(parameter_list%isAssignable(bddc_edge_continuity_algorithm_key, algorithm))
  FPLError = parameter_list%Get(bddc_edge_continuity_algorithm_key, algorithm)
  assert(FPLError == 0)

end subroutine Hcurl_l1_get_BDDC_edge_continuity_algorithm_case


subroutine Hcurl_l1_count_and_fill_coarse_subedges_and_owned_fine_edges( this, par_fe_space ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)       , intent(inout)  :: this
  type(par_fe_space_t)                      , intent(in)     :: par_fe_space 

  ! Iterators 
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef_within_object, vef_within_cell 
  class(fe_iterator_t), allocatable      :: fe
  integer(ip)                            :: ivef_within_cell, ivef_within_object
  integer(ip)                            :: iedge, istat

  ! Vertices in edges  
  type(fe_vef_iterator_t)                   :: vertex 
  class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  integer(ip)                               :: vertex_within_cell_id, vertex_within_edge_id  
  integer(ip)                               :: fine_edge, node_id
  integer(ip) , allocatable                 :: vertices_in_edge(:,:)

  ! Coarse vertices checker 
  integer(ip)                               :: number_coarse_vertices 
  integer(ip)                               :: number_nodes, inode  
  integer(ip), allocatable                  :: node_list(:)
  type(hash_table_ip_ip_t)                  :: nodes_counter
  type(hash_table_ip_ip_t), allocatable     :: edge_interior_vertices(:) 
  integer(ip)                               :: counter

  integer(ip)             , allocatable   :: number_fine_edges_per_coarse_edge(:)
  integer(ip)             , allocatable   :: fine_edges_list(:,:) 
  integer(ip)             , allocatable   :: perm_sorted_edges(:,:) 
  integer                                 :: number_coarse_edges, iedge_coarse, iedge_fine 

  ! Subedges counterpart 
  integer(ip)  :: number_potential_startend_nodes 
  integer(ip)  :: number_subedges, start_node 

  ! Edge sorting algorithms 
  logical                  :: reached_endpoint, found_following_edge
  logical                  :: bifurcation_occurred 
  integer(ip)              :: preceding_node, following_node
  integer(ip), allocatable :: perm(:) 
  integer(ip)              :: c 
  type(list_iterator_t)    :: subedges_iterator
  type(list_iterator_t)    :: fine_edges_in_subedges_iterator
  type(hash_table_ip_ip_t) :: number_fine_edges_per_subedge, added_edges   
  integer(ip)              :: number_subedges_in_coarse_edge 
  integer(ip)              :: total_number_subedges, isubedge, number_fine_edges
  integer(ip)              :: local_to_coarse_edge, local_to_coarse_subedge

  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call par_fe_space%create_fe_vef_iterator(vef_within_cell)
  call par_fe_space%create_fe_vef_iterator(vertex)
  
  ! Initialize variables 
  total_number_subedges  = 0
  number_coarse_vertices = 0
  number_coarse_edges    = 0

  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 0 ) then 
        number_coarse_vertices = number_coarse_vertices + 1
     elseif ( object%get_dimension() == 1 ) then 
        number_coarse_edges = number_coarse_edges + 1
     end if
     call object%next() 
  end do

  call memalloc( number_coarse_edges, number_fine_edges_per_coarse_edge, __FILE__, __LINE__ ) 
  number_fine_edges_per_coarse_edge = 0  
  allocate( edge_interior_vertices(number_coarse_edges), stat=istat); check(istat==0)
  
  iedge_coarse   = 0
  call object%first() 
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
        iedge_coarse = iedge_coarse + 1
		call edge_interior_vertices(iedge_coarse)%init(100)
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
		   if ( vef_within_object%get_dimension() == 0 ) then  
		      call edge_interior_vertices(iedge_coarse)%put( key=vef_within_object%get_lid(), val=1, stat=istat); check(istat==now_stored)
           elseif ( vef_within_object%get_dimension() == 1 .and. (.not. vef_within_object%is_at_boundary() ) ) then  
              number_fine_edges_per_coarse_edge( iedge_coarse ) = number_fine_edges_per_coarse_edge( iedge_coarse ) + 1
           end if
        end do
     end if
     call object%next() 
  end do
  
  call this%subedges_per_coarse_edge%create( number_coarse_edges ) 
  call number_fine_edges_per_subedge%init( sum(number_fine_edges_per_coarse_edge) )
  call this%fine_edge_direction%init( sum(number_fine_edges_per_coarse_edge) )
  call memalloc( number_coarse_edges, maxval(number_fine_edges_per_coarse_edge), fine_edges_list, __FILE__, __LINE__ ) 
  call memalloc( number_coarse_edges, maxval(number_fine_edges_per_coarse_edge), perm_sorted_edges, __FILE__, __LINE__ )
  call added_edges%init(sum(number_fine_edges_per_coarse_edge)) 
  fine_edges_list   = 0
  perm_sorted_edges = 0

  call object%first() 
  iedge_coarse = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then
        iedge_coarse = iedge_coarse + 1	   

        ! Initialize variables 
        call memalloc( number_fine_edges_per_coarse_edge(iedge_coarse), 2, vertices_in_edge, __FILE__, __LINE__ )
        call nodes_counter%init( 2*number_fine_edges_per_coarse_edge(iedge_coarse) )
        call memalloc( 2*number_fine_edges_per_coarse_edge(iedge_coarse), node_list, __FILE__, __LINE__ )

        vertices_in_edge = 0
        node_list        = 0
        number_nodes     = 0

        iedge_fine = 0
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 .and. (.not. vef_within_object%is_at_boundary() ) ) then
              iedge_fine = iedge_fine + 1
              fine_edges_list(iedge_coarse, iedge_fine) = vef_within_object%get_lid() 

              call vef_within_object%get_cell_around(1,fe) 
              ref_fe_geo                => fe%get_reference_fe_geo()
              vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
              ivef_within_cell          = fe%find_lpos_vef_lid(vef_within_object%get_lid())     
              vertices_of_line_iterator = vertices_of_line%create_iterator(ivef_within_cell)
              vertex_within_edge_id     = 1

              do while( .not. vertices_of_line_iterator%is_upper_bound() )
                 vertex_within_cell_id = vertices_of_line_iterator%get_current()
                 call fe%get_vef(vertex_within_cell_id, vertex )
                 node_id = vertex%get_lid() 		

                 ! Fill vertices in each edge   
                 vertices_in_edge( iedge_fine, vertex_within_edge_id )  = node_id 

                 ! Count how many times nodes appears
                 call nodes_counter%get( key=node_id, val=counter, stat=istat )
                 if ( istat/=key_found ) then 
                    number_nodes = number_nodes + 1
                    node_list(number_nodes) = node_id	
                    call nodes_counter%put(key=node_id, val=1, stat=istat)
                 else 
                    counter = counter + 1
                    call nodes_counter%del(key=node_id, stat=istat)
                    call nodes_counter%put(key=node_id, val=counter, stat=istat)
                 end if

                 vertex_within_edge_id = vertex_within_edge_id + 1
                 call vertices_of_line_iterator%next() 
              end do

           end if
        end do
		
		call mark_nodes_not_belonging_to_edge_object( edge_interior_vertices(iedge_coarse), nodes_counter )		
        call count_number_subedges( node_list, nodes_counter, number_subedges_in_coarse_edge, number_potential_startend_nodes ) 	
        call this%subedges_per_coarse_edge%sum_to_pointer_index(iedge_coarse, number_subedges_in_coarse_edge)

        local_to_coarse_edge = 0	
		bifurcation_occurred = .false. 
        do isubedge = 1, number_subedges_in_coarse_edge
           total_number_subedges = total_number_subedges + 1 
		   if  ( .not. bifurcation_occurred ) then 
		   start_node = identify_following_starting_node_from_list( number_potential_startend_nodes, node_list, nodes_counter )
           call build_path_from_starting_node() 
		   elseif ( bifurcation_occurred ) then 
		   start_node = following_node 
		   call build_path_from_bifurcation_node()
		   end if 
        end do

        call memfree(vertices_in_edge, __FILE__, __LINE__)
        call nodes_counter%free()
        call memfree( node_list, __FILE__, __LINE__ )
     end if
     call object%next() 
  end do

  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_vef_iterator(vef_within_cell)
  call par_fe_space%free_fe_vef_iterator(vertex)

  ! Build definitive lists 
  call this%subedges_per_coarse_edge%calculate_header()
  call this%subedges_per_coarse_edge%allocate_list_from_pointer()	

  c=0 
  subedges_iterator = this%subedges_per_coarse_edge%create_iterator()
  do while ( .not. subedges_iterator%is_upper_bound() )
     c = c + 1
     call subedges_iterator%set_current(c)
     call subedges_iterator%next()
  end do

  call create_and_fill_sorted_fine_edges_list() 

  call memfree( fine_edges_list, __FILE__, __LINE__ ) 
  call memfree( perm_sorted_edges, __FILE__, __LINE__ )
  call number_fine_edges_per_subedge%free()
  call added_edges%free()
  call fine_edges_in_subedges_iterator%free()  
  call memfree( number_fine_edges_per_coarse_edge, __FILE__, __LINE__ ) 
  deallocate( edge_interior_vertices, stat=istat); check(istat==0)

contains 

subroutine mark_nodes_not_belonging_to_edge_object( edge_interior_vertices, nodes_counter ) 
implicit none 
  type(hash_table_ip_ip_t)  , intent(inout)   :: nodes_counter
  type(hash_table_ip_ip_t)  , intent(in)      :: edge_interior_vertices
  
  integer(ip) :: inode
  integer(ip) :: counter, istat 

		 do inode=1, number_nodes 
           call edge_interior_vertices%get(key=node_list(inode), val=counter, stat=istat) 
           if ( istat==key_not_found ) then 
		      call nodes_counter%get(key=node_list(inode), val=counter, stat=istat) 
			  if ( counter == 2) then 
              call nodes_counter%del(key=node_list(inode), stat=istat)
              call nodes_counter%put(key=node_list(inode), val=-counter, stat=istat)
			  end if 
           end if
        end do
		
end subroutine mark_nodes_not_belonging_to_edge_object
		
  subroutine count_number_subedges(node_list, nodes_counter, number_subedges, number_potential_startend_nodes)
    implicit none 
    integer(ip) , allocatable , intent(in) :: node_list(:) 
    type(hash_table_ip_ip_t)  , intent(in) :: nodes_counter 
    integer(ip) :: number_subedges 

    integer(ip) :: ncorners_in_edge, number_potential_startend_nodes
    integer(ip) :: ninterior_node, nbifurcation_node 

    ncorners_in_edge     = 0
    number_potential_startend_nodes = 0
    ninterior_node       = 0
    nbifurcation_node    = 0 
    do inode=1, number_nodes 
       call nodes_counter%get( key=node_list(inode), val=counter, stat=istat) 
       if (counter.lt.0)  then 
          ncorners_in_edge      = ncorners_in_edge + 1
       elseif (counter==1) then 
          number_potential_startend_nodes  = number_potential_startend_nodes + 1
       elseif (counter==2) then
          ninterior_node        = ninterior_node + 1
       elseif (counter==3) then
          nbifurcation_node     = nbifurcation_node + 1
       elseif (counter>3) then 
          WRITE(*,*) 'ABORTING: bifurcation into', counter, 'paths' ; check(.false.) 
       end if
    end do

	if ( (number_potential_startend_nodes == 0) .and. ( (ninterior_node + ncorners_in_edge + nbifurcation_node) /= 0) ) then 
    WRITE(*,*) 'ABORTING: Partition gives place a closed path coarse edge'; check(.false.) 
	end if 
	
	!WRITE(*,*) 'Edge partitioning resume: *************************'
	!WRITE(*,*) 'Found', ncorners_in_edge, 'adjacent edge problematic cases,', number_potential_startend_nodes, &
	!           'Start/end nodes', nbifurcation_node, 'bifurcation nodes', ninterior_node, 'Interior nodes'
	!WRITE(*,*) '***************************************************'
    number_subedges = ( number_potential_startend_nodes + 3*nbifurcation_node + 2*ncorners_in_edge )/2 

  end subroutine count_number_subedges

  function identify_following_starting_node_from_list( number_potential_startend_nodes, node_list, nodes_counter ) result(start_node) 
    implicit none 
    integer(ip)               , intent(in) :: number_potential_startend_nodes
    integer(ip) , allocatable , intent(in) :: node_list(:) 
    type(hash_table_ip_ip_t)  , intent(in) :: nodes_counter 
    integer(ip)     :: start_node 

    integer(ip)                         :: inode
    integer(ip)                         :: found_nodes, istat 
    integer(ip)  , allocatable          :: start_end_nodes(:) 

    call memalloc( number_potential_startend_nodes, start_end_nodes, __FILE__, __LINE__ )
    
    found_nodes = 0
    do inode=1, size(node_list)  
       call nodes_counter%get( key=node_list(inode), val=counter, stat=istat)
       if ( (istat==key_found) .and. (counter == 1) ) then
          found_nodes = found_nodes + 1
          start_end_nodes( found_nodes ) = node_list(inode) 
       end if
    end do
	
	call find_node_w_minimum_nonconsecutive_gid( par_fe_space, start_end_nodes, start_node ) 
  
    call memfree( start_end_nodes, __FILE__, __LINE__ )
    
  end function identify_following_starting_node_from_list 
  	
 subroutine find_node_w_minimum_nonconsecutive_gid( par_fe_space, nodes_array, local_node_w_min_gid, pos_in_array) 
   implicit none 
   type(par_fe_space_t)       , intent(in)   :: par_fe_space
   integer(ip)  , allocatable,  intent(in)   :: nodes_array(:) 
   integer(ip)                , intent(inout):: local_node_w_min_gid 
   integer(ip), optional      , intent(inout):: pos_in_array 

   class(fe_iterator_t), allocatable        :: fe 
   type(fe_vef_iterator_t)                  :: vertex

   type(par_triangulation_t)         :: triangulation
   integer(igp)  , allocatable       :: node_gids(:) 
   integer(ip)                    :: inode, npotential_candidates 
   integer(igp)                   :: cell_around_gid, maximum_cell_around_gid 
   integer(ip)                    :: ielem, ielem_with_max_gid, inode_w_min_gid 

   npotential_candidates = size(nodes_array)
   call memalloc( npotential_candidates, node_gids,  __FILE__, __LINE__ )

   call par_fe_space%create_fe_iterator(fe)
   call par_fe_space%create_fe_vef_iterator(vertex) 
 
   do inode=1, npotential_candidates
      call vertex%set_lid(nodes_array(inode))
	  maximum_cell_around_gid = 0 
      do ielem = 1, vertex%get_num_cells_around()  
         call vertex%get_cell_around(ielem,fe)
         cell_around_gid = fe%get_gid()	
         if ( cell_around_gid > maximum_cell_around_gid ) then 
            maximum_cell_around_gid = cell_around_gid
            ielem_with_max_gid      = ielem 
         end if
      end do
      call vertex%get_cell_around(ielem_with_max_gid, fe)
      ivef_within_cell = fe%find_lpos_vef_lid(vertex%get_lid())
      node_gids(inode) = triangulation%generate_non_consecutive_vef_gid( maximum_cell_around_gid, ivef_within_cell, 1 )  
   end do
   
   call par_fe_space%free_fe_iterator(fe)
   call par_fe_space%free_fe_vef_iterator(vertex)

   inode_w_min_gid      = minloc( node_gids, DIM=1 ) 
   local_node_w_min_gid = nodes_array( inode_w_min_gid ) 
   
   if (present(pos_in_array)) pos_in_array = inode_w_min_gid

   call memfree( node_gids, __FILE__, __LINE__ )
 end subroutine find_node_w_minimum_nonconsecutive_gid

  subroutine build_path_from_starting_node() 

    call memalloc( 2, perm, __FILE__, __LINE__ ) 
    perm(1) = 2; perm(2) = 1; 
	
    call nodes_counter%del( key=start_node, stat=istat)
    number_potential_startend_nodes = number_potential_startend_nodes - 1

    following_node           = start_node 
    local_to_coarse_subedge  = 0 
    reached_endpoint         = .false. 
    do while ( .not. reached_endpoint )
       found_following_edge = .false. 
       do iedge = 1, number_fine_edges_per_coarse_edge(iedge_coarse)
          do inode = 1,2
             if ( (vertices_in_edge( iedge, inode) == following_node) ) then		         
                call added_edges%put(fine_edges_list(iedge_coarse, iedge), val=local_to_coarse_edge+1, stat=istat)

                if ( istat/=was_stored ) then 
                   local_to_coarse_edge = local_to_coarse_edge + 1	
                   local_to_coarse_subedge = local_to_coarse_subedge + 1
                   perm_sorted_edges(iedge_coarse, local_to_coarse_edge) = iedge
                   if ( inode .eq. 1 ) then
                      call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=same_as_coarse_edge, stat=istat)
                   else 
                      call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=opposite_to_coarse_edge, stat=istat)   
                   end if

                   found_following_edge = .true. 
				   preceding_node = vertices_in_edge(iedge, inode)
                   following_node = vertices_in_edge(iedge, perm(inode))  

                   ! Choose path 
                   call nodes_counter%get( key=following_node, val=counter, stat=istat) 
                   if (counter.lt.0)  then 
                      reached_endpoint = .true. 
                      call nodes_counter%del( key=following_node, stat=istat) 
                      call nodes_counter%put( key=following_node, val=1, stat=istat)
                      number_potential_startend_nodes = number_potential_startend_nodes + 1
                   elseif ( counter==1 ) then
                      reached_endpoint = .true.
                      call nodes_counter%del( key=following_node, stat=istat)
                      number_potential_startend_nodes = number_potential_startend_nodes - 1
                   elseif (counter==2 ) then
                      call nodes_counter%del( key=following_node, stat=istat)
                   elseif (counter==3) then 
				      reached_endpoint    = .true. 
					  bifurcation_occurred = .true. 
                      WRITE(*,*) 'Handling a bifurcation';  
                   end if

                   exit 
                end if

             end if
          end do
          if (found_following_edge) exit 
       end do
    end do

    call number_fine_edges_per_subedge%put( key=total_number_subedges, val=local_to_coarse_subedge, stat=istat ); check(istat==now_stored) 
    call memfree(perm, __FILE__, __LINE__) 

  end subroutine build_path_from_starting_node
  
  subroutine build_path_from_bifurcation_node() 
  implicit none 
  integer(ip) :: dummy_val, i, index 
  integer(ip) , allocatable :: potential_following_nodes(:)
  integer(ip) , allocatable :: potential_following_edges(:) 

    call memalloc( 2, perm, __FILE__, __LINE__ ) 
    perm(1) = 2; perm(2) = 1; 
	call memalloc( 2, potential_following_nodes, __FILE__, __LINE__ ) 
	call memalloc( 2, potential_following_edges, __FILE__, __LINE__ )

	dummy_val                = 0 
    following_node           = start_node 
    local_to_coarse_subedge  = 0 
    reached_endpoint         = .false. 
	bifurcation_occurred     = .false. 
	
	 ! Set bifurcation node as a potential start/end node 
	 call nodes_counter%del( key=following_node, stat=istat) 
     call nodes_counter%put( key=following_node, val=1, stat=istat)
     number_potential_startend_nodes = number_potential_startend_nodes + 1
	
	! Find potential directions  
	   i = 0
	   do iedge = 1, number_fine_edges_per_coarse_edge(iedge_coarse)
          do inode = 1,2
             if ( (vertices_in_edge( iedge, inode) == following_node) .and. (vertices_in_edge(iedge, perm(inode)) /= preceding_node) ) then	
				     i = i + 1
				     potential_following_nodes(i) = vertices_in_edge(iedge, perm(inode)) 
					 potential_following_edges(i) = iedge 
				 end if 
			 end do 
			 end do 
			 	 
	 call find_node_w_minimum_nonconsecutive_gid( par_fe_space, potential_following_nodes, following_node, index )
	   
	 ! Add first VEF from the minimum coordinate based direction 
	 iedge = potential_following_edges(index)
     call added_edges%put(fine_edges_list(iedge_coarse, iedge), val=local_to_coarse_edge+1, stat=istat); assert(istat/=was_stored) 
	 	 
	  local_to_coarse_edge = local_to_coarse_edge + 1	
      local_to_coarse_subedge = local_to_coarse_subedge + 1
      perm_sorted_edges(iedge_coarse, local_to_coarse_edge) = iedge
       if ( vertices_in_edge(iedge,1) == start_node ) then
         call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=same_as_coarse_edge, stat=istat)
       else 
         call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=opposite_to_coarse_edge, stat=istat)   
       end if

       ! Choose path 
       call nodes_counter%get( key=following_node, val=counter, stat=istat) 
       if (counter.lt.0)  then 
        reached_endpoint = .true. 
       call nodes_counter%del( key=following_node, stat=istat) 
       call nodes_counter%put( key=following_node, val=1, stat=istat)
        number_potential_startend_nodes = number_potential_startend_nodes + 1
       elseif ( counter==1 ) then
        reached_endpoint = .true.
       call nodes_counter%del( key=following_node, stat=istat)
        number_potential_startend_nodes = number_potential_startend_nodes - 1
       elseif (counter==2 ) then
        call nodes_counter%del( key=following_node, stat=istat)
       elseif (counter==3) then 
		reached_endpoint    = .true. 
		bifurcation_occurred = .true. 
        WRITE(*,*) 'Handling a bifurcation';  
       end if
					
    do while ( .not. reached_endpoint )
       found_following_edge = .false. 
       do iedge = 1, number_fine_edges_per_coarse_edge(iedge_coarse)
          do inode = 1,2
             if ( (vertices_in_edge( iedge, inode) == following_node) ) then		         
                call added_edges%put(fine_edges_list(iedge_coarse, iedge), val=local_to_coarse_edge+1, stat=istat)

                if ( istat/=was_stored ) then 
                   local_to_coarse_edge = local_to_coarse_edge + 1	
                   local_to_coarse_subedge = local_to_coarse_subedge + 1
                   perm_sorted_edges(iedge_coarse, local_to_coarse_edge) = iedge
                   if ( inode .eq. 1 ) then
                      call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=same_as_coarse_edge, stat=istat)
                   else 
                      call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=opposite_to_coarse_edge, stat=istat)   
                   end if

                   found_following_edge = .true. 
                   following_node = vertices_in_edge(iedge, perm(inode))  

                   ! Choose path 
                   call nodes_counter%get( key=following_node, val=counter, stat=istat) 
                   if (counter.lt.0)  then 
                      reached_endpoint = .true. 
                      call nodes_counter%del( key=following_node, stat=istat) 
                      call nodes_counter%put( key=following_node, val=1, stat=istat)
                      number_potential_startend_nodes = number_potential_startend_nodes + 1
                   elseif ( counter==1 ) then
                      reached_endpoint = .true.
                      call nodes_counter%del( key=following_node, stat=istat)
                      number_potential_startend_nodes = number_potential_startend_nodes - 1
                   elseif (counter==2 ) then
                      call nodes_counter%del( key=following_node, stat=istat)
                   elseif (counter==3) then 
				      reached_endpoint    = .true. 
					  bifurcation_occurred = .true. 
                      WRITE(*,*) 'Handling a bifurcation';  
                   end if

                   exit 
                end if

             end if
          end do
          if (found_following_edge) exit 
       end do
    end do

    call number_fine_edges_per_subedge%put( key=total_number_subedges, val=local_to_coarse_subedge, stat=istat ); check(istat==now_stored) 
    call memfree(perm, __FILE__, __LINE__) 
    call memfree(potential_following_nodes, __FILE__, __LINE__ )
	call memfree(potential_following_edges, __FILE__, __LINE__ ) 
	
  end subroutine build_path_from_bifurcation_node

  subroutine create_and_fill_sorted_fine_edges_list( )

    call this%sorted_fine_edges_in_coarse_subedge%create( this%subedges_per_coarse_edge%get_size() )
    do isubedge = 1, this%subedges_per_coarse_edge%get_size()
       call number_fine_edges_per_subedge%get( key=isubedge, val=number_fine_edges, stat=istat ); check(istat==key_found) 
       call this%sorted_fine_edges_in_coarse_subedge%sum_to_pointer_index(isubedge, number_fine_edges )
    end do

    call this%sorted_fine_edges_in_coarse_subedge%calculate_header()
    call this%sorted_fine_edges_in_coarse_subedge%allocate_list_from_pointer()	

    fine_edges_in_subedges_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator()
    do iedge_coarse = 1, number_coarse_edges 
       do c=1, number_fine_edges_per_coarse_edge(iedge_coarse)
          call fine_edges_in_subedges_iterator%set_current( fine_edges_list(iedge_coarse, perm_sorted_edges(iedge_coarse,c) ) )
          call fine_edges_in_subedges_iterator%next() 
       end do
    end do
	
    call this%sorted_fine_edges_in_coarse_subedge%print(6) 

  end subroutine create_and_fill_sorted_fine_edges_list

end subroutine Hcurl_l1_count_and_fill_coarse_subedges_and_owned_fine_edges
