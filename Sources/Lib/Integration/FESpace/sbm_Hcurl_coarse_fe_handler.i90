! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine Hcurl_l1_setup_constraint_matrix(this, par_fe_space, parameter_list, constraint_matrix) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  type(coo_sparse_matrix_t)             , intent(inout) :: constraint_matrix
  type(environment_t), pointer           :: par_environment
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef
  class(fe_iterator_t), allocatable      :: fe
  type(list_iterator_t)                  :: own_coarse_dofs_iterator
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 
  integer(ip)                            :: off
  integer(ip) :: field_id
  integer(ip) :: num_rows, num_cols
  integer(ip) :: num_fine_dofs_on_coarse_dof
  integer(ip) :: iface_within_object, ivef_within_cell, ivef_within_object, idof, dof_lid, coarse_dof_lid

  class(base_static_triangulation_t), pointer :: triangulation

  ! FE space traversal-related data types
  type(fe_face_iterator_t)            :: fe_face

  ! Face integration-related data types
  type(quadrature_t)     , pointer     :: quad
  type(face_map_t)       , pointer     :: face_map
  type(fe_map_t)         , pointer     :: face_map_face_map 
  type(face_integrator_t), pointer     :: face_int
  type(vector_field_t)                 :: shape_trial
  integer(ip)            , pointer     :: elem2dof(:)
  type(i1p_t)        , allocatable     :: test_elem2dof(:)

  ! FACE vector
  real(rp), allocatable                :: facevec(:)

  integer(ip)  :: istat
  integer(ip)  :: qpoint, num_quad_points
  real(rp)     :: factor
			
  par_environment => par_fe_space%get_par_environment()
  assert (associated(par_environment))
  assert (par_environment%am_i_l1_task())

  triangulation => par_fe_space%get_triangulation()
  allocate (test_elem2dof(1), stat=istat); check(istat==0);

  ! To-think where field_id should come from? Temporarily let us assume that we have
  ! a single-field PDE problem
  field_id = 1

  ! Free any dynamic memory that constraint_matrix may have inside
  call constraint_matrix%free()

  num_rows = par_fe_space%number_dofs_per_field(field_id)
  num_cols = par_fe_space%ptr_coarse_dofs_per_field(field_id+1)- &
       par_fe_space%ptr_coarse_dofs_per_field(field_id) 

  call memalloc(par_fe_space%get_max_number_shape_functions(), facevec, __FILE__, __LINE__ )

  ! Create constraint matrix (transposed)
  call constraint_matrix%create ( num_rows, num_cols )
 
  ! Fill constraint matrix entries (transposed)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_face_iterator(fe_face)
  call par_fe_space%create_fe_vef_iterator(vef)
  do while ( .not. object%has_finished() )
     if ( object%get_number_coarse_dofs(field_id) > 0 ) then

        own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(field_id)
        assert ( own_coarse_dofs_iterator%get_size() == 1 )

        coarse_dof_lid = own_coarse_dofs_iterator%get_current() 

        ! Face coarse DoF
        if ( object%get_dimension () == triangulation%get_num_dimensions()-1) then
           do iface_within_object=1, object%get_num_faces()
              call object%get_face(iface_within_object,fe_face)
              quad     => fe_face%get_quadrature()
              face_int => fe_face%get_face_integrator(1)
              face_map => fe_face%get_face_map()
			  
              call fe_face%get_cell_around(1,fe)
              facevec = 0.0_rp
              call fe_face%update_integration() 
              do qpoint = 1, quad%get_number_quadrature_points()
                 factor = face_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)
                 do idof = 1, fe%get_number_dofs()
                    call face_int%get_value(idof,qpoint,1,shape_trial)
                    facevec(idof) = facevec(idof) + factor
                 end do
              end do

              call fe_face%get_elem2dof(1, test_elem2dof)
              call constraint_matrix%insert(fe%get_number_dofs(), &
                                            test_elem2dof(1)%p, &
                                            coarse_dof_lid, &
                                            facevec)
           end do
        else    
           ! Arithmetic average on Either corner or edge coarse DoF
           num_fine_dofs_on_coarse_dof = 0 
           ! Count how many fine DoFs current coarse DoF aggregates
           do ivef_within_object=1, object%get_num_vefs()
              call object%get_vef(ivef_within_object,vef)
              call vef%get_cell_around(1,fe)
              call fe%get_field_elem2dof(field_id, elem2dof)
              ivef_within_cell = fe%find_lpos_vef_lid(vef%get_lid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof    = own_dofs_on_vef_iterator%get_current()
                 dof_lid = elem2dof(idof)
                 if ( dof_lid > 0 ) then
                    num_fine_dofs_on_coarse_dof = num_fine_dofs_on_coarse_dof + 1
                 end if
                 call own_dofs_on_vef_iterator%next()
              end do
           end do

           do ivef_within_object=1, object%get_num_vefs()
              call object%get_vef(ivef_within_object,vef)
              call vef%get_cell_around(1,fe)
              call fe%get_field_elem2dof(field_id, elem2dof)
              ivef_within_cell = fe%find_lpos_vef_lid(vef%get_lid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof    = own_dofs_on_vef_iterator%get_current()
                 dof_lid = elem2dof(idof)
                 if ( dof_lid > 0 ) then
                    call constraint_matrix%insert(dof_lid, coarse_dof_lid, 1.0_rp/real(num_fine_dofs_on_coarse_dof,rp))
                 end if
                 call own_dofs_on_vef_iterator%next()
              end do
           end do
        end if
     end if
     call object%next()
  end do
	
  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(fe_face)
  call par_fe_space%free_fe_vef_iterator(vef)
  deallocate (test_elem2dof, stat=istat); check(istat==0);
  call memfree(facevec, __FILE__, __LINE__ )
  call constraint_matrix%sort_and_compress()
  ! call constraint_matrix%print(6)
end subroutine Hcurl_l1_setup_constraint_matrix

subroutine Hcurl_l1_setup_change_basis_tools( this, par_fe_space ) 
implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                  , intent(in)       :: par_fe_space
  
  ! Define renumbering s.t. Wire Dofs [E,E^c]
  call this%compute_wire_dof_renumbering( par_fe_space )
  ! Sort fine edges in a coarse edge and give coarse unique orientation 
  call this%sort_fine_edges(par_fe_space)
  ! Compute the change basis arrays 
  call this%compute_edge_change_basis_matrix( par_fe_space )
  
end subroutine Hcurl_l1_setup_change_basis_tools

subroutine Hcurl_l1_allocate_and_fill_local_to_wire_dof_numbering(this, par_fe_space ) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space

  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef_within_object, vef_within_cell 
  class(fe_iterator_t), allocatable      :: fe
  type(fe_face_iterator_t)               :: fe_face
  integer(ip)            , pointer       :: elem2dof(:)
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 
  integer(ip) :: field_id, ielem 
  integer(ip) :: iface_within_object, ivef_within_cell, ivef_within_object, idof, dof_lid, coarse_dof_lid

  integer(ip)  :: number_wire_dofs, ivef_within_edge_adjacent_cell, iedge_coarse

  ! To-think where field_id should come from? Temporarily let us assume that we have
  ! a single-field PDE problem
  field_id = 1
  call memalloc ( par_fe_space%get_total_number_dofs(), this%local_to_wire_dof, __FILE__, __LINE__ ) 
  this%local_to_wire_dof=0

  ! Compute local numbering for the Wire Basket interface DOFs 
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_face_iterator(fe_face)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call par_fe_space%create_fe_vef_iterator(vef_within_cell)

  number_wire_dofs = 0
  this%number_coarse_edges = 0
  ! Every interface DOF on Edges or edge-container element Faces will be added in the Wire Basket numbering 
  ! In a first loop we add all DOFs belonging to COARSE EDGES (E)
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
        this%number_coarse_edges = this%number_coarse_edges + 1
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then  ! Only act if a fine edge has been found 
              call vef_within_object%get_cell_around(1,fe)
              call fe%get_field_elem2dof(field_id, elem2dof)
              ivef_within_cell = fe%find_lpos_vef_lid(vef_within_object%get_lid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof    = own_dofs_on_vef_iterator%get_current()
                 if (this%local_to_wire_dof(elem2dof(idof)) .eq. 0) then
                    number_wire_dofs = number_wire_dofs + 1
                    this%local_to_wire_dof(elem2dof(idof)) = number_wire_dofs
                 end if
                 call own_dofs_on_vef_iterator%next()
              end do
           end if

        end do
     end if
     call object%next()
  end do

  ! The new basis functions introduced in Edges will be 
    call memalloc ( number_wire_dofs, this%dofs_new_basis, __FILE__, __LINE__ )
    do idof=1, number_wire_dofs
    this%dofs_new_basis = idof
	end do 
  
  ! Assume same order for all elements in the Nedelec space 
	 this%order = fe%get_order(field_id) 
	
  ! In a second loop we add all remaining DOFs that are in touch to COARSE EDGES, faces and edges (E^c): 
  ! Run over fine edges contained in coarse edges > Run over local adjacent cells to those edges > Renumber dofs in local cells interface vefs  
  call object%first() 
  call memalloc( this%number_coarse_edges, this%number_fine_edges_per_coarse_edge, __FILE__, __LINE__ )
  this%number_fine_edges_per_coarse_edge = 0
  iedge_coarse = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
	     iedge_coarse = iedge_coarse + 1
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object,vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then ! Only check edge-container elements 
              this%number_fine_edges_per_coarse_edge( iedge_coarse ) = this%number_fine_edges_per_coarse_edge( iedge_coarse ) + 1
              ! Take local fes 
              do ielem = 1, vef_within_object%get_num_cells_around() 
                 call vef_within_object%get_cell_around(ielem,fe)
                 if ( fe%is_local() ) then 
                    ! Loop over all vefs on fe and count the interface dofs, vefs_in_cell all vefs in the cell containing vef_in_object 	   
                    do ivef_within_edge_adjacent_cell=1, fe%get_num_vefs()
                       call fe%get_vef(ivef_within_edge_adjacent_cell, vef_within_cell )
                       if ( vef_within_cell%is_at_interface() ) then ! Only interested in interface wire numbering 
                          call fe%get_field_elem2dof(field_id, elem2dof)
                          ivef_within_cell = fe%find_lpos_vef_lid(vef_within_cell%get_lid())
                          own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
                          ! Loop over interface dofs contained in the interface vef and assign numbering 
                          do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                             idof    = own_dofs_on_vef_iterator%get_current()
							 if (elem2dof(idof)>0) then 
                               if ( this%local_to_wire_dof(elem2dof(idof)) .eq. 0 ) then
                                number_wire_dofs = number_wire_dofs + 1
                                this%local_to_wire_dof(elem2dof(idof)) = number_wire_dofs
							   end if 
                             end if
                             call own_dofs_on_vef_iterator%next()
                          end do

                       end if
                    end do
                 end if
              end do

           end if
        end do
     end if
     call object%next()
  end do

  ! Ready to allocate local wire numbering and build the inverse 
  call memalloc ( number_wire_dofs, this%wire_to_local_dof, __FILE__, __LINE__ ) 
  this%wire_to_local_dof=0
  do idof=1, par_fe_space%get_total_number_dofs()
     if (this%local_to_wire_dof(idof) /= 0) then
        this%wire_to_local_dof(this%local_to_wire_dof(idof)) = idof
     end if
  end do

  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(fe_face)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_vef_iterator(vef_within_cell)

end subroutine Hcurl_l1_allocate_and_fill_local_to_wire_dof_numbering
  
subroutine Hcurl_l1_compute_edge_change_basis_matrix(this, par_fe_space)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp) , allocatable                                :: edge_elmat(:,:)

  call this%compute_edge_elmat(par_fe_space, edge_elmat)  
  call this%fill_edge_local_change_of_basis(par_fe_space, edge_elmat)
  ! Fill remaining change of basis part, E^c 
  ! (faces and edges not contained in the Coarse Edge but coupled to it by the Discrete Gradient) 

  call memfree(edge_elmat, __FILE__, __LINE__ ) 

end subroutine Hcurl_l1_compute_edge_change_basis_matrix

subroutine Hcurl_l1_compute_edge_elmat(this, par_fe_space, elmat)
  ! This subroutine computes the elemental 1D Discrete Gradient (phi',phi)_e matrix in a 
  ! reference edge. As the integration to be performed is not edge size-dependent Elemental 
  ! matrix in edges can be re-used for every edge just taking into acount the tangent direction.  
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(inout) :: elmat(:,:) 

  ! Local variables required by Wire edges moments integration
  class(reference_fe_t), pointer         :: ref_fe 
  type(hex_lagrangian_reference_fe_t)    :: fe_1D, fe_1D_reduced_order 
  type(quadrature_t)                     :: edge_quadrature
  type(interpolation_t)                  :: interpolation_1D, interpolation_1D_reduced_order 
  real(rp)                               :: shape_test
  type(vector_field_t)                   :: grad_shape_trial 
  integer(ip)                            :: ishape, jshape, qpoint, factor 
  integer(ip)                            :: field_id 

  field_id = 1
  ref_fe => par_fe_space%get_reference_fe(field_id) 

  ! Create a 1D scalar lagrangian reference FE of order k
  call fe_1D%create(topology          = ref_fe%get_topology(),          &
                    number_dimensions = 1,                              &
                    order             = ref_fe%get_order(),             &
                    field_type        = field_type_scalar,              &
                    continuity        = .true. )

  ! Create a 1D scalar lagrangian reference FE of order k-1
  call fe_1D_reduced_order%create(topology          = ref_fe%get_topology(),  &
                                  number_dimensions = 1,                      &
                                  order             = ref_fe%get_order()-1,   &
                                  field_type        = field_type_scalar,      &
                                  continuity        = .true. )

  select type(ref_fe)
     class is (nedelec_reference_fe_t)  
     call ref_fe%create_edge_quadrature( edge_quadrature )
     class DEFAULT
     assert(.false.) 
  end select

  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )
  call fe_1D_reduced_order%create_interpolation( edge_quadrature, interpolation_1D_reduced_order )

  ! IDEA: perform edge integrations ONLY over the elementary edge 
  ! REAL 1D CELL integration ( Phi'*inv(J)'*Phi*|J| )_e = +-( Phi', Phi)_e 
  ! The sign will be solved later when assembling to the Wire scheme  
  call memalloc( fe_1D_reduced_order%get_number_shape_functions(), fe_1D%get_number_shape_functions(), elmat, __FILE__, __LINE__ ) 
  elmat = 0.0_rp 
  do qpoint = 1, edge_quadrature%number_quadrature_points
     factor = edge_quadrature%get_weight(qpoint) 
     do ishape = 1, fe_1D_reduced_order%get_number_shape_functions() 
        call fe_1D_reduced_order%get_value(interpolation_1D_reduced_order, ishape, qpoint, shape_test)
        do jshape = 1, fe_1D%get_number_shape_functions() 
           call fe_1D%get_gradient(interpolation_1D, jshape, qpoint, grad_shape_trial)
           elmat(ishape, jshape) = elmat(ishape, jshape) + grad_shape_trial%get(1) * shape_test * factor 
        end do
     end do
  end do

  ! Free data 
  call fe_1D%free() 
  call fe_1D_reduced_order%free()
  call interpolation_1D%free() 
  call interpolation_1D_reduced_order%free()
  call edge_quadrature%free()

end subroutine Hcurl_l1_compute_edge_elmat

subroutine Hcurl_l1_fill_edge_local_change_of_basis(this, par_fe_space, elmat)
  ! Fill change of basis local to Coarse EDGES, G_Ee
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(in)    :: elmat(:,:) 

  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef_within_object
  integer(ip)                            :: ivef_within_object
  integer(ip)                            :: coarse_edge, fine_edge 
  integer(ip), pointer                   :: dofs_old_basis(:)
  integer(ip), pointer                   :: dofs_new_basis(:) 
  
  integer(ip) :: istat 
 
  allocate( this%change_basis_matrix%G(this%number_coarse_edges), stat=istat); check(istat==0)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
 
  coarse_edge = 0
 do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then 
	 coarse_edge = coarse_edge + 1
	             
		     ! Create local Edge change of basis matrix 
            call this%change_basis_matrix%G(coarse_edge)%create(num_rows_and_cols= this%order*this%number_fine_edges_per_coarse_edge(coarse_edge), &
                                                                symmetric_storage=.false.,                  &
                                                                is_symmetric     =.false.,                  &
                                                                sign             =SPARSE_MATRIX_SIGN_UNKNOWN )
			
			fine_edge = 0
	       do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then 
		   
			 fine_edge = fine_edge + 1
		     dofs_old_basis => this%get_dof_list_in_coarse_edge( coarse_edge, fine_edge)   
			 dofs_new_basis => this%get_dof_list_new_basis( coarse_edge, fine_edge ) 
			 ! Fill local Edge change of basis matrix
			 if ( (.not. this%is_first_edge(coarse_edge, fine_edge)) .and. (.not. this%is_last_edge(coarse_edge, fine_edge)) ) then  
			 call this%change_basis_matrix%G(coarse_edge)%insert(num_rows = this%order  ,& 
                                                                 num_cols = this%order+1,& 
                                                                 ia       = dofs_old_basis, &
                                                                 ja       = dofs_new_basis, &
                                                                 ioffset  = 0, &
                                                                 joffset  = 0, & 
                                                                 val      = elmat)
			 else 
			 
			 end if 
			 
           end if
        end do
     end if
     call object%next()
  end do
 
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object) 
  
end subroutine Hcurl_l1_fill_edge_local_change_of_basis

subroutine Hcurl_l1_sort_fine_edges( this, par_fe_space )
  ! This subroutine returns a permutation of fine edges (VEFS) contained in coarse edges such that they 
  ! are sorted following a path from the beginning to an end. The criteria to define origin and end of 
  ! the path is minimum in coordinates {x} ( recursive {y} {z} if needed). The path defines a unique 
  ! orientation for the coarse edge, local edges with different orientation are found through the process 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space

  type(fe_object_iterator_t)                :: object
  type(fe_vef_iterator_t)                   :: vef_within_object
  type(fe_vef_iterator_t)                   :: vertex 
  class(lagrangian_reference_fe_t), pointer :: ref_fe_geo
  class(fe_iterator_t), allocatable         :: fe
  integer(ip)                               :: ivef_within_object, ivef_within_cell 
  integer(ip)                               :: vertex_within_cell_id
  integer(ip)                               :: vertex_within_edge_id
  integer(ip)                               :: coarse_edge, node_id
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  integer(ip), allocatable                  :: vertices_in_edge(:,:)
  type(hash_table_ip_ip_t)                  :: nodes_visited 
  integer(ip)                               :: i, iedge, istat, inode, start_node, end_node 
  type(point_t)                             :: tangent_vector 
  type(point_t), allocatable                :: cell_coordinates(:)
  type(point_t), allocatable, target        :: node_coordinates(:,:) 
  type(point_t), pointer                    :: start_coords, end_coords
  integer(ip)                               :: dummy_val, found_nodes, local_edge, orientation_index
  integer(ip)                               :: perm(2), buffer_node, following_node
  logical                                   :: following_edge_is_found 

  perm(1) = 2; perm(2) = 1
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vertex) 
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  allocate(cell_coordinates( fe%cell%get_num_nodes() ) , stat=istat); check(istat==0) 
  call memalloc(this%number_coarse_edges , maxval(this%number_fine_edges_per_coarse_edge ), this%perm_sorted_edges, __FILE__, __LINE__ ) 
  call memalloc(this%number_coarse_edges , maxval(this%number_fine_edges_per_coarse_edge ), this%tangent_size, __FILE__, __LINE__ ) 
  this%perm_sorted_edges = 0
  this%tangent_size      = 0.0_rp 

  coarse_edge = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dimension() == 1 ) then ! Only sort coarse edges
        coarse_edge = coarse_edge + 1
        call memalloc( this%number_fine_edges_per_coarse_edge(coarse_edge), 2, vertices_in_edge, __FILE__, __LINE__ )
        call nodes_visited%init( this%number_fine_edges_per_coarse_edge(coarse_edge) + 1 )
        allocate( node_coordinates( this%number_fine_edges_per_coarse_edge(coarse_edge), 2 ), stat=istat)

        iedge = 0
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dimension() == 1 ) then    ! Only act if a fine edge has been found 
              iedge = iedge + 1
              call vef_within_object%get_cell_around(1,fe)       ! Do not care local or ghost 
              ref_fe_geo => fe%get_reference_fe_geo()
              ivef_within_cell          = fe%find_lpos_vef_lid(vef_within_object%get_lid())     
              vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
              vertices_of_line_iterator = vertices_of_line%create_iterator(ivef_within_cell)
              vertex_within_edge_id     = 1
              do while( .not. vertices_of_line_iterator%is_upper_bound() )
                 vertex_within_cell_id = vertices_of_line_iterator%get_current()
                 call fe%get_vef(vertex_within_cell_id, vertex )
                 node_id = vertex%get_lid() 
                 call fe%cell%get_coordinates(cell_coordinates)		
                 ! Build hash table to identify start-end node 
                 call nodes_visited%put(key=node_id, val=1, stat=istat)
                 if (istat == was_stored) call nodes_visited%del(key=node_id, stat=istat) 
                 ! Store nodes in a list 
                 vertices_in_edge( iedge, vertex_within_edge_id )  = node_id 
                 node_coordinates( iedge, vertex_within_edge_id)   = cell_coordinates(vertex_within_cell_id) 
                 if (vertex_within_edge_id == 2) then 
                    tangent_vector = node_coordinates(iedge,2) - node_coordinates(iedge,1)
                    this%tangent_size(coarse_edge, iedge) = tangent_vector%nrm2() 
                 end if
                 vertex_within_edge_id = vertex_within_edge_id + 1
                 call vertices_of_line_iterator%next() 
              end do
           end if
        end do

        ! Return potential start-end node and assign direction (decide which one is the origin) 
        found_nodes = 0
        do while ( found_nodes < 2 ) 
           do iedge = 1,this%number_fine_edges_per_coarse_edge(coarse_edge)
              do inode = 1,2
                 node_id = vertices_in_edge(iedge, inode)
                 call nodes_visited%get( key=node_id, val=dummy_val, stat=istat ) 
                 if (istat==key_found .and. found_nodes==0) then 
                    start_node = node_id; found_nodes = 1
                    start_coords => node_coordinates(iedge, inode)
                 elseif (istat==key_found .and. found_nodes==1) then 
                    end_node   = node_id; found_nodes = 2
                    end_coords => node_coordinates(iedge, inode) 
                 end if
              end do
           end do
        end do

        ! Define unique orientation for the edge, from the lowest x(i)_start --> x(i)_end recursively 
		! A switch between the start and the end is performed if x(i)_start > x(i)_end 
        if  ( end_coords%get(1) < start_coords%get(1)  ) then 
           buffer_node=start_node; start_node = end_node; end_node=buffer_node;   
        elseif ( end_coords%get(1) == start_coords%get(1) ) then  
           if ( end_coords%get(2) < start_coords%get(2)  ) then 
              buffer_node=start_node; start_node = end_node; end_node=buffer_node; 
           elseif ( end_coords%get(2) == start_coords%get(2) ) then
              if ( end_coords%get(3) < start_coords%get(3) ) then 
                 buffer_node=start_node; start_node = end_node; end_node=buffer_node; 
              elseif ( end_coords%get(3) > start_coords%get(3) ) then
			     ! Do-nothing
			  else 
                 ! If 3 coordinates are equal it must be the same point 
                 assert(.false.) 
              end if
           end if
        end if

        ! Build path from first to last fine edge belonging to the coarse edge
        local_edge        = 0
        following_node    = 0
		orientation_index = 1 ! The GLOBAL EDGE orientation is fixed from START-->END  
		following_node    = start_node 
        do while (local_edge .ne. this%number_fine_edges_per_coarse_edge(coarse_edge) )
           following_edge_is_found = .false. 
           do iedge = 1,this%number_fine_edges_per_coarse_edge(coarse_edge)
              do inode = 1,2
                  if ( (vertices_in_edge(iedge, inode) == following_node) ) then 
                    local_edge = local_edge + 1
                    this%perm_sorted_edges(coarse_edge, local_edge) = iedge
                    ! Fine edge has changed orientation (start-end) and the sign must be adjusted 
                    if ( inode .ne. orientation_index ) this%tangent_size(coarse_edge, iedge) = -this%tangent_size(coarse_edge, iedge)  
					vertices_in_edge(iedge,:) = 0 ! Do not let replication, (it should be pulled out from the list)
                    following_edge_is_found = .true. 
					following_node = vertices_in_edge(iedge, perm(inode)); exit 
                 end if
              end do
              if (following_edge_is_found) exit 
           end do
        end do

        call memfree(vertices_in_edge)
        call nodes_visited%free()
        deallocate( node_coordinates, stat=istat);  check(istat==0)
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(vertex)
  deallocate( cell_coordinates, stat=istat ); check(istat==0) 

end subroutine Hcurl_l1_sort_fine_edges

function Hcurl_l1_get_dof_list_in_coarse_edge(this, coarse_edge, fine_edge) result( dof_list ) 
! This function returns the list of dofs associated to the fine_edge-th edge  of the coarse_edge-th
! Edge of the subdomain. Return the list of all DOFs if no fine_edge is requested 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip) , optional                        , intent(in)       :: fine_edge 
integer(ip),  pointer                                            :: dof_list(:) 

integer(ip)                      :: dofs_per_fine_edge, ipos, iEdge 

assert( coarse_edge .le. this%number_coarse_edges ) 
dofs_per_fine_edge = this%order 

ipos = 0
do iedge=1, coarse_edge-1
ipos = ipos + this%number_fine_edges_per_coarse_edge(iedge)
end do

if ( present(fine_edge) ) then 
assert( fine_edge .le. this%number_fine_edges_per_coarse_edge(coarse_edge) ) 
ipos = ipos + dofs_per_fine_edge*(fine_edge-1) 
! Return fine_edge within coarse_edge list of dofs 
dof_list => this%wire_to_local_dof( ipos+1 :ipos+dofs_per_fine_edge )
else 
! Return full coarse Edge list of dofs 
dof_list => this%wire_to_local_dof( ipos+1 :ipos + dofs_per_fine_edge*this%number_fine_edges_per_coarse_edge(coarse_edge) )
end if 

end function Hcurl_l1_get_dof_list_in_coarse_edge

function Hcurl_l1_get_dof_list_new_basis(this, coarse_edge, fine_edge) result( dof_list ) 
! This function returns the list of dofs associated to the new basis in the fine_edge-th edge (sorted from one origin)
! of the coarse_edge-th Edge of the subdomain. Return the list of all DOFs if no fine_edge is requested 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip)                                   , intent(in)       :: fine_edge 
integer(ip),  pointer                                            :: dof_list(:) 

integer(ip) :: start_dof, end_dof 

! Consecutive number for Nodal Lagrangian DOFs in a coarse EDGE
if (this%perm_sorted_edges(coarse_edge, fine_edge)==1 ) then 
start_dof = 1
end_dof   = this%order
elseif (this%perm_sorted_edges(coarse_edge, fine_edge)==this%number_fine_edges_per_coarse_edge(coarse_edge) ) then 
start_dof = this%order + (this%perm_sorted_edges(coarse_edge, fine_edge)-2)*this%order
end_dof   = start_dof + this%order-1
else 
start_dof = this%order + (this%perm_sorted_edges(coarse_edge, fine_edge)-2)*this%order
end_dof   = start_dof + this%order
end if

dof_list => this%dofs_new_basis(start_dof:end_dof) 

end function Hcurl_l1_get_dof_list_new_basis

function Hcurl_l1_is_first_edge(this, coarse_edge, fine_edge) result( is_first_edge ) 
! This function asks for first edge in the sorted fine edges chain 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip)                                   , intent(in)       :: fine_edge 
logical      :: is_first_edge

is_first_edge = .false. 
if (this%perm_sorted_edges(coarse_edge, fine_edge) == 1) is_first_edge = .true. 
end function Hcurl_l1_is_first_edge

function Hcurl_l1_is_last_edge(this, coarse_edge, fine_edge) result( is_last_edge ) 
! This function asks for last Edge in the sorted fine edges chain 
implicit none 
class(Hcurl_l1_coarse_fe_handler_t), target   , intent(in)       :: this
integer(ip)                                   , intent(in)       :: coarse_edge
integer(ip)                                   , intent(in)       :: fine_edge 
logical      :: is_last_edge

is_last_edge = .false. 
if (this%perm_sorted_edges(coarse_edge, fine_edge) & 
	 == this%number_fine_edges_per_coarse_edge(coarse_edge) ) is_last_edge = .true. 
end function Hcurl_l1_is_last_edge
