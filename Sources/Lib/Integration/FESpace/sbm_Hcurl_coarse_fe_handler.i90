! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
subroutine Hcurl_l1_free( this ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this

  call this%change_basis_matrix%free()
  call this%fine_edge_direction%free() 
  call this%subedges_x_coarse_edge%free() 	
  call this%sorted_fine_edges_in_coarse_subedge%free()

end subroutine Hcurl_l1_free

!===============================================================================================
subroutine Hcurl_l1_get_num_coarse_dofs(this, field_id, par_fe_space, parameter_list, num_coarse_dofs)
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  integer(ip)                           , intent(in)    :: field_id 
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  integer(ip)                           , intent(inout) :: num_coarse_dofs(:)

  type(environment_t), pointer           :: environment
  type(fe_object_iterator_t)             :: object
  integer(ip)                            :: coarse_edge 

  type(list_iterator_t)     :: coarse_subedge_iterator
  integer(ip)               :: edge_continuity_algorithm 
  integer(ip)               :: num_fine_edges_in_subedge 

  environment=> par_fe_space%get_environment()
  assert ( associated ( environment) )
  assert ( environment%am_i_l1_task() )
  assert ( size(num_coarse_dofs) == par_fe_space%get_num_fe_objects() )

  num_coarse_dofs = 0
  call par_fe_space%create_fe_object_iterator(object)

  call this%get_BDDC_edge_continuity_algorithm_case( parameter_list, edge_continuity_algorithm ) 

  coarse_edge = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dim() .eq. 1 ) then     
        coarse_edge = coarse_edge + 1       
        coarse_subedge_iterator =  this%subedges_x_coarse_edge%create_iterator(coarse_edge) 

        do while ( .not. coarse_subedge_iterator%is_upper_bound() )
           num_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

           select case ( edge_continuity_algorithm ) 
           case (tangential_average) 
              num_coarse_dofs(object%get_gid()) = num_coarse_dofs(object%get_gid()) + 1
           case (tangential_average_and_first_order_moment) 
              if ( num_fine_edges_in_subedge == 1 .and. this%order == 1) then 
                 num_coarse_dofs(object%get_gid()) = num_coarse_dofs(object%get_gid()) + 1 
              else 
                 num_coarse_dofs(object%get_gid()) = num_coarse_dofs(object%get_gid()) + 2 
              end if
           case (all_dofs_in_coarse_edges) 
              num_coarse_dofs(object%get_gid()) = num_coarse_dofs(object%get_gid()) + this%order*num_fine_edges_in_subedge   
           end select

           call coarse_subedge_iterator%next()
        end do

     end if

     call object%next()
  end do

  call par_fe_space%free_fe_object_iterator(object)
end subroutine Hcurl_l1_get_num_coarse_dofs

!===============================================================================================
subroutine Hcurl_l1_setup_constraint_matrix(this, field_id, par_fe_space, parameter_list, constraint_matrix) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  integer(ip)                           , intent(in)    :: field_id 
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  type(coo_sparse_matrix_t)             , intent(inout) :: constraint_matrix
  type(environment_t), pointer           :: environment
  type(fe_object_iterator_t)             :: object
  type(fe_vef_iterator_t)                :: vef
  class(fe_cell_iterator_t), allocatable :: fe
  type(list_iterator_t)                  :: own_coarse_dofs_iterator
  type(list_iterator_t)                  :: own_dofs_on_vef_iterator 
  integer(ip) :: num_rows, num_cols
  integer(ip) ::  ivef_within_cell, ivef_within_object
  integer(ip) :: idof, dof_lid, coarse_dof_lid
  integer(ip), pointer    :: fe_dofs(:)

  integer(ip)                    :: edge_continuity_algorithm 
  type(serial_scalar_array_t)    :: first_moment_constraint_in_edges 
  real(rp), pointer              :: first_moment_constraint_in_edges_entries(:)
  integer(ip)                    :: coarse_edge, fine_edge, icdof, vef_local_dof 
  real(rp)                       :: sign_factor 

  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: num_fine_edges_in_subedge 
  integer(ip)               :: orientation, istat  
  integer(ip)               :: isubedge_coarse

  environment=> par_fe_space%get_environment()
  assert (associated(environment))
  assert (environment%am_i_l1_task())

  call this%get_BDDC_edge_continuity_algorithm_case( parameter_list, edge_continuity_algorithm ) 
  if ( edge_continuity_algorithm == tangential_average_and_first_order_moment ) then 
     call this%compute_first_order_moment_in_edges(par_fe_space, first_moment_constraint_in_edges)
     first_moment_constraint_in_edges_entries => first_moment_constraint_in_edges%get_entries()
  end if

  ! Free any dynamic memory that constraint_matrix may have inside
  call constraint_matrix%free()
  num_rows = par_fe_space%num_dofs_x_field (field_id)
  num_cols = par_fe_space%ptr_coarse_dofs_x_field(field_id+1) - par_fe_space%ptr_coarse_dofs_x_field(field_id) 

  ! Create constraint matrix (transposed)
  call constraint_matrix%create ( num_rows, num_cols )

  ! Fill constraint matrix entries (transposed)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_cell_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vef)

  coarse_edge = 0
  isubedge_coarse = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dim () == 1) then
        coarse_edge = coarse_edge + 1

        own_coarse_dofs_iterator = object%create_own_coarse_dofs_iterator(field_id)	
        if (.not. own_coarse_dofs_iterator%is_upper_bound() ) coarse_dof_lid = own_coarse_dofs_iterator%get_current()

        coarse_subedge_iterator = this%subedges_x_coarse_edge%create_iterator(coarse_edge)       		
        do while ( .not. coarse_subedge_iterator%is_upper_bound() ) 

           isubedge_coarse = isubedge_coarse + 1
           fine_edge = 0
           fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator( coarse_subedge_iterator%get_current() ) 
           num_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

           do while ( .not. fine_edge_iterator%is_upper_bound() ) 
              call vef%set_gid( fine_edge_iterator%get_current() )
              fine_edge = fine_edge + 1 

              call this%fine_edge_direction%get(key=fine_edge_iterator%get_current(), val=orientation, stat=istat); check(istat==key_found)
              sign_factor = 1.0_rp
              if ( orientation == opposite_to_coarse_edge ) sign_factor = -sign_factor
              call vef%get_cell_around(1,fe)
              call fe%get_field_fe_dofs(field_id, fe_dofs)
              ivef_within_cell = fe%get_vef_lid_from_gid(vef%get_gid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)
              vef_local_dof = 0
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof          = own_dofs_on_vef_iterator%get_current()
                 dof_lid       = fe_dofs(idof)
                 if ( dof_lid > 0 ) then
                    select case ( edge_continuity_algorithm ) 
                    case (tangential_average) 
                       call constraint_matrix%insert(dof_lid, coarse_dof_lid, sign_factor )	
                    case (tangential_average_and_first_order_moment) 					  
                       call constraint_matrix%insert(dof_lid, coarse_dof_lid, sign_factor )	
                       if ( (num_fine_edges_in_subedge .gt. 1) .or. (this%order .gt. 1) ) then 
                          call constraint_matrix%insert(dof_lid, coarse_dof_lid+1, -first_moment_constraint_in_edges_entries(dof_lid) )	
                       end if
                    case (all_dofs_in_coarse_edges) 
                       icdof = this%order*( fine_edge - 1 ) + vef_local_dof 
                       call constraint_matrix%insert(dof_lid, coarse_dof_lid+icdof, 1.0_rp )	
                    end select

                    vef_local_dof = vef_local_dof + 1
                 end if

                 call own_dofs_on_vef_iterator%next()
              end do
              call fine_edge_iterator%next() 
           end do

           select case ( edge_continuity_algorithm ) 
           case (tangential_average) 
              coarse_dof_lid = coarse_dof_lid + 1
           case (tangential_average_and_first_order_moment) 					  
              coarse_dof_lid = coarse_dof_lid + 1
              if ( (num_fine_edges_in_subedge .gt. 1) .or. (this%order .gt. 1) ) coarse_dof_lid = coarse_dof_lid + 1
           case (all_dofs_in_coarse_edges) 
              coarse_dof_lid = coarse_dof_lid + this%order*num_fine_edges_in_subedge
           end select

           call coarse_subedge_iterator%next() 
        end do
     end if
     call object%next()
  end do

  call par_fe_space%free_fe_cell_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef)
  call constraint_matrix%sort_and_compress() 
  if ( edge_continuity_algorithm == tangential_average_and_first_order_moment )  call first_moment_constraint_in_edges%free() 

  ! call constraint_matrix%print(6) 
end subroutine Hcurl_l1_setup_constraint_matrix

!===============================================================================================
subroutine Hcurl_l1_apply_weighting_operator_and_comm(this, W, x, y) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  real(rp),            allocatable,       intent(in)    :: W(:) 
  type(par_scalar_array_t)  , intent(inout) :: x
  type(par_scalar_array_t)  , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_local
  type(serial_scalar_array_t), pointer :: y_local
  real(rp), pointer :: x_local_entries(:)
  real(rp), pointer :: y_local_entries(:)

  type(environment_t), pointer        :: environment  
  class(execution_context_t), pointer :: l1_context

  environment => x%get_par_environment() 
  l1_context   => environment%get_l1_context()

  x_local         => x%get_serial_scalar_array()
  x_local_entries => x_local%get_entries()
  y_local         => y%get_serial_scalar_array()
  y_local_entries => y_local%get_entries()

  call this%apply_inverse_local_change_basis( x_local, x_local )
  y_local_entries = x_local_entries*W 
  call y%comm()
  call this%apply_global_change_basis( y, y )

end subroutine Hcurl_l1_apply_weighting_operator_and_comm

!===============================================================================================
subroutine Hcurl_l1_apply_transpose_weighting_operator(this, W, x, y) 
  implicit none
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  real(rp),            allocatable,       intent(in)    :: W(:) 
  type(par_scalar_array_t)  , intent(inout) :: x
  type(par_scalar_array_t)  , intent(inout) :: y
  type(serial_scalar_array_t), pointer :: x_local
  type(serial_scalar_array_t), pointer :: y_local
  real(rp), pointer :: x_local_entries(:)
  real(rp), pointer :: y_local_entries(:)

  type(environment_t), pointer        :: environment  
  class(execution_context_t), pointer :: l1_context

  environment => x%get_par_environment() 
  l1_context   => environment%get_l1_context()

  x_local         => x%get_serial_scalar_array()
  x_local_entries => x_local%get_entries()
  y_local         => y%get_serial_scalar_array()
  y_local_entries => y_local%get_entries()

  call this%apply_global_change_basis_transpose( x, x ) 
  y_local_entries = x_local_entries*W 
  call this%apply_inverse_local_change_basis_transpose( y_local, y_local )  

end subroutine Hcurl_l1_apply_transpose_weighting_operator
! -------------------------------------------------------------------------------------------------
!
!                                 Non overriding procedures 
!
! -------------------------------------------------------------------------------------------------
subroutine Hcurl_l1_setup_tools(this, par_fe_space)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(inout) :: par_fe_space

  integer(ip)                               :: num_coarse_edges, field_id  
  integer(ip)             , allocatable     :: num_fine_edges_x_coarse_edge(:)
  type(hash_table_ip_ip_t), allocatable     :: edge_interior_vertices(:)

  ! To think where does it comes from
  field_id = 1

  ! Count and partition coarse edges 
  call this%compute_subedges_info( par_fe_space ) 
  ! Fill change basis matrix 
  call this%compute_change_basis_matrix( par_fe_space ) 

end subroutine Hcurl_l1_setup_tools

!===============================================================================================
subroutine Hcurl_l1_compute_subedges_info(this, par_fe_space)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(inout) :: par_fe_space

  integer(ip)                               :: num_coarse_edges, field_id  
  integer(ip)             , allocatable     :: num_fine_edges_x_coarse_edge(:)
  type(hash_table_ip_ip_t), allocatable     :: edge_interior_vertices(:)

  ! To think where does it come from
  field_id = 1

  ! Count and sort fine edges within every coarse edge, split them if necessary 
  call this%count_coarse_edges_and_owned_fine_edges( par_fe_space, num_coarse_edges, num_fine_edges_x_coarse_edge, edge_interior_vertices  )	

  ! Fill sorted edges list 
  call this%fill_coarse_subedges_and_owned_fine_edges( par_fe_space, num_coarse_edges, num_fine_edges_x_coarse_edge, edge_interior_vertices  )

end subroutine Hcurl_l1_compute_subedges_info

!===============================================================================================
subroutine Hcurl_l1_compute_change_basis_matrix(this, par_fe_space)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(inout) :: par_fe_space

  integer(ip)                    :: field_id 
  type(environment_t), pointer   :: p_env
  real(rp) , allocatable         :: edge_elmat(:,:)

  integer(ip)                               :: num_coarse_edges 
  integer(ip)             , allocatable     :: num_fine_edges_x_coarse_edge(:)
  type(hash_table_ip_ip_t), allocatable     :: edge_interior_vertices(:)

  ! To think where does it come from
  field_id = 1
  p_env => par_fe_space%get_environment() 

  if ( p_env%am_I_l1_task() ) then 

     call this%change_basis_matrix%create(num_rows_and_cols= this%num_total_dofs - this%num_interior_dofs, &
          symmetric_storage=.false.,                                       &
          is_symmetric     =.false.,                                       &
          sign             = SPARSE_MATRIX_SIGN_UNKNOWN )

     ! Initialize with identity 
     call fill_identity_part() 

     ! Edge integration 
     call this%compute_edge_discrete_gradient_elmat(par_fe_space, edge_elmat)  
     call this%fill_edge_local_change_of_basis(par_fe_space, edge_elmat)
     call this%fill_edge_coupled_to_edges_local_change_of_basis(par_fe_space, edge_elmat)

     ! Faces integration 
     if ( this%order > 1 ) then 
        call this%fill_face_coupled_to_edges_local_change_of_basis(par_fe_space) 
     end if

     call this%change_basis_matrix%convert(csr_format)
     ! call this%change_basis_matrix%print_matrix_market(6)

     call memfree(edge_elmat, __FILE__, __LINE__ ) 
  end if

contains 
  subroutine fill_identity_part() 
    implicit none 

    type(fe_vef_iterator_t)    :: vef
    integer(ip), allocatable   :: dofs_old_basis(:) 
    type(list_iterator_t)      :: coarse_subedge_iterator
    type(list_iterator_t)      :: fine_edge_iterator 
    integer(ip)                :: idof 

    ! Initialize with identity 
    do idof = 1, this%num_total_dofs - this%num_interior_dofs  
       call this%change_basis_matrix%insert(ia       = idof,   &
            ja       = idof,   &
            val      = 1.0_rp )
    end do

    ! Substract DOFS belonging to coarse edges 	
    coarse_subedge_iterator =  this%subedges_x_coarse_edge%create_iterator() 
    call par_fe_space%create_fe_vef_iterator(vef)
    call memalloc( this%order, dofs_old_basis, __FILE__, __LINE__ )

    do while ( .not. coarse_subedge_iterator%is_upper_bound() )
       fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator( coarse_subedge_iterator%get_current() )
       do while ( .not. fine_edge_iterator%is_upper_bound() ) 

          call vef%set_gid( fine_edge_iterator%get_current() )
          call this%get_dofs_from_vef(par_fe_space, vef, dofs_old_basis)

          do idof = 1, this%order  
             call this%change_basis_matrix%insert(ia  = dofs_old_basis(idof) - this%num_interior_dofs,   &
                  ja  = dofs_old_basis(idof) - this%num_interior_dofs,   &
                  val = -1.0_rp )
          end do

          call fine_edge_iterator%next()  
       end do
       call coarse_subedge_iterator%next() 
    end do

    call par_fe_space%free_fe_vef_iterator(vef) 
    call memfree(dofs_old_basis, __FILE__, __LINE__ ) 

  end subroutine fill_identity_part

end subroutine Hcurl_l1_compute_change_basis_matrix

!===============================================================================================
subroutine Hcurl_l1_compute_edge_discrete_gradient_elmat(this, par_fe_space, elmat)
  ! This subroutine computes the elemental 1D Discrete Gradient (phi',phi)_e matrix in a 
  ! reference edge. As the integration to be performed is not edge size-dependent Elemental 
  ! matrix in edges can be re-used for every edge just taking into acount the tangent direction.  
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(inout) :: elmat(:,:) 

  ! Local variables required by Wire edges moments integration
  class(reference_fe_t), pointer         :: ref_fe 
  type(hex_lagrangian_reference_fe_t)    :: fe_1D, fe_1D_reduced_order
  type(hex_nedelec_reference_fe_t)       :: fe 
  type(quadrature_t)                     :: edge_quadrature
  type(interpolation_t)                  :: interpolation_1D, interpolation_1D_reduced_order 
  real(rp)                               :: shape_test, factor 
  type(vector_field_t)                   :: grad_shape_trial 
  integer(ip)                            :: ishape, jshape, qpoint 
  integer(ip)                            :: field_id 

  field_id = 1
  ref_fe => par_fe_space%get_reference_fe(field_id) 

  ! Create a 1D scalar lagrangian reference FE of order k
  call fe_1D%create(topology     = topology_hex,          &
       num_dims     = 1,                     &
       order        = ref_fe%get_order(),    &
       field_type   = field_type_scalar,     &
       conformity   = .true. )

  ! Create a 1D scalar lagrangian reference FE of order k-1
  call fe_1D_reduced_order%create(topology    = topology_hex,           &
       num_dims    = 1,                      &
       order       = ref_fe%get_order()-1,   &
       field_type  = field_type_scalar,      &
       conformity  = .true. )

  ! Create a dim-D scalar hex lagrangian reference FE of order k
  call fe%create(topology      = topology_hex,            &
       num_dims      = ref_fe%get_num_dims() ,  &
       order         = ref_fe%get_order(),      &
       field_type    = field_type_scalar,       &
       conformity    = .false. )

  call fe%create_edge_quadrature( edge_quadrature )
  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )
  call fe_1D_reduced_order%create_interpolation( edge_quadrature, interpolation_1D_reduced_order )

  ! IDEA: perform edge integrations ONLY over the elementary edge 
  ! REAL 1D CELL integration ( Phi'*inv(J)'*Phi*|J| )_e = +-( Phi', Phi)_e 
  ! The sign will be solved later when assembling to the Discrete Gradient   
  call memalloc( fe_1D_reduced_order%get_num_shape_functions(), fe_1D%get_num_shape_functions(), elmat, __FILE__, __LINE__ ) 
  elmat = 0.0_rp 
  do qpoint = 1, edge_quadrature%num_quadrature_points
     factor = edge_quadrature%get_weight(qpoint) 
     do ishape = 1, fe_1D_reduced_order%get_num_shape_functions() 
        call fe_1D_reduced_order%get_value(interpolation_1D_reduced_order, ishape, qpoint, shape_test)
        do jshape = 1, fe_1D%get_num_shape_functions() 
           call fe_1D%get_gradient(interpolation_1D, jshape, qpoint, grad_shape_trial)
           elmat(ishape, jshape) = elmat(ishape, jshape) + grad_shape_trial%get(1) * shape_test * factor
        end do
     end do
  end do

  ! Free data 
  call fe_1D%free() 
  call fe_1D_reduced_order%free()
  call fe%free()
  call interpolation_1D%free() 
  call interpolation_1D_reduced_order%free()
  call edge_quadrature%free()

end subroutine Hcurl_l1_compute_edge_discrete_gradient_elmat

!===============================================================================================
subroutine Hcurl_l1_fill_edge_local_change_of_basis(this, par_fe_space, elmat)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(in)    :: elmat(:,:) 

  type(fe_vef_iterator_t)                :: vef
  integer(ip)                            :: ivef
  integer(ip)                            :: shared_nodal_dof 
  integer(ip)                            :: new_basis_average_dof 
  integer(ip), allocatable               :: dofs_new_basis(:) 
  integer(ip), allocatable               :: dofs_old_basis(:)

  type(list_iterator_t) :: coarse_subedge_iterator
  type(list_iterator_t) :: fine_edge_iterator 
  integer(ip)           :: orientation 

  integer(ip) :: isubedge, idof, jdof, istat 
  real(rp)    :: sign_factor, factor   
  integer(ip) :: local_edge, num_fine_edges_in_subedge

  call par_fe_space%create_fe_vef_iterator(vef)
  call memalloc( this%order,   dofs_old_basis, __FILE__, __LINE__ )
  call memalloc( this%order+1, dofs_new_basis, __FILE__, __LINE__ )

  coarse_subedge_iterator =  this%subedges_x_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     isubedge = coarse_subedge_iterator%get_current()
     num_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )

     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator( coarse_subedge_iterator%get_current() )
     local_edge         = 0
     shared_nodal_dof   = 0

     ! Find DOF that will play the "average function" role in the new basis (last DOF in chain) 
     call fine_edge_iterator%end() 
     call vef%set_gid( fine_edge_iterator%get_current() )	 	 
     call this%get_dofs_from_vef(par_fe_space, vef, dofs_old_basis)
     new_basis_average_dof  = dofs_old_basis(this%order)

     ! Fill the rest of the DoFs with discrete gradients  
     call fine_edge_iterator%begin()
     do while ( .not. fine_edge_iterator%is_upper_bound() )
        local_edge = local_edge + 1
        call vef%set_gid( fine_edge_iterator%get_current() )	 	 
        call this%get_dofs_from_vef(par_fe_space, vef, dofs_old_basis) 

        ! Build dofs new basis from olds 
        dofs_new_basis(1)              = shared_nodal_dof 
        dofs_new_basis(2:this%order+1) = dofs_old_basis(1:this%order) 
        if (local_edge == num_fine_edges_in_subedge ) then
           dofs_new_basis(this%order+1)   = 0
        else 
           shared_nodal_dof = dofs_old_basis(this%order)
        end if

        call this%fine_edge_direction%get(key=fine_edge_iterator%get_current(), val=orientation, stat=istat); check(istat==key_found) 

        do jdof = 1, this%order+1   ! Loop over all nedelec-like dofs in the fine edge   
           if ( dofs_new_basis(jdof) > 0 ) then 
              if ( orientation == same_as_coarse_edge ) then 
                 call this%change_basis_matrix%insert(nz  = this%order,                                       &  
                      ia  = dofs_old_basis - this%num_interior_dofs,          &
                      ja  = dofs_new_basis(jdof) - this%num_interior_dofs,    &
                      val = elmat(:, jdof) )
              elseif ( orientation == opposite_to_coarse_edge ) then 
                 do idof = 1, this%order 
                    call this%change_basis_matrix%insert(ia  = dofs_old_basis(idof) - this%num_interior_dofs,  &
                         ja  = dofs_new_basis(jdof) - this%num_interior_dofs,  &
                         val = -elmat(this%order+1-idof, jdof) )
                 end do
              end if
           end if
        end do

        ! Last column is filled with average of all dofs_old_basis
        do idof=1, this%order 
           if ( orientation == same_as_coarse_edge )  then 
              sign_factor =  1.0_rp 
           else 
              sign_factor = -1.0_rp
           end if
           call this%change_basis_matrix%insert(ia  = dofs_old_basis(idof) - this%num_interior_dofs,  &
                ja  = new_basis_average_dof - this%num_interior_dofs, &  ! Last DOF 
                val = sign_factor )
        end do
        call fine_edge_iterator%next() 
     end do

     call coarse_subedge_iterator%next()
  end do

  call par_fe_space%free_fe_vef_iterator(vef) 
  call memfree(dofs_old_basis) 
  call memfree(dofs_new_basis) 

end subroutine Hcurl_l1_fill_edge_local_change_of_basis

!===============================================================================================
subroutine Hcurl_l1_fill_edge_coupled_to_edges_local_change_of_basis(this, par_fe_space, elmat)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  real(rp), allocatable                 , intent(in)    :: elmat(:,:) 

  type(fe_vef_iterator_t)                   :: edge, interior_edge
  type(fe_vef_iterator_t)                   :: vertex, interior_vertex 
  class(reference_fe_t), pointer            :: ref_fe_geo
  class(fe_cell_iterator_t), allocatable    :: fe
  integer(ip)                               :: ivef_within_cell 
  integer(ip)                               :: vertex_within_cell_id
  integer(ip)                               :: vertex_within_edge_id
  integer(ip)                               :: ielem, edge_id, interior_node_id  
  integer(ip)                               :: coarse_edge, fine_edge, node_id
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  integer(ip)                               :: idof, istat
  integer(ip)                               :: dummy_val, i
  logical(ip)                               :: is_affluent 
  type(hash_table_ip_ip_t)                  :: coupled_vefs_added_to_node

  integer(ip)                               :: new_basis_dof
  integer(ip), allocatable                  :: dofs_old_basis(:) 
  type(list_iterator_t) :: coarse_subedge_iterator
  type(list_iterator_t) :: fine_edge_iterator 
  integer(ip)           :: orientation, local_edge
  integer(ip)           :: isubedge, num_fine_edges_in_subedge 

  call memalloc( this%order, dofs_old_basis, __FILE__, __LINE__ )
  call par_fe_space%create_fe_cell_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vertex) 
  call par_fe_space%create_fe_vef_iterator(interior_vertex)
  call par_fe_space%create_fe_vef_iterator(edge)
  call par_fe_space%create_fe_vef_iterator(interior_edge)
  dummy_val = 0

  coarse_subedge_iterator =  this%subedges_x_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     isubedge                     = coarse_subedge_iterator%get_current()
     num_fine_edges_in_subedge    = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )
     fine_edge_iterator           = this%sorted_fine_edges_in_coarse_subedge%create_iterator( coarse_subedge_iterator%get_current() )

     do while ( fine_edge_iterator%get_distance_to_upper_bound() > 1 )
        call interior_edge%set_gid( fine_edge_iterator%get_current() )
        call this%find_edge_downstream_vertex(par_fe_space, interior_edge, interior_vertex )		
        call this%get_dofs_from_vef(par_fe_space, interior_edge, dofs_old_basis)

        ! Choose the last node as the new basis node 
								new_basis_dof = dofs_old_basis(this%order) 
        call this%fine_edge_direction%get( key=fine_edge_iterator%get_current(), val=orientation, stat=istat); check(istat==key_found) 

        ! Add current and following vef to avoid integration replication with fine edges belonging to the coarse edge 
        call coupled_vefs_added_to_node%init( interior_vertex%get_num_cells_around() )
        call coupled_vefs_added_to_node%put( key = fine_edge_iterator%get_current(), val=dummy_val, stat=istat); check(istat==now_stored)
        call fine_edge_iterator%next() 
        call coupled_vefs_added_to_node%put( key = fine_edge_iterator%get_current(), val=dummy_val, stat=istat); check(istat==now_stored)
        call fine_edge_iterator%previous() 

        do ielem = 1, interior_vertex%get_num_cells_around()
           call interior_vertex%get_cell_around(ielem, fe)      

           if ( fe%is_local() ) then 
              ref_fe_geo => fe%get_reference_fe_geo()
              ivef_within_cell = fe%get_vef_lid_from_gid(interior_vertex%get_gid())     
              interior_node_id = interior_vertex%get_gid() 
              ! Loop over edges in the element to find coupled edges 
              do edge_id = ref_fe_geo%get_first_n_face_id_of_dim(1), ref_fe_geo%get_first_n_face_id_of_dim(1) + ref_fe_geo%get_num_n_faces_of_dim(1)-1
                 ! Need global ID to check if it has been added 
                 call fe%get_vef(edge_id, edge) 			
                 if ( edge%is_at_interface() ) then 
                    ! Double check: vef has not been previously added in edge coupled to edges ( replication due to work in 2 different cells )
                    !             : vef does not belong to a different coarse edge, would imply coarse edges coupling 
                    call coupled_vefs_added_to_node%get( key=edge%get_gid(), val=dummy_val, stat=istat); if (istat==key_found) cycle 
                    call this%fine_edge_direction%get( key=edge%get_gid(), val=dummy_val, stat=istat);   if (istat==key_found) cycle

                    vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
                    vertices_of_line_iterator = vertices_of_line%create_iterator(edge_id)
                    vertex_within_edge_id     = 1

                    do while( .not. vertices_of_line_iterator%is_upper_bound() )
                       vertex_within_cell_id = vertices_of_line_iterator%get_current()
                       call fe%get_vef(vertex_within_cell_id, vertex )
                       node_id = vertex%get_gid() 
                       if (node_id == interior_node_id) then
                          ! A coupled edge has been found  
                          if (vertex_within_edge_id==1) is_affluent = .false.
                          if (vertex_within_edge_id==2) is_affluent = .true.   

                          call this%get_dofs_from_vef(par_fe_space, edge, dofs_old_basis)   

                          if ( is_affluent ) then  ! Affluent edge 
                             call this%change_basis_matrix%insert(nz       = this%order,                              & 
                                  ia       = dofs_old_basis - this%num_interior_dofs, &
                                  ja       = new_basis_dof - this%num_interior_dofs,  &
                                  val      = elmat(:, this%order+1) )
                          elseif ( .not. is_affluent ) then ! Effluent edge 		 
                             call this%change_basis_matrix%insert(nz       = this%order,                              & 
                                  ia       = dofs_old_basis - this%num_interior_dofs, &
                                  ja       = new_basis_dof - this%num_interior_dofs,  &
                                  val      = elmat(:, 1) )
                          end if

                          call coupled_vefs_added_to_node%put( key=edge%get_gid(), val=dummy_val, stat=istat)
                       end if
                       vertex_within_edge_id = vertex_within_edge_id + 1
                       call vertices_of_line_iterator%next() 
                    end do ! Loop over vertices in the edge 
                 end if ! Checker interface vef 
              end do
           end if
        end do ! Elems around node 
        call coupled_vefs_added_to_node%free() 

        call fine_edge_iterator%next() 
     end do
     call coarse_subedge_iterator%next()
  end do

  call par_fe_space%free_fe_cell_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(vertex)
  call par_fe_space%free_fe_vef_iterator(interior_vertex)
  call par_fe_space%free_fe_vef_iterator(edge)
  call par_fe_space%free_fe_vef_iterator(interior_edge)
  call memfree(dofs_old_basis)

end subroutine Hcurl_l1_fill_edge_coupled_to_edges_local_change_of_basis

!===============================================================================================
subroutine Hcurl_l1_find_edge_downstream_vertex( this, par_fe_space, vef, vertex ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(inout) :: this		
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space
  type(fe_vef_iterator_t)               , intent(in)    :: vef 
  type(fe_vef_iterator_t)               , intent(inout) :: vertex 

  class(reference_fe_t), pointer             :: ref_fe_geo
  class(fe_cell_iterator_t), allocatable     :: fe 
  integer(ip)                                :: ivef_within_cell, vertex_within_cell_id 
  type(list_t), pointer                      :: vertices_of_line
  type(list_iterator_t)                      :: vertices_of_line_iterator
  integer(ip)                                :: orientation, istat

  call par_fe_space%create_fe_cell_iterator(fe)

  call vef%get_cell_around(1, fe)
  ivef_within_cell = fe%get_vef_lid_from_gid(vef%get_gid()) 		
  ref_fe_geo => fe%get_reference_fe_geo()
  vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
  vertices_of_line_iterator = vertices_of_line%create_iterator(ivef_within_cell)
  call this%fine_edge_direction%get( key=vef%get_gid(), val=orientation, stat=istat); check(istat==key_found)

  if (orientation == same_as_coarse_edge ) then 
     call vertices_of_line_iterator%next() 
  end if
  vertex_within_cell_id = vertices_of_line_iterator%get_current()
  call fe%get_vef(vertex_within_cell_id, vertex )

  call par_fe_space%free_fe_cell_iterator(fe)

end subroutine Hcurl_l1_find_edge_downstream_vertex

!===============================================================================================
subroutine hex_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis( this, par_fe_space )
  implicit none 
  class(hex_Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                      , intent(inout)    :: par_fe_space 

  class(reference_fe_t), pointer          :: ref_fe 
  type(fe_vef_iterator_t)                 :: vef
  class(fe_cell_iterator_t), allocatable  :: fe
  class(fe_facet_iterator_t), allocatable :: fe_face 
  integer(ip)             , pointer       :: fe_dofs(:)
  type(list_t), pointer                  :: nodes_in_edge
  type(list_iterator_t)                  :: nodes_in_edge_iterator
  type(hex_nedelec_reference_fe_t)       :: Nedelec_fe_2D
  type(hex_lagrangian_reference_fe_t)    :: Lagrangian_fe_3D
  type(interpolation_t)                  :: Lagrangian_interpolation
  type(interpolation_t)                  :: Nedelec_interpolation
  real(rp), allocatable                  :: elmat(:,:) 
  integer(ip)                            :: field_id, ielem, iface_around_edge
  integer(ip)                            :: fine_edge, vef_lid, inode
  integer(ip)                            :: ivef_within_fe
  integer(ip)                            :: node_within_cell_id

  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: num_fine_edges_in_subedge 
  integer(ip)               :: orientation, istat  
  integer(ip)               :: isubedge_coarse
  integer(ip)               :: num_nedelec_dofs_x_face 

  type(list_t), pointer :: nodes_n_face
  type(list_t), pointer :: facets_n_face 
  type(list_iterator_t) :: nodes_n_face_iterator
  type(list_iterator_t) :: facets_n_face_iterator
  integer(ip)           :: facet_gid, face_id, shared_dof  
  logical               :: vefs_are_coupled 
  integer(ip), allocatable   :: dofs_on_vef(:) 

  field_id = 1 
  call par_fe_space%set_up_facet_integration()
  call par_fe_space%create_fe_facet_iterator(fe_face)
  call par_fe_space%create_fe_cell_iterator(fe) 
  call par_fe_space%create_fe_vef_iterator(vef)
  num_nedelec_dofs_x_face = 2*this%order*(this%order-1)

  ref_fe => par_fe_space%get_reference_fe(field_id)
  call Nedelec_fe_2D%create(topology   = topology_hex,          &
       num_dims   = 2,                     &
       order      = this%order-1,          &
       field_type = field_type_vector,     &
       conformity = .false. )

  call Lagrangian_fe_3D%create(topology    = topology_hex,         &
       num_dims    = 3,                    &
       order       = this%order,           &
       field_type  = field_type_scalar,    &
       conformity  = .true. )

  call memalloc( num_nedelec_dofs_x_face, this%order+1, elmat, __FILE__, __LINE__ )	   	 
  call Nedelec_fe_2D%create_interpolation( fe_face%get_quadrature(), Nedelec_interpolation )

  nodes_n_face           => Lagrangian_fe_3D%get_dofs_n_face() 	
  facets_n_face          => Lagrangian_fe_3D%get_facets_n_face() 

  coarse_subedge_iterator = this%subedges_x_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator(coarse_subedge_iterator%get_current())
     fine_edge  = 0
     shared_dof = 0
     do while ( .not. fine_edge_iterator%is_upper_bound() ) 
        call vef%set_gid( fine_edge_iterator%get_current() )
        fine_edge = fine_edge + 1

        do ielem = 1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem, fe)      
           if ( fe%is_local() ) then 				
              ivef_within_fe = fe%get_vef_lid_from_gid( vef%get_gid() )	

              do face_id = ref_fe%get_first_facet_id(), ref_fe%get_first_facet_id() + ref_fe%get_num_facets()-1
                 ! Chapuza, need for an inverse facet_gids(fe_face_lid) to assign fe_face id ! 
                 facet_gid = fe%get_vef_gid( face_id ) - ( par_fe_space%triangulation%get_num_vefs() -  fe_face%fe_space%facet_gids%size() )
                 call fe_face%set_gid( facet_gid )	
                 if ( fe_face%is_at_interface() ) then 
                    facets_n_face_iterator = facets_n_face%create_iterator(face_id) 

                    vefs_are_coupled = .false. 
                    do while ( .not. facets_n_face_iterator%is_upper_bound() ) 
                       if ( facets_n_face_iterator%get_current() == ivef_within_fe ) then 
                          vefs_are_coupled = .true.; exit 
                       end if
                       call facets_n_face_iterator%next() 
                    end do

                    if ( vefs_are_coupled ) then 
                       nodes_n_face_iterator = nodes_n_face%create_iterator(ivef_within_fe)

                       call Lagrangian_fe_3D%create_interpolation_restricted_to_facet( fe%get_vef_lid_from_gid(fe%get_vef_gid(face_id))-ref_fe%get_first_facet_id()+1,  &
                            -1,                                                                              &
                            fe_face%get_quadrature(),                                                        &
                            Lagrangian_interpolation                                                         )

                       call this%compute_face_discrete_gradient_elmat(fe,                        &
                            fe_face,                   &
                            Nedelec_fe_2D,             &
                            Lagrangian_fe_3D,          &
                            Nedelec_interpolation,     &
                            Lagrangian_interpolation,  &
                            nodes_n_face_iterator,     &
                            elmat)

                       call this%assemble_face_coupled_to_edges_B_elmat( par_fe_space,                           &
                            elmat,                                  & 
                            fe_face,                                & 
                            fine_edge,                              & 
                            coarse_subedge_iterator%get_current(),  & 
                            vef,                                    & 
                            shared_dof                              )
                    end if
                 end if
              end do
           end if
        end do

        call this%get_dofs_from_vef(par_fe_space, vef, dofs_on_vef)
        shared_dof = dofs_on_vef(size(dofs_on_vef))								
        call fine_edge_iterator%next() 
     end do

     call coarse_subedge_iterator%next()
  end do

  ! Free 
  call Lagrangian_fe_3D%free() 
  call Nedelec_fe_2D%free() 	  
  call Nedelec_interpolation%free() 
  call Lagrangian_interpolation%free() 

  call nodes_n_face_iterator%free()
  call facets_n_face_iterator%free() 

  call par_fe_space%free_fe_cell_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(fe_face)	  
  call par_fe_space%free_fe_vef_iterator(vef) 

  call memfree(elmat, __FILE__, __LINE__ ) 
  call memfree(dofs_on_vef, __FILE__, __LINE__ )
end subroutine hex_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis

!===============================================================================================
subroutine tet_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis( this, par_fe_space )
  implicit none 
  class(tet_Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                      , intent(inout)    :: par_fe_space 

  class(reference_fe_t), pointer         :: ref_fe 
  type(fe_vef_iterator_t)                :: vef, vertex
  class(fe_cell_iterator_t), allocatable  :: fe
  class(fe_facet_iterator_t), allocatable :: fe_face
  type(list_t), pointer                  :: nodes_n_face
  type(list_t), pointer                  :: faces_n_face 
  type(list_iterator_t)                  :: vertices_in_face_iterator
  type(list_iterator_t)                  :: nodes_iterator
  type(list_iterator_t)                  :: facets_in_face_iterator 
  type(tet_lagrangian_reference_fe_t)    :: ref_fe_2D
  type(tet_lagrangian_reference_fe_t)    :: Lagrangian_fe_3D
  type(interpolation_t)                  :: Lagrangian_interpolation
  type(interpolation_t)                  :: ref_fe_interpolation
  real(rp), allocatable                  :: elmat(:,:) 
  integer(ip)                            :: field_id, ielem, facet_gid, face_id 
  integer(ip)                            :: fine_edge, vef_lid, inode
  integer(ip)                            :: ivef_within_fe
  integer(ip)                            :: node_within_cell_id

  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: num_fine_edges_in_subedge 
  integer(ip)               :: orientation, istat  
  integer(ip)               :: isubedge_coarse

  integer(ip), allocatable  :: dofs_on_edge(:)  
  integer(ip)               :: new_basis_edge_dof 
  type(hash_table_ip_ip_t)  :: already_added_faces 
  logical                   :: vefs_are_coupled 

  field_id = 1
  call par_fe_space%set_up_facet_integration()
  call par_fe_space%create_fe_facet_iterator(fe_face)
  call par_fe_space%create_fe_cell_iterator(fe) 
  call par_fe_space%create_fe_vef_iterator(vef)
  call par_fe_space%create_fe_vef_iterator(vertex)

  ref_fe => par_fe_space%get_reference_fe(field_id) 
  call ref_fe_2D%create(topology    = topology_tet,          &
       num_dims    = 2,                     &
       order       = this%order-2,          &
       field_type  = field_type_scalar,     &
       conformity  = .true. )

  call Lagrangian_fe_3D%create(topology   = topology_tet,          &
       num_dims    = 3,                     &
       order       = this%order,            &
       field_type  = field_type_scalar,     &
       conformity  = .true. )

  call memalloc( this%order*(this%order-1), this%order+1, elmat, __FILE__, __LINE__ )	   	 
  call ref_fe_2D%create_interpolation( fe_face%get_quadrature(), ref_fe_interpolation )

  coarse_subedge_iterator = this%subedges_x_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator(coarse_subedge_iterator%get_current())
     fine_edge = 0
     call already_added_faces%init( 20 ) ! Magic number, give an upper bound 
     ! Find faces coupled with edges and integrate terms
     do while ( .not. fine_edge_iterator%is_upper_bound() ) 
        call vef%set_gid( fine_edge_iterator%get_current() )
        fine_edge = fine_edge + 1

        do ielem = 1, vef%get_num_cells_around()
           call vef%get_cell_around(ielem, fe)      
           if ( fe%is_local() ) then 				
              ivef_within_fe = fe%get_vef_lid_from_gid( vef%get_gid() )				

              do face_id = ref_fe%get_first_facet_id(), ref_fe%get_first_facet_id() + ref_fe%get_num_facets()-1
                 nodes_n_face          => Lagrangian_fe_3D%get_dofs_n_face() 	
                 faces_n_face          => Lagrangian_fe_3D%get_facets_n_face() 

                 ! Chapuza, need for an inverse facet_gids(fe_face_lid) to assign fe_face id ! 
                 facet_gid = fe%get_vef_gid( face_id ) - ( par_fe_space%triangulation%get_num_vefs() -  fe_face%fe_space%facet_gids%size() )
                 call fe_face%set_gid(facet_gid)				
                 if ( fe_face%is_at_interface() ) then 
                    facets_in_face_iterator = faces_n_face%create_iterator(face_id) 

                    vefs_are_coupled = .false. 
                    do while ( .not. facets_in_face_iterator%is_upper_bound() ) 
                       if ( facets_in_face_iterator%get_current() == ivef_within_fe ) then 
                          vefs_are_coupled = .true.; exit 
                       end if
                       call facets_in_face_iterator%next() 
                    end do

                    if ( vefs_are_coupled ) then 

                       nodes_iterator = nodes_n_face%create_iterator(ivef_within_fe)					

                       call Lagrangian_fe_3D%create_interpolation_restricted_to_facet( fe%get_vef_lid_from_gid(fe%get_vef_gid(face_id))-ref_fe%get_first_facet_id()+1, &
                            -1,                                                                             &
                            fe_face%get_quadrature(),                                                       &
                            Lagrangian_interpolation                                                        )

                       call this%compute_face_discrete_gradient_elmat(fe,                        &
                            fe_face,                   &
                            ref_fe_2D,                 &
                            Lagrangian_fe_3D,          &
                            ref_fe_interpolation,      &
                            Lagrangian_interpolation,  &
                            nodes_iterator,            &
                            elmat)

                       call this%assemble_face_coupled_to_edges_B_elmat( par_fe_space,                           &
                            elmat,                                  & 
                            fe_face,                                & 
                            fine_edge,                              & 
                            coarse_subedge_iterator%get_current(),  & 
                            vef )

                    end if
                 end if
              end do
           end if
        end do

        ! Find faces coupled to coarse edges through nodes and integrate terms 
        if ( fine_edge_iterator%get_distance_to_upper_bound() > 1 ) then 

           call this%find_edge_downstream_vertex( par_fe_space, vef, vertex )	
           call this%get_dofs_from_vef(par_fe_space, vef, dofs_on_edge)
           new_basis_edge_dof = dofs_on_edge( size(dofs_on_edge) ) 

           do ielem = 1, vertex%get_num_cells_around()
              call vertex%get_cell_around(ielem, fe)      
              if ( fe%is_local() ) then 				
                 ivef_within_fe = fe%get_vef_lid_from_gid( vertex%get_gid() )				

                 do face_id = ref_fe%get_first_facet_id(), ref_fe%get_first_facet_id() + ref_fe%get_num_facets()-1	
                    nodes_n_face          => Lagrangian_fe_3D%get_dofs_n_face() 

                    ! Chapuza, need for an inverse facet_gids(fe_face_lid) to assign fe_face id ! 
                    facet_gid = fe%get_vef_gid( face_id ) - ( par_fe_space%triangulation%get_num_vefs() -  fe_face%fe_space%facet_gids%size() )
                    call fe_face%set_gid(facet_gid)				
                    if ( fe_face%is_at_interface() ) then 

                       vertices_in_face_iterator = nodes_n_face%create_iterator(face_id) 
                       nodes_iterator = nodes_n_face%create_iterator(ivef_within_fe)

                       vefs_are_coupled = .false. 
                       do while ( .not. vertices_in_face_iterator%is_upper_bound() ) 
                          if ( vertices_in_face_iterator%get_current() == nodes_iterator%get_current() ) then 
                             vefs_are_coupled = .true.; exit 
                          end if
                          call vertices_in_face_iterator%next() 
                       end do

                       if ( vefs_are_coupled ) then 

                          call Lagrangian_fe_3D%create_interpolation_restricted_to_facet( fe%get_vef_lid_from_gid(fe%get_vef_gid(face_id))-ref_fe%get_first_facet_id()+1,  &
                               -1,                                                                              &
                               fe_face%get_quadrature(),                                                        &
                               Lagrangian_interpolation                                                         )

                          call this%compute_face_discrete_gradient_elmat(fe,                        &
                               fe_face,                   &
                               ref_fe_2D,                 &
                               Lagrangian_fe_3D,          &
                               ref_fe_interpolation,      &
                               Lagrangian_interpolation,  &
                               nodes_iterator,            &
                               elmat)

                          call this%assemble_face_coupled_to_vertex_B_elmat( par_fe_space,                           &
                               elmat,                                  & 
                               fe_face,                                & 
                               fine_edge,                              & 
                               coarse_subedge_iterator%get_current(),  & 
                               vef,                                    & 
                               new_basis_edge_dof                      )
                       end if
                    end if
                 end do
              end if
           end do

        end if

        call fine_edge_iterator%next() 
     end do

     call coarse_subedge_iterator%next()
  end do

  ! Free 
  call ref_fe_2D%free()
  call Lagrangian_fe_3D%free()   
  call ref_fe_interpolation%free() 
  call Lagrangian_interpolation%free() 

  call vertices_in_face_iterator%free() 
  call facets_in_face_iterator%free()  

  call par_fe_space%free_fe_cell_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(fe_face)	  
  call par_fe_space%free_fe_vef_iterator(vef) 
  call par_fe_space%free_fe_vef_iterator(vertex) 

  call memfree(elmat, __FILE__, __LINE__ ) 
  if (allocated(dofs_on_edge)) call memfree(dofs_on_edge, __FILE__, __LINE__ )
end subroutine tet_Hcurl_l1_fill_face_coupled_to_edges_local_change_of_basis

!===============================================================================================
subroutine hex_Hcurl_l1_compute_face_discrete_gradient_elmat(this, fe, fe_face, ref_fe_2D, Lagrangian_fe_3D, ref_fe_interpolation, Lagrangian_interpolation_ref, nodes_in_edge_iterator, elmat)
  implicit none 
  class(hex_Hcurl_l1_coarse_fe_handler_t)  , intent(in)       :: this
  type(fe_cell_iterator_t)                 , intent(inout)    :: fe 
  type(fe_facet_iterator_t)                , intent(inout)    :: fe_face
  class(lagrangian_reference_fe_t)         , intent(in)       :: ref_fe_2D
  class(lagrangian_reference_fe_t)         , intent(in)       :: Lagrangian_fe_3D
  type(interpolation_t)                    , intent(in)       :: ref_fe_interpolation
  type(interpolation_t)                    , intent(in)       :: Lagrangian_interpolation_ref
  type(list_iterator_t)                    , intent(inout)    :: nodes_in_edge_iterator
  real(rp), allocatable                    , intent(inout)    :: elmat(:,:) 

  integer(ip) :: ielem 
  type(quadrature_t)       , pointer     :: quad
  type(cell_map_t)         , pointer     :: cell_map 
  type(facet_maps_t)       , pointer     :: facet_maps
  type(facet_map_t)        , pointer     :: facet_map
  type(interpolation_t)                  :: Lagrangian_interpolation_phy 
  type(vector_field_t)                   :: cross_product_gradv_shape_trial_normal
  type(vector_field_t)                   :: cross_product_gradv_shape_trial_normal_proj
  type(vector_field_t)                   :: col_jacobian

  integer(ip)                            :: num_qpoints, idof, i 
  real(rp)                               :: factor
  type(vector_field_t)                   :: normal, v_shape_test, gradv_shape_trial
  type(vector_field_t)                   :: mapped_shape_test 
  integer(ip)                            :: ishape, jshape, qpoint
  integer(ip)                            :: vef_lid, facet_lid 
  integer(ip)                            :: num_nedelec_dofs_x_face 

  class(reference_fe_t) , pointer        :: reference_fe 
  class(reference_fe_t) , pointer        :: reference_fe_geo 

  type(vector_field_t)                   :: shape_trial

  integer(ip) :: field_id 

  call fe%update_integration() 	
  call fe_face%update_integration()

  field_id = 1 ! To think where it comes from ! 

  quad             => fe_face%get_quadrature()
  num_qpoints      =  quad%get_num_quadrature_points()
  facet_maps       => fe_face%get_facet_maps() 
  facet_map        => facet_maps%get_facet_map()
  cell_map         => fe%get_cell_map()
  reference_fe     => fe%get_reference_fe(field_id) 
  reference_fe_geo => fe%get_reference_fe_geo() 

  elmat = 0.0_rp 
  call cross_product_gradv_shape_trial_normal_proj%init(0.0_rp)

  call Lagrangian_interpolation_phy%copy(Lagrangian_interpolation_ref) 
  call Lagrangian_fe_3D%apply_cell_map( fe%get_cell_map (),           &
       Lagrangian_interpolation_ref, &
       Lagrangian_interpolation_phy  )

  num_nedelec_dofs_x_face = 2*this%order*(this%order-1)
  do qpoint = 1, num_qpoints
     factor    = facet_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)
     call facet_map%get_normal(qpoint, normal)

     vef_lid = fe%get_vef_lid_from_gid( fe_face%vef%get_gid() )
     facet_lid = vef_lid - reference_fe_geo%get_first_facet_id()+1
     normal = reference_fe%get_normal_orientation_factor(facet_lid) * normal

     do ishape = 1, num_nedelec_dofs_x_face
        call ref_fe_2D%get_value(ref_fe_interpolation, ishape, qpoint, v_shape_test)

        ! Apply facet_map to test function 
        call mapped_shape_test%init(0.0_rp)
        do i=1, reference_fe%get_num_dims()-1 
           call facet_map%get_jacobian_column(i,qpoint,col_jacobian)
           call mapped_shape_test%add( v_shape_test%get(i) * (1.0_rp/col_jacobian%nrm2()) * col_jacobian%get_value() )
        end do

        ! WARNING: Update 2D interpolation for the Nedelec test functions ( J**{-T} will only work in HEX structured meshes! )
        do i=1, Lagrangian_fe_3D%get_num_dims()
           call cell_map%get_jacobian_column(i,qpoint,col_jacobian)
           call mapped_shape_test%set(i, mapped_shape_test%get(i)/col_jacobian%nrm2() )
        end do

        call nodes_in_edge_iterator%begin() 
        do jshape = 1, nodes_in_edge_iterator%get_size() 
           call Lagrangian_fe_3D%get_gradient(Lagrangian_interpolation_phy, nodes_in_edge_iterator%get_current(), qpoint, gradv_shape_trial)
           cross_product_gradv_shape_trial_normal = cross_product(gradv_shape_trial,normal)			         
           elmat(ishape,jshape) = elmat(ishape, jshape) +  factor * cross_product_gradv_shape_trial_normal*mapped_shape_test
           call nodes_in_edge_iterator%next() 
        end do
     end do
  end do

  call Lagrangian_interpolation_phy%free() 

end subroutine hex_Hcurl_l1_compute_face_discrete_gradient_elmat

!===============================================================================================
subroutine tet_Hcurl_l1_compute_face_discrete_gradient_elmat(this, fe, fe_face, ref_fe_2D, Lagrangian_fe_3D, ref_fe_interpolation, Lagrangian_interpolation_ref, nodes_in_edge_iterator, elmat)
  implicit none 
  class(tet_Hcurl_l1_coarse_fe_handler_t)    , intent(in)       :: this
  type(fe_cell_iterator_t)                   , intent(inout)    :: fe 
  type(fe_facet_iterator_t)                  , intent(inout)    :: fe_face
  class(lagrangian_reference_fe_t)           , intent(in)       :: ref_fe_2D
  class(lagrangian_reference_fe_t)           , intent(in)       :: Lagrangian_fe_3D
  type(interpolation_t)                      , intent(in)       :: ref_fe_interpolation
  type(interpolation_t)                      , intent(in)       :: Lagrangian_interpolation_ref
  type(list_iterator_t)                      , intent(inout)    :: nodes_in_edge_iterator
  real(rp), allocatable                      , intent(inout)    :: elmat(:,:) 

  integer(ip) :: ielem 
  type(quadrature_t)       , pointer     :: quad
  type(cell_map_t)         , pointer     :: cell_map 
  type(facet_maps_t)       , pointer     :: facet_maps
  type(facet_map_t)        , pointer     :: facet_map
  type(interpolation_t)                  :: Lagrangian_interpolation_phy 

  integer(ip)                            :: num_qpoints, idof
  real(rp)                               :: factor
  type(vector_field_t)                   :: gradv_shape_trial
  real(rp)                               :: v_shape_test
  type(vector_field_t)                   :: tangent
  integer(ip)                            :: ishape, jshape, qpoint

  integer(ip) :: direction, c, num_scalar_test_functions 
  real(rp)    :: face_area 

  type(vector_field_t)                   :: shape_trial
  real(rp), allocatable                  :: elm(:,:) 

  call fe%update_integration() 	
  call fe_face%update_integration()

  quad           => fe_face%get_quadrature()
  num_qpoints    =  quad%get_num_quadrature_points()
  facet_maps     => fe_face%get_facet_maps()
  facet_map      => facet_maps%get_facet_map()
  cell_map       => fe%get_cell_map () 

  elmat = 0.0_rp 
  call Lagrangian_interpolation_phy%copy(Lagrangian_interpolation_ref) 
  call Lagrangian_fe_3D%apply_cell_map( fe%get_cell_map (),           &
       Lagrangian_interpolation_ref, &
       Lagrangian_interpolation_phy  )

  num_scalar_test_functions = this%order*(this%order-1)/2
  do qpoint = 1, num_qpoints
     factor = facet_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)

     do direction=1,2
        c = (direction-1)*num_scalar_test_functions 
        call facet_map%get_jacobian_column(direction,qpoint,tangent)
        do ishape = 1, num_scalar_test_functions 
           call ref_fe_2D%get_value(ref_fe_interpolation, ishape, qpoint, v_shape_test)
           call nodes_in_edge_iterator%begin() 
           do jshape = 1, nodes_in_edge_iterator%get_size() 
              call Lagrangian_fe_3D%get_gradient(Lagrangian_interpolation_phy, nodes_in_edge_iterator%get_current(), qpoint, gradv_shape_trial)		         
              elmat(ishape+c, jshape) = elmat(ishape+c, jshape) +  1.0_rp/facet_map%get_measure() * factor * gradv_shape_trial * v_shape_test * tangent 
              call nodes_in_edge_iterator%next() 
           end do
        end do
     end do
  end do

  call Lagrangian_interpolation_phy%free() 

end subroutine tet_Hcurl_l1_compute_face_discrete_gradient_elmat

!===============================================================================================
subroutine hex_Hcurl_l1_assemble_face_coupled_to_edges_B_elmat( this, par_fe_space, elmat, fe_face, local_edge, coarse_edge, vef, shared_dof)
  implicit none 
  class(hex_Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                      , intent(in)       :: par_fe_space 
  real(rp), allocatable                     , intent(in)       :: elmat(:,:) 
  type(fe_facet_iterator_t)                 , intent(in)       :: fe_face
  integer(ip)                               , intent(in)       :: local_edge
  integer(ip)                               , intent(in)       :: coarse_edge 
  type(fe_vef_iterator_t)                   , intent(in)       :: vef
  integer(ip)                               , intent(in)       :: shared_dof 

  integer(ip)                            :: num_nedelec_dofs_x_face
  integer(ip)                            :: idof, jdof
  integer(ip), allocatable               :: dofs_face_old_basis(:)
  integer(ip), allocatable               :: dofs_old_basis(:) 
  integer(ip), allocatable               :: dofs_new_basis(:) 
  integer(ip)                            :: num_fine_edges_in_subedge 
  integer(ip)                            :: fine_edge_direction, istat

  num_nedelec_dofs_x_face =  size(elmat,1) 

  call memalloc( num_nedelec_dofs_x_face, dofs_face_old_basis, __FILE__, __LINE__ )
  call memalloc( this%order, dofs_old_basis, __FILE__, __LINE__ ) 
  call this%get_dofs_from_vef(par_fe_space, fe_face, dofs_face_old_basis)
  call this%get_dofs_from_vef(par_fe_space, vef, dofs_old_basis ) 

  call memalloc( this%order+1, dofs_new_basis, __FILE__, __LINE__ )
  num_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_edge )

  ! Build dofs new basis from olds 
  dofs_new_basis(1)                      = shared_dof 
  dofs_new_basis(2:this%order+1)         = dofs_old_basis(1:this%order) 
  if (local_edge == 1) then 
     dofs_new_basis(1) = 0
  elseif (local_edge == num_fine_edges_in_subedge ) then
     dofs_new_basis(this%order+1)   = 0
  end if

  call this%fine_edge_direction%get( key=vef%get_gid(), val=fine_edge_direction, stat=istat); check(istat==key_found)  
  do jdof = 1, this%order + 1  
     if ( dofs_new_basis(jdof) > 0) then
        select case ( fine_edge_direction ) 
        case ( same_as_coarse_edge )
           call this%change_basis_matrix%insert(nz       = num_nedelec_dofs_x_face,                        & 
                ia       = dofs_face_old_basis - this%num_interior_dofs,   &
                ja       = dofs_new_basis(jdof)- this%num_interior_dofs,   &
                val      = elmat(:, jdof) )
        case ( opposite_to_coarse_edge )
           call this%change_basis_matrix%insert(nz       = num_nedelec_dofs_x_face,                             & 
                ia       = dofs_face_old_basis - this%num_interior_dofs,        &
                ja       = dofs_new_basis(jdof)- this%num_interior_dofs,   &
                val      = elmat(:, this%order+2-jdof) ) 
        end select
     end if
  end do

  call memfree( dofs_old_basis, __FILE__, __LINE__ )
  call memfree( dofs_new_basis, __FILE__, __LINE__ )
  call memfree( dofs_face_old_basis, __FILE__, __LINE__ )

end subroutine hex_Hcurl_l1_assemble_face_coupled_to_edges_B_elmat

!===============================================================================================
subroutine tet_Hcurl_l1_assemble_face_coupled_to_edges_B_elmat( this, par_fe_space, elmat, fe_face, fine_edge, coarse_edge, vef)
  implicit none 
  class(tet_Hcurl_l1_coarse_fe_handler_t)   , intent(inout)    :: this
  type(par_fe_space_t)                      , intent(in)       :: par_fe_space 
  real(rp), allocatable                     , intent(in)       :: elmat(:,:) 
  type(fe_facet_iterator_t)                 , intent(in)       :: fe_face
  integer(ip)                               , intent(in)       :: fine_edge
  integer(ip)                               , intent(in)       :: coarse_edge 
  type(fe_vef_iterator_t)                   , intent(in)       :: vef

  integer(ip)                            :: num_nedelec_dofs_x_face
  integer(ip)                            :: idof, jdof
  integer(ip), allocatable               :: dofs_face_old_basis(:)
  integer(ip), allocatable               :: dofs_edge_old_basis(:)
  integer(ip), allocatable               :: dofs_edge_new_basis(:) 
  integer(ip)                            :: num_fine_edges_in_subedge 
  integer(ip)                            :: fine_edge_direction, istat

  num_nedelec_dofs_x_face =  size(elmat,1) 

  call this%get_dofs_from_vef(par_fe_space, fe_face, dofs_face_old_basis)
  num_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_edge )
  call this%fine_edge_direction%get( key=vef%get_gid(), val=fine_edge_direction, stat=istat); check(istat==key_found)  

  ! Build dofs new basis from olds
  call this%get_dofs_from_vef(par_fe_space, vef, dofs_edge_old_basis ) 
  call memalloc( this%order + 1, dofs_edge_new_basis, __FILE__, __LINE__ )
  dofs_edge_new_basis = 0
  dofs_edge_new_basis(2:this%order) = dofs_edge_old_basis(1:this%order-1)  
  do jdof = 2, this%order  ! Interior-only coupling 
     assert ( dofs_edge_new_basis(jdof) > 0) 
     select case ( fine_edge_direction ) 
     case ( same_as_coarse_edge ) 													
        call this%change_basis_matrix%insert(nz       = num_nedelec_dofs_x_face,                             & 
             ia       = dofs_face_old_basis - this%num_interior_dofs,        &
             ja       = dofs_edge_new_basis(jdof)- this%num_interior_dofs,   &
             val      = elmat(:, jdof) )
     case ( opposite_to_coarse_edge ) 
        call this%change_basis_matrix%insert(nz       = num_nedelec_dofs_x_face,                             & 
             ia       = dofs_face_old_basis - this%num_interior_dofs,        &
             ja       = dofs_edge_new_basis(jdof)- this%num_interior_dofs,   &
             val      = elmat(:, this%order+2-jdof) ) 
     end select
  end do

  call memfree( dofs_face_old_basis, __FILE__, __LINE__ )
  call memfree( dofs_edge_new_basis, __FILE__, __LINE__ )
  call memfree( dofs_edge_old_basis, __FILE__, __LINE__ ) 
end subroutine tet_Hcurl_l1_assemble_face_coupled_to_edges_B_elmat

!===============================================================================================
subroutine tet_Hcurl_l1_assemble_face_coupled_to_vertex_B_elmat( this, par_fe_space, elmat, fe_face, fine_edge, coarse_edge, vef, dof_new_basis)
  implicit none 
  class(tet_Hcurl_l1_coarse_fe_handler_t), intent(inout)    :: this
  type(par_fe_space_t)                   , intent(in)       :: par_fe_space 
  real(rp), allocatable                  , intent(in)       :: elmat(:,:) 
  type(fe_facet_iterator_t)               , intent(in)       :: fe_face
  integer(ip)                            , intent(in)       :: fine_edge
  integer(ip)                            , intent(in)       :: coarse_edge 
  type(fe_vef_iterator_t)                , intent(in)       :: vef
  integer(ip)                            , intent(in)       :: dof_new_basis 

  integer(ip)                            :: num_nedelec_dofs_x_face
  integer(ip), allocatable               :: dofs_face_old_basis(:)

  num_nedelec_dofs_x_face =  size(elmat,1) 
  call this%get_dofs_from_vef(par_fe_space, fe_face, dofs_face_old_basis)
  ! Assemble all face DoFs with the vertex DoF 
  call this%change_basis_matrix%insert(nz       = num_nedelec_dofs_x_face,                        & 
       ia       = dofs_face_old_basis - this%num_interior_dofs,   &
       ja       = dof_new_basis - this%num_interior_dofs,         &
       val      = elmat(:, 1) )
  call memfree( dofs_face_old_basis, __FILE__, __LINE__ )
end subroutine tet_Hcurl_l1_assemble_face_coupled_to_vertex_B_elmat

!===============================================================================================
subroutine Hcurl_l1_compute_first_order_moment_in_edges(this, par_fe_space, constraint_in_edges)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)   , intent(in)    :: this
  type(par_fe_space_t)                  , intent(in)    :: par_fe_space 
  type(serial_scalar_array_t)           , intent(inout) :: constraint_in_edges

  type(fe_vef_iterator_t)     :: vef
  integer(ip)                 :: ivef, vef_lid 
  integer(ip)                 :: field_id, idof
  real(rp),    allocatable    :: elvec(:) 
  real(rp)                    :: factor 

  integer(ip), allocatable    :: dofs_old_basis(:) 
  integer(ip), allocatable    :: dofs_new_basis(:) 
  integer(ip)                 :: shared_nodal_dof 

  type(list_iterator_t)     :: coarse_subedge_iterator
  type(list_iterator_t)     :: fine_edge_iterator
  integer(ip)               :: num_fine_edges_in_subedge 
  integer(ip)               :: local_edge 

		class(fe_cell_iterator_t), allocatable :: fe_cell 
  class(cell_iterator_t)   , allocatable :: cell
  type(point_t)            , allocatable :: cell_coordinates(:)
  type(hex_nedelec_reference_fe_t)       :: fe 
  type(hex_lagrangian_reference_fe_t)    :: fe_1D
		type(hex_lagrangian_reference_fe_t)    :: d_fe_geo 
  class(reference_fe_t) , pointer        :: ref_fe
  type(quadrature_t)                     :: edge_quadrature
  type(interpolation_t)                  :: interpolation_1D 
  integer(ip)                            :: ishape, qpoint 
  real(rp)                               :: shape_test 
  type(edge_map_t)                       :: edge_map
  type(point_t), pointer                 :: edge_map_coordinates(:)
  integer(ip)                            :: vertex_within_edge_id 
  integer(ip)                            :: vertex_within_cell_id 
  type(list_t), pointer                  :: vertices_of_line
  type(list_iterator_t)                  :: vertices_of_line_iterator
		real(rp)                               :: edge_length 

  field_id = 1
  call constraint_in_edges%create_and_allocate( par_fe_space%get_block_num_dofs(field_id) )
  call constraint_in_edges%init(0.0_rp) 

  ref_fe => par_fe_space%get_reference_fe(field_id) 

		call par_fe_space%create_fe_cell_iterator(fe_cell)
		call par_fe_space%triangulation%create_cell_iterator(cell) 
  call par_fe_space%create_fe_vef_iterator(vef)
		
  ! Create a 1D scalar lagrangian reference FE of order k
  call fe_1D%create(topology    = topology_hex,       &
       num_dims    = 1,                              &
       order       = ref_fe%get_order(),             &
       field_type  = field_type_scalar,              &
       conformity  = .true. )

  call fe%create(topology    = topology_hex,         &
       num_dims    = 1,                              &
       order       = ref_fe%get_order(),             &
       field_type  = field_type_scalar,              &
       conformity  = .false. )
		
		! Create a d-dim scalar HEX lagrangian reference FE of order 1 (geometry)
  call d_fe_geo%create(topology    = topology_hex,             &
                       num_dims    = ref_fe%get_num_dims(),    &
                       order       = 1,                        &
                       field_type  = field_type_scalar,        &
                       conformity  = .false. )

  call fe%create_edge_quadrature( edge_quadrature )
  call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )
		call edge_map%create( edge_quadrature, d_fe_geo )
		
  call memalloc( fe_1D%get_num_shape_functions(), elvec, __FILE__, __LINE__ ) 

  ! Loop on fine edges and assemble the elemental vector, C_new  
  call memalloc( this%order,   dofs_old_basis, __FILE__, __LINE__ )
  call memalloc( this%order+1, dofs_new_basis, __FILE__, __LINE__ )
  call memalloc(cell%get_num_nodes(),cell_coordinates,__FILE__,__LINE__)

  coarse_subedge_iterator = this%subedges_x_coarse_edge%create_iterator() 
  do while ( .not. coarse_subedge_iterator%is_upper_bound() )
     num_fine_edges_in_subedge = this%sorted_fine_edges_in_coarse_subedge%get_sublist_size( coarse_subedge_iterator%get_current() )
     fine_edge_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator(coarse_subedge_iterator%get_current())

     local_edge       = 0
     shared_nodal_dof = 0
     do while ( .not. fine_edge_iterator%is_upper_bound() )
        local_edge = local_edge + 1
        call vef%set_gid( fine_edge_iterator%get_current() ) 

        call vef%get_cell_around(1, cell)
        call cell%get_nodes_coordinates (cell_coordinates)
        vef_lid = cell%get_vef_lid_from_gid( vef%get_gid() )

        edge_map_coordinates => edge_map%get_coordinates()

        ! Extract coordinates of the vertices within the face
        vertices_of_line          => ref_fe%get_vertices_n_face() 
        vertices_of_line_iterator = vertices_of_line%create_iterator(vef_lid)
        vertex_within_edge_id = 1
        do while ( .not. vertices_of_line_iterator%is_upper_bound () )
           vertex_within_cell_id = vertices_of_line_iterator%get_current()
           call edge_map_coordinates(vertex_within_edge_id)%init(cell_coordinates(vertex_within_cell_id)%get_value() )
           call vertices_of_line_iterator%next()
           vertex_within_edge_id = vertex_within_edge_id + 1
        end do

        ! Update edge_map on current edge
        call edge_map%update(local_edge_id = vef_lid - ref_fe%get_first_n_face_id_of_dim(1)+1, &
             reference_fe  = fe_cell%get_reference_fe_geo(),                                   &
             quadrature    = edge_quadrature )

        elvec = 0.0_rp 
        do qpoint = 1, edge_quadrature%num_quadrature_points
           factor = edge_map%get_det_jacobian(qpoint) * edge_quadrature%get_weight(qpoint)
           do ishape = 1, fe_1D%get_num_shape_functions() 
              call fe_1D%get_value(interpolation_1D, ishape, qpoint, shape_test)
              elvec(ishape) = elvec(ishape) + shape_test * factor 
           end do
        end do 

        ! Assemble 
        call this%get_dofs_from_vef(par_fe_space, vef, dofs_old_basis)
        dofs_new_basis(1)              = shared_nodal_dof 
        dofs_new_basis(2:this%order+1) = dofs_old_basis(1:this%order)  
        if (local_edge == num_fine_edges_in_subedge ) then
           dofs_new_basis(this%order+1)   = 0
        else 
           shared_nodal_dof               = dofs_old_basis(this%order)
        end if

        do idof = 1, this%order+1    
           if ( dofs_new_basis(idof) > 0 ) then 
              call constraint_in_edges%add( i    = dofs_new_basis(idof),  &
                   val  = elvec(idof)*factor  )
           end if
        end do
        call fine_edge_iterator%next() 
     end do
     call coarse_subedge_iterator%next()
  end do

  ! Change of basis for the assembled vector: C_new*inv(G) = C_old --> SOLVE G^t C_old = C_new 
  call this%apply_inverse_local_change_basis_transpose( constraint_in_edges, constraint_in_edges )

  call memfree(elvec, __FILE__, __LINE__ )
  call memfree(dofs_new_basis, __FILE__, __LINE__ )
  call memfree(dofs_old_basis, __FILE__, __LINE__ )
  call memfree(cell_coordinates, __FILE__, __LINE__ )

		call par_fe_space%free_fe_cell_iterator(fe_cell)
  call par_fe_space%triangulation%free_cell_iterator(cell) 
  call par_fe_space%free_fe_vef_iterator(vef) 

  call fe%free()
  call fe_1D%free() 
		call d_fe_geo%free() 
  call interpolation_1D%free() 
  call edge_quadrature%free()
		call edge_map%free() 

end subroutine Hcurl_l1_compute_first_order_moment_in_edges

! -------------------------------------------------------------------------------------------------
!
!                                 Change of basis matrix applications 
!
! -------------------------------------------------------------------------------------------------
subroutine Hcurl_l1_apply_global_change_basis(this, x_new, x_old)
  ! Thanks to structure of change basis, it can be applied locally without 
  ! further consideration and obtain the fully assembled local parts of the global
  ! change of basis 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t), target, intent(in)     :: this
  type(par_scalar_array_t)                   , intent(in)     :: x_new
  type(par_scalar_array_t)                   , intent(inout)  :: x_old

  type(serial_scalar_array_t)  , pointer   :: x_new_local
  type(serial_scalar_array_t)  , pointer   :: x_old_local
  type(serial_scalar_array_t)              :: x_new_local_G
  type(serial_scalar_array_t)              :: x_old_local_G
  type(serial_scalar_array_t)              :: change_basis_times_x
  
  type(sparse_matrix_t), pointer           :: change_basis_matrix

  x_old_local         => x_old%get_serial_scalar_array()
  x_new_local         => x_new%get_serial_scalar_array()

  call x_new_local%create_view( this%num_interior_dofs + 1,  & 
       this%num_total_dofs,         &
       x_new_local_G )

  call x_old_local%create_view( this%num_interior_dofs + 1,  & 
       this%num_total_dofs,         &
       x_old_local_G )

  ! Apply local change basis operator 
  call change_basis_times_x%create_and_allocate(this%num_total_dofs - this%num_interior_dofs) 
  
  change_basis_matrix => this%change_basis_matrix 
  call change_basis_matrix%apply(x_new_local_G, change_basis_times_x)
  call x_old_local_G%copy( change_basis_times_x ) 

  call change_basis_times_x%free() 
end subroutine Hcurl_l1_apply_global_change_basis

!===============================================================================================
subroutine Hcurl_l1_apply_global_change_basis_transpose(this, x_old, x_new)
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
  type(par_scalar_array_t)                 , intent(in)     :: x_old
  type(par_scalar_array_t)                 , intent(inout)  :: x_new

  type(serial_scalar_array_t), pointer  :: x_old_local 
  type(serial_scalar_array_t), pointer  :: x_new_local
  type(serial_scalar_array_t)           :: x_new_local_G
  type(serial_scalar_array_t)           :: x_old_local_G
  type(serial_scalar_array_t)           :: change_basis_trans_times_x

  x_old_local         => x_old%get_serial_scalar_array()
  x_new_local         => x_new%get_serial_scalar_array()

  call x_new_local%create_view( this%num_interior_dofs + 1,  & 
       this%num_total_dofs,         &
       x_new_local_G )

  call x_old_local%create_view( this%num_interior_dofs + 1,  & 
       this%num_total_dofs,         &
       x_old_local_G )

  ! Nullify non-owned dofs to perform the global Q'*x computation locally 
  call x_new%nullify_non_owned_dofs() 

  call change_basis_trans_times_x%create_and_allocate(this%num_total_dofs-this%num_interior_dofs) 

  ! Apply local change basis to built DoF 
  call this%change_basis_matrix%apply_transpose(x_old_local_G, change_basis_trans_times_x) 

  call x_new_local_G%copy(change_basis_trans_times_x)  

  ! Assemble all local contributions to the full Q'*x product 
  call x_new%comm() 

  call change_basis_trans_times_x%free() 
end subroutine Hcurl_l1_apply_global_change_basis_transpose

!===============================================================================================
subroutine Hcurl_l1_apply_inverse_local_change_basis(this, x_old_local, x_new_local) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
  type(serial_scalar_array_t)              , intent(in)     :: x_old_local
  type(serial_scalar_array_t)              , intent(inout)  :: x_new_local

  type(serial_scalar_array_t)              :: x_new_local_G
  type(serial_scalar_array_t)              :: x_old_local_G
  type(serial_scalar_array_t)              :: inv_change_basis_times_x

  ! Direct solver data
  type(direct_solver_t)        :: direct_solver 
  integer                      :: FPLError
  type(parameterlist_t)        :: parameter_list
  integer                      :: iparm(64)

  iparm      = 0 ! Init all entries to zero	
  iparm(1)   = 1 ! no solver default
  iparm(2)   = 2 ! fill-in reordering from METIS
  iparm(8)   = 2 ! nums of iterative refinement steps
  iparm(10)  = 8 ! perturb the pivot elements with 1E-8
  iparm(11)  = 1 ! use scaling 
  iparm(13)  = 1 ! use maximum weighted matching algorithm 
  iparm(21)  = 1 ! 1x1 + 2x2 pivots

  call parameter_list%init()
  FPLError =            parameter_list%set(key = direct_solver_type     ,   value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type,   value = pardiso_mkl_uns)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level, value = 0)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm); assert(FPLError == 0)  
  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(this%change_basis_matrix)

  call x_new_local%create_view( this%num_interior_dofs + 1,   & 
       this%num_total_dofs,          &
       x_new_local_G )

  call x_old_local%create_view( this%num_interior_dofs + 1,  & 
       this%num_total_dofs,         &
       x_old_local_G )

  ! Apply global inverse by means of local applications 
  call inv_change_basis_times_x%create_and_allocate( this%num_total_dofs - this%num_interior_dofs) 
  call inv_change_basis_times_x%init(0.0_rp) 

  call direct_solver%solve( x_old_local_G , inv_change_basis_times_x )
  call x_new_local_G%copy(inv_change_basis_times_x) 

  call direct_solver%free() 
  call inv_change_basis_times_x%free() 

end subroutine Hcurl_l1_apply_inverse_local_change_basis

!===============================================================================================
subroutine Hcurl_l1_apply_inverse_local_change_basis_transpose(this, x_new_local, x_old_local ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)      , intent(in)     :: this
  type(serial_scalar_array_t)              , intent(in)     :: x_new_local
  type(serial_scalar_array_t)              , intent(inout)  :: x_old_local

  type(serial_scalar_array_t)              :: x_new_local_G
  type(serial_scalar_array_t)              :: x_old_local_G
  type(serial_scalar_array_t)              :: inv_change_basis_trans_times_x

  ! Direct solver data
  type(direct_solver_t)        :: direct_solver 
  integer                      :: FPLError
  type(parameterlist_t)        :: parameter_list
  integer                      :: iparm(64)

  iparm      = 0 ! Init all entries to zero
  iparm(1)   = 1 ! no solver default
  iparm(2)   = 2 ! fill-in reordering from METIS
  iparm(8)   = 2 ! nums of iterative refinement steps
  iparm(10)  = 8 ! perturb the pivot elements with 1E-8
  iparm(11)  = 1 ! use scaling 
  iparm(12)  = 2 ! Solve transposed system 
  iparm(13)  = 1 ! use maximum weighted matching algorithm 
  iparm(21)  = 1 ! 1x1 + 2x2 pivots

  ! Create direct solver to update iterates 
  call parameter_list%init()
  FPLError =            parameter_list%set(key = direct_solver_type     ,   value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type,   value = pardiso_mkl_uns)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level, value = 0)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm); assert(FPLError == 0)  
  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(this%change_basis_matrix)

  call x_new_local%create_view( this%num_interior_dofs + 1,  & 
       this%num_total_dofs,         &
       x_new_local_G )

  call x_old_local%create_view( this%num_interior_dofs + 1,  & 
       this%num_total_dofs,         &
       x_old_local_G )

  ! Apply transposed inverse locally
  call inv_change_basis_trans_times_x%create_and_allocate( this%num_total_dofs - this%num_interior_dofs)
  call inv_change_basis_trans_times_x%init(0.0_rp) 

  call direct_solver%solve( x_new_local_G, inv_change_basis_trans_times_x )

  call x_old_local_G%copy( inv_change_basis_trans_times_x ) 

  call inv_change_basis_trans_times_x%free() 
  call direct_solver%free() 

end subroutine Hcurl_l1_apply_inverse_local_change_basis_transpose
! -------------------------------------------------------------------------------------------
! 
!             Getters for DoFs in different numberings 
!
! -------------------------------------------------------------------------------------------
subroutine Hcurl_l1_get_dofs_from_vef(this, par_fe_space, fe_vef, dof_list) 
  implicit none 
  ! This function returns dofs associated to a local VEF in the local 
  ! wire numbering. Interface does not contain sets of consecutive dofs 
  ! on its vefs, extract one-by-one info 
  class(Hcurl_l1_coarse_fe_handler_t)           , intent(in)       :: this
  type(par_fe_space_t)                          , intent(in)       :: par_fe_space 
  class(fe_vef_iterator_t)                      , intent(in)       :: fe_vef
  integer(ip), allocatable                      , intent(inout)    :: dof_list(:)

  class(fe_cell_iterator_t) , allocatable     :: fe
  type(list_iterator_t)                       :: own_dofs_on_vef_iterator 
  integer(ip)                                 :: field_id, ivef_within_cell 
  integer(ip)            , pointer            :: fe_dofs(:)
  integer(ip)                                 :: idof
  logical   :: reallocate 

  field_id = 1 ! To specify where it comes from! 
  call par_fe_space%create_fe_cell_iterator(fe) 

  call fe_vef%get_cell_around(1,fe)
  call fe%get_field_fe_dofs(field_id, fe_dofs)
  ivef_within_cell = fe%get_vef_lid_from_gid( fe_vef%vef%get_gid() )

  own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(ivef_within_cell, field_id)

  reallocate = .false.
  if (allocated(dof_list)) reallocate = ( size(dof_list) < own_dofs_on_vef_iterator%get_size() )                                      
  if ( (.not. allocated(dof_list)) .or. reallocate) then
     if (allocated(dof_list)) call memfree(dof_list, __FILE__,__LINE__); 
     call memalloc(own_dofs_on_vef_iterator%get_size(), dof_list, __FILE__,__LINE__);
  end if

  dof_list = 0
  idof     = 0
  do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
     idof = idof + 1
     dof_list(idof) = fe_dofs(own_dofs_on_vef_iterator%get_current())
     call own_dofs_on_vef_iterator%next()
  end do

  call par_fe_space%free_fe_cell_iterator(fe) 
end subroutine Hcurl_l1_get_dofs_from_vef

!===============================================================================================
subroutine Hcurl_l1_get_BDDC_edge_continuity_algorithm_case( parameter_list, algorithm )
  implicit none
  type(parameterlist_t)                 , intent(in)    :: parameter_list
  integer(ip)                           , intent(out)   :: algorithm

  character(len=*), parameter :: bddc_edge_continuity_algorithm_key     = 'bddc_edge_continuity_algorithm'
  integer(ip) :: FPLError

  assert(parameter_list%isAssignable(bddc_edge_continuity_algorithm_key, algorithm))
  FPLError = parameter_list%Get(bddc_edge_continuity_algorithm_key, algorithm)
  assert(FPLError == 0)

end subroutine Hcurl_l1_get_BDDC_edge_continuity_algorithm_case
! -------------------------------------------------------------------------------------------------
!
!                                 Coarse Edges counting and sorting subroutines 
!
! -------------------------------------------------------------------------------------------------
subroutine Hcurl_l1_count_coarse_edges_and_owned_fine_edges( this, par_fe_space, num_coarse_edges, &
     num_fine_edges_x_coarse_edge, edge_interior_vertices ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)       , intent(inout)  :: this
  type(par_fe_space_t)                      , intent(in)     :: par_fe_space 
  integer(ip)                               , intent(inout)  :: num_coarse_edges 
  integer(ip)             , allocatable     , intent(inout)  :: num_fine_edges_x_coarse_edge(:)
  type(hash_table_ip_ip_t), allocatable     , intent(inout)  :: edge_interior_vertices(:)

  ! Iterators 
  class(reference_fe_t)    , pointer      :: reference_fe 
  class(fe_cell_iterator_t), allocatable  :: fe
  type(fe_object_iterator_t)              :: object
  type(fe_vef_iterator_t)                 :: vertex 
  type(fe_vef_iterator_t)                 :: vef_within_object
  integer(ip)                             :: vef_lid, ivef_within_object
  integer(ip)                             :: iedge, iedge_coarse, istat

  ! Dofs on vef checker 
  type(list_iterator_t)        :: own_dofs_on_vef_iterator
  integer(ip)                  :: idof, field_id           
  integer(ip), pointer         :: fe_dofs(:)
  logical                      :: dofs_on_vef 

  field_id   = 1 ! To think where it comes from 

  call par_fe_space%create_fe_cell_iterator(fe)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call par_fe_space%create_fe_vef_iterator(vertex)

  ! Initialize H(curl) coarse fe handler common used variables 
  reference_fe           => fe%get_reference_fe(field_id) 
  this%order             = reference_fe%get_order() 
  this%num_interior_dofs = par_fe_space%get_block_num_interior_dofs(field_id)
  this%num_total_dofs    = par_fe_space%get_field_num_dofs(field_id) 

  ! Count number of coarse edges 
  num_coarse_edges = 0
  do while ( .not. object%has_finished() )
     if ( object%get_dim() == 1 ) then 
        num_coarse_edges = num_coarse_edges + 1
     end if
     call object%next() 
  end do

  call memalloc( num_coarse_edges, num_fine_edges_x_coarse_edge, __FILE__, __LINE__ ) 
  num_fine_edges_x_coarse_edge = 0  

  ! List all interior vertices belonging to the coarse edge, needed to discard vertices that do not 
  ! belong to the coarse edge 
  allocate( edge_interior_vertices(num_coarse_edges), stat=istat); check(istat==0)

  ! Count number of active fine edges per coarse edge 
  iedge_coarse   = 0
  call object%first() 
  do while ( .not. object%has_finished() )
     if ( object%get_dim() == 1 ) then 
        iedge_coarse = iedge_coarse + 1
        call edge_interior_vertices(iedge_coarse)%init(object%get_num_vefs()) 

        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dim() == 0 ) then  
              call edge_interior_vertices(iedge_coarse)%put( key=vef_within_object%get_gid(), val=1, stat=istat); check(istat==now_stored)

           elseif ( vef_within_object%get_dim() == 1 ) then   

              call vef_within_object%get_cell_around(1,fe)
              call fe%get_field_fe_dofs(field_id, fe_dofs)
              vef_lid         = fe%get_vef_lid_from_gid(vef_within_object%get_gid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(vef_lid, field_id)

              ! Only count VEFs that contain free dofs
              dofs_on_vef = .false. 
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof    = own_dofs_on_vef_iterator%get_current()
                 if ( fe_dofs(idof) > 0 ) then
                    dofs_on_vef = .true.
                    exit
                 end if
                 call own_dofs_on_vef_iterator%next()
              end do

              if ( dofs_on_vef ) then
                 num_fine_edges_x_coarse_edge( iedge_coarse ) = num_fine_edges_x_coarse_edge( iedge_coarse ) + 1
              end if

           end if
        end do
     end if
     call object%next() 
  end do

  ! Free iterators 
  call par_fe_space%free_fe_cell_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_vef_iterator(vertex)

end subroutine Hcurl_l1_count_coarse_edges_and_owned_fine_edges

!===============================================================================================
subroutine Hcurl_l1_fill_coarse_subedges_and_owned_fine_edges( this, par_fe_space, num_coarse_edges, num_fine_edges_x_coarse_edge, edge_interior_vertices ) 
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)       , intent(inout)  :: this
  type(par_fe_space_t)                      , intent(in)     :: par_fe_space 
  integer(ip)                               , intent(in)     :: num_coarse_edges 
  integer(ip)             , allocatable     , intent(in)     :: num_fine_edges_x_coarse_edge(:)
  type(hash_table_ip_ip_t), allocatable     , intent(inout)  :: edge_interior_vertices(:)

  ! Iterators 
  type(fe_object_iterator_t)              :: object
  type(fe_vef_iterator_t)                 :: vef_within_object 
  class(fe_cell_iterator_t), allocatable  :: fe
  integer(ip)                             :: vef_lid, ivef_within_object
  ! Vertices in edges  
  type(fe_vef_iterator_t)                   :: vertex 
  class(reference_fe_t),  pointer           :: ref_fe_geo
  type(list_t), pointer                     :: vertices_of_line
  type(list_iterator_t)                     :: vertices_of_line_iterator
  integer(ip)                               :: vertex_within_cell_id, vertex_within_edge_id  
  integer(ip) , allocatable                 :: vertices_in_edge(:,:)
  ! Nodes data 
  integer(ip)                               :: node_id
  integer(ip)                               :: num_nodes
  integer(ip), allocatable                  :: node_list(:)
  type(hash_table_ip_ip_t)                  :: nodes_counter
  type(hash_table_ip_ip_t)                  :: nodes_type 
  integer(ip)                               :: counter
  integer(ip), allocatable                  :: num_nodes_each_type(:)
  ! Edges data
  integer(ip)             , allocatable     :: fine_edges_list(:,:) 
  integer                                   :: iedge_coarse, iedge_fine 

  ! Edge sorting algorithms 
  integer(ip)              :: start_node_gid, first_fine_edge 
  integer(ip)              :: num_fine_edges_found 
  type(hash_table_ip_ip_t) :: num_fine_edges_x_subedge
  integer(ip)              :: num_subedges_in_coarse_edge 
  integer(ip)              :: total_num_subedges
  integer(ip)              :: offcomponent_fine_edges

  ! Dofs on vef checker 
  type(list_iterator_t)        :: own_dofs_on_vef_iterator
  integer(ip)                  :: idof, field_id           
  integer(ip), pointer         :: fe_dofs(:)
  logical                      :: dofs_on_vef 
  integer(ip)                  :: istat

  field_id   = 1 ! To think where it comes from 

  call par_fe_space%create_fe_cell_iterator(fe)
  call par_fe_space%create_fe_object_iterator(object)
  call par_fe_space%create_fe_vef_iterator(vef_within_object)
  call par_fe_space%create_fe_vef_iterator(vertex)

  ! Initialize variables 
  total_num_subedges  = 0
  call this%subedges_x_coarse_edge%create( num_coarse_edges ) 
  call num_fine_edges_x_subedge%init( sum(num_fine_edges_x_coarse_edge) )
  call this%fine_edge_direction%init( sum(num_fine_edges_x_coarse_edge) )
  call memalloc( num_coarse_edges, maxval(num_fine_edges_x_coarse_edge), fine_edges_list, __FILE__, __LINE__ ) 
  fine_edges_list   = 0

  call object%first() 
  iedge_coarse = 0
  call memalloc( num_node_types, num_nodes_each_type, __FILE__, __LINE__ ) 
  do while ( .not. object%has_finished() )
     if ( object%get_dim() == 1 ) then
        iedge_coarse = iedge_coarse + 1	   

        ! Initialize variables 
        call memalloc( num_fine_edges_x_coarse_edge(iedge_coarse), 2, vertices_in_edge, __FILE__, __LINE__ )
        call memalloc( 2*num_fine_edges_x_coarse_edge(iedge_coarse), node_list, __FILE__, __LINE__ )
        ! Node identification algorithm 
        call nodes_counter%init( 2*num_fine_edges_x_coarse_edge(iedge_coarse) )
        call nodes_type%init( 2*num_fine_edges_x_coarse_edge(iedge_coarse) )

        vertices_in_edge = 0
        node_list        = 0
        num_nodes        = 0

        iedge_fine = 0
        do ivef_within_object=1, object%get_num_vefs()
           call object%get_vef(ivef_within_object, vef_within_object)
           if ( vef_within_object%get_dim() == 1 ) then

              call vef_within_object%get_cell_around(1,fe)
              call fe%get_field_fe_dofs(field_id, fe_dofs)
              vef_lid         = fe%get_vef_lid_from_gid(vef_within_object%get_gid())
              own_dofs_on_vef_iterator = fe%create_own_dofs_on_vef_iterator(vef_lid , field_id)

              dofs_on_vef = .false. 
              do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                 idof    = own_dofs_on_vef_iterator%get_current()
                 if ( fe_dofs(idof) > 0 ) then
                    dofs_on_vef = .true.
                    exit
                 end if
                 call own_dofs_on_vef_iterator%next()
              end do

              if ( dofs_on_vef ) then

                 iedge_fine = iedge_fine + 1
                 fine_edges_list(iedge_coarse, iedge_fine) = vef_within_object%get_gid() 

                 call vef_within_object%get_cell_around(1,fe) 
                 ref_fe_geo                => fe%get_reference_fe_geo()
                 vertices_of_line          => ref_fe_geo%get_vertices_n_face() 
                 vef_lid                   = fe%get_vef_lid_from_gid(vef_within_object%get_gid())     
                 vertices_of_line_iterator = vertices_of_line%create_iterator(vef_lid)
                 vertex_within_edge_id     = 1

                 do while( .not. vertices_of_line_iterator%is_upper_bound() )
                    vertex_within_cell_id = vertices_of_line_iterator%get_current()
                    call fe%get_vef(vertex_within_cell_id, vertex )
                    node_id = vertex%get_gid() 		

                    ! Fill vertices in each edge   
                    vertices_in_edge( iedge_fine, vertex_within_edge_id )  = node_id 
                    call nodes_counter%get( key=node_id, val=counter, stat=istat )
                    ! New node introduced to the table 
                    if ( istat/=key_found ) then 
                       num_nodes = num_nodes + 1
                       node_list(num_nodes) = node_id	
                       call nodes_counter%put(key=node_id, val=1, stat=istat)
                    else 
                       ! Repeated node, update counter 
                       counter = counter + 1
                       call nodes_counter%del(key=node_id, stat=istat)
                       call nodes_counter%put(key=node_id, val=counter, stat=istat)
                    end if

                    vertex_within_edge_id = vertex_within_edge_id + 1
                    call vertices_of_line_iterator%next() 
                 end do

              end if
           end if
        end do

        call assign_and_count_node_types( edge_interior_vertices(iedge_coarse), num_nodes, node_list, nodes_counter, nodes_type, num_nodes_each_type ) 

        ! Build start-->end chained node path till a end/problematic node is found. 
        ! Repeat till all fine edges have been sorted and assigned to a subedge
        num_fine_edges_found           = 0
        num_subedges_in_coarse_edge    = 0
        offcomponent_fine_edges        = 0
        do while ( any(num_nodes_each_type.ne.0) ) 
           num_subedges_in_coarse_edge =  num_subedges_in_coarse_edge + 1
           total_num_subedges          = total_num_subedges + 1

           call identify_following_starting_node( par_fe_space, num_nodes, num_nodes_each_type, node_list, nodes_type, start_node_gid )

           call choose_path_direction( par_fe_space, start_node_gid, num_fine_edges_x_coarse_edge(iedge_coarse), vertices_in_edge, & 
                node_list, nodes_counter, nodes_type, first_fine_edge )   

           call build_path_from_starting_node_and_direction_till_end_node(this, iedge_coarse, num_fine_edges_x_coarse_edge(iedge_coarse), fine_edges_list,    &
                vertices_in_edge, nodes_counter, nodes_type, start_node_gid, first_fine_edge,       &
                num_nodes_each_type, num_fine_edges_found, offcomponent_fine_edges )

           offcomponent_fine_edges = offcomponent_fine_edges + num_fine_edges_found 
           call num_fine_edges_x_subedge%put( key=total_num_subedges, val=num_fine_edges_found, stat=istat ); check(istat==now_stored) 
        end do
        call this%subedges_x_coarse_edge%sum_to_pointer_index(iedge_coarse, num_subedges_in_coarse_edge)

        call memfree(vertices_in_edge, __FILE__, __LINE__)
        call nodes_counter%free()
        call nodes_type%free()
        call memfree( node_list, __FILE__, __LINE__ )
     end if
     call object%next() 
  end do

  call this%subedges_x_coarse_edge%calculate_header()
  call this%subedges_x_coarse_edge%allocate_list_from_pointer()

  ! Fill H(curl) coarse fe handler sorted fine edges list in subedges 
  call this%fill_edges_lists( num_fine_edges_x_coarse_edge, num_fine_edges_x_subedge, fine_edges_list ) 

  ! Free iterators 
  call par_fe_space%free_fe_cell_iterator(fe)
  call par_fe_space%free_fe_object_iterator(object)
  call par_fe_space%free_fe_vef_iterator(vef_within_object)
  call par_fe_space%free_fe_vef_iterator(vertex)

  ! Free data 
  call memfree( num_nodes_each_type, __FILE__, __LINE__ ) 
  call memfree( fine_edges_list, __FILE__, __LINE__ ) 
  deallocate( edge_interior_vertices, stat=istat); check(istat==0)   
  call num_fine_edges_x_subedge%free()
  call memfree( num_fine_edges_x_coarse_edge, __FILE__, __LINE__ ) 

end subroutine Hcurl_l1_fill_coarse_subedges_and_owned_fine_edges

!===============================================================================================
subroutine Hcurl_l1_fill_edges_lists( this, num_fine_edges_x_coarse_edge, num_fine_edges_x_subedge, fine_edges_list )    
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)     , intent(inout)  :: this
  integer(ip)             , allocatable   , intent(in)     :: num_fine_edges_x_coarse_edge(:)
  type(hash_table_ip_ip_t)                , intent(in)     :: num_fine_edges_x_subedge
  integer(ip)             , allocatable   , intent(in)     :: fine_edges_list(:,:) 

  integer(ip)                             :: iedge, istat
  integer                                 :: iedge_coarse

  ! Edges iterators  
  type(list_iterator_t)    :: subedges_iterator
  type(list_iterator_t)    :: fine_edges_in_subedges_iterator
  integer(ip)              :: isubedge
  integer(ip)              :: num_fine_edges
  integer(ip)              :: c 

  c=0 
  subedges_iterator = this%subedges_x_coarse_edge%create_iterator()
  do while ( .not. subedges_iterator%is_upper_bound() )
     c = c + 1
     call subedges_iterator%set_current(c)
     call subedges_iterator%next()
  end do

  call this%sorted_fine_edges_in_coarse_subedge%create( this%subedges_x_coarse_edge%get_size() )
  do isubedge = 1, this%subedges_x_coarse_edge%get_size()
     call num_fine_edges_x_subedge%get( key=isubedge, val=num_fine_edges, stat=istat ); check(istat==key_found) 
     call this%sorted_fine_edges_in_coarse_subedge%sum_to_pointer_index(isubedge, num_fine_edges )
  end do

  call this%sorted_fine_edges_in_coarse_subedge%calculate_header()
  call this%sorted_fine_edges_in_coarse_subedge%allocate_list_from_pointer()	

  fine_edges_in_subedges_iterator = this%sorted_fine_edges_in_coarse_subedge%create_iterator()
  do iedge_coarse = 1, size(num_fine_edges_x_coarse_edge)  
     do c=1, num_fine_edges_x_coarse_edge(iedge_coarse)
        call fine_edges_in_subedges_iterator%set_current( fine_edges_list(iedge_coarse,c) )
        call fine_edges_in_subedges_iterator%next() 
     end do
  end do

  !		call this%subedges_x_coarse_edge%print(6) 
  !  call this%sorted_fine_edges_in_coarse_subedge%print(6)

  call subedges_iterator%free() 
  call fine_edges_in_subedges_iterator%free() 

end subroutine Hcurl_l1_fill_edges_lists

!===============================================================================================
subroutine assign_and_count_node_types(edge_interior_vertices, num_nodes, node_list, nodes_counter, nodes_type, num_nodes_each_type )
  implicit none 
  type(hash_table_ip_ip_t)  , intent(in)    :: edge_interior_vertices
  integer(ip)               , intent(in)    :: num_nodes 
  integer(ip) , allocatable , intent(in)    :: node_list(:)  
  type(hash_table_ip_ip_t)  , intent(in)    :: nodes_counter 
  type(hash_table_ip_ip_t)  , intent(inout) :: nodes_type 
  integer(ip), allocatable  , intent(inout) :: num_nodes_each_type(:)
  ! Locals 
  integer(ip) :: num_startend_nodes 
  integer(ip) :: inode
  integer(ip) :: counter, istat 

  num_nodes_each_type = 0	
  num_startend_nodes  = 0 

  ! Count nodes of each type 
  do inode=1, num_nodes 
     call nodes_counter%get( key=node_list(inode), val=counter, stat=istat) 
     if (counter .eq. 1) then 
        call nodes_type%put(key=node_list(inode), val=edge_boundary_node, stat=istat)
        num_nodes_each_type( edge_boundary_node ) = num_nodes_each_type( edge_boundary_node ) + 1
        num_startend_nodes = num_startend_nodes + 1
     elseif (counter .eq. 2) then
        call nodes_type%put(key=node_list(inode), val=interior_node, stat=istat)
        num_nodes_each_type( interior_node ) = num_nodes_each_type( interior_node ) + 1
     elseif (counter .ge. 3) then
        call nodes_type%put(key=node_list(inode), val=n_furcation_node, stat=istat)
        num_nodes_each_type( n_furcation_node ) = num_nodes_each_type( n_furcation_node ) + 1
        num_startend_nodes    = num_startend_nodes + counter
        WRITE(*,*) 'NFURCATION-NODE is FOUND WITH N=', counter 
     end if
  end do

  ! Mark interior nodes not belonging to the coarse object as not_owned_nodes 
  do inode=1, num_nodes  
     call edge_interior_vertices%get(key=node_list(inode), val=counter, stat=istat) 
     if ( istat==key_not_found ) then 
        call nodes_counter%get( key=node_list(inode), val=counter, stat=istat); check(istat==key_found) 
        if ( counter == 2) then 
           call nodes_type%del(key=node_list(inode), stat=istat); check(istat==deleted) 
           call nodes_type%put(key=node_list(inode), val=not_owned_node, stat=istat)
           num_nodes_each_type( interior_node )  = num_nodes_each_type( interior_node ) - 1
           num_nodes_each_type( not_owned_node ) = num_nodes_each_type( not_owned_node ) + 1
           num_startend_nodes = num_startend_nodes + 2  
        end if
     end if
  end do

end subroutine assign_and_count_node_types

!===============================================================================================
subroutine identify_following_starting_node( par_fe_space, num_nodes, num_nodes_each_type, node_list, nodes_type, start_node_gid )
  implicit none 
  type(par_fe_space_t)      , intent(in)    :: par_fe_space 
  integer(ip)               , intent(in)    :: num_nodes 
  integer(ip) , allocatable , intent(in)    :: num_nodes_each_type(:)
  integer(ip) , allocatable , intent(in)    :: node_list(:) 
  type(hash_table_ip_ip_t)  , intent(in)    :: nodes_type 
  integer(ip)               , intent(inout) :: start_node_gid 

  integer(ip)                    :: inode, node_type 
  integer(ip)                    :: found_nodes, istat 
  integer(ip)  , allocatable     :: potential_startend_nodes(:) 

  ! Priority to edge_boundary nodes 
  if ( num_nodes_each_type(edge_boundary_node) > 0 ) then 

     call memalloc( num_nodes_each_type(edge_boundary_node), potential_startend_nodes, __FILE__, __LINE__ )    
     found_nodes = 0
     do inode=1, num_nodes   
        call nodes_type%get( key=node_list(inode), val=node_type, stat=istat)
        if ( (istat==key_found) .and. (node_type == edge_boundary_node) ) then
           found_nodes = found_nodes + 1
           potential_startend_nodes( found_nodes ) = node_list(inode) 
        end if
     end do

     ! Secondly, look for not_owned nodes where the coarse edge may be splitted 
  elseif ( num_nodes_each_type(not_owned_node) > 0 ) then 

     call memalloc( num_nodes_each_type(not_owned_node), potential_startend_nodes, __FILE__, __LINE__ )    
     found_nodes = 0
     do inode=1, num_nodes   
        call nodes_type%get( key=node_list(inode), val=node_type, stat=istat)
        if ( (istat==key_found) .and. (node_type == not_owned_node) ) then
           found_nodes = found_nodes + 1
           potential_startend_nodes( found_nodes ) = node_list(inode) 
        end if
     end do

     ! Thirdly, look for n_furcation_nodes where the coarse edge may be splitted 
  elseif ( num_nodes_each_type(n_furcation_node) > 0 ) then   
     call memalloc( num_nodes_each_type(n_furcation_node), potential_startend_nodes, __FILE__, __LINE__ )    
     found_nodes = 0
     do inode=1, num_nodes   
        call nodes_type%get( key=node_list(inode), val=node_type, stat=istat)
        if ( (istat==key_found) .and. (node_type == n_furcation_node) ) then
           found_nodes = found_nodes + 1
           potential_startend_nodes( found_nodes ) = node_list(inode) 
        end if
     end do

     ! If none of the others, we only have interior nodes and a closed path, the edge may be splitted 
  elseif ( num_nodes_each_type(interior_node) > 0 ) then 
     call memalloc( num_nodes_each_type(interior_node), potential_startend_nodes, __FILE__, __LINE__ )   
     found_nodes = 0
     do inode=1, num_nodes   
        call nodes_type%get( key=node_list(inode), val=node_type, stat=istat) 
        if ( (istat==key_found) .and. (node_type==interior_node) ) then
           found_nodes = found_nodes + 1
           potential_startend_nodes( found_nodes ) = node_list(inode) 
        end if
     end do

  end if

  ! Choose one node among the potential ones: the minimum_nonconsecutive_gid node 
  call find_node_w_minimum_nonconsecutive_gid( par_fe_space, potential_startend_nodes, start_node_gid ) 

  call memfree( potential_startend_nodes, __FILE__, __LINE__ )

end subroutine identify_following_starting_node

!===============================================================================================
subroutine choose_path_direction( par_fe_space, start_node_gid, num_fine_edges, vertices_in_edge, node_list, nodes_counter, nodes_type, first_fine_edge)
  implicit none 
  type(par_fe_space_t)     , intent(in)    :: par_fe_space 
  integer(ip)              , intent(in)    :: start_node_gid
  integer(ip)              , intent(in)    :: num_fine_edges 
  integer(ip), allocatable , intent(in)    :: vertices_in_edge(:,:)
  integer(ip), allocatable , intent(in)    :: node_list(:) 
  type(hash_table_ip_ip_t) , intent(in)    :: nodes_counter
  type(hash_table_ip_ip_t) , intent(in)    :: nodes_type 
  integer(ip)              , intent(inout) :: first_fine_edge
  ! Locals 
  integer(ip) :: i, node_type 
  integer(ip) :: perm(2) 
  integer(ip) :: counter, istat  
  integer(ip) :: iedge, inode
  integer(ip) , allocatable :: potential_following_nodes_ids(:)
  integer(ip) , allocatable :: potential_following_edges(:) 
  integer(ip) :: following_node_gid, index 


  call nodes_type%get( key=start_node_gid, val=node_type, stat=istat); check(istat==key_found) 
  if ( node_type .eq. edge_boundary_node ) then

     ! Unique direction defined by edge containing the node. Forward loop ensures that selected edge 
     ! has not been sorted yet! 
     do iedge = num_fine_edges, 1, -1
        if ( (vertices_in_edge(iedge,1)==start_node_gid) .or. (vertices_in_edge(iedge,2)==start_node_gid) ) then 
           first_fine_edge = iedge; exit 
        end if
     end do

  else

     ! Choose first edge from all potential first edges 
     call nodes_counter%get( key=start_node_gid, val=counter, stat=istat ); check(istat==key_found) 
     perm = (/ 2,1 /)
     call memalloc( counter, potential_following_nodes_ids, __FILE__, __LINE__ ) 
     call memalloc( counter, potential_following_edges, __FILE__, __LINE__ )

     i = 0
     do iedge = 1, num_fine_edges
        do inode = 1,2
           if ( vertices_in_edge(iedge,inode)==start_node_gid ) then	
              i = i + 1
              potential_following_nodes_ids(i) = vertices_in_edge(iedge, perm(inode)) 
              potential_following_edges(i)     = iedge 
           end if
        end do
     end do

     call find_node_w_minimum_nonconsecutive_gid( par_fe_space, potential_following_nodes_ids, following_node_gid, index )

     ! Add first VEF from the minimum coordinate based direction 
     first_fine_edge = potential_following_edges(index)

     call memfree( potential_following_nodes_ids, __FILE__, __LINE__ ) 
     call memfree( potential_following_edges, __FILE__, __LINE__ ) 
  end if

end subroutine choose_path_direction

!===============================================================================================
subroutine build_path_from_starting_node_and_direction_till_end_node(this, iedge_coarse, num_fine_edges_in_coarse_edge, fine_edges_list, vertices_in_edge,  &
     nodes_counter, nodes_type, start_node_gid, first_fine_edge, num_nodes_each_type,        & 
     num_fine_edges_found, offcomponent_fine_edges )
  implicit none 
  class(Hcurl_l1_coarse_fe_handler_t)     , intent(inout)  :: this
  integer(ip)                             , intent(in)     :: iedge_coarse 
  integer(ip)                             , intent(in)     :: num_fine_edges_in_coarse_edge 
  integer(ip)              , allocatable  , intent(inout)  :: fine_edges_list(:,:) 
  integer(ip)              , allocatable  , intent(inout)  :: vertices_in_edge(:,:) 
  type(hash_table_ip_ip_t)                , intent(inout)  :: nodes_counter
  type(hash_table_ip_ip_t)                , intent(inout)  :: nodes_type 
  integer(ip)                             , intent(inout)  :: start_node_gid 
  integer(ip)                             , intent(in)     :: first_fine_edge 
  integer(ip)                             , intent(inout)  :: num_nodes_each_type(num_node_types) 
  integer(ip)                             , intent(inout)  :: num_fine_edges_found 
  integer(ip)                             , intent(in)     :: offcomponent_fine_edges

  integer(ip) :: iedge, inode 
  integer(ip) :: counter, perm(2) 
  integer(ip) :: following_node_gid 
  integer(ip) :: node_type, istat

  integer(ip) :: i 
  integer(ip) :: edge_gid_buffer
  integer(ip) :: nodes_gid_buffer(2) 

  perm = (/ 2,1 /) 
  num_fine_edges_found = 0
  following_node_gid   = start_node_gid 

  ! Loop till an end node is found 
  do while ( (num_fine_edges_found==0) .or. (.not. is_end_node(nodes_type, following_node_gid)) )
     start_node_gid = following_node_gid
     call update_nodes_counter_and_type( start_node_gid, nodes_counter, nodes_type, num_nodes_each_type )

     if ( num_fine_edges_found == 0 ) then 
        num_fine_edges_found = 1
        iedge = first_fine_edge 						
        do inode=1,2 
           if (vertices_in_edge(iedge,inode) == start_node_gid) then 
              following_node_gid = vertices_in_edge(iedge, perm(inode) )
              exit 
           end if
        end do

     else 

        edges_loop: do iedge = 1+offcomponent_fine_edges+num_fine_edges_found, num_fine_edges_in_coarse_edge 
           nodes_loop: do inode = 1,2
              if ( (vertices_in_edge(iedge,inode)==start_node_gid) ) then		         
                 num_fine_edges_found = num_fine_edges_found + 1              
                 exit edges_loop 
              end if
           end do nodes_loop
        end do edges_loop
     end if

     ! Assign direction to found edge 
     if ( inode .eq. 1 ) then
        call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=same_as_coarse_edge, stat=istat)
     else 
        call this%fine_edge_direction%put(key=fine_edges_list(iedge_coarse, iedge), val=opposite_to_coarse_edge, stat=istat)   
     end if

     ! Update information for the next node 
     following_node_gid  = vertices_in_edge(iedge, perm(inode))

     ! Swap edges_list and associated info order to send found edge to sorted position  
     edge_gid_buffer = fine_edges_list( iedge_coarse, offcomponent_fine_edges+num_fine_edges_found ) 
     fine_edges_list( iedge_coarse, offcomponent_fine_edges+num_fine_edges_found ) = fine_edges_list( iedge_coarse, iedge )
     fine_edges_list( iedge_coarse, iedge ) = edge_gid_buffer 

     nodes_gid_buffer = vertices_in_edge(offcomponent_fine_edges+num_fine_edges_found, :)  
     vertices_in_edge(offcomponent_fine_edges+num_fine_edges_found, :) = vertices_in_edge(iedge, :)
     vertices_in_edge(iedge, :) = nodes_gid_buffer 
  end do

  ! Update last node counter and type found in the chain 
  call update_nodes_counter_and_type( following_node_gid, nodes_counter, nodes_type, num_nodes_each_type )

end subroutine build_path_from_starting_node_and_direction_till_end_node

!===============================================================================================
subroutine update_nodes_counter_and_type ( node_id, nodes_counter, nodes_type, num_nodes_each_type ) 
  ! This subroutine Updates counters and the state according to the following diagram 
  !   NODE_TYPE     |   NODE_COUNTER       ||        UPDATED NODE_TYPE   |  UPDATED NODE_COUNTER 
  ! ----------------------------------------------------------------------------------------------
  !   edge_boundary         1           ---- >                   -                    0
  !   interior              2           ---- >                   -                    0
  !   n-furcation           n           ---- >     (n>2)   n-furcation               n-1    
  !                                     ----->     (n=2)   edge_boundary              1
  !   not_owned             2           ---- >             edge_boundary              1
  ! ----------------------------------------------------------------------------------------------

  implicit none 
  integer(ip)              , intent(in)    :: node_id 
  type(hash_table_ip_ip_t) , intent(inout) :: nodes_counter
  type(hash_table_ip_ip_t) , intent(inout) :: nodes_type 
  integer(ip)              , intent(inout) :: num_nodes_each_type(num_node_types)  

  integer(ip) :: node_type
  integer(ip) :: counter 
  integer(ip) :: istat 

  call nodes_type%get( key=node_id, val=node_type, stat=istat); check(istat==key_found) 

  select case ( node_type ) 
  case (edge_boundary_node)  

     call nodes_counter%del( key=node_id, stat=istat); check(istat==deleted)
     call nodes_type%del( key=node_id, stat=istat); check(istat==deleted)
     num_nodes_each_type( edge_boundary_node ) = num_nodes_each_type( edge_boundary_node ) - 1

  case ( interior_node ) 

     call nodes_counter%del( key=node_id, stat=istat); check(istat==deleted)
     call nodes_type%del( key=node_id, stat=istat); check(istat==deleted)
     num_nodes_each_type( interior_node ) = num_nodes_each_type( interior_node ) - 1

  case ( n_furcation_node ) 

     call nodes_counter%get( key=node_id, val=counter, stat=istat); check(istat==key_found)
     call nodes_counter%del( key=node_id, stat=istat); check(istat==deleted)
     call nodes_counter%put( key=node_id, val=counter-1, stat=istat); check(istat==now_stored)

     if ( counter .eq. 2 ) then 
        call nodes_type%del( key=node_id, stat=istat); check(istat==deleted)
        call nodes_type%put( key=node_id, val=edge_boundary_node, stat=istat); check(istat==now_stored)
        num_nodes_each_type( n_furcation_node ) = num_nodes_each_type( n_furcation_node ) - 1
        num_nodes_each_type( edge_boundary_node ) = num_nodes_each_type( edge_boundary_node ) + 1
     end if

  case ( not_owned_node ) 

     call nodes_counter%get( key=node_id, val=counter, stat=istat); check(istat==key_found)
     call nodes_counter%del( key=node_id, stat=istat); check(istat==deleted)
     call nodes_counter%put( key=node_id, val=counter-1, stat=istat); check(istat==now_stored)
     call nodes_type%del( key=node_id, stat=istat); check(istat==deleted)
     call nodes_type%put( key=node_id, val=edge_boundary_node, stat=istat); check(istat==now_stored)
     num_nodes_each_type( not_owned_node ) = num_nodes_each_type( not_owned_node ) - 1
     num_nodes_each_type( edge_boundary_node ) = num_nodes_each_type( edge_boundary_node ) + 1

  end select

end subroutine update_nodes_counter_and_type

!===============================================================================================
function is_end_node( nodes_type, node_id ) 
  implicit none 
  type(hash_table_ip_ip_t)  , intent(in) :: nodes_type
  integer(ip)               , intent(in) :: node_id 
  logical :: is_end_node 

  integer(ip) :: node_type, istat

  call nodes_type%get( key=node_id, val=node_type, stat=istat); check(istat==key_found) 
  if ( node_type==interior_node ) then 
     is_end_node = .false.  
  else 
     is_end_node = .true. 
  end if

end function is_end_node

!===============================================================================================
subroutine find_node_w_minimum_nonconsecutive_gid( par_fe_space, nodes_array, local_node_w_min_ggid, pos_in_array) 
  implicit none 
  type(par_fe_space_t)       , intent(in)   :: par_fe_space
  integer(ip)  , allocatable,  intent(in)   :: nodes_array(:) 
  integer(ip)                , intent(inout):: local_node_w_min_ggid 
  integer(ip), optional      , intent(inout):: pos_in_array 

  class(fe_cell_iterator_t), allocatable   :: fe 
  type(fe_vef_iterator_t)                  :: vertex

  type(par_triangulation_t)         :: triangulation
  integer(igp)  , allocatable       :: node_ggids(:) 
  integer(ip)                    :: ivef_within_cell 
  integer(ip)                    :: inode, npotential_candidates 
  integer(igp)                   :: cell_around_ggid, maximum_cell_around_ggid 
  integer(ip)                    :: ielem, ielem_with_max_ggid, inode_w_min_ggid 

  npotential_candidates = size(nodes_array)
  call memalloc( npotential_candidates, node_ggids,  __FILE__, __LINE__ )
  node_ggids = 0

  call par_fe_space%create_fe_cell_iterator(fe)
  call par_fe_space%create_fe_vef_iterator(vertex) 

  do inode=1, npotential_candidates
     call vertex%set_gid(nodes_array(inode))
     maximum_cell_around_ggid = 0 
     do ielem = 1, vertex%get_num_cells_around()  
        call vertex%get_cell_around(ielem,fe)
        cell_around_ggid = fe%get_ggid()	
        if ( cell_around_ggid > maximum_cell_around_ggid ) then 
           maximum_cell_around_ggid = cell_around_ggid
           ielem_with_max_ggid      = ielem 
        end if
     end do
     call vertex%get_cell_around(ielem_with_max_ggid, fe)
     ivef_within_cell = fe%get_vef_lid_from_gid(vertex%get_gid())
     node_ggids(inode) = triangulation%generate_non_consecutive_vef_ggid( maximum_cell_around_ggid, ivef_within_cell, 1 )  
  end do

  call par_fe_space%free_fe_cell_iterator(fe)
  call par_fe_space%free_fe_vef_iterator(vertex)

  inode_w_min_ggid      = minloc( node_ggids, DIM=1 ) 
  local_node_w_min_ggid = nodes_array( inode_w_min_ggid ) 

  if (present(pos_in_array)) pos_in_array = inode_w_min_ggid

  call memfree( node_ggids, __FILE__, __LINE__ )
end subroutine find_node_w_minimum_nonconsecutive_gid
