! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
! ================================================================================
subroutine tet_Hcurl_interpolator_create( this, fe_space, field_id )
  implicit none
  class(tet_Hcurl_interpolator_t)      , intent(inout) :: this 
  class(serial_fe_space_t)             , intent(in)    :: fe_space
  integer(ip)                          , intent(in)    :: field_id

  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t)    , pointer     :: reference_fe 
  integer(ip)                            :: reduced_order_vector(SPACE_DIM)
  integer(ip)                            :: num_interior_moments
  integer(ip)                            :: idime, istat 

  integer(ip) :: reference_fe_id  
  integer(ip) :: num_reference_fes

  this%field_id = field_id
  call fe_space%create_fe_cell_iterator(fe)
  num_reference_fes = fe_space%get_num_reference_fes()

  ! Allocate maps with possible variable degree  
  allocate ( this%edge_maps(num_reference_fes), stat=istat); check(istat==0)
  allocate ( this%facet_maps(num_reference_fes), stat=istat); check(istat==0)
  allocate ( this%cell_maps(num_reference_fes), stat=istat); check(istat==0)
  ! Quadratures with possible variable degree
  allocate ( this%edge_quadratures(num_reference_fes), stat=istat); check(istat==0)
  allocate ( this%facet_quadratures(num_reference_fes), stat=istat); check(istat==0)
  allocate ( this%cell_quadratures(num_reference_fes), stat=istat); check(istat==0)
  ! Interpolations with possible variable degree  
  allocate ( this%edge_interpolations(num_reference_fes), stat=istat); check(istat==0) 
  allocate ( this%facet_interpolations(num_reference_fes), stat=istat); check(istat==0)
  allocate ( this%cell_interpolations(num_reference_fes), stat=istat); check(istat==0)
  ! Allocate FEs 
  allocate ( this%fes_1D(num_reference_fes), stat=istat); check(istat==0) 
  allocate ( this%fes_2D(num_reference_fes), stat=istat); check(istat==0)
  allocate ( this%fes_lagrangian(num_reference_fes), stat=istat); check(istat==0)

  do reference_fe_id = 1, num_reference_fes 
     reference_fe => fe_space%get_reference_fe(reference_fe_id) 

     select type ( reference_fe ) 
     type is ( tet_nedelec_reference_fe_t ) 

        ! Create a 1D scalar lagrangian reference FE of order k-1
        call this%fes_1D(reference_fe_id)%create(topology          = reference_fe%get_topology(),  &
             num_dims          = 1,                            &
             order             = reference_fe%get_order()-1,   &
             field_type        = field_type_scalar,            &
             conformity        = .true. )

        call reference_fe%create_edge_quadrature( this%edge_quadratures(reference_fe_id) )

        call this%edge_maps(reference_fe_id)%create( this%edge_quadratures(reference_fe_id), fe%get_reference_fe_geo() )
        call this%fes_1D(reference_fe_id)%create_interpolation( this%edge_quadratures(reference_fe_id), this%edge_interpolations(reference_fe_id) )
        if (.not. allocated(this%edge_function_values) ) then 
           allocate (this%edge_function_values(this%edge_quadratures(reference_fe_id)%get_num_quadrature_points(),1), stat=istat); check(istat==0)
        end if
        if (.not. allocated(this%scalar_function_values_on_edge) ) then 
           call memalloc ( this%edge_quadratures(reference_fe_id)%get_num_quadrature_points(), 1, this%scalar_function_values_on_edge, __FILE__, __LINE__)
        end if

        if ( reference_fe%get_num_dims() == 3 .and. reference_fe%get_order() > 1 ) then 
           ! Create a 2D Lagrangian reference FE of order k-1
           call this%fes_2D(reference_fe_id)%create(topology   = reference_fe%get_topology(),  &
                num_dims   = 2,                            &
                order      = reference_fe%get_order()-2,           &
                field_type = field_type_scalar,            &
                conformity = .true. )

           call reference_fe%create_facet_quadrature( this%facet_quadratures(reference_fe_id) )
           call this%fes_2D(reference_fe_id)%create_interpolation( this%facet_quadratures(reference_fe_id), this%facet_interpolations(reference_fe_id) )
           call this%facet_maps(reference_fe_id)%create( this%facet_quadratures(reference_fe_id), fe%get_reference_fe_geo() )
           if (.not. allocated(this%facet_function_values) ) then 
              allocate (this%facet_function_values(this%facet_quadratures(reference_fe_id)%get_num_quadrature_points(),1), stat=istat); check(istat==0)
           end if
           if (.not. allocated(this%scalar_function_values_on_facet)) then 
              call memalloc ( this%facet_quadratures(reference_fe_id)%get_num_quadrature_points(), 1, this%scalar_function_values_on_facet, __FILE__, __LINE__)
           end if

        end if

        ! Compute number interior shape functions shape functions
        num_interior_moments = reference_fe%get_order()
        do idime=1, reference_fe%get_num_dims()-1
           num_interior_moments = num_interior_moments * ( reference_fe%get_order()-idime )/idime 
        end do

        call reference_fe%create_quadrature( this%cell_quadratures(reference_fe_id) )
        call this%cell_maps(reference_fe_id)%create( this%cell_quadratures(reference_fe_id), fe%get_reference_fe_geo() )

        if ( num_interior_moments > 0 ) then 

           ! Create a D-DIM Lagrangian reference FE of order k-D
           call this%fes_lagrangian(reference_fe_id)%create(topology          = reference_fe%get_topology(), &
                num_dims          = reference_fe%get_num_dims(),                           &
                order             = reference_fe%get_order()-reference_fe%get_num_dims(),  &
                field_type        = field_type_vector,                                     &
                conformity        = .true. )

           call this%fes_lagrangian(reference_fe_id)%create_interpolation( this%cell_quadratures(reference_fe_id), this%cell_interpolations(reference_fe_id))
           if (.not. allocated(this%cell_function_values)) then 
              allocate (this%cell_function_values(this%cell_quadratures(reference_fe_id)%get_num_quadrature_points(),1), stat=istat); check(istat==0)
           end if

        end if
        class DEFAULT 
           ! Structures are not filled if does not share the same type, i.e. belongs to another field 
     end select

  end do
  call fe_space%free_fe_cell_iterator( fe )
end subroutine tet_Hcurl_interpolator_create

! ================================================================================
subroutine tet_Hcurl_interpolator_evaluate_vector_function_moments( this, fe, vector_function, dof_values, n_face_mask, time ) 
  implicit none
  class(tet_Hcurl_interpolator_t) , intent(inout) :: this
  class(fe_cell_iterator_t)       , intent(in)    :: fe
  class(vector_function_t)        , intent(in)    :: vector_function
  real(rp) , allocatable          , intent(inout) :: dof_values(:) 
  logical  , optional             , intent(in)    :: n_face_mask(:)
  real(rp) , optional             , intent(in)    :: time 

  ! Edge moments evaluation 
  type(vector_field_t)                :: tangent 
  type(list_iterator_t)               :: vertex_iterator 
  type(point_t), pointer              :: edge_map_coordinates(:)
  integer(ip)                         :: edge_id  
  integer(ip)                         :: vertex_within_edge_id 
  real(rp)                            :: edge_measure 

  ! Faces moments integration  
  type(point_t), pointer              :: facet_map_coordinates(:)
  integer(ip)                         :: facet_id, facet_lid
  integer(ip)                         :: vertex_within_facet_id
  integer(ip)                         :: direction 
  real(rp)                            :: facet_measure 

  ! Local variables required by interior moments integration
  type(vector_field_t)                :: v_shape_test
  type(vector_field_t)                :: mapped_shape_test 
  integer(ip)                         :: num_interior_moments 
  real(rp)                            :: cell_measure 

  ! Common integration 
  class(reference_fe_t), pointer      :: reference_fe 
  class(reference_fe_t), pointer      :: reference_fe_geo 
  type(point_t)        , pointer      :: cell_coordinates(:)
  integer(ip)                         :: vertex_within_cell_id
  real(rp)                            :: shape_test, factor 
  integer(ip)                         :: idime, ishape
  integer(ip)                         :: qpoint, num_quad_points 
  type(vector_field_t), allocatable   :: function_values(:) 
  type(point_t), pointer              :: quad_points_coordinates(:)

  integer(ip) :: reference_fe_id 
  real(rp)    :: time_(1) 
  integer(ip) :: c, d, istat 

  if (present(time)) time_(1) = time
  reference_fe     => fe%get_reference_fe(this%field_id)
  reference_fe_id  =  fe%get_reference_fe_id(this%field_id)
  reference_fe_geo => fe%get_reference_fe_geo()

  call this%reallocate_arrays(fe, dof_values,            & 
       this%edge_function_values, & 
       this%facet_function_values,& 
       this%cell_function_values ) 

  ! Extract cell coordinates 
  cell_coordinates => this%cell_maps(reference_fe_id)%get_coordinates() 
  call fe%get_nodes_coordinates( cell_coordinates ) 

  d = 0
  dof_values = 0.0_rp 
  do edge_id = reference_fe%get_first_n_face_id_of_dim(1), & 
       reference_fe%get_first_n_face_id_of_dim(1) + reference_fe%get_num_n_faces_of_dim(1)-1

							call this%update_map_coordinates( reference_fe, cell_coordinates, edge_id, this%edge_maps(reference_fe_id) )

     call this%edge_maps(reference_fe_id)%update(local_edge_id = edge_id - reference_fe%get_first_n_face_id_of_dim(1)+1, &
          reference_fe  = reference_fe,                                           &
          quadrature    = this%edge_quadratures(reference_fe_id) )

     num_quad_points = this%edge_quadratures(reference_fe_id)%get_num_quadrature_points()
     quad_points_coordinates => this%edge_maps(reference_fe_id)%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to edge 
     if ( present(time) ) then 
        call vector_function%get_values_set(quad_points_coordinates, time_, this%edge_function_values(1:num_quad_points,1:1) )
     else 
        call vector_function%get_values_set(quad_points_coordinates, this%edge_function_values(1:num_quad_points,1) )
     end if

     edge_measure = this%edge_maps(reference_fe_id)%get_measure()
     ! Integrate edge boundary moments int_edge(f.tau q), q \in P_k-1
     do qpoint = 1, num_quad_points 
        factor = this%edge_maps(reference_fe_id)%get_det_jacobian(qpoint) * this%edge_quadratures(reference_fe_id)%get_weight(qpoint)
        call this%edge_maps(reference_fe_id)%get_tangent(qpoint, tangent)
        do ishape=1, this%fes_1D(reference_fe_id)%get_num_shape_functions()
           call this%fes_1D(reference_fe_id)%get_value(this%edge_interpolations(reference_fe_id), ishape, qpoint, shape_test)
           dof_values(d+ishape) = dof_values(d+ishape) + 1.0_rp/edge_measure * this%edge_function_values(qpoint,1) * shape_test * tangent * factor 
        end do
     end do

     d = d + this%fes_1D(reference_fe_id)%get_num_shape_functions()
  end do

  if ( reference_fe%get_num_dims() == 3 .and. reference_fe%get_order() > 1 ) then

     do facet_id = reference_fe%get_first_facet_id(), & 
          reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1

										call this%update_map_coordinates( reference_fe, cell_coordinates, facet_id, this%facet_maps(reference_fe_id) ) 

        facet_lid = facet_id - reference_fe_geo%get_first_facet_id()+1
        call this%facet_maps(reference_fe_id)%update(reorientation_factor   = reference_fe_geo%get_normal_orientation_factor(facet_lid), &
             quadrature             = this%facet_quadratures(reference_fe_id) ) 

        num_quad_points = this%facet_quadratures(reference_fe_id)%num_quadrature_points
        quad_points_coordinates => this%facet_maps(reference_fe_id)%get_quadrature_points_coordinates()

        ! Fill vector function values restricted to facet 
        if ( present(time) ) then 
           call vector_function%get_values_set(quad_points_coordinates, time_, this%facet_function_values(1:num_quad_points,1:1) )
        else 
           call vector_function%get_values_set(quad_points_coordinates, this%facet_function_values(1:num_quad_points,1) )
        end if

        facet_measure = this%facet_maps(reference_fe_id)%get_measure()  										
        ! Integrate face boundary moments int_Face(g, q¬∑tau), q \in P_{k-2}
        do qpoint = 1, num_quad_points
           factor = this%facet_maps(reference_fe_id)%get_det_jacobian(qpoint) * this%facet_quadratures(reference_fe_id)%get_weight(qpoint)				
           do direction = 1, this%fes_2D(reference_fe_id)%get_num_dims() 
              c = (direction-1)*this%fes_2D(reference_fe_id)%get_num_shape_functions()
              call this%facet_maps(reference_fe_id)%get_jacobian_column(direction,qpoint,tangent) ! x_i - x^0_i (not normalized)
              do ishape=1, this%fes_2D(reference_fe_id)%get_num_shape_functions()
                 call this%fes_2D(reference_fe_id)%get_value(this%facet_interpolations(reference_fe_id), ishape, qpoint, shape_test)   
                 dof_values(d+ishape+c) = dof_values(d+ishape+c) + 1.0_rp/facet_measure  * this%facet_function_values(qpoint,1) * shape_test * tangent * factor
              end do
           end do
        end do

        d = d + this%fes_2D(reference_fe_id)%get_num_shape_functions()*this%fes_2D(reference_fe_id)%get_num_dims() 
     end do

  end if

  ! Compute number interior shape functions shape functions
  num_interior_moments = reference_fe%get_order()
  do idime=1, reference_fe%get_num_dims()-1
     num_interior_moments = num_interior_moments * ( reference_fe%get_order()-idime )/idime 
  end do

  if ( num_interior_moments > 0 ) then 

     ! Update cell map 
     call this%cell_maps(reference_fe_id)%update(this%cell_quadratures(reference_fe_id))

     ! Extract quadrature points coordinates 
     num_quad_points = this%cell_quadratures(reference_fe_id)%num_quadrature_points
     quad_points_coordinates => this%cell_maps(reference_fe_id)%get_quadrature_points_coordinates()

     ! Fill vector function values restricted to cell 
     if ( present(time) ) then 
        call vector_function%get_values_set(quad_points_coordinates, time_, this%cell_function_values(1:num_quad_points, 1:1) ) 
     else 
        call vector_function%get_values_set(quad_points_coordinates, this%cell_function_values(1:num_quad_points, 1) )
     end if

     cell_measure = this%cell_maps(reference_fe_id)%get_measure()  			
     ! Integration of interior moments 
     ! 2D CASE: int_K (g¬∑q), q \in P_{k-2,k-2} x P_{k-2,k-2} 
     ! 3D CASE: int_K (g¬∑q), q \in P_{k-3,k-3,k-3} x P_{k-3,k-3,k-3} x P_{k-3,k-3,k-3}     
     do qpoint = 1, this%cell_quadratures(reference_fe_id)%num_quadrature_points
        factor = this%cell_maps(reference_fe_id)%get_det_jacobian(qpoint) * this%cell_quadratures(reference_fe_id)%get_weight(qpoint)
        do ishape=1, this%fes_lagrangian(reference_fe_id)%get_num_shape_functions()
           call this%fes_lagrangian(reference_fe_id)%get_value(this%cell_interpolations(reference_fe_id), ishape, qpoint, v_shape_test) 
           mapped_shape_test = 1.0_rp/this%cell_maps(reference_fe_id)%get_det_jacobian(qpoint) * this%cell_maps(reference_fe_id)%apply_jacobian( qpoint, v_shape_test ) 
           dof_values(d+ishape) = dof_values(d+ishape) + 1.0_rp/cell_measure * this%cell_function_values(qpoint,1) * mapped_shape_test * factor 
        end do
     end do

  end if

end subroutine tet_Hcurl_interpolator_evaluate_vector_function_moments

!==================================================================================================
subroutine tet_Hcurl_interpolator_evaluate_function_components_moments(this, n_face_mask, fe, vector_function_scalar_components, dof_values, time)
  class(tet_Hcurl_interpolator_t) , intent(inout) :: this
  logical                         , intent(in)    :: n_face_mask(:)  
  class(fe_cell_iterator_t)       , intent(in)    :: fe
  class(p_scalar_function_t)      , intent(in)    :: vector_function_scalar_components(:,:)
  real(rp) , allocatable          , intent(inout) :: dof_values(:) 
  real(rp) , optional             , intent(in)    :: time 

  ! Edges 
  type(vector_field_t)                :: tangent
  type(list_iterator_t)               :: vertex_iterator 
  type(point_t), pointer              :: edge_map_coordinates(:)
  integer(ip)                         :: edge_id  
  integer(ip)                         :: vertex_within_edge_id  
  real(rp)                            :: edge_measure 

  ! Faces 
  integer(ip)                         :: facet_id, facet_lid
  type(point_t), pointer              :: facet_map_coordinates(:)
  type(vector_field_t)                :: col_jacobian
  integer(ip)                         :: vertex_within_facet_id 
  real(rp)                            :: facet_measure  
  integer(ip)                         :: direction

  ! Common integration 
  class(reference_fe_t), pointer      :: reference_fe 
  class(reference_fe_t), pointer      :: reference_fe_geo
  type(point_t)        , pointer      :: cell_coordinates(:) 
  real(rp)                            :: time_(1)  
  integer(ip)                         :: vertex_within_cell_id
  real(rp)                            :: shape_test, factor 
  type(vector_field_t)                :: v_shape_test 
  integer(ip)                         :: idime, ishape, idof 
  integer(ip)                         :: qpoint, num_quad_points 
  type(point_t), pointer              :: quad_points_coordinates(:)
  type(list_iterator_t)               :: own_dofs
  integer(ip)                         :: i, d, iedge, icomp, istat
  integer(ip)                         :: reference_fe_id 

  if ( present(time) ) time_(1) = time 	
  reference_fe_id  =  fe%get_reference_fe_id(this%field_id)
  reference_fe     => fe%get_reference_fe( this%field_id ) 
  reference_fe_geo => fe%get_reference_fe_geo()

  call this%reallocate_arrays( fe, dof_values,                     &  
       this%scalar_function_values_on_edge, & 
       this%scalar_function_values_on_facet )

  ! Extract cell coordinates 
  cell_coordinates => this%cell_maps(reference_fe_id)%get_coordinates() 
  call fe%get_nodes_coordinates( cell_coordinates ) 

  dof_values = 0.0_rp	
  do edge_id = reference_fe%get_first_n_face_id_of_dim(1), & 
       reference_fe%get_first_n_face_id_of_dim(1) + reference_fe%get_num_n_faces_of_dim(1)-1

     if ( n_face_mask(edge_id) ) then 
        num_quad_points = this%edge_quadratures(reference_fe_id)%get_num_quadrature_points()
								
								call this%update_map_coordinates( reference_fe, cell_coordinates, edge_id, this%edge_maps(reference_fe_id) )

        call this%edge_maps(reference_fe_id)%update(local_edge_id = edge_id - reference_fe%get_first_n_face_id_of_dim(1)+1, &
             reference_fe  = reference_fe,                                           &
             quadrature    = this%edge_quadratures(reference_fe_id) )

        quad_points_coordinates => this%edge_maps(reference_fe_id)%get_quadrature_points_coordinates()

        ! Fill vector function values restricted to edge 
        select case(reference_fe %get_field_type())
        case ( field_type_scalar )
           ! reference_fe MUST BE a vector-valued FE
           assert (.false.)
        case ( field_type_vector )
           do icomp=1, reference_fe%get_num_field_components()
              if(present(time)) then
                 call vector_function_scalar_components(icomp, edge_id)%p%get_values_set_space_time(quad_points_coordinates,  & 
                      time_,                    & 
                      this%scalar_function_values_on_edge(1:num_quad_points,:))
              else
                 call vector_function_scalar_components(icomp, edge_id)%p%get_values_set_space(quad_points_coordinates,this%scalar_function_values_on_edge(1:num_quad_points,1))
              end if
              do qpoint = 1, num_quad_points
                 call this%edge_function_values(qpoint,1)%set(icomp,this%scalar_function_values_on_edge(qpoint,1))
              end do
           end do
        case ( field_type_tensor )
           ! reference_fe MUST BE a vector-valued FE
           assert(.false.)
        end select

        edge_measure = this%edge_maps(reference_fe_id)%get_measure()
        ! Integrate edge boundary moments int_edge(g¬∑tau q), q \in P_k-1
        own_dofs = reference_fe%create_dofs_n_face_iterator(edge_id)
        do qpoint = 1, num_quad_points
           factor = this%edge_maps(reference_fe_id)%get_det_jacobian(qpoint) * this%edge_quadratures(reference_fe_id)%get_weight(qpoint)
           call this%edge_maps(reference_fe_id)%get_tangent(qpoint, tangent)								
           call own_dofs%begin() 
           do ishape = 1, this%fes_1D(reference_fe_id)%get_num_shape_functions() 
              idof = own_dofs%get_current() 
              call this%fes_1D(reference_fe_id)%get_value(this%edge_interpolations(reference_fe_id), ishape, qpoint, shape_test)
              dof_values(idof) = dof_values(idof) + 1.0_rp/edge_measure * this%edge_function_values(qpoint,1) * shape_test * tangent * factor 
              call own_dofs%next() 
           end do
        end do
     end if
  end do

  if ( reference_fe%get_num_dims() == 3 .and. reference_fe%get_order() > 1 ) then

     do facet_id = reference_fe%get_first_facet_id(), & 
          reference_fe%get_first_facet_id() + reference_fe%get_num_facets()-1

        if ( n_face_mask(facet_id) ) then 

           num_quad_points        =  this%facet_quadratures(reference_fe_id)%get_num_quadrature_points()
											
											call this%update_map_coordinates( reference_fe, cell_coordinates, facet_id, this%facet_maps(reference_fe_id) ) 

           facet_lid = facet_id - reference_fe_geo%get_first_facet_id()+1
           call this%facet_maps(reference_fe_id)%update(reorientation_factor   = reference_fe_geo%get_normal_orientation_factor(facet_lid), &
                quadrature             = this%facet_quadratures(reference_fe_id) ) 

           quad_points_coordinates => this%facet_maps(reference_fe_id)%get_quadrature_points_coordinates()

           ! Fill vector function values restricted to face 
           select case(reference_fe%get_field_type())
           case ( field_type_scalar )
              ! reference_fe MUST BE a vector-valued FE
              assert (.false.)
           case ( field_type_vector )
              do icomp=1, reference_fe%get_num_field_components()
                 if(present(time)) then
                    call vector_function_scalar_components(icomp, facet_id)%p%get_values_set_space_time(quad_points_coordinates,  & 
                         time_,                    & 
                         this%scalar_function_values_on_facet(1:num_quad_points,:))
                 else
                    call vector_function_scalar_components(icomp, facet_id)%p%get_values_set_space(quad_points_coordinates,this%scalar_function_values_on_facet(1:num_quad_points,1))
                 end if
                 do qpoint = 1, num_quad_points
                    call this%facet_function_values(qpoint,1)%set(icomp,this%scalar_function_values_on_facet(qpoint,1))
                 end do
              end do
           case ( field_type_tensor )
              ! reference_fe MUST BE a vector-valued FE
              assert(.false.)
           end select

           facet_measure = this%facet_maps(reference_fe_id)%get_measure()  
           ! Integrate face boundary moments int_Face(g x n q), q \in Q_k-2,k-1 x Q_k-1,k-2
           do qpoint = 1, this%facet_quadratures(reference_fe_id)%num_quadrature_points
              factor = this%facet_maps(reference_fe_id)%get_det_jacobian(qpoint) * this%facet_quadratures(reference_fe_id)%get_weight(qpoint)

              own_dofs = reference_fe%create_dofs_n_face_iterator(facet_id)
              do direction = 1, this%fes_2D(reference_fe_id)%get_num_dims() 
                 call this%facet_maps(reference_fe_id)%get_jacobian_column(direction,qpoint,tangent) ! x_i - x^0_i (not normalized)
                 do ishape=1, this%fes_2D(reference_fe_id)%get_num_shape_functions()
                    idof = own_dofs%get_current() 
                    call this%fes_2D(reference_fe_id)%get_value(this%facet_interpolations(reference_fe_id), ishape, qpoint, shape_test)    
                    dof_values(idof) = dof_values(idof) + 1.0_rp/facet_measure  * this%facet_function_values(qpoint,1) * shape_test * tangent * factor
                    call own_dofs%next() 
                 end do
              end do

           end do

        end if
     end do
  end if

end subroutine tet_Hcurl_interpolator_evaluate_function_components_moments

! ================================================================================
subroutine tet_Hcurl_interpolator_free( this ) 
  implicit none
  class(tet_Hcurl_interpolator_t)   , intent(inout) :: this
  integer(ip) :: num_reference_fes, istat, i 

  num_reference_fes = size(this%edge_maps) 
  do i=1, num_reference_fes 
     ! Edge related data  
     call this%fes_1D(i)%free()
     call this%edge_quadratures(i)%free() 
     call this%edge_maps(i)%free() 
     call this%edge_interpolations(i)%free()  

     ! Face related data  
     call this%fes_2D(i)%free()
     call this%facet_quadratures(i)%free() 
     call this%facet_maps(i)%free() 
     call this%facet_interpolations(i)%free() 

     ! Element related data  
     call this%fes_lagrangian(i)%free()
     call this%cell_quadratures(i)%free() 
     call this%cell_maps(i)%free() 
     call this%cell_interpolations(i)%free() 
  end do

  ! Deallocate structures 
  deallocate ( this%edge_maps, stat=istat); check(istat==0)
  deallocate ( this%facet_maps, stat=istat); check(istat==0)
  deallocate ( this%cell_maps, stat=istat); check(istat==0)
  ! Quadratures with possible variable degree
  deallocate ( this%edge_quadratures, stat=istat); check(istat==0)
  deallocate ( this%facet_quadratures, stat=istat); check(istat==0)
  deallocate ( this%cell_quadratures, stat=istat); check(istat==0)
  ! Interpolations with possible variable degree  
  deallocate ( this%edge_interpolations, stat=istat); check(istat==0) 
  deallocate ( this%facet_interpolations, stat=istat); check(istat==0)
  deallocate ( this%cell_interpolations, stat=istat); check(istat==0)
  ! Allocate FEs 
  deallocate ( this%fes_1D, stat=istat); check(istat==0) 
  deallocate ( this%fes_2D, stat=istat); check(istat==0)
  deallocate ( this%fes_lagrangian, stat=istat); check(istat==0)

  ! Functions evaluations
  if ( allocated(this%edge_function_values))  deallocate( this%edge_function_values , stat=istat); check(istat==0) 
  if ( allocated(this%facet_function_values)) deallocate( this%facet_function_values , stat=istat); check(istat==0) 
  if ( allocated(this%cell_function_values))  deallocate( this%cell_function_values , stat=istat); check(istat==0) 

  if ( allocated(this%scalar_function_values_on_edge) )  call memfree( this%scalar_function_values_on_edge, __FILE__, __LINE__ ) 
  if ( allocated(this%scalar_function_values_on_facet) ) call memfree( this%scalar_function_values_on_facet, __FILE__, __LINE__ )

end subroutine tet_Hcurl_interpolator_free
