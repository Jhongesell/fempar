! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine serial_fe_space_create_same_reference_fes_on_all_cells( this,          &
                                                                   triangulation, &
                                                                   reference_fes, &
                                                                   conditions )
  implicit none
  class(serial_fe_space_t)                    , intent(inout) :: this
  class(base_static_triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  class(conditions_t)       , target, optional, intent(in)    :: conditions

  integer(ip) :: i, istat, jfield, ifield

  call this%free()

  call this%set_triangulation(triangulation)  
  call this%set_number_fields(size(reference_fes))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_ref_fe_id_per_fe()
  call this%fill_ref_fe_id_per_fe_same_on_all_cells()
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_per_field()
  call this%allocate_and_init_ptr_lst_dofs()
  
  if ( present(conditions) ) call this%set_conditions(conditions)
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%set_up_strong_dirichlet_bcs()
  
end subroutine serial_fe_space_create_same_reference_fes_on_all_cells

subroutine serial_fe_space_create_different_between_cells( this,                     &
                                                           triangulation,            &
                                                           reference_fes,            &
                                                           set_ids_to_reference_fes, &
                                                           conditions )
  implicit none
  class(serial_fe_space_t)                    , intent(inout) :: this
  class(base_static_triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t)       , target, optional, intent(in)    :: conditions
  
  call this%free()
  
  call this%set_triangulation(triangulation)  
  call this%set_number_fields(size(set_ids_to_reference_fes,1))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_ref_fe_id_per_fe()
  call this%fill_ref_fe_id_per_fe_different_between_cells(set_ids_to_reference_fes)
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_per_field()
  call this%allocate_and_init_ptr_lst_dofs()
  
  if ( present(conditions) ) call this%set_conditions(conditions)
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%set_up_strong_dirichlet_bcs()
  
end subroutine serial_fe_space_create_different_between_cells

subroutine serial_fe_space_free (this)
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  call this%free_reference_fes()
  call this%free_ref_fe_id_per_fe()
  call this%free_fe_space_type_per_field()
  call this%free_ptr_lst_dofs()
  call this%free_at_strong_dirichlet_bound()
  call this%free_has_fixed_dofs()
  nullify(this%conditions)
  call this%strong_dirichlet_values%free()
  if (allocated(this%number_dofs_per_field)) call memfree( this%number_dofs_per_field, __FILE__, __LINE__ )
  call this%free_fe_integration()
  call this%free_fe_face_integration()
  nullify(this%block_layout)
end subroutine serial_fe_space_free

subroutine serial_fe_space_print ( this )
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_iterator_t), allocatable :: fe
  type(i1p_t), allocatable         :: elem2dof(:)
  integer(ip)                      :: field_id, istat

  if (allocated(this%number_dofs_per_field)) write(*,'(a,i10,a)') '********* number_dofs_per_field ',this%number_dofs_per_field,'********'
  write(*,'(a,i10,a)') '********* number_strong_dirichlet_dofs',this%strong_dirichlet_values%get_size(),'********'

  allocate ( elem2dof(this%get_number_fields()), stat=istat)
  check(istat==0)

  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     write(*,'(a,i10,a)') '********* ELEMENT: ',fe%get_lid(),'********'
     write(*,'(a)') '********* ELEMENT 2 DOF********'
     call fe%get_elem2dof(elem2dof)
     do field_id = 1, fe%get_number_fields()
        write(*,'(a,i10,a)') '********* FIELD: ',field_id,'********'
        write(*,'(10i10)') elem2dof(field_id)%p
     end do
     call fe%next()
  end do
  call this%free_fe_iterator(fe) 

  call this%strong_dirichlet_values%print(6)

  deallocate ( elem2dof, stat=istat)
  check(istat==0)
end subroutine serial_fe_space_print


subroutine serial_fe_space_allocate_and_fill_fe_space_type_per_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_iterator_t), allocatable :: fe
  integer(ip) :: field_id
  class(reference_fe_t), pointer ::reference_fe

  call memalloc ( this%number_fields, this%fe_space_type_per_field, __FILE__, __LINE__ )

  call this%create_fe_iterator(fe)
  do field_id=1, this%get_number_fields()
     this%fe_space_type_per_field(field_id) = fe%get_fe_space_type(field_id)
  end do

#ifdef DEBUG  
  call fe%next()
  do while ( .not. fe%has_finished())
     do field_id=1, this%get_number_fields()
        assert ( this%fe_space_type_per_field(field_id) == fe%get_fe_space_type(field_id)  )
     end do
     call fe%next()
  end do
#endif  
  call this%free_fe_iterator(fe)
end subroutine serial_fe_space_allocate_and_fill_fe_space_type_per_field

subroutine serial_fe_space_free_fe_space_type_per_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( allocated(this%fe_space_type_per_field) ) call memfree ( this%fe_space_type_per_field, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_fe_space_type_per_field

subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)                    :: field_id
  class(fe_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe

  call this%free_ptr_lst_dofs()
  
  call memalloc ( this%number_fields, &
       this%triangulation%get_num_cells()+1, &
       this%ptr_dofs_per_fe, __FILE__, __LINE__ )

  this%ptr_dofs_per_fe(1,1) = 1 
  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     do field_id=1, fe%get_number_fields()-1
        reference_fe => fe%get_reference_fe(field_id)
        this%ptr_dofs_per_fe(field_id+1,fe%get_lid()) = & 
             this%ptr_dofs_per_fe(field_id,fe%get_lid()) + reference_fe%get_number_shape_functions()
     end do
     reference_fe => fe%get_reference_fe(field_id)
     this%ptr_dofs_per_fe(1,fe%get_lid()+1) = & 
          this%ptr_dofs_per_fe(field_id,fe%get_lid()) + reference_fe%get_number_shape_functions()
     call fe%next()
  end do
  call this%free_fe_iterator(fe) 

  call memalloc ( this%ptr_dofs_per_fe(1,this%triangulation%get_num_cells()+1)-1,&
       this%lst_dofs_lids, &
       __FILE__, __LINE__ )
  this%lst_dofs_lids = 0
end subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs

subroutine serial_fe_space_move_alloc_ptr_dofs_per_fe_out ( this, ptr_dofs_per_fe )
  implicit none
  class(serial_fe_space_t)             , intent(inout) :: this
  integer(ip)             , allocatable, intent(inout) :: ptr_dofs_per_fe(:,:)
  assert ( .not. allocated(ptr_dofs_per_fe) )
  if ( allocated(this%ptr_dofs_per_fe) ) then
     call move_alloc( to=ptr_dofs_per_fe, from=this%ptr_dofs_per_fe )
  end if
end subroutine serial_fe_space_move_alloc_ptr_dofs_per_fe_out

subroutine serial_fe_space_move_alloc_lst_dofs_lids_out ( this, lst_dofs_lids )
  implicit none
  class(serial_fe_space_t)             , intent(inout) :: this
  integer(ip)             , allocatable, intent(inout) :: lst_dofs_lids(:)
  assert ( .not. allocated(lst_dofs_lids) )
  if ( allocated(this%lst_dofs_lids) ) then
     call move_alloc( to=lst_dofs_lids, from=this%lst_dofs_lids )
  end if
end subroutine serial_fe_space_move_alloc_lst_dofs_lids_out

subroutine serial_fe_space_free_ptr_lst_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%ptr_dofs_per_fe)) call memfree ( this%ptr_dofs_per_fe, __FILE__, __LINE__ )
  if (allocated(this%lst_dofs_lids)) call memfree ( this%lst_dofs_lids, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_ptr_lst_dofs

subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_at_strong_dirichlet_bound()
  call memalloc ( this%number_fields, &
       this%triangulation%get_num_cells(), &
       this%at_strong_dirichlet_boundary_per_fe, __FILE__, __LINE__ )
  this%at_strong_dirichlet_boundary_per_fe = .false. 
end subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound

subroutine serial_fe_space_free_at_strong_dirichlet_bound (this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%at_strong_dirichlet_boundary_per_fe)) then
     call memfree ( this%at_strong_dirichlet_boundary_per_fe, __FILE__, __LINE__ )
  end if
end subroutine serial_fe_space_free_at_strong_dirichlet_bound

subroutine serial_fe_space_allocate_and_init_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_has_fixed_dofs()
  call memalloc ( this%number_fields, &
       this%triangulation%get_num_cells(), &
       this%has_fixed_dofs_per_fe, __FILE__, __LINE__ )
  this%has_fixed_dofs_per_fe = .false. 
end subroutine serial_fe_space_allocate_and_init_has_fixed_dofs

subroutine serial_fe_space_free_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%has_fixed_dofs_per_fe)) then
     call memfree ( this%has_fixed_dofs_per_fe, __FILE__, __LINE__ )
  end if
end subroutine serial_fe_space_free_has_fixed_dofs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)             :: field_id
  integer(ip)             :: ivef
  integer(ip)             :: component_id
  integer(ip), allocatable :: offset_component_per_field(:)
  integer(ip)             :: istat
  class(fe_iterator_t), allocatable :: fe, source_fe
  type(fe_vef_iterator_t)    :: vef
  class(reference_fe_t), pointer :: reference_fe
  logical              , allocatable :: components_code(:)
  integer(ip), allocatable           :: visited_vef_to_fe_map(:,:)
  integer(ip)                        :: previous_number_dirichlet_dofs
  integer(ip)                        :: number_strong_dirichlet_dofs
  
  if ( .not. associated(this%conditions) ) then
    call this%strong_dirichlet_values%create_and_allocate(0)
    return
  end if
  
  ! For every component of every field, we go through all FEs and look for DoFs 
  ! subject to strong Dirichlet BCs. It would be desirable (for efficiency) to 
  ! know a priori which FEs have DoFs which are subject to strong Dirichlet BCs, 
  ! but at the present moment we do not have any way to determine such a thing
  assert ( this%conditions%get_number_components() == this%get_number_components() )
  call memalloc ( this%conditions%get_number_components(), components_code, __FILE__, __LINE__ )

  call memalloc (this%get_number_fields()+1,offset_component_per_field,__FILE__,__LINE__)
  call memalloc ( 2, this%triangulation%get_num_vefs(), visited_vef_to_fe_map,  __FILE__, __LINE__ )

  ! Count number_strong_dirichlet_dofs
  number_strong_dirichlet_dofs = 0

  call this%create_fe_iterator(fe)
  call this%create_fe_iterator(source_fe)
  call this%create_fe_vef_iterator(vef)

  ! Precompute the offsets
  offset_component_per_field(1) = 1
  do field_id = 1, this%get_number_fields()
    reference_fe => fe%get_reference_fe(field_id)
    offset_component_per_field(field_id+1) = offset_component_per_field(field_id) + reference_fe%get_number_field_components()
  end do

  do field_id = 1, this%get_number_fields()
    ! Initialize
    visited_vef_to_fe_map = -1

    call fe%first()
    do while (.not. fe%has_finished() )
      if ( fe%is_local() ) then
         do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)

            ! Check whether a set_id different from 0 has been set for current vef. 
            ! TO-DO: Should we also ask whether current vef is at the boundary?
            !        "0" is a magic number. MUCH BETTER REPLACE by parameter constant.
            if ( vef%get_set_id() /= 0 ) then ! .and. vef%at_boundary()??? )

               ! Get components code corresponding to set_id assigned to current vef
               ! TO-DO: The number of calls to this TBP (virtual) could be reduced by using
               ! a more clever strategy. Does pay off to look carefully at this?
               call this%conditions%get_components_code( vef%get_set_id(), components_code )

               ! Auxiliary function containing the work done at each innermost iteration
               previous_number_dirichlet_dofs = number_strong_dirichlet_dofs
               call this%set_up_strong_dirichlet_bcs_on_vef_and_field(fe,&
                                                                      vef,&
                                                                      ivef,&
                                                                      field_id,&
                                                                      components_code(offset_component_per_field(field_id):&
                                                                                      offset_component_per_field(field_id+1)-1),&
                                                                      number_strong_dirichlet_dofs,&
                                                                      visited_vef_to_fe_map,&
                                                                      source_fe)

               if ( visited_vef_to_fe_map(1, vef%get_lid()) == -1 .and. &
                    previous_number_dirichlet_dofs < number_strong_dirichlet_dofs ) then
                  visited_vef_to_fe_map ( 1, vef%get_lid() ) = fe%get_lid()
                  visited_vef_to_fe_map ( 2, vef%get_lid() ) = ivef
               end if
            end if
         end do
      end if

      call fe%next()
    end do ! Loop in FEs
  end do ! Loop in fields


  call this%strong_dirichlet_values%create_and_allocate(number_strong_dirichlet_dofs)
  call this%strong_dirichlet_values%init(0.0_rp)
  
  ! This second sweep over all cells cannot be integrated as part of the first one
  ! as the fe%determine_* TBPs have as a pre-condition that this%strong_dirichlet_values
  ! has at least been created (i.e., that it has at least size already set)
  call fe%first()
  do while (.not. fe%has_finished() )
    if ( fe%is_local() ) then
      do field_id = 1, this%get_number_fields()
         call fe%determine_at_strong_dirichlet_boundary(field_id)
         call fe%determine_has_fixed_dofs(field_id)
      end do
    end if
    call fe%next()
  end do

  call memfree ( visited_vef_to_fe_map,  __FILE__, __LINE__ )
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree (offset_component_per_field,__FILE__,__LINE__)
  call this%free_fe_iterator(fe)
  call this%free_fe_iterator(source_fe)
  call this%free_fe_vef_iterator(vef)
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field(this,&
                                                                        fe, &
                                                                        vef, &
                                                                        ivef, &
                                                                        field_id,&
                                                                        components_code,&
                                                                        number_strong_dirichlet_dofs,&
                                                                        visited_vef_to_fe_map,&
                                                                        source_fe)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_iterator_t),     intent(inout) :: fe
  type(fe_vef_iterator_t),  intent(in)    :: vef
  integer(ip),              intent(in)    :: ivef
  integer(ip),              intent(in)    :: field_id
  logical,                  intent(in)    :: components_code(:)
  integer(ip),              intent(inout) :: number_strong_dirichlet_dofs
  integer(ip),              intent(inout) :: visited_vef_to_fe_map(:,:)
  class(fe_iterator_t),     intent(inout) :: source_fe

  type(list_iterator_t)           :: own_dofs_on_vef_iterator
  class(reference_fe_t), pointer  :: reference_fe

  ! TO-DO: there is no need to call `get_reference_fe` for each inner loop iteration.
  !        We could use an allocatable array of type(p_reference_fe_t) items, and
  !        allocate/initialize it from the beginning.
  reference_fe => fe%get_reference_fe(field_id)
  assert ( size(components_code) == reference_fe%get_number_field_components() )
  
  select type ( reference_fe )
     class is ( nedelec_reference_fe_t )
     if ( components_code(1) ) then
       if ( visited_vef_to_fe_map(1, vef%get_lid()) == -1 ) then
           call fe%fill_own_dofs_on_vef ( ivef, &
                                          field_id, &
                                          number_strong_dirichlet_dofs, &
                                          free_dofs_loop=.false.)
       end if
     end if
     class is ( lagrangian_reference_fe_t )
     if ( visited_vef_to_fe_map(1, vef%get_lid()) == -1 ) then
       call fe%fill_own_dofs_on_vef_component_wise ( ivef, &
                                                     field_id, &
                                                     number_strong_dirichlet_dofs, &
                                                     components_code, &
                                                     free_dofs_loop=.false. )
     end if
  end select
  
  if ( visited_vef_to_fe_map(1, vef%get_lid()) /= -1 ) then
    call source_fe%set_lid(visited_vef_to_fe_map(1,vef%get_lid()))
    call fe%fill_own_dofs_on_vef_from_source_fe ( ivef, &
                                                  source_fe, &
                                                  visited_vef_to_fe_map(2,vef%get_lid()), &
                                                  field_id) 
  end if
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field

subroutine serial_fe_space_interpolate_dirichlet_values (this, conditions, time, fields_to_interpolate)
  implicit none
  class(serial_fe_space_t), intent(inout)  :: this
  class(conditions_t)     , intent(in)     :: conditions
  real(rp)       , optional   , intent(in) :: time
  integer(ip)    , optional   , intent(in) :: fields_to_interpolate(:)

  !  Locals
  integer(ip)                                :: field_id, istat, ifield, jfield
  integer(ip)                                :: icomp, component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: number_components
  integer(ip)                                :: number_fields
  integer(ip)                                :: reference_fe_id
  integer(ip)                                :: number_reference_fes
  integer(ip)                                :: local_within_ref_fe_dof_id
  integer(ip)                                :: local_within_ref_fe_scalar_dof_id
  integer(ip)                                :: strong_dirichlet_dof_id
  integer(ip)                                :: ivef
  real(rp)                                   :: time_(1)
  type(allocatable_array_rp2_t), allocatable :: values(:,:)
  type(fe_map_t)               , allocatable :: fe_maps(:)
  type(p_quadrature_t)         , allocatable :: nodal_quadratures(:)
  type(point_t)                , pointer     :: nodal_coordinates(:)
  type(point_t)                , pointer     :: cell_coordinates(:)
  logical                      , allocatable :: components_code(:)
  logical                      , allocatable :: reference_fes_touched(:)
  integer(ip)                  , allocatable :: fields_to_interpolate_(:)


  class(reference_fe_t)        , pointer     :: reference_fe
  class(scalar_function_t)     , pointer     :: scalar_function

  type(list_iterator_t)    :: own_dofs_on_vef_iterator
  class(fe_iterator_t), allocatable :: fe
  type(fe_vef_iterator_t)     :: vef
  type(i1p_t), allocatable :: elem2dof(:)

  number_components    = this%get_number_components()
  number_reference_fes = this%get_number_reference_fes()
  number_fields        = this%get_number_fields()

  if ( present(fields_to_interpolate) ) then 
     ! User specifies which fields will be interpolated
     call memalloc ( size(fields_to_interpolate) , fields_to_interpolate_ , __FILE__, __LINE__ ) 
     fields_to_interpolate_ = fields_to_interpolate
  else  
     ! By default, all fields will be interpolated
     call memalloc ( number_fields , fields_to_interpolate_, __FILE__, __LINE__ )  
     do field_id = 1,number_fields 
        fields_to_interpolate_(field_id) = field_id  
     end do
  end if
  
  ! fields_to_interpolate_ consistency check (only in DEBUG mode)
#ifdef DEBUG
  do ifield = 1, size(fields_to_interpolate_) 
    field_id = fields_to_interpolate_(ifield)
    assert ( field_id >= 1 .and. field_id <= number_fields)
    do jfield = ifield+1, size(fields_to_interpolate_)
      assert ( fields_to_interpolate_(ifield) /= fields_to_interpolate_(jfield) )
    end do
  end do
#endif

  ! Build offset components 
  call memalloc( this%get_number_fields(), offset_component, __FILE__, __LINE__ ) 
  offset_component(1) = 0
  do field_id = 2, this%get_number_fields() 
     reference_fe                   => this%get_reference_fe(field_id-1)
     offset_component(field_id)     =  offset_component(field_id-1) + reference_fe%get_number_field_components() 
  end do

  assert ( conditions%get_number_components() == number_components )
  call memalloc ( number_components, components_code, __FILE__, __LINE__ )

  call memalloc ( number_reference_fes, reference_fes_touched, __FILE__, __LINE__ )
  reference_fes_touched = .false.

  allocate(fe_maps(number_reference_fes), stat=istat)
  check(istat==0)
  allocate(nodal_quadratures(number_reference_fes), stat=istat)
  check(istat==0)
  allocate(values(number_components,number_reference_fes), stat=istat)
  check(istat==0)
  allocate ( elem2dof(number_fields), stat=istat ) 
  check (istat==0)

  ! IMPORTANT : The following code is implicitly assuming that the
  !             composition of reference FEs, for all cells on top of
  !             the same geometric reference FE, is the same.
  !             This assumption is reasonable provided that this 
  !             FE space has the same assumption whenever we are dealing
  !             with continuous Galerkin FEs.

  if ( present(time) ) time_(1) = time

  call this%create_fe_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then 
        do ifield = 1, size(fields_to_interpolate_) 
           field_id = fields_to_interpolate_(ifield) 
           reference_fe => fe%get_reference_fe(field_id)

           if ( fe%at_strong_dirichlet_boundary(field_id) ) then
              reference_fe_id = this%reference_fe_id_per_fe(field_id, fe%get_lid()) 
              if ( .not. reference_fes_touched(reference_fe_id) ) then
                 reference_fes_touched(reference_fe_id) = .true.
                 nodal_quadratures(reference_fe_id)%p => reference_fe%get_nodal_quadrature()
                 call fe_maps(reference_fe_id)%create(nodal_quadratures(reference_fe_id)%p, & 
                      fe%get_reference_fe_geo())

                 do icomp=1, reference_fe%get_number_field_components()
                    component_id = offset_component(field_id) + icomp
                    call values(component_id,reference_fe_id)%create(nodal_quadratures(reference_fe_id)%p%get_number_quadrature_points(),1) 
                 end do
              end if

              ! TO-DO: This call should ONLY be performed once 
              !        per FE s.t. at least one of its fields
              !        has DoFs subject to BCs.
              call fe%get_elem2dof(elem2dof)

              cell_coordinates => fe_maps(reference_fe_id)%get_coordinates()
              call fe%get_coordinates(cell_coordinates)
              call fe_maps(reference_fe_id)%compute_quadrature_coordinates()
              nodal_coordinates => fe_maps(reference_fe_id)%get_quadrature_coordinates()

              ! Go over all vefs within current FE
              do ivef = 1, fe%get_num_vefs()
                 call fe%get_vef(ivef, vef)

                 ! Check whether a set_id different from 0 has been set for current vef. 
                 ! TO-DO: Should we also ask whether current vef is at the boundary?
                 !        "0" is a magic number. MUCH BETTER REPLACE by parameter constant.
                 if ( vef%get_set_id() /= 0 ) then ! .and. vef%at_boundary()??? )              

                    ! Get components code corresponding to set_id assigned to current vef
                    ! TO-DO: The number of calls to this TBP (virtual) could be reduced by using
                    ! a more clever strategy. Does it pay off to look carefully at this?
                    call conditions%get_components_code( vef%get_set_id(), components_code )

                    do icomp=1, reference_fe%get_number_field_components()
                       component_id = offset_component(field_id) + icomp
                       if (components_code(component_id)) then
                          call conditions%get_function( vef%get_set_id(), component_id, scalar_function )
                          assert(associated(scalar_function))
                          ! Evaluate function
                          if(present(time)) then
                             call scalar_function%get_values_set_space_time(nodal_coordinates,time_,values(component_id,reference_fe_id)%a)
                          else
                             call scalar_function%get_values_set_space(nodal_coordinates,values(component_id,reference_fe_id)%a(:,1))
                          end if
                       end if
                    end do

                    own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
                    do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                       local_within_ref_fe_dof_id  = own_dofs_on_vef_iterator%get_current()
                       component_id = offset_component(field_id) + reference_fe%get_component_node(local_within_ref_fe_dof_id)
                       if ( components_code(component_id) ) then 
                          ! Check if current node is subject to strong Dirichlet boundary conditions
                          if(fe%is_strong_dirichlet_dof(elem2dof(field_id)%p(local_within_ref_fe_dof_id))) then
                             local_within_ref_fe_scalar_dof_id = reference_fe%get_scalar_from_vector_node(local_within_ref_fe_dof_id)
                             strong_dirichlet_dof_id = -elem2dof(field_id)%p(local_within_ref_fe_dof_id)
                             call this%strong_dirichlet_values%insert(strong_dirichlet_dof_id,values(component_id,field_id)%a(local_within_ref_fe_scalar_dof_id,1))
                          end if
                       end if
                       call own_dofs_on_vef_iterator%next()
                    end do
                 end if
              end do
           end if
        end do
     end if
     call fe%next() 
  end do
  call this%free_fe_iterator(fe) 
  call this%free_fe_vef_iterator(vef)
  
  call memfree ( reference_fes_touched, __FILE__, __LINE__ )
  call memfree ( components_code, __FILE__, __LINE__ )


  do reference_fe_id = 1, number_reference_fes
     call fe_maps(reference_fe_id)%free()
     do component_id = 1, number_components
        call values(component_id, reference_fe_id)%free()
     end do
  end do

  call memfree(offset_component, __FILE__, __LINE__) 
  deallocate(elem2dof, stat=istat ) 
  check (istat==0)
  deallocate(fe_maps, stat=istat)
  check(istat==0)
  deallocate(nodal_quadratures, stat=istat)
  check(istat==0)
  deallocate(values, stat=istat)
  check(istat==0)
  call memfree ( fields_to_interpolate_, __FILE__, __LINE__ ) 
end subroutine serial_fe_space_interpolate_dirichlet_values


subroutine serial_fe_space_update_fixed_dof_values(this, free_dof_values, fixed_dof_values)
  implicit none
  class(serial_fe_space_t)   , intent(in)       :: this
  class(vector_t)            , intent(in)       :: free_dof_values
  type(serial_scalar_array_t), intent(inout)    :: fixed_dof_values
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  real(rp), pointer :: strong_dirichlet_values_entries(:)
  real(rp), pointer :: fixed_dof_values_entries(:)
  strong_dirichlet_values         => this%get_strong_dirichlet_values()
  strong_dirichlet_values_entries => strong_dirichlet_values%get_entries()
  fixed_dof_values_entries        => fixed_dof_values%get_entries()
  fixed_dof_values_entries(1:size(strong_dirichlet_values_entries)) = strong_dirichlet_values_entries
end subroutine serial_fe_space_update_fixed_dof_values

subroutine serial_fe_space_project_dirichlet_values_curl_conforming (this, conditions, time, fields_to_project)
  implicit none
  class(serial_fe_space_t), intent(inout)  :: this
  class(conditions_t)     , intent(in)     :: conditions
  real(rp)       , optional   , intent(in) :: time
  integer(ip)    , optional   , intent(in) :: fields_to_project(:) 

  !  Locals
  integer(ip)                  , allocatable :: fields_to_project_(:)  
  integer(ip)                                :: field_id, istat
  integer(ip)                                :: component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: number_components
  logical                      , allocatable :: components_code(:)

  class(reference_fe_t)        , pointer     :: reference_fe

  class(fe_iterator_t), allocatable  :: fe
  type(fe_face_iterator_t)           :: fe_face

  type(i1p_t), allocatable :: elem2dof(:)

  type(sparse_matrix_t)       :: matrix
  type(serial_scalar_array_t) :: rhs
  type(serial_scalar_array_t) :: projected_nodal_values
  integer(ip), allocatable    :: subset2global_dirichlet_dofs(:) 
  integer(ip), allocatable    :: global2subset_dirichlet_dofs(:) 
  integer(ip), allocatable    :: subset_elem2dof(:) 
#ifdef ENABLE_MKL  
  type(direct_solver_t)           :: direct_solver
#else
  type(iterative_linear_solver_t) :: iterative_linear_solver
#endif
  real(rp), allocatable       :: elmat(:,:)
  real(rp), allocatable       :: elvec(:) 
  integer(ip)                 :: qpoint, n_q_points, ishape, jshape


  type(p_scalar_function_t), allocatable :: function_scalar_components(:)
  real(rp)                 , allocatable :: scalar_function_values(:,:)
  type(vector_field_t)     , allocatable :: vector_function_values(:,:)

  type(parameterlist_t)  :: parameter_list
  integer(ip)            :: FPLError
  integer                :: iparm(64)
  integer(ip)            :: ifield, jfield, idof, idof_subset, idof_global
  integer(ip)            :: number_subset_strong_dirichlet_dofs

  number_components = this%get_number_components()
  assert ( conditions%get_number_components() == number_components )
  call memalloc ( number_components, components_code, __FILE__, __LINE__ )

  call this%allocate_and_fill_fields_to_project_(fields_to_project_, &
                                                 fields_to_project)
  
  call this%allocate_and_fill_offset_component(offset_component)
  
  call memalloc ( this%get_max_number_shape_functions(), &
                  this%get_max_number_shape_functions(), &
                  elmat, __FILE__, __LINE__ )

  call memalloc ( this%get_max_number_shape_functions(), &
                  elvec, __FILE__, __LINE__ )

  call memalloc ( this%get_max_number_shape_functions(), subset_elem2dof, __FILE__, __LINE__ )

  allocate ( vector_function_values(this%get_max_number_face_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( scalar_function_values(this%get_max_number_face_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( function_scalar_components(this%triangulation%get_num_dimensions()), & 
             stat=istat); check(istat==0);
  
  allocate( elem2dof(this%get_number_fields()), stat=istat); check(istat==0);

  number_subset_strong_dirichlet_dofs = this%allocate_and_fill_global2subset_and_inverse(fields_to_project_, &
                                                                                         global2subset_dirichlet_dofs, &
                                                                                         subset2global_dirichlet_dofs)
  
  ! Create linear system 
  call matrix%create(num_rows_and_cols=number_subset_strong_dirichlet_dofs, &
                     symmetric_storage=.false.,       &
                     is_symmetric=.false.,            &
                     sign=SPARSE_MATRIX_SIGN_UNKNOWN )

  call rhs%create_and_allocate(number_subset_strong_dirichlet_dofs) 
  call rhs%init(0.0_rp)

  ! Create data structures
  call projected_nodal_values%create_and_allocate(number_subset_strong_dirichlet_dofs)
  call this%create_fe_face_iterator(fe_face)
  call this%create_fe_iterator(fe)
  do while ( .not. fe_face%has_finished() )
     if ( fe_face%is_at_boundary() ) then
        if ( fe_face%get_set_id() /= 0 ) then
           call fe_face%update_integration() 
           call fe_face%get_cell_around(1,fe)
           call fe%get_elem2dof(elem2dof)
           call conditions%get_components_code( fe_face%get_set_id(), components_code )

           do ifield = 1, size(fields_to_project_)    
              field_id = fields_to_project_(ifield) 
              component_id = offset_component(field_id) + 1
              if (components_code(component_id)) then
                 
                 call this%get_function_scalar_components(fe_face, &
                                                          fe, &
                                                          field_id, &
                                                          component_id, &
                                                          conditions, &
                                                          function_scalar_components)
                 
                 call this%evaluate_vector_function_scalar_components(fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
                 
                 call this%project_curl_conforming_compute_elmat_elvec(fe_face, &
                                                                       fe, &
                                                                       field_id, &
                                                                       vector_function_values, &
                                                                       elmat, &
                                                                       elvec)
              
              
                 ! Consecutive DOF re-numbering for the subset of Dirichlet DOFs to be projected 
                 subset_elem2dof = 0
                 do idof = 1, size(elem2dof(field_id)%p)
                    if ( fe%is_strong_dirichlet_dof(elem2dof(field_id)%p(idof)) ) then 
                        subset_elem2dof(idof) = global2subset_dirichlet_dofs( -elem2dof(field_id)%p(idof) )
                    end if
                 end do
                 
                 reference_fe => fe%get_reference_fe(field_id)
                 call matrix%insert(num_rows = reference_fe%get_number_shape_functions(),& 
                                    num_cols = reference_fe%get_number_shape_functions(),& 
                                    ia       = subset_elem2dof, &
                                    ja       = subset_elem2dof, &
                                    ioffset  = 0, &
                                    joffset  = 0, & 
                                    val      = elmat)
                 call rhs%add(num_entries = reference_fe%get_number_shape_functions(),& 
                              ia          = subset_elem2dof, &
                              ioffset     = 0, &
                              val         = elvec)
              end if
           end do
        end if
     end if
     call fe_face%next()
  end do
  call fe_face%free()
  call this%free_fe_iterator(fe)
  call matrix%convert(csr_format)

  call parameter_list%init()
#ifdef ENABLE_MKL
  FPLError = parameter_list%set(key = direct_solver_type                  ,  value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type  ,  value = pardiso_mkl_uns)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level,  value = 0)
  iparm = 0
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm)
  assert(FPLError == 0)

  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(matrix)
  call direct_solver%numerical_setup()
  call direct_solver%solve(rhs,projected_nodal_values)
  call direct_solver%free()
#else
  FPLError = parameter_list%set(key = ils_rtol, value = 1.0e-12_rp)
  FPLError = FPLError + parameter_list%set(key = ils_output_frequency, value = 30)
  assert(FPLError == 0)
  call iterative_linear_solver%create(this%get_environment())
  call iterative_linear_solver%set_type_from_string(cg_name)
  call iterative_linear_solver%set_parameters_from_pl(parameter_list)
  call iterative_linear_solver%set_operators(matrix, .identity. matrix) 
  call iterative_linear_solver%solve(rhs,projected_nodal_values)
  call iterative_linear_solver%free()
#endif
  call parameter_list%free()

  ! Insert projected nodal values into strong_dirichlet_values array 
  call this%strong_dirichlet_values%insert_subvector(iblock=1, &
                                                     size_indices=number_subset_strong_dirichlet_dofs, &
                                                     indices=subset2global_dirichlet_dofs,             &
                                                     values=projected_nodal_values%get_entries())

  call matrix%free()
  call rhs%free()
  call projected_nodal_values%free()
  call memfree (elmat, __FILE__, __LINE__)
  call memfree (elvec, __FILE__, __LINE__)
  call memfree (offset_component, __FILE__, __LINE__ )
  deallocate ( function_scalar_components, stat=istat); check(istat==0);
  deallocate ( vector_function_values, stat=istat); check(istat==0);
  deallocate ( scalar_function_values, stat=istat); check(istat==0);
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree ( subset2global_dirichlet_dofs, __FILE__, __LINE__ )
  call memfree ( global2subset_dirichlet_dofs, __FILE__, __LINE__ ) 
  call memfree ( fields_to_project_, __FILE__, __LINE__ )
  call memfree ( subset_elem2dof, __FILE__, __LINE__ )
  deallocate(elem2dof, stat=istat ); check (istat==0)
end subroutine serial_fe_space_project_dirichlet_values_curl_conforming


subroutine serial_fe_space_allocate_and_fill_fields_to_project_ (this, &
                                                                 fields_to_project_, &
                                                                 fields_to_project)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: fields_to_project_(:)
  integer(ip), optional       , intent(in)    :: fields_to_project(:)
  
  integer(ip) :: ifield, jfield, field_id
  
  if (allocated(fields_to_project_)) call memfree(fields_to_project_,__FILE__,__LINE__)

  if ( present(fields_to_project) ) then 
     ! User specifies which fields will be projected 
     call memalloc ( size(fields_to_project), fields_to_project_, __FILE__, __LINE__ ) 
     fields_to_project_ = fields_to_project
  else  
     ! By default, all fields are projected ( i.e., 1-field case where no subset selection is needed) 
     call memalloc ( this%get_number_fields() , fields_to_project_, __FILE__, __LINE__ )  
     do field_id=1,this%get_number_fields() 
        fields_to_project_(field_id) = field_id
     end do
  end if
  
  ! fields_to_project_ consistency check (only in DEBUG mode)
#ifdef DEBUG
  do ifield = 1, size(fields_to_project_) 
    field_id = fields_to_project_(ifield)
    assert ( field_id >= 1 .and. field_id <= this%get_number_fields() )
    do jfield = ifield+1, size(fields_to_project_)
      assert ( fields_to_project_(ifield) /= fields_to_project_(jfield) )
    end do
  end do
#endif  
  
end subroutine serial_fe_space_allocate_and_fill_fields_to_project_

subroutine serial_fe_space_allocate_and_fill_offset_component(this, offset_component)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: offset_component(:)
  integer(ip) :: field_id
  class(reference_fe_t), pointer :: reference_fe
  if (allocated(offset_component)) call memfree(offset_component, __FILE__, __LINE__ )
  ! Build offset components 
  call memalloc( this%get_number_fields(), offset_component, __FILE__, __LINE__ ) 
  offset_component(1) = 0
  do field_id = 2, this%get_number_fields() 
     reference_fe                   => this%get_reference_fe(field_id-1)
     offset_component(field_id)     =  offset_component(field_id-1) + reference_fe%get_number_field_components() 
  end do
end subroutine serial_fe_space_allocate_and_fill_offset_component

! Returns the sum of those DoFs subject to strong Dirichlet boundary conditions
! associated to the fields enumerated in the fields_to_project(:) dummy argument
function serial_fe_space_allocate_and_fill_global2subset_and_inverse(this,              &
                                                                     fields_to_project, &
                                                                     global2subset,     &
                                                                     subset2global) result(num_subset_strong_dirichlet_dofs)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip)                 , intent(in)    :: fields_to_project(:)
  integer(ip), allocatable    , intent(inout) :: global2subset(:)                 
  integer(ip), allocatable    , intent(inout) :: subset2global(:)
  integer(ip)                                 :: num_subset_strong_dirichlet_dofs

  integer(ip)              :: ifield, field_id, idof, idof_subset, idof_global
  integer(ip)              :: istat
  class(fe_iterator_t), allocatable :: fe
  type(i1p_t), allocatable :: elem2dof(:)


  if (allocated(global2subset)) call memfree(global2subset,__FILE__,__LINE__)
  if (allocated(subset2global)) call memfree(subset2global,__FILE__,__LINE__)
  
  allocate( elem2dof(this%get_number_fields()), stat=istat); check(istat==0);
  call memalloc ( this%strong_dirichlet_values%get_size(), global2subset, __FILE__, __LINE__ ) 
  global2subset=0

  ! Count number of Dirichlet DOFs to be projected
  num_subset_strong_dirichlet_dofs = 0
  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        do ifield = 1, size(fields_to_project) 
           field_id = fields_to_project(ifield) 
           if ( fe%at_strong_dirichlet_boundary(field_id) ) then 
              call fe%get_elem2dof(elem2dof)
              do idof = 1,size(elem2dof(field_id)%p)
                 if ( fe%is_strong_dirichlet_dof(elem2dof(field_id)%p(idof)) ) then 
                    if (global2subset(-elem2dof(field_id)%p(idof))==0) then 
                       num_subset_strong_dirichlet_dofs = num_subset_strong_dirichlet_dofs + 1
                       global2subset(-elem2dof(field_id)%p(idof)) = num_subset_strong_dirichlet_dofs 
                    end if
                 end if
              end do
           end if
        end do
     end if
     call fe%next()
  end do
  call this%free_fe_iterator(fe)
  ! Allocate + compute subset2global_dirichlet_dofs from subset2global_dirichlet_dofs
  call memalloc ( num_subset_strong_dirichlet_dofs, subset2global, __FILE__, __LINE__ ) 
  idof_subset=1
  do idof_global=1, this%strong_dirichlet_values%get_size()
     if (global2subset(idof_global) /= 0) then
        subset2global(idof_subset) = global2subset(idof_global) 
        idof_subset=idof_subset+1
     end if
  end do  
  deallocate(elem2dof, stat=istat ); check (istat==0)
end function serial_fe_space_allocate_and_fill_global2subset_and_inverse

subroutine serial_fe_space_get_function_scalar_components ( this, &
                                                            fe_face, &
                                                            fe, &
                                                            field_id, &
                                                            component_id, &
                                                            conditions, & 
                                                            function_scalar_components )
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  type(fe_face_iterator_t)    , intent(in)    :: fe_face
  class(fe_iterator_t)        , intent(inout) :: fe
  integer(ip)                 , intent(in)    :: field_id
  integer(ip)                 , intent(in)    :: component_id
  class(conditions_t)         , intent(in)    :: conditions
  type(p_scalar_function_t)   , intent(inout) :: function_scalar_components(:)
  
  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  
  assert ( reference_fe%get_number_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_number_fields() )
  assert ( component_id >= 1 .and. component_id <= conditions%get_number_components() )
  
  ! Retreive the scalar functions corresponding to the components of the function to be projected
  do icomp=1, reference_fe%get_number_field_components()
       call conditions%get_function(fe_face%get_set_id(), &
                                    component_id+icomp-1, &
                                    function_scalar_components(icomp)%p)
  end do
end subroutine serial_fe_space_get_function_scalar_components

subroutine serial_fe_space_evaluate_vector_function_scalar_components(this, &
                                                                      fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  type(fe_face_iterator_t) , intent(inout) :: fe_face
  class(fe_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(p_scalar_function_t), intent(in)    :: function_scalar_components(:)
  real(rp)                 , intent(inout) :: scalar_function_values(:,:) ! Work-space
  type(vector_field_t)     , intent(inout) :: vector_function_values(:,:)
  real(rp), optional       , intent(in)    :: time

  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  type(quadrature_t)   , pointer :: quadrature
  type(face_map_t)     , pointer :: face_map
  type(point_t)        , pointer :: quad_coords(:)
                   
  real(rp)                       :: time_(1)
  integer(ip)                    :: qpoint, n_q_points
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  face_map     => fe_face%get_face_map()   
  quad_coords  => face_map%get_quadrature_coordinates()
  
  assert ( reference_fe%get_number_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_number_fields() )
  
  if ( present(time) ) time_(1) = time
  
  quadrature   => fe_face%get_quadrature()
  n_q_points   = quadrature%get_number_quadrature_points()
  
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! reference_fe MUST BE a vector-valued FE
     assert (.false.)
  case ( field_type_vector )
     do icomp=1, reference_fe%get_number_field_components()
        if(present(time)) then
           call function_scalar_components(icomp)%p%get_values_set_space_time(quad_coords,time_,scalar_function_values(1:n_q_points,:))
        else
           call function_scalar_components(icomp)%p%get_values_set_space(quad_coords,scalar_function_values(1:n_q_points,1))
        end if
        do qpoint = 1, n_q_points
           call vector_function_values(qpoint,1)%set(icomp,scalar_function_values(qpoint,1))
        end do
     end do
  case ( field_type_tensor )
     ! reference_fe MUST BE a vector-valued FE
     assert(.false.)
  end select
end subroutine serial_fe_space_evaluate_vector_function_scalar_components

subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec ( this, &
                                                                         fe_face, & 
                                                                         fe, &
                                                                         field_id, &
                                                                         vector_function_values, &
                                                                         elmat, &
                                                                         elvec)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  type(fe_face_iterator_t) , intent(inout) :: fe_face
  class(fe_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(vector_field_t)     , intent(in)    :: vector_function_values(:,:)
  real(rp)                 , intent(inout) :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)

  ! Locals
  class(reference_fe_t)  , pointer :: reference_fe
  type(quadrature_t)     , pointer :: quadrature
  integer(ip)                      :: qpoint, n_q_points
  type(face_map_t)       , pointer :: face_map
  type(fe_map_t)         , pointer :: face_map_face_map
  type(face_integrator_t), pointer :: face_int
  integer(ip)                      :: ishape, jshape
  real(rp)                         :: factor
  type(vector_field_t) :: normal 
  type(vector_field_t) :: vector_shape_test, vector_shape_trial
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  quadrature        => fe_face%get_quadrature()
  face_map          => fe_face%get_face_map()   
  face_map_face_map => face_map%get_face_map()
  n_q_points        = quadrature%get_number_quadrature_points()
  face_int          => fe_face%get_face_integrator(field_id)
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! Curl-conforming projection does not make sense with scalar-valued fields
     assert(.false.)
  case ( field_type_vector )
     elmat = 0.0_rp
     elvec = 0.0_rp
     do qpoint = 1, n_q_points
        factor = face_map%get_det_jacobian(qpoint) * quadrature%get_weight(qpoint)
        call face_map_face_map%get_normal(qpoint, normal)
        do ishape = 1, reference_fe%get_number_shape_functions() 
           call face_int%get_value(ishape,qpoint,1,vector_shape_test)
           do jshape = 1, reference_fe%get_number_shape_functions()
              call face_int%get_value(jshape,qpoint,1,vector_shape_trial)
              elmat(ishape,jshape) = elmat(ishape,jshape) + cross_product(vector_shape_test,normal)*cross_product(vector_shape_trial,normal)*factor
           end do
           elvec(ishape) = elvec(ishape) + cross_product(vector_function_values(qpoint,1),normal)*cross_product(vector_shape_test,normal)*factor
        end do
     end do
  case ( field_type_tensor )
     ! Curl-conforming projection does not make sense with tensor-valued fields
     assert(.false.)
  end select
end subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec


subroutine serial_fe_space_allocate_and_fill_reference_fes ( this, reference_fes )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  type(p_reference_fe_t)                ,  intent(in)   :: reference_fes(:)
  integer(ip) :: i, istat

  this%reference_fes_size = size(reference_fes)
  allocate( this%reference_fes(this%reference_fes_size), stat=istat )
  check ( istat == 0 )

  do i  = 1, this%reference_fes_size
     this%reference_fes(i) = reference_fes(i)
  end do
end subroutine serial_fe_space_allocate_and_fill_reference_fes

subroutine serial_fe_space_free_reference_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: istat
  this%reference_fes_size = 0
  if (allocated(this%reference_fes)) then
     deallocate( this%reference_fes, stat=istat )
     check ( istat == 0 )
  end if
end subroutine serial_fe_space_free_reference_fes

subroutine serial_fe_space_allocate_ref_fe_id_per_fe ( this )
  class(serial_fe_space_t), intent(inout) :: this
  call memalloc (this%number_fields, &
       this%triangulation%get_num_cells(), &
       this%reference_fe_id_per_fe, &
       __FILE__, __LINE__)
end subroutine serial_fe_space_allocate_ref_fe_id_per_fe

subroutine serial_fe_space_free_ref_fe_id_per_fe ( this )
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%reference_fe_id_per_fe)) then
     call memfree (this%reference_fe_id_per_fe, &
          __FILE__, __LINE__)
  end if
end subroutine serial_fe_space_free_ref_fe_id_per_fe

subroutine serial_fe_space_fill_ref_fe_id_per_fe_same_on_all_cells ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this

  integer(ip) :: ifield
  integer(ip) :: ife

  do ife=1, this%triangulation%get_num_cells()
     do ifield=1, this%number_fields
        this%reference_fe_id_per_fe(ifield,ife) = ifield
     end do
  end do

end subroutine serial_fe_space_fill_ref_fe_id_per_fe_same_on_all_cells

subroutine serial_fe_space_fill_ref_fe_id_per_fe_different_between_cells ( this, set_ids_to_reference_fes )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: set_ids_to_reference_fes(:,:)

  integer(ip) :: ifield
  class(cell_iterator_t),allocatable :: cell

  call this%triangulation%create_cell_iterator(cell)
  do while (.not. cell%has_finished())
    do ifield=1, this%number_fields
      this%reference_fe_id_per_fe(ifield,cell%get_lid()) = set_ids_to_reference_fes(ifield,cell%get_set_id())
    end do
    call cell%next()
  end do
  call this%triangulation%free_cell_iterator(cell)

end subroutine serial_fe_space_fill_ref_fe_id_per_fe_different_between_cells

subroutine serial_fe_space_check_cell_vs_fe_topology_consistency(this)
  implicit none
  class(serial_fe_space_t)          , intent(in) :: this
  class(fe_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe_unkno
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: field_id

#ifdef DEBUG
  call this%create_fe_iterator(fe)
  call fe%first()
  do while ( .not. fe%has_finished())
     reference_fe_geo => fe%get_reference_fe_geo()
     do field_id = 1, fe%get_number_fields()  
        reference_fe_unkno => fe%get_reference_fe(field_id)
        assert ( reference_fe_unkno%get_topology() == reference_fe_geo%get_topology() )
     end do
     call fe%next()
  end do
  call fe%free()
#endif

end subroutine serial_fe_space_check_cell_vs_fe_topology_consistency

subroutine serial_fe_space_allocate_fe_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_fe_quadratures_degree()
  call memalloc ( this%triangulation%get_num_cells(), this%fe_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_fe_quadratures_degree 

subroutine serial_fe_space_clear_fe_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  assert ( allocated(this%fe_quadratures_degree) )
  this%fe_quadratures_degree = fe_space_default_quadrature_degree_flag
end subroutine serial_fe_space_clear_fe_quadratures_degree

subroutine serial_fe_space_free_fe_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%fe_quadratures_degree)) call memfree ( this%fe_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_fe_quadratures_degree

subroutine serial_fe_space_allocate_max_order_reference_fe_id_per_fe ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_max_order_reference_fe_id_per_fe()
  call memalloc ( this%triangulation%get_num_cells(), this%max_order_reference_fe_id_per_fe, __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_max_order_reference_fe_id_per_fe 

subroutine serial_fe_space_free_max_order_reference_fe_id_per_fe ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%max_order_reference_fe_id_per_fe)) call memfree ( this%max_order_reference_fe_id_per_fe, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_max_order_reference_fe_id_per_fe 

subroutine serial_fe_space_compute_max_order_reference_fe_id_per_fe ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_iterator_t), allocatable :: fe
  integer(ip) :: max_order, max_order_reference_fe_id_within_fe
  integer(ip) :: field_id
  
  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     max_order = -1
     do field_id=1, this%get_number_fields()
        if ( max_order <= fe%get_max_order_single_field(field_id) ) then
           max_order = fe%get_max_order_single_field(field_id)
           max_order_reference_fe_id_within_fe = fe%get_reference_fe_id(field_id)
        end if
     end do
     this%max_order_reference_fe_id_per_fe(fe%get_lid()) = max_order_reference_fe_id_within_fe
     call fe%next()
  end do
  call this%free_fe_iterator(fe) 
end subroutine serial_fe_space_compute_max_order_reference_fe_id_per_fe 

subroutine serial_fe_space_initialize_fe_integration ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this

  class(fe_iterator_t), allocatable :: fe
  integer(ip)         :: current_quadrature_and_map
  integer(ip)         :: current_cell_integrator

  integer(ip)         :: field_id
  integer(ip)         :: max_order, max_order_reference_fe_id_within_fe
  integer(ip)         :: fe_quadrature_and_map_key
  integer(ip)         :: fe_cell_integrators_position_key
  integer(ip)         :: istat
  type(quadrature_t), pointer :: quadrature

  class(reference_fe_t), pointer :: reference_fe

  call this%free_fe_integration()
  
  call this%allocate_max_order_reference_fe_id_per_fe()
  call this%compute_max_order_reference_fe_id_per_fe()
  
  ! Determine the size of fe_quadratures, fe_maps, and fe_cell_integrators 
  ! while filling the corresponding hash tables
  call this%fe_quadratures_and_maps_position%init()
  call this%fe_cell_integrators_position%init()
  current_quadrature_and_map = 1
  current_cell_integrator  = 1
  
  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     fe_quadrature_and_map_key = this%generate_fe_quadratures_position_key(fe%get_reference_fe_geo_id(),&
                                                                           fe%get_quadrature_degree())

     call this%fe_quadratures_and_maps_position%put(key = fe_quadrature_and_map_key,  &
                                                    val = current_quadrature_and_map, &
                                                    stat= istat)
     if (istat == now_stored) then
        current_quadrature_and_map = current_quadrature_and_map + 1
     end if

     do field_id=1, this%get_number_fields()
        fe_cell_integrators_position_key = &
             this%generate_fe_cell_integrators_position_key(fe%get_reference_fe_geo_id(), &
                                                 fe%get_quadrature_degree(), &
                                                 this%reference_fe_id_per_fe(field_id, fe%get_lid()))

        call this%fe_cell_integrators_position%put(key=fe_cell_integrators_position_key, &
                                                     val=current_cell_integrator, &
                                                     stat=istat)
        if (istat == now_stored) then
           current_cell_integrator = current_cell_integrator + 1
        end if
     end do

     call fe%next()
  end do

  allocate ( this%fe_quadratures(current_quadrature_and_map-1), stat=istat)
  check (istat==0)

  allocate ( this%fe_maps(current_quadrature_and_map-1), stat=istat)
  check (istat==0)

  allocate ( this%fe_cell_integrators(current_cell_integrator-1), stat=istat)
  check (istat==0)

  call this%fe_quadratures_and_maps_position%init()
  call this%fe_cell_integrators_position%init()
  current_quadrature_and_map = 1
  current_cell_integrator  = 1

  call fe%first()
  do while ( .not. fe%has_finished())
   
     fe_quadrature_and_map_key = this%generate_fe_quadratures_position_key(fe%get_reference_fe_geo_id(),&
                                                                           fe%get_quadrature_degree())
     
     call this%fe_quadratures_and_maps_position%put(key = fe_quadrature_and_map_key,  &
                                                    val = current_quadrature_and_map, &
                                                    stat= istat)
     if (istat == now_stored) then
        ! Create quadrature and fe_map associated to current max_order_within_fe
        max_order_reference_fe_id_within_fe = this%max_order_reference_fe_id_per_fe(fe%get_lid()) 
        reference_fe => this%reference_fes(max_order_reference_fe_id_within_fe)%p
        call reference_fe%create_quadrature(this%fe_quadratures(current_quadrature_and_map))!, &
                                            !fe%get_quadrature_degree())
        call this%fe_maps(current_quadrature_and_map)%create(this%fe_quadratures(current_quadrature_and_map),&
                                                             fe%get_reference_fe_geo())
        current_quadrature_and_map = current_quadrature_and_map + 1
     end if

     do field_id=1, this%get_number_fields()
        fe_cell_integrators_position_key = &
             this%generate_fe_cell_integrators_position_key(fe%get_reference_fe_geo_id(), &
                                                              fe%get_quadrature_degree(), &
                                                              this%reference_fe_id_per_fe(field_id, fe%get_lid()))
        
        call this%fe_cell_integrators_position%put(key=fe_cell_integrators_position_key, &
                                                     val=current_cell_integrator, &
                                                     stat=istat)
        if (istat == now_stored) then 
           quadrature => fe%get_quadrature()
           call this%fe_cell_integrators(current_cell_integrator)%create(quadrature,&
                                                                             fe%get_reference_fe(field_id))
           current_cell_integrator = current_cell_integrator + 1
        end if
     end do
     call fe%next()
  end do
  call this%free_fe_iterator(fe)
end subroutine serial_fe_space_initialize_fe_integration

subroutine serial_fe_space_free_fe_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)         :: i, istat

  class(reference_fe_t), pointer :: reference_fe

  call this%fe_quadratures_and_maps_position%free()
  call this%fe_cell_integrators_position%free()

  if (allocated(this%fe_quadratures)) then
     do i=1, size(this%fe_quadratures)
        call this%fe_quadratures(i)%free()
     end do
     deallocate(this%fe_quadratures, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%fe_maps)) then
     do i=1, size(this%fe_maps)
        call this%fe_maps(i)%free()
     end do
     deallocate(this%fe_maps, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%fe_cell_integrators)) then
     do i=1, size(this%fe_cell_integrators)
        call this%fe_cell_integrators(i)%free()
     end do
     deallocate(this%fe_cell_integrators, stat=istat)
     check(istat==0)
  end if
  
  call this%free_fe_quadratures_degree()
  call this%free_max_order_reference_fe_id_per_fe()
  
end subroutine serial_fe_space_free_fe_integration


! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_number_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
function serial_fe_space_generate_fe_quadratures_position_key ( this, geo_reference_fe_id, quadrature_degree)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip) :: serial_fe_space_generate_fe_quadratures_position_key
  massert ( quadrature_degree >= -1,  "serial_fe_space_generate_fe_quadratures_position_key::Invalid quadrature degree")
  massert ( geo_reference_fe_id >= 1 .and. geo_reference_fe_id <= this%triangulation%get_number_reference_fes_geo(), "serial_fe_space_generate_fe_quadratures_position_key::Invalid geo_reference_fe_id" )
  serial_fe_space_generate_fe_quadratures_position_key = quadrature_degree * this%triangulation%get_number_reference_fes_geo() + geo_reference_fe_id + this%triangulation%get_number_reference_fes_geo()
end function serial_fe_space_generate_fe_quadratures_position_key

! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_number_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
!   * reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_generate_fe_cell_integrators_position_key ( this, geo_reference_fe_id, quadrature_degree, reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: reference_fe_id
  integer(ip) :: serial_fe_space_generate_fe_cell_integrators_position_key
  massert ( reference_fe_id >= 1 .and. reference_fe_id <= this%get_number_reference_fes(), "serial_fe_space_generate_fe_cell_integrators_position_key::Invalid reference_fe_id" )
  serial_fe_space_generate_fe_cell_integrators_position_key =  reference_fe_id + &
       this%generate_fe_quadratures_position_key(geo_reference_fe_id,quadrature_degree) * this%get_number_reference_fes()
end function serial_fe_space_generate_fe_cell_integrators_position_key

subroutine serial_fe_space_allocate_fe_face_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_fe_face_quadratures_degree()
  call memalloc ( this%triangulation%get_num_faces(), this%fe_face_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_fe_face_quadratures_degree 

subroutine serial_fe_space_clear_fe_face_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  assert ( allocated(this%fe_face_quadratures_degree) )
  this%fe_face_quadratures_degree = fe_space_default_quadrature_degree_flag
end subroutine serial_fe_space_clear_fe_face_quadratures_degree

subroutine serial_fe_space_free_fe_face_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%fe_face_quadratures_degree)) call memfree ( this%fe_face_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_fe_face_quadratures_degree

subroutine serial_fe_space_allocate_max_order_reference_fe_id_per_fe_face ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_max_order_reference_fe_id_per_fe_face()
  call memalloc ( this%triangulation%get_num_faces(), this%max_order_reference_fe_id_per_fe_face , __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_max_order_reference_fe_id_per_fe_face  

subroutine serial_fe_space_free_max_order_reference_fe_id_per_fe_face  ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%max_order_reference_fe_id_per_fe_face)) call memfree ( this%max_order_reference_fe_id_per_fe_face , __FILE__, __LINE__ )
end subroutine serial_fe_space_free_max_order_reference_fe_id_per_fe_face  

subroutine serial_fe_space_compute_max_order_reference_fe_id_per_fe_face ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  type(fe_face_iterator_t) :: face
  class(fe_iterator_t), allocatable :: fe
  integer(ip) :: max_order, max_order_reference_fe_id, reference_fe_id
  integer(ip) :: max_order_fes_around_fe_face
  integer(ip) :: field_id, icell_around
  
  call this%create_fe_face_iterator(face)
  call this%create_fe_iterator(fe)
  do while ( .not. face%has_finished())
     max_order_fes_around_fe_face = -1
     max_order_reference_fe_id    =  1 
     do icell_around = 1, face%get_num_cells_around()
        call face%get_cell_around(icell_around, fe)
        do field_id=1, fe%get_number_fields()
           if ( max_order_fes_around_fe_face <= fe%get_max_order_single_field(field_id) ) then
              max_order_fes_around_fe_face = fe%get_max_order_single_field(field_id)
              max_order_reference_fe_id = fe%get_reference_fe_id(field_id)
           end if
        end do
     end do
     this%max_order_reference_fe_id_per_fe_face(face%get_face_lid()) = max_order_reference_fe_id 
     call face%next()
  end do
  call this%free_fe_vef_iterator(face)
  call this%free_fe_iterator(fe)
end subroutine serial_fe_space_compute_max_order_reference_fe_id_per_fe_face  

subroutine serial_fe_space_initialize_fe_face_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  type(fe_face_iterator_t)          :: fe_face
  class(fe_iterator_t), allocatable :: fe

  integer(ip) :: current_fe_face_quadrature
  integer(ip) :: current_fe_face_map
  integer(ip) :: current_fe_face_integrator

  integer(ip)            :: max_order_fes_around_fe_face
  integer(ip)            :: reference_fes_geo_id(2)
  type(p_lagrangian_reference_fe_t) :: reference_fes_geo(2)

  integer(ip)            :: reference_fes_id(2)
  type(p_reference_fe_t) :: reference_fes(2)

  integer(ip) :: fe_face_quadratures_position_key
  integer(ip) :: fe_face_integrators_position_key

  integer(ip) :: field_id, istat, icell_around

  class(reference_fe_t), pointer :: reference_fe

  call this%free_fe_face_integration()

  call this%allocate_max_order_reference_fe_id_per_fe_face()
  call this%compute_max_order_reference_fe_id_per_fe_face()
  
  ! Determine the size of fe_face_quadratures, fe_face_maps, 
  ! and fe_face_integrators while filling the corresponding hash tables
  call this%fe_face_quadratures_position%init()
  call this%fe_face_integrators_position%init()
  current_fe_face_quadrature = 1
  current_fe_face_map = 1
  current_fe_face_integrator = 1

  call this%create_fe_iterator(fe)
  call this%create_fe_face_iterator(fe_face)
  do while ( .not. fe_face%has_finished() ) 
     reference_fes_geo_id(2) = 0 
     do icell_around = 1, fe_face%get_num_cells_around()
        call fe_face%get_cell_around(icell_around, fe)
        reference_fes_geo_id(icell_around) = fe%get_reference_fe_geo_id()
     end do

     fe_face_quadratures_position_key = &
          this%generate_fe_face_quadratures_position_key(fe_face%get_quadrature_degree(), &
                                                         reference_fes_geo_id(1), &
                                                         reference_fes_geo_id(2) )
          
     call this%fe_face_quadratures_position%put(key  = fe_face_quadratures_position_key, &
                                                val  = current_fe_face_quadrature, &
                                                stat = istat)  
     
     if (istat == now_stored) then
        current_fe_face_quadrature = current_fe_face_quadrature + 1
        current_fe_face_map = current_fe_face_map + 1
     end if

     do field_id=1, this%get_number_fields()
        reference_fes_id(2) = 0  
        do icell_around = 1, fe_face%get_num_cells_around()
           call fe_face%get_cell_around(icell_around, fe)
           reference_fes_id(icell_around) = this%reference_fe_id_per_fe(field_id, fe%get_lid())
        end do

        fe_face_integrators_position_key = &
             this%generate_fe_face_integrators_position_key(fe_face%get_quadrature_degree(), &
                                                            reference_fes_id(1), &
                                                            reference_fes_id(2) )

        call this%fe_face_integrators_position%put(key=fe_face_integrators_position_key, &
                                                   val=current_fe_face_integrator, &
                                                   stat=istat)
        if (istat == now_stored) then
           current_fe_face_integrator = current_fe_face_integrator + 1
        end if
     end do
     call fe_face%next()
  end do

  allocate ( this%fe_face_quadratures(current_fe_face_quadrature-1), stat=istat)
  check (istat==0)

  allocate ( this%fe_face_maps(current_fe_face_map-1), stat=istat)
  check (istat==0)

  allocate ( this%fe_face_integrators(current_fe_face_integrator-1), stat=istat)
  check (istat==0)

  call this%fe_face_quadratures_position%init()
  call this%fe_face_integrators_position%init()
  current_fe_face_quadrature = 1
  current_fe_face_map = 1
  current_fe_face_integrator = 1

  call fe_face%first()
  do while ( .not. fe_face%has_finished() ) 
     reference_fes_geo_id(2) = 0
     nullify(reference_fes_geo(2)%p)
     do icell_around = 1, fe_face%get_num_cells_around()
        call fe_face%get_cell_around(icell_around, fe)
        reference_fes_geo_id(icell_around) =  fe%get_reference_fe_geo_id()
        reference_fes_geo(icell_around)%p  => fe%get_reference_fe_geo()
     end do

     fe_face_quadratures_position_key = &
          this%generate_fe_face_quadratures_position_key(fe_face%get_quadrature_degree(), &
                                                         reference_fes_geo_id(1), &
                                                         reference_fes_geo_id(2) )
     
     
     call this%fe_face_quadratures_position%put(key  = fe_face_quadratures_position_key, &
                                                val  = current_fe_face_quadrature, &
                                                stat = istat)  
     if (istat == now_stored) then
        reference_fe=>this%reference_fes( this%max_order_reference_fe_id_per_fe_face(fe_face%get_face_lid()) )%p
        call reference_fe%create_face_quadrature(this%fe_face_quadratures(current_fe_face_quadrature),fe_face%get_quadrature_degree())
        call this%fe_face_maps(current_fe_face_map)%create(fe_face%get_quadrature(), &
                                                           reference_fes_geo(1)%p, &
                                                           reference_fes_geo(2)%p )
        current_fe_face_quadrature = current_fe_face_quadrature + 1
        current_fe_face_map = current_fe_face_map + 1
     end if

     do field_id=1, this%get_number_fields()
        reference_fes_id(2) = 0  
        nullify(reference_fes(2)%p)
        do icell_around = 1, fe_face%get_num_cells_around()
           call fe_face%get_cell_around(icell_around, fe)
           reference_fes_id(icell_around) = this%reference_fe_id_per_fe(field_id, fe%get_lid())
           reference_fes(icell_around)%p => fe%get_reference_fe(field_id)
        end do

        fe_face_integrators_position_key = &
             this%generate_fe_face_integrators_position_key(fe_face%get_quadrature_degree(), &
                                                            reference_fes_id(1), &
                                                            reference_fes_id(2) )

        call this%fe_face_integrators_position%put(key=fe_face_integrators_position_key, &
                                                   val=current_fe_face_integrator, &
                                                   stat=istat)
        if (istat == now_stored) then
           call this%fe_face_integrators(current_fe_face_integrator)%create(fe_face%get_quadrature(), &
                reference_fes(1)%p, &
                reference_fes(2)%p )
           current_fe_face_integrator = current_fe_face_integrator + 1
        end if
     end do
     call fe_face%next()
  end do
  call this%free_fe_iterator(fe)
  call fe_face%free()
end subroutine serial_fe_space_initialize_fe_face_integration

subroutine serial_fe_space_free_fe_face_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat

  !if (allocated(this%max_order_per_fe_face)) call memfree ( this%max_order_per_fe_face, __FILE__, __LINE__ )

  call this%fe_face_quadratures_position%free()
  call this%fe_face_integrators_position%free()

  if (allocated(this%fe_face_quadratures)) then
     do i=1, size(this%fe_face_quadratures)
        call this%fe_face_quadratures(i)%free()
     end do
     deallocate(this%fe_face_quadratures, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%fe_face_maps)) then
     do i=1, size(this%fe_face_maps)
        call this%fe_face_maps(i)%free()
     end do
     deallocate(this%fe_face_maps, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%fe_face_integrators)) then
     do i=1, size(this%fe_face_integrators)
        call this%fe_face_integrators(i)%free()
     end do
     deallocate(this%fe_face_integrators, stat=istat)
     check(istat==0)
  end if
  
  call this%free_fe_face_quadratures_degree()
  call this%free_max_order_reference_fe_id_per_fe_face()
  
end subroutine serial_fe_space_free_fe_face_integration

! Provided the identifiers of the reference_fes_geo corresponding 
! to the cells around a fe_face, and the quadrature degree, computes a unique key 
! that is used to retrieve the position in the "this%fe_face_quadratures(:)" allocatable array through 
! the corresponding hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_geo_reference_fe_id can range from 0 to number_reference_fes_geo 
!      (with 0 for boundary fe_faces)
!    * left_geo_reference_fe_id can range from 1 to number_reference_fes_geo
function serial_fe_space_fe_face_quadratures_position_key ( this, quadrature_degree, left_geo_reference_fe_id, right_geo_reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_geo_reference_fe_id
  integer(ip)                 , intent(in) :: right_geo_reference_fe_id
  integer(ip) :: serial_fe_space_fe_face_quadratures_position_key
  integer(ip) :: num_reference_fes_geo

  num_reference_fes_geo = this%triangulation%get_number_reference_fes_geo()
  serial_fe_space_fe_face_quadratures_position_key = left_geo_reference_fe_id + &
       (num_reference_fes_geo)*(right_geo_reference_fe_id) + &
       (num_reference_fes_geo)*(num_reference_fes_geo+1)*(quadrature_degree+1)
end function serial_fe_space_fe_face_quadratures_position_key

! For a given field, provided the identifiers of the reference_fes corresponding 
! to the cells around a fe_face, and the quadrature degree to be used, computes a unique key that 
! is used to retrieve the position in the "this%fe_face_integrators(:)" allocatable array through the corresponding 
! hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_reference_fe_id can range from 1 to this%reference_fes_size 
!      (with 0 for boundary fe_faces)
!    * left_reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_fe_face_integrators_position_key(this, quadrature_degree, left_reference_fe_id, right_reference_fe_id)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_reference_fe_id
  integer(ip)                 , intent(in) :: right_reference_fe_id
  integer(ip) :: serial_fe_space_fe_face_integrators_position_key
  serial_fe_space_fe_face_integrators_position_key = left_reference_fe_id + &
       (this%reference_fes_size)*(right_reference_fe_id) + &
       (this%reference_fes_size)*(this%reference_fes_size+1)*(quadrature_degree+1)
end function serial_fe_space_fe_face_integrators_position_key

subroutine serial_fe_space_create_dof_values(this, dof_values)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  class(vector_t), allocatable, intent(inout) :: dof_values
  integer(ip) :: istat

  assert ( associated(this%block_layout) ) 
  
  if (allocated(dof_values)) then
     call dof_values%free()
     deallocate(dof_values, stat=istat); check(istat==0);
  end if

  if (this%block_layout%get_num_blocks() == 1) then
     allocate ( serial_scalar_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_scalar_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_block_num_dofs(1))
        class default
        check(.false.)
     end select
  else
     allocate ( serial_block_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_block_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_num_blocks(),this%block_layout%get_num_dofs_x_block())
        class default
        check(.false.)
     end select
  end if
end subroutine serial_fe_space_create_dof_values

subroutine serial_fe_space_fill_dof_info( this, block_layout )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  type(block_layout_t), target, intent(inout) :: block_layout
  logical :: perform_numbering
  
  perform_numbering = .not. associated(this%block_layout) 
  if (.not. perform_numbering) perform_numbering = .not. (this%block_layout == block_layout)
  if ( perform_numbering ) then
    this%block_layout => block_layout
    call memalloc( this%number_fields, this%number_dofs_per_field, __FILE__, __LINE__ )   
    if ( this%number_fields >= 1 ) then 
      call this%count_dofs()
    end if  
    call this%list_dofs()
  end if
end subroutine serial_fe_space_fill_dof_info

subroutine serial_fe_space_count_dofs ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this   
  logical, allocatable :: per_field_vefs_visited(:,:)
  integer(ip) :: field_id, vef_lid, ivef, num_own_dofs_on_vef, iblock
  class(fe_iterator_t), allocatable :: fe
  
  ! Count #DoFs per field
  this%number_dofs_per_field = 0
  
  call memalloc ( this%number_fields, this%triangulation%get_num_vefs(), per_field_vefs_visited,  __FILE__, __LINE__ )
  per_field_vefs_visited = .false.

  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        do field_id=1, this%number_fields
          if ( .not. fe%is_void(field_id)) then
            this%number_dofs_per_field(field_id) = this%number_dofs_per_field(field_id) + &
                                                      fe%count_own_dofs(field_id)
            if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
               do ivef = 1, fe%get_num_vefs()
                 vef_lid = fe%get_vef_lid(ivef)
                 if ( .not. per_field_vefs_visited (field_id,vef_lid) ) then
                    num_own_dofs_on_vef = fe%count_own_dofs_on_vef(ivef,field_id)
                    if (num_own_dofs_on_vef>0) then
                      per_field_vefs_visited (field_id,vef_lid) = .true.
                      this%number_dofs_per_field(field_id) = this%number_dofs_per_field(field_id) + &
                                                                  num_own_dofs_on_vef 
                    end if
                 end if
               end do           
            end if                                       
          end if
        end do
     end if
     call fe%next()
  end do
  
  ! Count #DoFs per block
  call this%block_layout%clear_num_dofs_x_block()
  do field_id=1, this%get_number_fields()
    iblock = this%block_layout%get_block_id(field_id) 
    call this%block_layout%add_to_block_num_dofs(iblock,this%number_dofs_per_field(field_id))     
  end do
  
  call this%free_fe_iterator(fe)
  call memfree ( per_field_vefs_visited,  __FILE__, __LINE__ )
end subroutine serial_fe_space_count_dofs 

subroutine serial_fe_space_list_dofs ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this   
  
  integer(ip), allocatable :: owner_cell_gid_per_field_and_vef(:,:)
  integer(ip), allocatable :: per_field_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: blocks_current_num_dofs(:)
  integer(ip), allocatable :: fields_current_dof(:)
  class(fe_iterator_t), allocatable :: fe, source_fe
  integer(ip) :: block_id, field_id
  integer(ip) :: ivef, vef_lid
  integer(ip) :: previous_dof_block
  
  call memalloc ( this%get_number_fields(), this%triangulation%get_num_vefs(), owner_cell_gid_per_field_and_vef,  __FILE__, __LINE__ )
  owner_cell_gid_per_field_and_vef = -1
  
  call memalloc ( this%get_number_fields(), this%triangulation%get_num_vefs(), per_field_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_vef_lid_in_owner_cell = -1
  
  call memalloc( this%block_layout%get_num_blocks(), blocks_current_num_dofs, __FILE__, __LINE__ )
  blocks_current_num_dofs = 0
  
  call memalloc( this%number_fields, fields_current_dof, __FILE__, __LINE__ )
  fields_current_dof = 0
  
  if (this%number_fields > 1) then
    do field_id=1, this%number_fields
       block_id = this%block_layout%get_block_id(field_id)
       fields_current_dof(field_id) = fields_current_dof(field_id) + blocks_current_num_dofs(block_id)
       blocks_current_num_dofs(block_id) = blocks_current_num_dofs(block_id) + this%number_dofs_per_field(field_id)
    end do
  end if
  
  call this%create_fe_iterator(source_fe)
  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
       do field_id=1, this%get_number_fields()
         if ( .not. fe%is_void(field_id)) then
           call fe%fill_own_dofs ( field_id, fields_current_dof(field_id) )
           do ivef = 1, fe%get_num_vefs()
             vef_lid = fe%get_vef_lid(ivef)
             if ( owner_cell_gid_per_field_and_vef( field_id, vef_lid ) == -1 ) then
                previous_dof_block = fields_current_dof(field_id)
                call fe%fill_own_dofs_on_vef ( ivef, field_id, fields_current_dof(field_id), free_dofs_loop=.true.  )
                if (previous_dof_block < fields_current_dof(field_id)) then
                  owner_cell_gid_per_field_and_vef( field_id, vef_lid ) = fe%get_lid() 
                  per_field_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                end if
             else 
                call source_fe%set_lid(owner_cell_gid_per_field_and_vef(field_id, vef_lid))
                call fe%fill_own_dofs_on_vef_from_source_fe ( ivef, &
                                                              source_fe, &
                                                              per_field_vef_lid_in_owner_cell(field_id,vef_lid), &
                                                              field_id) 
             end if
           end do
         end if
       end do
     end if
     call fe%next()
  end do  
  
  ! Set #DoFs per field and block in case of single-field, single-block problem
  ! (as we did not call fe_space%count_dofs() in this case)
  if ( this%number_fields == 1 ) then
    field_id = 1
    block_id = 1
    this%number_dofs_per_field(field_id) = fields_current_dof(field_id)
    call this%block_layout%set_block_num_dofs(block_id,this%number_dofs_per_field(field_id))
  end if
  
  call this%free_fe_iterator(source_fe)
  call this%free_fe_iterator(fe)
  call memfree( blocks_current_num_dofs, __FILE__, __LINE__ )
  call memfree( fields_current_dof     , __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_per_field_and_vef,  __FILE__, __LINE__ )
  call memfree ( per_field_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
end subroutine serial_fe_space_list_dofs 

subroutine serial_fe_space_allocate_number_dofs_per_field( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( .not. allocated(this%number_dofs_per_field) ) & 
     call memalloc( this%get_number_fields(), this%number_dofs_per_field, __FILE__, __LINE__ )
  assert ( size(this%number_dofs_per_field) == this%get_number_fields() )
end subroutine serial_fe_space_allocate_number_dofs_per_field

subroutine serial_fe_space_fill_elem2dof_and_count_dofs( this, field_id ) 
  implicit none
  ! Parameters
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip)                 ,  intent(in)   :: field_id

  ! Local variables
  integer(ip) :: ivef, vef_lid, ielem
  integer(ip) :: iblock, init_dof_block, current_dof_block, previous_dof_block
  integer(ip), allocatable :: visited_vef_to_fe_map(:,:)
  class(fe_iterator_t), allocatable :: fe, source_fe
  

  iblock            = this%block_layout%get_block_id(field_id)
  init_dof_block    = this%block_layout%get_block_num_dofs(iblock)
  current_dof_block = init_dof_block

  call this%create_fe_iterator(fe)
  if ( this%fe_space_type_per_field(field_id) == fe_space_type_cg ) then
     call memalloc ( 2, this%triangulation%get_num_vefs(), visited_vef_to_fe_map,  __FILE__, __LINE__ )
     visited_vef_to_fe_map = -1
     call this%create_fe_iterator(source_fe)
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%fill_own_dofs ( field_id, current_dof_block )
           do ivef = 1, fe%get_num_vefs()
              vef_lid = fe%get_vef_lid(ivef)
              if ( visited_vef_to_fe_map ( 1, vef_lid ) == -1 ) then
                 previous_dof_block = current_dof_block
                 call fe%fill_own_dofs_on_vef ( ivef, field_id, current_dof_block, free_dofs_loop=.true.  )
                 if (previous_dof_block < current_dof_block) then
                   visited_vef_to_fe_map ( 1, vef_lid ) = fe%get_lid()
                   visited_vef_to_fe_map ( 2, vef_lid ) = ivef
                 end if
              else 
                 call source_fe%set_lid(visited_vef_to_fe_map(1,vef_lid))
                 call fe%fill_own_dofs_on_vef_from_source_fe ( ivef, &
                      source_fe, &
                      visited_vef_to_fe_map(2,vef_lid), &
                      field_id) 
              end if
           end do
        end if
        call fe%next()
     end do
     call this%free_fe_iterator(source_fe)
     call memfree ( visited_vef_to_fe_map,  __FILE__, __LINE__ )
  else 
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%fill_own_dofs ( field_id, current_dof_block )
        end if
        call fe%next()
     end do
  end if
  call this%free_fe_iterator(fe)
  this%number_dofs_per_field(field_id) = current_dof_block - init_dof_block
  call this%block_layout%add_to_block_num_dofs(iblock,this%number_dofs_per_field(field_id))     
end subroutine serial_fe_space_fill_elem2dof_and_count_dofs

subroutine serial_fe_space_renumber_dofs_block (this, block_id, perm_old2new)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: block_id
  integer(ip)             , intent(in)    :: perm_old2new(this%block_layout%get_block_num_dofs(block_id))
  class(fe_iterator_t), allocatable :: fe

  call this%create_fe_iterator(fe)
  do while ( .not. fe%has_finished())
     call fe%renumber_dofs_block ( block_id, perm_old2new )
     call fe%next()
  end do
  call this%free_fe_iterator(fe)

end subroutine serial_fe_space_renumber_dofs_block

function serial_fe_space_get_num_dimensions ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)                          :: serial_fe_space_get_num_dimensions
  class(base_static_triangulation_t), pointer :: triangulation
  triangulation => this%get_triangulation()
  serial_fe_space_get_num_dimensions = triangulation%get_num_dimensions()
end function serial_fe_space_get_num_dimensions

function serial_fe_space_get_number_reference_fes ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_number_reference_fes
  serial_fe_space_get_number_reference_fes = size(this%reference_fes)
end function serial_fe_space_get_number_reference_fes

function serial_fe_space_get_reference_fe ( this, reference_fe_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: reference_fe_id
  class(reference_fe_t), pointer :: serial_fe_space_get_reference_fe
  assert ( reference_fe_id >=1 .and. reference_fe_id <= this%get_number_reference_fes() )
  serial_fe_space_get_reference_fe => this%reference_fes(reference_fe_id)%p
end function serial_fe_space_get_reference_fe

function serial_fe_space_get_field_type ( this, field_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: field_id
  character(:), pointer :: serial_fe_space_get_field_type
  class(fe_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe

  call this%create_fe_iterator(fe)
  reference_fe => fe%get_reference_fe(field_id)
  serial_fe_space_get_field_type => reference_fe%get_field_type()
  call this%free_fe_iterator(fe)
end function serial_fe_space_get_field_type

function serial_fe_space_get_number_components ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_number_components
  class(fe_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe
  integer(ip) :: field_id

  call this%create_fe_iterator(fe)
  serial_fe_space_get_number_components = 0
  do field_id = 1, this%get_number_fields()
     reference_fe => fe%get_reference_fe(field_id)
     serial_fe_space_get_number_components = serial_fe_space_get_number_components + &
          reference_fe%get_number_field_components()
  end do
  call this%free_fe_iterator(fe)
end function serial_fe_space_get_number_components

function serial_fe_space_get_max_number_shape_functions( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_number_shape_functions
  integer(ip) :: irefe
  serial_fe_space_get_max_number_shape_functions = 0
  do irefe = 1, this%reference_fes_size
     serial_fe_space_get_max_number_shape_functions = max(serial_fe_space_get_max_number_shape_functions, &
          this%reference_fes(irefe)%p%get_number_shape_functions())
  end do
end function serial_fe_space_get_max_number_shape_functions

function serial_fe_space_get_max_number_dofs_on_a_cell( this ) result (max_dofs)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: max_dofs
  class(fe_iterator_t), allocatable :: fe
  max_dofs = 0
  call this%create_fe_iterator(fe)
  do while (.not. fe%has_finished())
    max_dofs = max(max_dofs,fe%get_number_dofs())
    call fe%next()
  end do
  call this%free_fe_iterator(fe)
end function serial_fe_space_get_max_number_dofs_on_a_cell

function serial_fe_space_get_max_number_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_number_quadrature_points
  integer(ip) :: iquad
  serial_fe_space_get_max_number_quadrature_points = 0
  do iquad = 1, size(this%fe_quadratures)
     serial_fe_space_get_max_number_quadrature_points =       & 
          max(serial_fe_space_get_max_number_quadrature_points, &
          this%fe_quadratures(iquad)%get_number_quadrature_points())
  end do
end function serial_fe_space_get_max_number_quadrature_points

function serial_fe_space_get_max_number_nodal_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_number_nodal_quadrature_points
  integer(ip) :: i
  type(quadrature_t), pointer :: nodal_quadrature

  serial_fe_space_get_max_number_nodal_quadrature_points = 0
  do i= 1, this%reference_fes_size
     if (this%reference_fes(i)%p%has_nodal_quadrature()) then
        nodal_quadrature => this%reference_fes(i)%p%get_nodal_quadrature()
        serial_fe_space_get_max_number_nodal_quadrature_points =       & 
             max(serial_fe_space_get_max_number_nodal_quadrature_points, &
             nodal_quadrature%get_number_quadrature_points())
     end if
  end do
end function serial_fe_space_get_max_number_nodal_quadrature_points

function serial_fe_space_get_max_number_face_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_number_face_quadrature_points
  integer(ip) :: iquad
  serial_fe_space_get_max_number_face_quadrature_points = 0
  do iquad = 1, size(this%fe_face_quadratures)
     serial_fe_space_get_max_number_face_quadrature_points =       & 
          max(serial_fe_space_get_max_number_face_quadrature_points, &
          this%fe_face_quadratures(iquad)%get_number_quadrature_points())
  end do
end function serial_fe_space_get_max_number_face_quadrature_points

function serial_fe_space_get_triangulation( this) result(triangulation)
  implicit none
  class(serial_fe_space_t)      , intent(in)    :: this 
  class(base_static_triangulation_t), pointer       :: triangulation
  assert ( associated(this%triangulation) )
  triangulation => this%triangulation
end function serial_fe_space_get_triangulation

subroutine serial_fe_space_set_triangulation( this, triangulation )
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this 
  class(base_static_triangulation_t), target, intent(in)    :: triangulation
  this%triangulation => triangulation
end subroutine serial_fe_space_set_triangulation

function serial_fe_space_get_environment(this) result(environment)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  class(environment_t), pointer:: environment 
  environment => this%triangulation%get_par_environment()
end function serial_fe_space_get_environment

function serial_fe_space_get_number_strong_dirichlet_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_number_strong_dirichlet_dofs
  serial_fe_space_get_number_strong_dirichlet_dofs = this%strong_dirichlet_values%get_size()
end function serial_fe_space_get_number_strong_dirichlet_dofs

function serial_fe_space_get_conditions( this) result(conditions)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  class(conditions_t), pointer :: conditions
  assert ( associated(this%conditions) )
  conditions => this%conditions
end function serial_fe_space_get_conditions

subroutine serial_fe_space_set_conditions( this, conditions )
  implicit none
  class(serial_fe_space_t)        , intent(inout) :: this 
  class(conditions_t)     , target, intent(in)    :: conditions
  this%conditions => conditions
end subroutine serial_fe_space_set_conditions

function serial_fe_space_get_strong_dirichlet_values(this) result(strong_dirichlet_values)
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this 
  type(serial_scalar_array_t), pointer :: strong_dirichlet_values
  strong_dirichlet_values => this%strong_dirichlet_values
end function serial_fe_space_get_strong_dirichlet_values

function serial_fe_space_get_number_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_number_fixed_dofs
  serial_fe_space_get_number_fixed_dofs = this%strong_dirichlet_values%get_size()
end function serial_fe_space_get_number_fixed_dofs

function serial_fe_space_get_number_blocks( this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_number_blocks
  assert ( associated (this%block_layout) ) 
  serial_fe_space_get_number_blocks = this%block_layout%get_num_blocks()
end function serial_fe_space_get_number_blocks

function serial_fe_space_get_field_blocks( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip), pointer :: serial_fe_space_get_field_blocks(:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_blocks)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_blocks => this%block_layout%get_field_id_to_block_id()
  end if
end function serial_fe_space_get_field_blocks

function serial_fe_space_get_field_coupling( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  logical, pointer :: serial_fe_space_get_field_coupling(:,:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_coupling)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_coupling => this%block_layout%get_field_coupling()
  end if
end function serial_fe_space_get_field_coupling

! Returns the number of DoFs associated to block with identifier block_id
function serial_fe_space_get_block_number_dofs ( this, block_id )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)          , intent(in) :: block_id
  integer(ip)                       :: serial_fe_space_get_block_number_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  serial_fe_space_get_block_number_dofs = 0
  if ( environment%am_i_l1_task() ) then 
     serial_fe_space_get_block_number_dofs  = this%block_layout%get_block_num_dofs(block_id)
  end if
end function serial_fe_space_get_block_number_dofs

! Sets the number of DoFs associated to block with identifier block_id to num_dofs
subroutine serial_fe_space_set_block_number_dofs ( this, block_id, num_dofs )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)             , intent(in) :: block_id
  integer(ip)             , intent(in) :: num_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then 
     call this%block_layout%set_block_num_dofs(block_id,num_dofs)
  end if
end subroutine serial_fe_space_set_block_number_dofs

! Returns a pointer to the block_layout member variable
function serial_fe_space_get_block_layout ( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(block_layout_t), pointer :: serial_fe_space_get_block_layout
  serial_fe_space_get_block_layout => this%block_layout
end function serial_fe_space_get_block_layout

! Sets the pointer block_layout member variable
subroutine serial_fe_space_set_block_layout ( this, block_layout )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  type(block_layout_t), target, intent(in)    :: block_layout
  this%block_layout => block_layout
end subroutine serial_fe_space_set_block_layout

! Nullifies the pointer block_layout member variable
subroutine serial_fe_space_nullify_block_layout ( this )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  nullify(this%block_layout)
end subroutine serial_fe_space_nullify_block_layout


subroutine serial_fe_space_create_fe_iterator ( this, fe )
  implicit none
  class(serial_fe_space_t)         , intent(in)  :: this
  class(fe_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_iterator(fe)
  allocate(fe_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine serial_fe_space_create_fe_iterator

subroutine serial_fe_space_free_fe_iterator ( this, fe )
  implicit none
  class(serial_fe_space_t)         , intent(in)  :: this
  class(fe_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  if(allocated(fe)) then
     call fe%free()
     deallocate(fe, stat=istat); check(istat==0)
  end if
end subroutine serial_fe_space_free_fe_iterator

subroutine serial_fe_space_create_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  type(vef_iterator_t) :: vef
  call fe_vef%free()
  call fe_vef%create(this,vef)
end subroutine serial_fe_space_create_fe_vef_iterator

subroutine serial_fe_space_create_itfc_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  type(itfc_vef_iterator_t) :: vef
  call fe_vef%free()
  call fe_vef%create(this,vef)
end subroutine serial_fe_space_create_itfc_fe_vef_iterator

subroutine serial_fe_space_create_fe_face_iterator ( this, fe_face )
  implicit none
  class(serial_fe_space_t) , target, intent(in)    :: this
  type(fe_face_iterator_t)         , intent(inout) :: fe_face
  type(face_iterator_t) :: vef
  integer(ip) :: istat
  call fe_face%free()
  call fe_face%create(this,vef)
end subroutine serial_fe_space_create_fe_face_iterator

subroutine serial_fe_space_free_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_vef_iterator_t), intent(inout) :: fe_vef
  call fe_vef%free()
end subroutine serial_fe_space_free_fe_vef_iterator



