! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine serial_fe_space_create_same_reference_fes_on_all_cells( this,          &
                                                                   triangulation, &
                                                                   reference_fes, &
                                                                   conditions )
  implicit none
  class(serial_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t)            , target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  class(conditions_t)       , target, optional, intent(in)    :: conditions

  integer(ip) :: i, istat, jfield, ifield

  call this%free()

  call this%set_triangulation(triangulation)  
  call this%set_num_fields(size(reference_fes))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_field_cell_to_ref_fes()
  call this%fill_field_cell_to_ref_fes_same_on_all_cells()
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_x_field()
  call this%fill_facet_gids()
  call this%allocate_and_init_ptr_lst_dofs_gids()
  
  if ( present(conditions) ) call this%set_conditions(conditions)
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%set_up_strong_dirichlet_bcs()
  
end subroutine serial_fe_space_create_same_reference_fes_on_all_cells

subroutine serial_fe_space_create_different_ref_fes_between_cells( this,                     &
                                                           triangulation,            &
                                                           reference_fes,            &
                                                           set_ids_to_reference_fes, &
                                                           conditions )
  implicit none
  class(serial_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t)    , target          , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t)       , target, optional, intent(in)    :: conditions
  
  call this%free()
  
  call this%set_triangulation(triangulation)  
  call this%set_num_fields(size(set_ids_to_reference_fes,1))
  call this%allocate_and_fill_reference_fes(reference_fes)
  call this%allocate_field_cell_to_ref_fes()
  call this%fill_field_cell_to_ref_fes_different_ref_fes_between_cells(set_ids_to_reference_fes)
  call this%check_cell_vs_fe_topology_consistency()
  call this%allocate_and_fill_fe_space_type_x_field()
  call this%fill_facet_gids()
  call this%allocate_and_init_ptr_lst_dofs_gids()
  
  if ( present(conditions) ) call this%set_conditions(conditions)
  call this%allocate_and_init_at_strong_dirichlet_bound()
  call this%allocate_and_init_has_fixed_dofs()
  call this%set_up_strong_dirichlet_bcs()
  
end subroutine serial_fe_space_create_different_ref_fes_between_cells

subroutine serial_fe_space_free (this)
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  call this%free_reference_fes()
  call this%free_field_cell_to_ref_fes()
  call this%free_fe_space_type_x_field()
  call this%free_facet_gids()
  call this%free_ptr_lst_dofs()
  call this%free_at_strong_dirichlet_boundary()
  call this%free_has_fixed_dofs()
  nullify(this%conditions)
  this%num_fixed_dofs = 0
  if (allocated(this%num_dofs_x_field)) call memfree( this%num_dofs_x_field, __FILE__, __LINE__ )
  call this%free_fe_integration()
  call this%free_facet_integration()
  nullify(this%block_layout)
end subroutine serial_fe_space_free

subroutine serial_fe_space_print ( this )
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t), allocatable         :: fe_dofs(:)
  integer(ip)                      :: field_id, istat

  if (allocated(this%num_dofs_x_field)) write(*,'(a,i10,a)') '********* num_dofs_x_field ',this%num_dofs_x_field,'********'

  allocate ( fe_dofs(this%get_num_fields()), stat=istat)
  check(istat==0)

  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     write(*,'(a,i10,a)') '********* ELEMENT: ',fe%get_gid(),'********'
     write(*,'(a)') '********* ELEMENT 2 DOF********'
     call fe%get_fe_dofs(fe_dofs)
     do field_id = 1, fe%get_num_fields()
        write(*,'(a,i10,a)') '********* FIELD: ',field_id,'********'
        write(*,'(10i10)') fe_dofs(field_id)%p
     end do
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)

  deallocate ( fe_dofs, stat=istat)
  check(istat==0)
end subroutine serial_fe_space_print


subroutine serial_fe_space_allocate_and_fill_fe_space_type_x_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: field_id
  class(reference_fe_t), pointer ::reference_fe

  call memalloc ( this%num_fields, this%fe_space_type_x_field, __FILE__, __LINE__ )

  call this%create_fe_cell_iterator(fe)
  do field_id=1, this%get_num_fields()
     this%fe_space_type_x_field(field_id) = fe%get_fe_space_type(field_id)
  end do

#ifdef DEBUG  
  call fe%next()
  do while ( .not. fe%has_finished())
     do field_id=1, this%get_num_fields()
        assert ( this%fe_space_type_x_field(field_id) == fe%get_fe_space_type(field_id)  )
     end do
     call fe%next()
  end do
#endif  
  call this%free_fe_cell_iterator(fe)
end subroutine serial_fe_space_allocate_and_fill_fe_space_type_x_field

subroutine serial_fe_space_free_fe_space_type_x_field(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( allocated(this%fe_space_type_x_field) ) call memfree ( this%fe_space_type_x_field, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_fe_space_type_x_field

subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs_gids(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)                    :: field_id
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe

  call this%free_ptr_lst_dofs()
  
  call memalloc ( this%num_fields, &
       this%triangulation%get_num_cells()+1, &
       this%ptr_dofs_x_fe, __FILE__, __LINE__ )

  this%ptr_dofs_x_fe(1,1) = 1 
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     do field_id=1, fe%get_num_fields()-1
        reference_fe => fe%get_reference_fe(field_id)
        this%ptr_dofs_x_fe(field_id+1,fe%get_gid()) = & 
             this%ptr_dofs_x_fe(field_id,fe%get_gid()) + reference_fe%get_num_shape_functions()
     end do
     reference_fe => fe%get_reference_fe(field_id)
     this%ptr_dofs_x_fe(1,fe%get_gid()+1) = & 
          this%ptr_dofs_x_fe(field_id,fe%get_gid()) + reference_fe%get_num_shape_functions()
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe) 

  call memalloc ( this%ptr_dofs_x_fe(1,this%triangulation%get_num_cells()+1)-1,&
       this%lst_dofs_gids, &
       __FILE__, __LINE__ )
  this%lst_dofs_gids = 0
end subroutine serial_fe_space_allocate_and_init_ptr_lst_dofs_gids

subroutine serial_fe_space_move_alloc_ptr_dofs_x_fe_out ( this, ptr_dofs_x_fe )
  implicit none
  class(serial_fe_space_t)             , intent(inout) :: this
  integer(ip)             , allocatable, intent(inout) :: ptr_dofs_x_fe(:,:)
  assert ( .not. allocated(ptr_dofs_x_fe) )
  if ( allocated(this%ptr_dofs_x_fe) ) then
     call move_alloc( to=ptr_dofs_x_fe, from=this%ptr_dofs_x_fe )
  end if
end subroutine serial_fe_space_move_alloc_ptr_dofs_x_fe_out

subroutine serial_fe_space_move_alloc_lst_dofs_gids_out ( this, lst_dofs_gids )
  implicit none
  class(serial_fe_space_t)             , intent(inout) :: this
  integer(ip)             , allocatable, intent(inout) :: lst_dofs_gids(:)
  assert ( .not. allocated(lst_dofs_gids) )
  if ( allocated(this%lst_dofs_gids) ) then
     call move_alloc( to=lst_dofs_gids, from=this%lst_dofs_gids )
  end if
end subroutine serial_fe_space_move_alloc_lst_dofs_gids_out

subroutine serial_fe_space_free_ptr_lst_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%ptr_dofs_x_fe)) call memfree ( this%ptr_dofs_x_fe, __FILE__, __LINE__ )
  if (allocated(this%lst_dofs_gids)) call memfree ( this%lst_dofs_gids, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_ptr_lst_dofs

subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_at_strong_dirichlet_boundary()
  call memalloc ( this%num_fields, &
       this%triangulation%get_num_cells(), &
       this%at_strong_dirichlet_boundary_x_fe, __FILE__, __LINE__ )
  this%at_strong_dirichlet_boundary_x_fe = .false. 
end subroutine serial_fe_space_allocate_and_init_at_strong_dirichlet_bound

subroutine serial_fe_space_free_at_strong_dirichlet_boundary (this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%at_strong_dirichlet_boundary_x_fe)) then
     call memfree ( this%at_strong_dirichlet_boundary_x_fe, __FILE__, __LINE__ )
  end if
end subroutine serial_fe_space_free_at_strong_dirichlet_boundary

subroutine serial_fe_space_allocate_and_init_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_has_fixed_dofs()
  call memalloc ( this%num_fields, &
       this%triangulation%get_num_cells(), &
       this%has_fixed_dofs_x_fe, __FILE__, __LINE__ )
  this%has_fixed_dofs_x_fe = .false. 
end subroutine serial_fe_space_allocate_and_init_has_fixed_dofs

subroutine serial_fe_space_free_has_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%has_fixed_dofs_x_fe)) then
     call memfree ( this%has_fixed_dofs_x_fe, __FILE__, __LINE__ )
  end if
end subroutine serial_fe_space_free_has_fixed_dofs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip)             :: field_id
  integer(ip)             :: ivef
  integer(ip)             :: component_id
  integer(ip), allocatable :: offset_component_x_field(:)
  integer(ip)             :: istat
  class(fe_cell_iterator_t), allocatable :: fe, source_fe
  type(fe_vef_iterator_t)    :: vef
  class(reference_fe_t), pointer :: reference_fe
  logical              , allocatable :: components_code(:)
  integer(ip), allocatable           :: visited_vef_to_cell_map(:,:)
  integer(ip)                        :: previous_num_dirichlet_dofs
  
  ! Count num_fixed_dofs
  this%num_fixed_dofs = 0
  
  if ( .not. associated(this%conditions) ) then
    return
  end if
  
  ! For every component of every field, we go through all FEs and look for DoFs 
  ! subject to strong Dirichlet BCs. It would be desirable (for efficiency) to 
  ! know a priori which FEs have DoFs which are subject to strong Dirichlet BCs, 
  ! but at the present moment we do not have any way to determine such a thing
  assert ( this%conditions%get_num_components() == this%get_num_components() )
  call memalloc ( this%conditions%get_num_components(), components_code, __FILE__, __LINE__ )

  call memalloc (this%get_num_fields()+1,offset_component_x_field,__FILE__,__LINE__)
  call memalloc ( 2, this%triangulation%get_num_vefs(), visited_vef_to_cell_map,  __FILE__, __LINE__ )

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_vef_iterator(vef)

  ! Precompute the offsets
  offset_component_x_field(1) = 1
  do field_id = 1, this%get_num_fields()
    reference_fe => fe%get_reference_fe(field_id)
    offset_component_x_field(field_id+1) = offset_component_x_field(field_id) + reference_fe%get_num_field_components()
  end do

  do field_id = 1, this%get_num_fields()
    ! Initialize
    visited_vef_to_cell_map = -1

    call fe%first()
    do while (.not. fe%has_finished() )
      if ( fe%is_local() ) then
         do ivef = 1, fe%get_num_vefs()
            call fe%get_vef(ivef, vef)

            ! Check whether a set_id different from 0 has been set for current vef. 
            ! TO-DO: Should we also ask whether current vef is at the boundary?
            !        "0" is a magic number. MUCH BETTER REPLACE by parameter constant.
            if ( vef%get_set_id() /= 0 .and. vef%get_gid() > 0 ) then ! .and. vef%at_boundary()??? )

               ! Get components code corresponding to set_id assigned to current vef
               ! TO-DO: The number of calls to this TBP (virtual) could be reduced by using
               ! a more clever strategy. Does pay off to look carefully at this?
               call this%conditions%get_components_code( vef%get_set_id(), components_code )

               ! Auxiliary function containing the work done at each innermost iteration
               previous_num_dirichlet_dofs = this%num_fixed_dofs
               call this%set_up_strong_dirichlet_bcs_on_vef_and_field(fe,&
                                                                      vef,&
                                                                      ivef,&
                                                                      field_id,&
                                                                      components_code(offset_component_x_field(field_id):&
                                                                                      offset_component_x_field(field_id+1)-1),&
                                                                      visited_vef_to_cell_map,&
                                                                      source_fe)

               if ( visited_vef_to_cell_map(1, vef%get_gid()) == -1 .and. &
                    previous_num_dirichlet_dofs < this%num_fixed_dofs ) then
                  visited_vef_to_cell_map ( 1, vef%get_gid() ) = fe%get_gid()
                  visited_vef_to_cell_map ( 2, vef%get_gid() ) = ivef
               end if
            end if
         end do
      end if

      call fe%next()
    end do ! Loop in FEs
  end do ! Loop in fields
  ! This second sweep over all cells cannot be integrated as part of the first one
  ! as the fe%determine_* TBPs have as a pre-condition that this%strong_dirichlet_values
  ! has at least been created (i.e., that it has at least size already set)
  call fe%first()
  do while (.not. fe%has_finished() )
    if ( fe%is_local() ) then
      do field_id = 1, this%get_num_fields()
         call fe%determine_at_strong_dirichlet_boundary(field_id)
         call fe%determine_has_fixed_dofs(field_id)
      end do
    end if
    call fe%next()
  end do

  call memfree ( visited_vef_to_cell_map,  __FILE__, __LINE__ )
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree (offset_component_x_field,__FILE__,__LINE__)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_vef_iterator(vef)
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs

subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field(this,&
                                                                        fe, &
                                                                        vef, &
                                                                        ivef, &
                                                                        field_id,&
                                                                        components_code,&
                                                                        visited_vef_to_cell_map,&
                                                                        source_fe)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t),     intent(inout) :: fe
  type(fe_vef_iterator_t),  intent(in)    :: vef
  integer(ip),              intent(in)    :: ivef
  integer(ip),              intent(in)    :: field_id
  logical,                  intent(in)    :: components_code(:)
  integer(ip),              intent(inout) :: visited_vef_to_cell_map(:,:)
  class(fe_cell_iterator_t),     intent(inout) :: source_fe

  type(list_iterator_t)           :: own_dofs_on_vef_iterator
  class(reference_fe_t), pointer  :: reference_fe

  ! TO-DO: there is no need to call `get_reference_fe` for each inner loop iteration.
  !        We could use an allocatable array of type(p_reference_fe_t) items, and
  !        allocate/initialize it from the beginning.
  reference_fe => fe%get_reference_fe(field_id)
  assert ( size(components_code) == reference_fe%get_num_field_components() )
  
  select type ( reference_fe )
     class is ( nedelec_reference_fe_t )
     if ( components_code(1) ) then
       if ( visited_vef_to_cell_map(1, vef%get_gid()) == -1 ) then
           call fe%generate_own_dofs_vef ( ivef, &
                                          field_id, &
                                          this%num_fixed_dofs, &
                                          free_dofs_loop=.false.)
       end if
     end if
     class is ( lagrangian_reference_fe_t )
     if ( visited_vef_to_cell_map(1, vef%get_gid()) == -1 ) then
       call fe%generate_own_dofs_vef_component_wise ( ivef, &
                                                     field_id, &
                                                     this%num_fixed_dofs, &
                                                     components_code, &
                                                     free_dofs_loop=.false. )
     end if
  end select
  
  if ( visited_vef_to_cell_map(1, vef%get_gid()) /= -1 ) then
    call source_fe%set_gid(visited_vef_to_cell_map(1,vef%get_gid()))
    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                                                  source_fe, &
                                                  visited_vef_to_cell_map(2,vef%get_gid()), &
                                                  field_id) 
  end if
end subroutine serial_fe_space_set_up_strong_dirichlet_bcs_on_vef_and_field

subroutine serial_fe_space_interpolate_dirichlet_values (this, fe_function, time, fields_to_interpolate)
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  class(fe_function_t)              , intent(inout) :: fe_function
  real(rp)                , optional, intent(in)    :: time
  integer(ip)             , optional, intent(in)    :: fields_to_interpolate(:)

  !  Locals
  integer(ip)                                :: field_id, istat, ifield, jfield
  integer(ip)                                :: icomp, component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: num_components
  integer(ip)                                :: num_fields
  integer(ip)                                :: reference_fe_id
  integer(ip)                                :: num_reference_fes
  integer(ip)                                :: local_within_ref_fe_dof_id
  integer(ip)                                :: local_within_ref_fe_scalar_dof_id
  integer(ip)                                :: strong_dirichlet_dof_id
  integer(ip)                                :: ivef
  real(rp)                                   :: time_(1)
  type(allocatable_array_rp2_t), allocatable :: values(:,:)
  type(cell_map_t)               , allocatable :: cell_maps(:)
  type(p_quadrature_t)         , allocatable :: nodal_quadratures(:)
  type(point_t)                , pointer     :: nodal_coordinates(:)
  type(point_t)                , pointer     :: cell_coordinates(:)
  logical                      , allocatable :: components_code(:)
  logical                      , allocatable :: reference_fes_touched(:)
  integer(ip)                  , allocatable :: fields_to_interpolate_(:)


  class(reference_fe_t)        , pointer     :: reference_fe
  class(scalar_function_t)     , pointer     :: scalar_function
  type(serial_scalar_array_t)  , pointer     :: strong_dirichlet_values

  type(list_iterator_t)    :: own_dofs_on_vef_iterator
  class(fe_cell_iterator_t), allocatable :: fe
  type(fe_vef_iterator_t)     :: vef
  type(i1p_t), allocatable :: fe_dofs(:)

  num_components    = this%get_num_components()
  num_reference_fes = this%get_num_reference_fes()
  num_fields        = this%get_num_fields()

  if ( present(fields_to_interpolate) ) then 
     ! User specifies which fields will be interpolated
     call memalloc ( size(fields_to_interpolate) , fields_to_interpolate_ , __FILE__, __LINE__ ) 
     fields_to_interpolate_ = fields_to_interpolate
  else  
     ! By default, all fields will be interpolated
     call memalloc ( num_fields , fields_to_interpolate_, __FILE__, __LINE__ )  
     do field_id = 1,num_fields 
        fields_to_interpolate_(field_id) = field_id  
     end do
  end if
  
  ! fields_to_interpolate_ consistency check (only in DEBUG mode)
#ifdef DEBUG
  do ifield = 1, size(fields_to_interpolate_) 
    field_id = fields_to_interpolate_(ifield)
    assert ( field_id >= 1 .and. field_id <= num_fields)
    do jfield = ifield+1, size(fields_to_interpolate_)
      assert ( fields_to_interpolate_(ifield) /= fields_to_interpolate_(jfield) )
    end do
  end do
#endif

  ! Build offset components 
  call memalloc( this%get_num_fields(), offset_component, __FILE__, __LINE__ ) 
  offset_component(1) = 0
  do field_id = 2, this%get_num_fields() 
     reference_fe                   => this%get_reference_fe(field_id-1)
     offset_component(field_id)     =  offset_component(field_id-1) + reference_fe%get_num_field_components() 
  end do
  
  assert ( associated(this%conditions) )
  call memalloc ( num_components, components_code, __FILE__, __LINE__ )

  call memalloc ( num_reference_fes, reference_fes_touched, __FILE__, __LINE__ )
  reference_fes_touched = .false.

  allocate(cell_maps(num_reference_fes), stat=istat)
  check(istat==0)
  allocate(nodal_quadratures(num_reference_fes), stat=istat)
  check(istat==0)
  allocate(values(num_components,num_reference_fes), stat=istat)
  check(istat==0)
  allocate ( fe_dofs(num_fields), stat=istat ) 
  check (istat==0)

  strong_dirichlet_values => fe_function%get_fixed_dof_values()
  
  ! IMPORTANT : The following code is implicitly assuming that the
  !             composition of reference FEs, for all cells on top of
  !             the same geometric reference FE, is the same.
  !             This assumption is reasonable provided that this 
  !             FE space has the same assumption whenever we are dealing
  !             with continuous Galerkin FEs.

  if ( present(time) ) time_(1) = time

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then 
        do ifield = 1, size(fields_to_interpolate_) 
           field_id = fields_to_interpolate_(ifield) 
           reference_fe => fe%get_reference_fe(field_id)

           if ( fe%at_strong_dirichlet_boundary(field_id) ) then
              reference_fe_id = this%field_cell_to_ref_fes(field_id, fe%get_gid()) 
              if ( .not. reference_fes_touched(reference_fe_id) ) then
                 reference_fes_touched(reference_fe_id) = .true.
                 nodal_quadratures(reference_fe_id)%p => reference_fe%get_nodal_quadrature()
                 call cell_maps(reference_fe_id)%create(nodal_quadratures(reference_fe_id)%p, & 
                      fe%get_reference_fe_geo())

                 do icomp=1, reference_fe%get_num_field_components()
                    component_id = offset_component(field_id) + icomp
                    call values(component_id,reference_fe_id)%create(nodal_quadratures(reference_fe_id)%p%get_num_quadrature_points(),1) 
                 end do
              end if

              ! TO-DO: This call should ONLY be performed once 
              !        per FE s.t. at least one of its fields
              !        has DoFs subject to BCs.
              call fe%get_fe_dofs(fe_dofs)

              cell_coordinates => cell_maps(reference_fe_id)%get_coordinates()
              call fe%get_nodes_coordinates(cell_coordinates)
              call cell_maps(reference_fe_id)%compute_quadrature_points_coordinates()
              nodal_coordinates => cell_maps(reference_fe_id)%get_quadrature_points_coordinates()

              ! Go over all vefs within current FE
              do ivef = 1, fe%get_num_vefs()
                 call fe%get_vef(ivef, vef)

                 ! Check whether a set_id different from 0 has been set for current vef. 
                 ! TO-DO: Should we also ask whether current vef is at the boundary?
                 !        "0" is a magic number. MUCH BETTER REPLACE by parameter constant.
                 if ( vef%get_set_id() /= 0 ) then ! .and. vef%at_boundary()??? )              

                    ! Get components code corresponding to set_id assigned to current vef
                    ! TO-DO: The number of calls to this TBP (virtual) could be reduced by using
                    ! a more clever strategy. Does it pay off to look carefully at this?
                    call this%conditions%get_components_code( vef%get_set_id(), components_code )

                    do icomp=1, reference_fe%get_num_field_components()
                       component_id = offset_component(field_id) + icomp
                       if (components_code(component_id)) then
                          call this%conditions%get_function( vef%get_set_id(), component_id, scalar_function )
                          assert(associated(scalar_function))
                          ! Evaluate function
                          if(present(time)) then
                             call scalar_function%get_values_set_space_time(nodal_coordinates,time_,values(component_id,reference_fe_id)%a)
                          else
                             call scalar_function%get_values_set_space(nodal_coordinates,values(component_id,reference_fe_id)%a(:,1))
                          end if
                       end if
                    end do

                    own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(ivef)
                    do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() )
                       local_within_ref_fe_dof_id  = own_dofs_on_vef_iterator%get_current()
                       component_id = offset_component(field_id) + reference_fe%get_component_node(local_within_ref_fe_dof_id)
                       if ( components_code(component_id) ) then 
                          ! Check if current node is subject to strong Dirichlet boundary conditions
                          if(fe%is_strong_dirichlet_dof(fe_dofs(field_id)%p(local_within_ref_fe_dof_id))) then
                             local_within_ref_fe_scalar_dof_id = reference_fe%get_scalar_from_vector_node(local_within_ref_fe_dof_id)
                             strong_dirichlet_dof_id = -fe_dofs(field_id)%p(local_within_ref_fe_dof_id)
                             call strong_dirichlet_values%insert(strong_dirichlet_dof_id,values(component_id,field_id)%a(local_within_ref_fe_scalar_dof_id,1))
                          end if
                       end if
                       call own_dofs_on_vef_iterator%next()
                    end do
                 end if
              end do
           end if
        end do
     end if
     call fe%next() 
  end do
  call this%free_fe_cell_iterator(fe) 
  call this%free_fe_vef_iterator(vef)
  
  call memfree ( reference_fes_touched, __FILE__, __LINE__ )
  call memfree ( components_code, __FILE__, __LINE__ )


  do reference_fe_id = 1, num_reference_fes
     call cell_maps(reference_fe_id)%free()
     do component_id = 1, num_components
        call values(component_id, reference_fe_id)%free()
     end do
  end do
  
  call memfree(offset_component, __FILE__, __LINE__) 
  deallocate(fe_dofs, stat=istat ) 
  check (istat==0)
  deallocate(cell_maps, stat=istat)
  check(istat==0)
  deallocate(nodal_quadratures, stat=istat)
  check(istat==0)
  deallocate(values, stat=istat)
  check(istat==0)
  call memfree ( fields_to_interpolate_, __FILE__, __LINE__ ) 
end subroutine serial_fe_space_interpolate_dirichlet_values

function select_default_interpolator_type(reference_fe) 
  implicit none
  class(reference_fe_t), intent(in) :: reference_fe
  character(:), allocatable :: select_default_interpolator_type
  
  select type ( reference_fe )
		class is (nedelec_reference_fe_t ) 
    select_default_interpolator_type = interpolator_type_Hcurl
		class is (lagrangian_reference_fe_t)
    select_default_interpolator_type = interpolator_type_H1  
  class is (void_reference_fe_t)
    check(.false.)
		class DEFAULT
		check(.false.) 
		end select 
end function select_default_interpolator_type 

subroutine serial_fe_space_project_scalar_function (this, function, field_id, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)         , intent(in)    :: this
  class(scalar_function_t)         , intent(in)    :: function 
  integer(ip)                      , intent(in)    :: field_id 
  type(fe_function_t)              , intent(inout) :: fe_function
  character(*)           , optional, intent(in)    :: interpolator_type
  real(rp)               , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer     :: reference_fe 
  class(fe_cell_iterator_t), allocatable :: fe 
  real(rp)                 , allocatable :: dof_values(:)
  class(interpolator_t)    , allocatable :: interpolator
  character(:)             , allocatable :: interpolator_type_
  
  ! Extract reference_fe_t instance associated to field_id on the
  ! first cell of the mesh. TO-DO: what happens if is it void?
  call this%create_fe_cell_iterator(fe)
  reference_fe => fe%get_reference_fe(field_id)
  call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )
		
  ! Process optional arguments
  if ( present(interpolator_type) ) then
    interpolator_type_ = interpolator_type
  else
    interpolator_type_  = select_default_interpolator_type(reference_fe)
  end if
  
  call make_interpolator  (interpolator_type_, reference_fe%get_topology(), interpolator )
  call interpolator%create(this, field_id)
  do while (.not. fe%has_finished() )  
     if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then
        call interpolator%evaluate_scalar_function_moments( fe, function, dof_values, time=time )
        call fe_function%insert_nodal_values(fe, field_id, dof_values)
     end if
     call fe%next()
  end do
  call memfree( dof_values, __FILE__, __LINE__ )
  call this%free_fe_cell_iterator(fe) 
  call interpolator%free() 
end subroutine serial_fe_space_project_scalar_function

subroutine serial_fe_space_project_vector_function (this, function, field_id, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)         , intent(in)    :: this
  class(vector_function_t)         , intent(in)    :: function 
  integer(ip)                      , intent(in)    :: field_id 
  type(fe_function_t)              , intent(inout) :: fe_function
  character(*)           , optional, intent(in)    :: interpolator_type
  real(rp)               , optional, intent(in)    :: time
  
  class(reference_fe_t)    , pointer     :: reference_fe 
  class(fe_cell_iterator_t), allocatable :: fe 
  real(rp)                 , allocatable :: dof_values(:)
  class(interpolator_t)    , allocatable :: interpolator
  character(:)             , allocatable :: interpolator_type_
  
  ! Extract reference_fe_t instance associated to field_id on the
  ! first cell of the mesh. TO-DO: what happens if is it void?
  call this%create_fe_cell_iterator(fe)
  reference_fe => fe%get_reference_fe(field_id)
		call memalloc( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )
  
  ! Process optional arguments
  if ( present(interpolator_type) ) then
    interpolator_type_ = interpolator_type
  else
    interpolator_type_  = select_default_interpolator_type(reference_fe)
  end if
  
  call make_interpolator  (interpolator_type_, reference_fe%get_topology(), interpolator )
  call interpolator%create(this, field_id)
  do while (.not. fe%has_finished() )  
     if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then
        call interpolator%evaluate_vector_function_moments( fe, function, dof_values, time=time )
        call fe_function%insert_nodal_values(fe, field_id, dof_values)
     end if
     call fe%next()
  end do
  call memfree( dof_values, __FILE__, __LINE__ )
  call this%free_fe_cell_iterator(fe) 
  call interpolator%free() 

end subroutine serial_fe_space_project_vector_function

subroutine serial_fe_space_project_Dirichlet_boundary_function (this, fe_function, interpolator_type, time)
  implicit none
  class(serial_fe_space_t)          , intent(in)    :: this
  type(fe_function_t)               , intent(inout) :: fe_function
  character(*)            , optional, intent(in)    :: interpolator_type(:)
  real(rp)                , optional, intent(in)    :: time

  class(reference_fe_t)    , pointer        :: reference_fe 
  class(fe_cell_iterator_t), allocatable    :: fe 
  type(fe_vef_iterator_t)                   :: vef 
  type(list_iterator_t)                     :: own_dofs_on_vef_iterator 	

  integer(ip)                :: field_id 
  integer(ip)                :: icomp, component_id 
  logical     , allocatable  :: components_code(:)
  integer(ip) , allocatable  :: offset_component(:)
  real(rp)                   :: time_(1) 

  type(p_scalar_function_t), allocatable :: function_scalar_components(:)
  real(rp)  , allocatable                :: dof_values(:)  
  integer(ip), pointer                   :: fe_dofs(:)
  real(rp)                   , pointer   :: fixed_dof_values_entries(:)
  integer(ip)                            :: idof, vef_lid, istat
  type(point_t) , pointer           :: coordinates(:)
  type(p_interpolator_t),  allocatable :: interpolators(:) 
  character(:)             , allocatable :: interpolator_type_

  fixed_dof_values_entries => fe_function%fixed_dof_values%get_entries()

  call this%allocate_and_fill_offset_component(offset_component)
  assert(associated(this%conditions) )
  call memalloc ( this%get_num_components(), components_code, __FILE__, __LINE__ )

  allocate ( function_scalar_components(this%triangulation%get_num_dims()), stat=istat); check(istat==0);

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)

  ! Create and initialize interpolator 
  allocate ( interpolators(this%get_num_fields()), stat=istat); check(istat==0)  
  do field_id = 1, this%get_num_fields() 
     reference_fe => fe%get_reference_fe(field_id)
     
     if ( present(interpolator_type) ) then
       interpolator_type_ = interpolator_type(field_id)
     else
       interpolator_type_  = select_default_interpolator_type(reference_fe)
     end if
     
     call make_interpolator( interpolator_type_, reference_fe%get_topology(), interpolators(field_id)%p )  
					call interpolators(field_id)%p%create( this, field_id ) 
  end do

  if ( present(time) ) time_(1) = time 
  do while (.not. fe%has_finished() )     

     do field_id = 1, this%get_num_fields()

        if ( fe%is_local() .and. fe%at_strong_dirichlet_boundary(field_id) ) then 
           reference_fe => fe%get_reference_fe(field_id)					 
           call memalloc ( reference_fe%get_num_shape_functions(), dof_values, __FILE__, __LINE__ )

           call fe%get_field_fe_dofs(field_id,fe_dofs)

           ! Loop over all vefs in FE
           do vef_lid = 1, fe%get_num_vefs() 
              call fe%get_vef(vef_lid, vef)  

              if ( vef%get_set_id() /= 0 ) then 
                 ! Get scalar boundary functions 
                 call this%conditions%get_components_code( vef%get_set_id(), components_code )
                 component_id = offset_component(field_id) + 1
                 if (components_code(component_id)) then

                    ! Retreive the scalar functions corresponding to the components of the function to be projected
                    do icomp=1, reference_fe%get_num_field_components()
                       call this%conditions%get_function(vef%get_set_id(), &
                            component_id+icomp-1, &
                            function_scalar_components(icomp)%p)
                    end do

                    call interpolators(field_id)%p%evaluate_function_scalar_components_moments( fe, &
                                                                                                function_scalar_components, &
                                                                                                dof_values, &
                                                                                                time=time )

                    own_dofs_on_vef_iterator = reference_fe%create_own_dofs_on_n_face_iterator(vef_lid) 
                    do while ( .not. own_dofs_on_vef_iterator%is_upper_bound() ) 
                       idof = own_dofs_on_vef_iterator%get_current()   
                       fixed_dof_values_entries(-fe_dofs(idof)) = dof_values(idof) 
                       call own_dofs_on_vef_iterator%next()  
                    end do
                    call own_dofs_on_vef_iterator%free() 
                 end if
              end if
           end do
           call memfree( dof_values, __FILE__, __LINE__ )
        end if
     end do
     call fe%next()									
  end do

  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef) 

  do field_id = 1, this%get_num_fields() 
     call interpolators(field_id)%p%free() 
  end do
  deallocate( interpolators, stat=istat); check(istat==0) 

  deallocate ( function_scalar_components, stat=istat); check(istat==0);
  call memfree( components_code, __FILE__, __LINE__ ) 
  call memfree (offset_component, __FILE__, __LINE__ )

end subroutine serial_fe_space_project_Dirichlet_boundary_function

subroutine serial_fe_space_project_dirichlet_values_curl_conforming (this, fe_function, time, fields_to_project)
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  class(fe_function_t)              , intent(inout) :: fe_function
  real(rp)                , optional, intent(in)    :: time
  integer(ip)             , optional, intent(in)    :: fields_to_project(:)

  !  Locals
  integer(ip)                  , allocatable :: fields_to_project_(:)  
  integer(ip)                                :: field_id, istat
  integer(ip)                                :: component_id
  integer(ip)                  , allocatable :: offset_component(:)
  integer(ip)                                :: num_components
  logical                      , allocatable :: components_code(:)
  type(serial_scalar_array_t)  , pointer     :: strong_dirichlet_values

  class(reference_fe_t)        , pointer     :: reference_fe

  class(fe_cell_iterator_t)     , allocatable :: fe
  class(fe_facet_iterator_t), allocatable :: fe_face

  type(i1p_t), allocatable :: fe_dofs(:)

  type(sparse_matrix_t)       :: matrix
  type(serial_scalar_array_t) :: rhs
  type(serial_scalar_array_t) :: projected_nodal_values
  integer(ip), allocatable    :: subset2global_dirichlet_dofs(:) 
  integer(ip), allocatable    :: global2subset_dirichlet_dofs(:) 
  integer(ip), allocatable    :: subset_fe_dofs(:) 
#ifdef ENABLE_MKL  
  type(direct_solver_t)           :: direct_solver
#else
  type(iterative_linear_solver_t) :: iterative_linear_solver
#endif
  real(rp), allocatable       :: elmat(:,:)
  real(rp), allocatable       :: elvec(:) 
  integer(ip)                 :: qpoint, n_q_points, ishape, jshape


  type(p_scalar_function_t), allocatable :: function_scalar_components(:)
  real(rp)                 , allocatable :: scalar_function_values(:,:)
  type(vector_field_t)     , allocatable :: vector_function_values(:,:)
  type(vector_field_t)     , allocatable :: shape_values(:,:)

  type(parameterlist_t)  :: parameter_list
  integer(ip)            :: FPLError
  integer                :: iparm(64)
  integer(ip)            :: ifield, jfield, idof, idof_subset, idof_global
  integer(ip)            :: num_subset_strong_dirichlet_dofs

  assert ( associated(this%conditions) )
  call memalloc ( this%get_num_components(), components_code, __FILE__, __LINE__ )

  call this%allocate_and_fill_fields_to_project_(fields_to_project_, &
                                                 fields_to_project)
  
  call this%allocate_and_fill_offset_component(offset_component)
  
  call memalloc ( this%get_max_num_shape_functions(), &
                  this%get_max_num_shape_functions(), &
                  elmat, __FILE__, __LINE__ )

  call memalloc ( this%get_max_num_shape_functions(), &
                  elvec, __FILE__, __LINE__ )

  call memalloc ( this%get_max_num_shape_functions(), subset_fe_dofs, __FILE__, __LINE__ )

  allocate ( vector_function_values(this%get_max_num_facet_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( scalar_function_values(this%get_max_num_facet_quadrature_points(),1), & 
             stat=istat); check(istat==0);

  allocate ( function_scalar_components(this%triangulation%get_num_dims()), & 
             stat=istat); check(istat==0);
  
  allocate( fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);

  num_subset_strong_dirichlet_dofs = this%allocate_and_fill_global2subset_and_inverse(fields_to_project_, &
                                                                                         global2subset_dirichlet_dofs, &
                                                                                         subset2global_dirichlet_dofs)
  
  ! Create linear system 
  call matrix%create(num_rows_and_cols=num_subset_strong_dirichlet_dofs, &
                     symmetric_storage=.true.,       &
                     is_symmetric=.true.,            &
                     sign=SPARSE_MATRIX_SIGN_POSITIVE_DEFINITE )

  call rhs%create_and_allocate(num_subset_strong_dirichlet_dofs) 
  call rhs%init(0.0_rp)

  ! Create data structures
  call projected_nodal_values%create_and_allocate(num_subset_strong_dirichlet_dofs)
  call this%create_fe_facet_iterator(fe_face)
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe_face%has_finished() )
     if ( fe_face%is_at_boundary() ) then
        if ( fe_face%get_set_id() /= 0 ) then
           call fe_face%update_integration() 
           call fe_face%get_cell_around(1,fe)
           call fe%get_fe_dofs(fe_dofs)
           call this%conditions%get_components_code( fe_face%get_set_id(), components_code )

           do ifield = 1, size(fields_to_project_)    
              field_id = fields_to_project_(ifield) 
              component_id = offset_component(field_id) + 1
              if (components_code(component_id)) then
                 
                 call this%get_function_scalar_components(fe_face, &
                                                          fe, &
                                                          field_id, &
                                                          component_id, &
                                                          function_scalar_components)
                 
                 call this%evaluate_vector_function_scalar_components(fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
                 
                 call this%project_curl_conforming_compute_elmat_elvec(fe_face, &
                                                                       fe, &
                                                                       field_id, &
                                                                       vector_function_values, &
                                                                       elmat, &
                                                                       elvec, &
                                                                       shape_values)
              
              
                 ! Consecutive DOF re-numbering for the subset of Dirichlet DOFs to be projected 
                 subset_fe_dofs = 0
                 do idof = 1, size(fe_dofs(field_id)%p)
                    if ( fe%is_strong_dirichlet_dof(fe_dofs(field_id)%p(idof)) ) then 
                        subset_fe_dofs(idof) = global2subset_dirichlet_dofs( -fe_dofs(field_id)%p(idof) )
                    end if
                 end do
                 
                 reference_fe => fe%get_reference_fe(field_id)
                 call matrix%insert(num_rows = reference_fe%get_num_shape_functions(),& 
                                    num_cols = reference_fe%get_num_shape_functions(),& 
                                    ia       = subset_fe_dofs, &
                                    ja       = subset_fe_dofs, &
                                    ioffset  = 0, &
                                    joffset  = 0, & 
                                    val      = elmat)
                 call rhs%add(num_entries = reference_fe%get_num_shape_functions(),& 
                              ia          = subset_fe_dofs, &
                              ioffset     = 0, &
                              val         = elvec)
              end if
           end do
        end if
     end if
     call fe_face%next()
  end do
  call this%free_fe_facet_iterator(fe_face)
  call this%free_fe_cell_iterator(fe)
  call matrix%convert(csr_format)
  				
  call parameter_list%init()
#ifdef ENABLE_MKL
  FPLError = parameter_list%set(key = direct_solver_type                  ,  value = pardiso_mkl)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_matrix_type  ,  value = pardiso_mkl_spd)
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_message_level,  value = 0)
  iparm = 0
  FPLError = FPLError + parameter_list%set(key = pardiso_mkl_iparm,         value = iparm)
  assert(FPLError == 0)

  call direct_solver%set_type_from_pl(parameter_list)
  call direct_solver%set_parameters_from_pl(parameter_list)
  call direct_solver%set_matrix(matrix)
  call direct_solver%numerical_setup()
  call direct_solver%solve(rhs,projected_nodal_values)
  call direct_solver%free()
#else
  FPLError = parameter_list%set(key = ils_rtol, value = 1.0e-12_rp)
  FPLError = FPLError + parameter_list%set(key = ils_output_frequency, value = 30)
  assert(FPLError == 0)
  call iterative_linear_solver%create(this%get_environment())
  call iterative_linear_solver%set_type_from_string(cg_name)
  call iterative_linear_solver%set_parameters_from_pl(parameter_list)
  call iterative_linear_solver%set_operators(matrix, .identity. matrix) 
  call iterative_linear_solver%solve(rhs,projected_nodal_values)
  call iterative_linear_solver%free()
#endif
  call parameter_list%free()

  ! Insert projected nodal values into strong_dirichlet_values array 
  strong_dirichlet_values => fe_function%get_fixed_dof_values()
  call strong_dirichlet_values%insert_subvector(iblock=1, &
                                                size_indices=num_subset_strong_dirichlet_dofs, &
                                                indices=subset2global_dirichlet_dofs,             &
                                                values=projected_nodal_values%get_entries())

  call matrix%free()
  call rhs%free()
  call projected_nodal_values%free()
  call memfree (elmat, __FILE__, __LINE__)
  call memfree (elvec, __FILE__, __LINE__)
  call memfree (offset_component, __FILE__, __LINE__ )
  deallocate ( function_scalar_components, stat=istat); check(istat==0);
  deallocate ( vector_function_values, stat=istat); check(istat==0);
  deallocate ( scalar_function_values, stat=istat); check(istat==0);
  deallocate ( shape_values, stat=istat); check(istat==0);
  call memfree ( components_code, __FILE__, __LINE__ )
  call memfree ( subset2global_dirichlet_dofs, __FILE__, __LINE__ )
  call memfree ( global2subset_dirichlet_dofs, __FILE__, __LINE__ ) 
  call memfree ( fields_to_project_, __FILE__, __LINE__ )
  call memfree ( subset_fe_dofs, __FILE__, __LINE__ )
  deallocate(fe_dofs, stat=istat ); check (istat==0)
end subroutine serial_fe_space_project_dirichlet_values_curl_conforming


subroutine serial_fe_space_allocate_and_fill_fields_to_project_ (this, &
                                                                 fields_to_project_, &
                                                                 fields_to_project)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: fields_to_project_(:)
  integer(ip), optional       , intent(in)    :: fields_to_project(:)
  
  integer(ip) :: ifield, jfield, field_id
  
  if (allocated(fields_to_project_)) call memfree(fields_to_project_,__FILE__,__LINE__)

  if ( present(fields_to_project) ) then 
     ! User specifies which fields will be projected 
     call memalloc ( size(fields_to_project), fields_to_project_, __FILE__, __LINE__ ) 
     fields_to_project_ = fields_to_project
  else  
     ! By default, all fields are projected ( i.e., 1-field case where no subset selection is needed) 
     call memalloc ( this%get_num_fields() , fields_to_project_, __FILE__, __LINE__ )  
     do field_id=1,this%get_num_fields() 
        fields_to_project_(field_id) = field_id
     end do
  end if
  
  ! fields_to_project_ consistency check (only in DEBUG mode)
#ifdef DEBUG
  do ifield = 1, size(fields_to_project_) 
    field_id = fields_to_project_(ifield)
    assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
    do jfield = ifield+1, size(fields_to_project_)
      assert ( fields_to_project_(ifield) /= fields_to_project_(jfield) )
    end do
  end do
#endif  
  
end subroutine serial_fe_space_allocate_and_fill_fields_to_project_

subroutine serial_fe_space_allocate_and_fill_offset_component(this, offset_component)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip), allocatable    , intent(inout) :: offset_component(:)
  integer(ip) :: field_id
  class(reference_fe_t), pointer :: reference_fe
  if (allocated(offset_component)) call memfree(offset_component, __FILE__, __LINE__ )
  ! Build offset components 
  call memalloc( this%get_num_fields(), offset_component, __FILE__, __LINE__ ) 
  offset_component(1) = 0
  do field_id = 2, this%get_num_fields() 
     reference_fe                   => this%get_reference_fe(field_id-1)
     offset_component(field_id)     =  offset_component(field_id-1) + reference_fe%get_num_field_components() 
  end do
end subroutine serial_fe_space_allocate_and_fill_offset_component

! Returns the sum of those DoFs subject to strong Dirichlet boundary conditions
! associated to the fields enumerated in the fields_to_project(:) dummy argument
function serial_fe_space_allocate_and_fill_global2subset_and_inverse(this,              &
                                                                     fields_to_project, &
                                                                     global2subset,     &
                                                                     subset2global) result(num_subset_strong_dirichlet_dofs)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  integer(ip)                 , intent(in)    :: fields_to_project(:)
  integer(ip), allocatable    , intent(inout) :: global2subset(:)                 
  integer(ip), allocatable    , intent(inout) :: subset2global(:)
  integer(ip)                                 :: num_subset_strong_dirichlet_dofs

  integer(ip)              :: ifield, field_id, idof, idof_subset, idof_global
  integer(ip)              :: istat
  class(fe_cell_iterator_t), allocatable :: fe
  type(i1p_t), allocatable :: fe_dofs(:)


  if (allocated(global2subset)) call memfree(global2subset,__FILE__,__LINE__)
  if (allocated(subset2global)) call memfree(subset2global,__FILE__,__LINE__)
  
  allocate( fe_dofs(this%get_num_fields()), stat=istat); check(istat==0);
  call memalloc ( this%num_fixed_dofs, global2subset, __FILE__, __LINE__ ) 
  global2subset=0

  ! Count number of Dirichlet DOFs to be projected
  num_subset_strong_dirichlet_dofs = 0
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        do ifield = 1, size(fields_to_project) 
           field_id = fields_to_project(ifield) 
           if ( fe%at_strong_dirichlet_boundary(field_id) ) then 
              call fe%get_fe_dofs(fe_dofs)
              do idof = 1,size(fe_dofs(field_id)%p)
                 if ( fe%is_strong_dirichlet_dof(fe_dofs(field_id)%p(idof)) ) then 
                    if (global2subset(-fe_dofs(field_id)%p(idof))==0) then 
                       num_subset_strong_dirichlet_dofs = num_subset_strong_dirichlet_dofs + 1
                       global2subset(-fe_dofs(field_id)%p(idof)) = num_subset_strong_dirichlet_dofs 
                    end if
                 end if
              end do
           end if
        end do
     end if
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
  ! Allocate + compute subset2global_dirichlet_dofs from subset2global_dirichlet_dofs
  call memalloc ( num_subset_strong_dirichlet_dofs, subset2global, __FILE__, __LINE__ ) 

  idof_subset=1
  do idof_global=1, this%num_fixed_dofs
     if (global2subset(idof_global) /= 0) then
        subset2global(global2subset(idof_global)) = idof_global
     end if
  end do  
  deallocate(fe_dofs, stat=istat ); check (istat==0)
end function serial_fe_space_allocate_and_fill_global2subset_and_inverse

subroutine serial_fe_space_get_function_scalar_components ( this, &
                                                            fe_face, &
                                                            fe, &
                                                            field_id, &
                                                            component_id, &
                                                            function_scalar_components )
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  class(fe_facet_iterator_t)   , intent(in)    :: fe_face
  class(fe_cell_iterator_t)        , intent(inout) :: fe
  integer(ip)                 , intent(in)    :: field_id
  integer(ip)                 , intent(in)    :: component_id
  type(p_scalar_function_t)   , intent(inout) :: function_scalar_components(:)
  
  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  
  assert ( reference_fe%get_num_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  assert ( component_id >= 1 .and. component_id <= this%conditions%get_num_components() )
  
  ! Retreive the scalar functions corresponding to the components of the function to be projected
  do icomp=1, reference_fe%get_num_field_components()
       call this%conditions%get_function(fe_face%get_set_id(), &
                                         component_id+icomp-1, &
                                         function_scalar_components(icomp)%p)
  end do
end subroutine serial_fe_space_get_function_scalar_components

subroutine serial_fe_space_evaluate_vector_function_scalar_components(this, &
                                                                      fe_face, &
                                                                      fe, &
                                                                      field_id, &
                                                                      function_scalar_components, &
                                                                      scalar_function_values, &
                                                                      vector_function_values, &
                                                                      time)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  class(fe_facet_iterator_t), intent(inout) :: fe_face
  class(fe_cell_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(p_scalar_function_t), intent(in)    :: function_scalar_components(:)
  real(rp)                 , intent(inout) :: scalar_function_values(:,:) ! Work-space
  type(vector_field_t)     , intent(inout) :: vector_function_values(:,:)
  real(rp), optional       , intent(in)    :: time

  ! Locals
  integer(ip)                    :: icomp
  class(reference_fe_t), pointer :: reference_fe
  type(quadrature_t)   , pointer :: quadrature
  type(point_t)        , pointer :: quad_coords(:)
                   
  real(rp)                       :: time_(1)
  integer(ip)                    :: qpoint, n_q_points
  
  call fe_face%get_cell_around(1,fe)
  reference_fe => fe%get_reference_fe(field_id)
  quad_coords  => fe_face%get_quadrature_points_coordinates()
  
  assert ( reference_fe%get_num_field_components() <= size(function_scalar_components) )
  assert ( field_id >= 1 .and. field_id <= this%get_num_fields() )
  
  if ( present(time) ) time_(1) = time
  
  quadrature   => fe_face%get_quadrature()
  n_q_points   = quadrature%get_num_quadrature_points()
  
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! reference_fe MUST BE a vector-valued FE
     assert (.false.)
  case ( field_type_vector )
     do icomp=1, reference_fe%get_num_field_components()
        if(present(time)) then
           call function_scalar_components(icomp)%p%get_values_set_space_time(quad_coords,time_,scalar_function_values(1:n_q_points,:))
        else
           call function_scalar_components(icomp)%p%get_values_set_space(quad_coords,scalar_function_values(1:n_q_points,1))
        end if
        do qpoint = 1, n_q_points
           call vector_function_values(qpoint,1)%set(icomp,scalar_function_values(qpoint,1))
        end do
     end do
  case ( field_type_tensor )
     ! reference_fe MUST BE a vector-valued FE
     assert(.false.)
  end select
end subroutine serial_fe_space_evaluate_vector_function_scalar_components

subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec ( this, &
                                                                         fe_face, & 
                                                                         fe, &
                                                                         field_id, &
                                                                         vector_function_values, &
                                                                         elmat, &
                                                                         elvec, &
                                                                         shape_values)
  implicit none
  class(serial_fe_space_t) , intent(in)    :: this
  class(fe_facet_iterator_t), intent(inout) :: fe_face
  class(fe_cell_iterator_t)     , intent(inout) :: fe
  integer(ip)              , intent(in)    :: field_id
  type(vector_field_t)     , intent(in)    :: vector_function_values(:,:)
  real(rp)                 , intent(inout) :: elmat(:,:)
  real(rp)                 , intent(inout) :: elvec(:)
  type(vector_field_t), allocatable, intent(inout) :: shape_values(:,:)

  ! Locals
  class(reference_fe_t)  , pointer :: reference_fe
  type(quadrature_t)     , pointer :: quadrature
  integer(ip)                      :: qpoint, n_q_points
  integer(ip)                      :: ishape, jshape
  real(rp)                         :: factor
  type(vector_field_t) :: normals(2)
  type(vector_field_t) :: vector_shape_test, vector_shape_trial
  
  call fe_face%get_cell_around(1,fe)
  reference_fe      => fe%get_reference_fe(field_id)
  quadrature        => fe_face%get_quadrature()  
  n_q_points        = quadrature%get_num_quadrature_points()
  select case(reference_fe%get_field_type())
  case ( field_type_scalar )
     ! Curl-conforming projection does not make sense with scalar-valued fields
     assert(.false.)
  case ( field_type_vector )
     elmat = 0.0_rp
     elvec = 0.0_rp
     call fe_face%get_values(1,shape_values)
     do qpoint = 1, n_q_points
     call fe_face%get_normals(qpoint, normals)
        factor = fe_face%get_det_jacobian(qpoint) * quadrature%get_weight(qpoint)
        
        do ishape = 1, reference_fe%get_num_shape_functions() 
           do jshape = 1, reference_fe%get_num_shape_functions()
              elmat(ishape,jshape) = elmat(ishape,jshape) + cross_product(shape_values(ishape,qpoint),normals(1))*cross_product(shape_values(jshape,qpoint),normals(1))*factor
           end do
           elvec(ishape) = elvec(ishape) + cross_product(vector_function_values(qpoint,1),normals(1))*cross_product(shape_values(ishape,qpoint),normals(1))*factor
        end do
     end do
  case ( field_type_tensor )
     ! Curl-conforming projection does not make sense with tensor-valued fields
     assert(.false.)
  end select
end subroutine serial_fe_space_project_curl_conforming_compute_elmat_elvec


  subroutine serial_fe_space_interpolate_scalar( this, &
                                                 field_id, &
                                                 function, &
                                                 fe_function, &
                                                 time )
                                                           
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: field_id
  class(scalar_function_t), intent(in)    :: function
  class(fe_function_t)    , intent(inout) :: fe_function
  real(rp)   , optional   , intent(in)    :: time
  
  logical       , allocatable    :: cell_maps_created(:)
  type(cell_map_t), allocatable    :: cell_maps(:)
  
  integer(ip)                    :: reference_fe_id
  integer(ip)                    :: num_nodes
  class(reference_fe_t), pointer :: reference_fe
 
  integer(ip)                    :: n_nodal_q_points
  type(quadrature_t), pointer    :: nodal_quadrature
  integer(ip)                    :: block_id
  
  class(fe_cell_iterator_t), allocatable :: fe
  type(point_t)        , pointer :: nodal_coordinates(:)
  type(point_t)        , pointer :: cell_coordinates(:)
  real(rp), allocatable          :: fe_function_values(:,:)
  real(rp), allocatable          :: nodal_values(:)
  real(rp)                       :: time_(1)
  type(i1p_t)      , allocatable :: fe_dofs(:)
  integer(ip)      , pointer     :: field_blocks(:)
  integer(ip)                    :: i, istat
  class(environment_t), pointer  :: environment
  
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then
  
  if ( present(time) ) time_(1) = time
  
  allocate ( fe_dofs(this%get_num_fields()), stat=istat)
  check(istat==0)
  
  allocate(cell_maps(this%get_num_reference_fes()), stat=istat)
  check(istat==0)
  
  call memalloc(this%get_num_reference_fes(), cell_maps_created, __FILE__, __LINE__)
  cell_maps_created = .false.
  
  call memalloc(this%get_max_num_nodal_quadrature_points(), 1, fe_function_values, __FILE__, __LINE__ )
  
  call memalloc(this%get_max_num_shape_functions(), nodal_values, __FILE__, __LINE__ )
  
  field_blocks => this%get_field_blocks()
  block_id = field_blocks(field_id)
  
  call this%create_fe_cell_iterator(fe)
  
  ! Loop over the elements
  do while ( .not. fe%has_finished())
  
     if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then
     
       ! Create FE_MAP for current cell + field_id if we didn't
       reference_fe_id = fe%get_reference_fe_id(field_id)
       reference_fe     => fe%get_reference_fe(field_id)
       nodal_quadrature => reference_fe%get_nodal_quadrature()
       if ( .not. cell_maps_created(reference_fe_id) ) then
         call cell_maps(reference_fe_id)%create(nodal_quadrature,fe%get_reference_fe_geo())
         cell_maps_created(reference_fe_id) = .true.
       end if
       
       ! Map reference_fe nodal coordinates to actual domain 
       cell_coordinates => cell_maps(reference_fe_id)%get_coordinates()
       call fe%get_nodes_coordinates(cell_coordinates)
       call cell_maps(reference_fe_id)%compute_quadrature_points_coordinates()
       nodal_coordinates => cell_maps(reference_fe_id)%get_quadrature_points_coordinates()
       
       n_nodal_q_points = nodal_quadrature%get_num_quadrature_points()
      
       ! Evaluate scalar function
       if(present(time)) then
         call function%get_values_set_space_time(nodal_coordinates, &
                                                        time_, &
                                                        fe_function_values(1:n_nodal_q_points,1:1))
       else
         call function%get_values_set_space(nodal_coordinates, &
                                            fe_function_values(1:n_nodal_q_points,1))
       end if
       
       call fe%get_fe_dofs(fe_dofs)
       num_nodes = reference_fe%get_num_shape_functions()
       nodal_values(1:num_nodes) = fe_function_values(1:num_nodes,1)
       
       ! Update interior DoFs
       call fe_function%free_dof_values%insert_subvector(block_id, &
                                             num_nodes, &
                                             fe_dofs(field_id)%p, &
                                             nodal_values(1:num_nodes))
       
       ! Update DoFs subject to strong Dirichlet BCs
       if ( fe%at_strong_dirichlet_boundary(field_id) ) then
           fe_dofs(field_id)%p = -fe_dofs(field_id)%p
           call fe_function%fixed_dof_values%insert_subvector(1, &
                                                              num_nodes, &
                                                              fe_dofs(field_id)%p, &
                                                              nodal_values(1:num_nodes))
           fe_dofs(field_id)%p = -fe_dofs(field_id)%p
       end if
     end if
     
     ! Go to next FE
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)

  do i=1, size(cell_maps)
    call cell_maps(i)%free()
  end do
  deallocate(cell_maps, stat=istat)
  check(istat==0)
  
  deallocate (fe_dofs, stat=istat)
  check(istat==0)
  
  call memfree(cell_maps_created, __FILE__, __LINE__)
  call memfree(fe_function_values, __FILE__, __LINE__ )
  call memfree(nodal_values, __FILE__, __LINE__ )
  
  end if
end subroutine serial_fe_space_interpolate_scalar

subroutine serial_fe_space_interpolate_vector( this, &
                                               field_id, &
                                               function, &
                                               fe_function, &
                                               time )
                                                           
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: field_id
  class(vector_function_t), intent(in)    :: function
  class(fe_function_t)    , intent(inout) :: fe_function
  real(rp)   , optional   , intent(in)    :: time
  
  logical       , allocatable    :: cell_maps_created(:)
  type(cell_map_t), allocatable    :: cell_maps(:)
  
  integer(ip)                    :: reference_fe_id
  integer(ip)                    :: num_nodes
  integer(ip)                    :: inode, inode_scalar, icomp
  class(reference_fe_t), pointer :: reference_fe
 
  integer(ip)                    :: n_nodal_q_points
  type(quadrature_t), pointer    :: nodal_quadrature
  integer(ip)                    :: block_id
  
  class(fe_cell_iterator_t), allocatable :: fe
  type(point_t)        , pointer :: nodal_coordinates(:)
  type(point_t)        , pointer :: cell_coordinates(:)
  type(vector_field_t) , allocatable :: fe_function_values(:,:)
  real(rp), allocatable          :: nodal_values(:)
  real(rp)                       :: time_(1)
  type(i1p_t)      , allocatable :: fe_dofs(:)
  integer(ip)      , pointer     :: field_blocks(:)
  integer(ip)                    :: i, istat
  
    class(environment_t), pointer  :: environment
  
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then

  if ( present(time) ) time_(1) = time
  
  allocate ( fe_dofs(this%get_num_fields()), stat=istat)
  check(istat==0)
  
  allocate(cell_maps(this%get_num_reference_fes()), stat=istat)
  check(istat==0)
  
  call memalloc(this%get_num_reference_fes(), cell_maps_created, __FILE__, __LINE__)
  cell_maps_created = .false.
  
  allocate ( fe_function_values(this%get_max_num_nodal_quadrature_points(), 1), stat=istat)
  check(istat==0)
  
  call memalloc(this%get_max_num_shape_functions(), nodal_values, __FILE__, __LINE__ )
  
  field_blocks => this%get_field_blocks()
  block_id = field_blocks(field_id)
  
  call this%create_fe_cell_iterator(fe)
  
  ! Loop over the elements
  do while ( .not. fe%has_finished())

     if ( fe%is_local() .and. .not. fe%is_void(field_id) ) then
     
       ! Create FE_MAP for current cell + field_id if we didn't
       reference_fe_id = fe%get_reference_fe_id(field_id)
       reference_fe     => fe%get_reference_fe(field_id)
       nodal_quadrature => reference_fe%get_nodal_quadrature()
       if ( .not. cell_maps_created(reference_fe_id) ) then
         call cell_maps(reference_fe_id)%create(nodal_quadrature,fe%get_reference_fe_geo())
         cell_maps_created(reference_fe_id) = .true.
       end if
       
       ! Map reference_fe nodal coordinates to actual domain 
       cell_coordinates => cell_maps(reference_fe_id)%get_coordinates()
       call fe%get_nodes_coordinates(cell_coordinates)
       call cell_maps(reference_fe_id)%compute_quadrature_points_coordinates()
       nodal_coordinates => cell_maps(reference_fe_id)%get_quadrature_points_coordinates()
       
       n_nodal_q_points = nodal_quadrature%get_num_quadrature_points()
      
       ! Evaluate scalar function
       if(present(time)) then
         call function%get_values_set_space_time(nodal_coordinates, &
                                                 time_, &
                                                 fe_function_values(1:n_nodal_q_points,1:1))
       else
         call function%get_values_set_space(nodal_coordinates, &
                                                   fe_function_values(1:n_nodal_q_points,1))
       end if
       
       call fe%get_fe_dofs(fe_dofs)
       num_nodes = reference_fe%get_num_shape_functions()
       
       ! Fill nodal_values from fe_function_values
       do inode=1, num_nodes
          icomp        = reference_fe%get_component_node(inode) 
          inode_scalar = reference_fe%get_scalar_from_vector_node(inode)
          nodal_values(inode) = fe_function_values(inode_scalar,1)%get(icomp)
       end do   
       
       ! Update interior DoFs
       call fe_function%free_dof_values%insert_subvector(block_id, &
                                                    num_nodes, &
                                                    fe_dofs(field_id)%p, &
                                                    nodal_values(1:num_nodes))
       
       ! Update DoFs subject to strong Dirichlet BCs
       if ( fe%at_strong_dirichlet_boundary(field_id) ) then
           fe_dofs(field_id)%p = -fe_dofs(field_id)%p
           call fe_function%fixed_dof_values%insert_subvector(1, &
                                                              num_nodes, &
                                                              fe_dofs(field_id)%p, &
                                                              nodal_values(1:num_nodes))
           fe_dofs(field_id)%p = -fe_dofs(field_id)%p
       end if
     end if
     
     
     ! Go to next FE
     call fe%next()
  end do   
  call this%free_fe_cell_iterator(fe)

  do i=1, size(cell_maps)
    call cell_maps(i)%free()
  end do
  deallocate(cell_maps, stat=istat)
  check(istat==0)
  
  deallocate (fe_dofs, stat=istat)
  check(istat==0)
  
  call memfree(cell_maps_created, __FILE__, __LINE__)
  deallocate ( fe_function_values, stat=istat)
  check(istat==0)  
  call memfree(nodal_values, __FILE__, __LINE__ )
  end if
end subroutine serial_fe_space_interpolate_vector

subroutine serial_fe_space_interpolate_tensor( this, &
                                               field_id, &
                                               function, &
                                               fe_function, &
                                               time )            
  implicit none
  
  class(serial_fe_space_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: field_id
  class(tensor_function_t), intent(in)    :: function
  class(fe_function_t)    , intent(inout) :: fe_function
  real(rp)   , optional   , intent(in)    :: time   
  ! Not implemented yet
  check(.false.)
end subroutine serial_fe_space_interpolate_tensor

subroutine serial_fe_space_allocate_and_fill_reference_fes ( this, reference_fes )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  type(p_reference_fe_t)                ,  intent(in)   :: reference_fes(:)
  integer(ip) :: i, istat

  this%reference_fes_size = size(reference_fes)
  allocate( this%reference_fes(this%reference_fes_size), stat=istat )
  check ( istat == 0 )

  do i  = 1, this%reference_fes_size
     this%reference_fes(i) = reference_fes(i)
  end do
end subroutine serial_fe_space_allocate_and_fill_reference_fes

subroutine serial_fe_space_free_reference_fes ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this
  integer(ip) :: istat
  this%reference_fes_size = 0
  if (allocated(this%reference_fes)) then
     deallocate( this%reference_fes, stat=istat )
     check ( istat == 0 )
  end if
end subroutine serial_fe_space_free_reference_fes

subroutine serial_fe_space_allocate_field_cell_to_ref_fes ( this )
  class(serial_fe_space_t), intent(inout) :: this
  call memalloc (this%num_fields, &
       this%triangulation%get_num_cells(), &
       this%field_cell_to_ref_fes, &
       __FILE__, __LINE__)
end subroutine serial_fe_space_allocate_field_cell_to_ref_fes

subroutine serial_fe_space_move_alloc_field_cell_to_ref_fes ( this, field_cell_to_ref_fes )
  implicit none
  class(serial_fe_space_t)             , intent(inout) :: this
  integer(ip)             , allocatable, intent(inout) :: field_cell_to_ref_fes(:,:)
  assert ( .not. allocated(field_cell_to_ref_fes) )
  if ( allocated(this%field_cell_to_ref_fes) ) then
     call move_alloc( to=field_cell_to_ref_fes, from=this%field_cell_to_ref_fes )
  end if
end subroutine serial_fe_space_move_alloc_field_cell_to_ref_fes

subroutine serial_fe_space_free_field_cell_to_ref_fes ( this )
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%field_cell_to_ref_fes)) then
     call memfree (this%field_cell_to_ref_fes, &
          __FILE__, __LINE__)
  end if
end subroutine serial_fe_space_free_field_cell_to_ref_fes

subroutine serial_fe_space_fill_field_cell_to_ref_fes_same_on_all_cells ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this

  integer(ip) :: ifield
  integer(ip) :: ife

  do ife=1, this%triangulation%get_num_cells()
     do ifield=1, this%num_fields
        this%field_cell_to_ref_fes(ifield,ife) = ifield
     end do
  end do

end subroutine serial_fe_space_fill_field_cell_to_ref_fes_same_on_all_cells

subroutine sfes_fill_field_cell_to_ref_fes_different_ref_fes_between_cells ( this, set_ids_to_reference_fes )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: set_ids_to_reference_fes(:,:)

  integer(ip) :: ifield
  class(cell_iterator_t),allocatable :: cell

  call this%triangulation%create_cell_iterator(cell)
  do while (.not. cell%has_finished())
    do ifield=1, this%num_fields
      this%field_cell_to_ref_fes(ifield,cell%get_gid()) = set_ids_to_reference_fes(ifield,cell%get_set_id())
    end do
    call cell%next()
  end do
  call this%triangulation%free_cell_iterator(cell)

end subroutine sfes_fill_field_cell_to_ref_fes_different_ref_fes_between_cells

subroutine serial_fe_space_check_cell_vs_fe_topology_consistency(this)
  implicit none
  class(serial_fe_space_t)          , intent(in) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe_unkno
  class(reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: field_id

#ifdef DEBUG
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     reference_fe_geo => fe%get_reference_fe_geo()
     do field_id = 1, fe%get_num_fields()  
        reference_fe_unkno => fe%get_reference_fe(field_id)
        assert ( reference_fe_unkno%get_topology() == reference_fe_geo%get_topology() )
     end do
     call fe%next()
  end do
  call fe%free()
#endif

end subroutine serial_fe_space_check_cell_vs_fe_topology_consistency

subroutine serial_fe_space_allocate_cell_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_cell_quadratures_degree()
  call memalloc ( this%triangulation%get_num_cells(), this%cell_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_cell_quadratures_degree 

subroutine serial_fe_space_clear_cell_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  assert ( allocated(this%cell_quadratures_degree) )
  this%cell_quadratures_degree = fe_space_default_quadrature_degree_flag
end subroutine serial_fe_space_clear_cell_quadratures_degree

subroutine serial_fe_space_free_cell_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%cell_quadratures_degree)) call memfree ( this%cell_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_cell_quadratures_degree

subroutine serial_fe_space_allocate_max_order_reference_fe_id_x_cell ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_max_order_reference_fe_id_x_cell()
  call memalloc ( this%triangulation%get_num_cells(), this%max_order_reference_fe_id_x_cell, __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_max_order_reference_fe_id_x_cell 

subroutine serial_fe_space_free_max_order_reference_fe_id_x_cell ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%max_order_reference_fe_id_x_cell)) call memfree ( this%max_order_reference_fe_id_x_cell, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_max_order_reference_fe_id_x_cell 

subroutine serial_fe_space_compute_max_order_reference_fe_id_x_cell ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip) :: max_order, max_order_reference_fe_id_within_fe
  integer(ip) :: field_id
  
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     max_order = -1
     do field_id=1, this%get_num_fields()
        if ( max_order <= fe%get_max_order_single_field(field_id) ) then
           max_order = fe%get_max_order_single_field(field_id)
           max_order_reference_fe_id_within_fe = fe%get_reference_fe_id(field_id)
        end if
     end do
     this%max_order_reference_fe_id_x_cell(fe%get_gid()) = max_order_reference_fe_id_within_fe
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe) 
end subroutine serial_fe_space_compute_max_order_reference_fe_id_x_cell 

subroutine serial_fe_space_set_up_cell_integration ( this )
  implicit none
  class(serial_fe_space_t)          , intent(inout) :: this

  class(fe_cell_iterator_t), allocatable :: fe
  integer(ip)         :: current_quadrature_and_map
  integer(ip)         :: current_cell_integrator

  integer(ip)         :: field_id
  integer(ip)         :: max_order, max_order_reference_fe_id_within_fe
  integer(ip)         :: cell_quadrature_and_map_key
  integer(ip)         :: cell_integrators_position_key
  integer(ip)         :: istat
  type(quadrature_t), pointer :: quadrature

  class(reference_fe_t), pointer :: reference_fe

  call this%free_fe_integration()
  
  call this%allocate_max_order_reference_fe_id_x_cell()
  call this%compute_max_order_reference_fe_id_x_cell()
  
  ! Determine the size of cell_quadratures, cell_maps, and cell_integrators 
  ! while filling the corresponding hash tables
  call this%cell_quadratures_and_maps_position%init()
  call this%cell_integrators_position%init()
  current_quadrature_and_map = 1
  current_cell_integrator  = 1
  
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     cell_quadrature_and_map_key = this%generate_cell_quadratures_position_key(fe%get_reference_fe_geo_id(),&
                                                                           fe%get_quadrature_degree())

     call this%cell_quadratures_and_maps_position%put(key = cell_quadrature_and_map_key,  &
                                                    val = current_quadrature_and_map, &
                                                    stat= istat)
     if (istat == now_stored) then
        current_quadrature_and_map = current_quadrature_and_map + 1
     end if

     do field_id=1, this%get_num_fields()
        cell_integrators_position_key = &
             this%generate_cell_integrators_position_key(fe%get_reference_fe_geo_id(), &
                                                 fe%get_quadrature_degree(), &
                                                 this%field_cell_to_ref_fes(field_id, fe%get_gid()))

        call this%cell_integrators_position%put(key=cell_integrators_position_key, &
                                                     val=current_cell_integrator, &
                                                     stat=istat)
        if (istat == now_stored) then
           current_cell_integrator = current_cell_integrator + 1
        end if
     end do

     call fe%next()
  end do

  allocate ( this%cell_quadratures(current_quadrature_and_map-1), stat=istat)
  check (istat==0)

  allocate ( this%cell_maps(current_quadrature_and_map-1), stat=istat)
  check (istat==0)

  allocate ( this%cell_integrators(current_cell_integrator-1), stat=istat)
  check (istat==0)

  call this%cell_quadratures_and_maps_position%init()
  call this%cell_integrators_position%init()
  current_quadrature_and_map = 1
  current_cell_integrator  = 1

  call fe%first()
  do while ( .not. fe%has_finished())
   
     cell_quadrature_and_map_key = this%generate_cell_quadratures_position_key(fe%get_reference_fe_geo_id(),&
                                                                           fe%get_quadrature_degree())
     
     call this%cell_quadratures_and_maps_position%put(key = cell_quadrature_and_map_key,  &
                                                    val = current_quadrature_and_map, &
                                                    stat= istat)
     if (istat == now_stored) then
        ! Create quadrature and cell_map associated to current max_order_within_fe
        max_order_reference_fe_id_within_fe = this%max_order_reference_fe_id_x_cell(fe%get_gid()) 
        reference_fe => this%reference_fes(max_order_reference_fe_id_within_fe)%p
        call reference_fe%create_quadrature(this%cell_quadratures(current_quadrature_and_map))!, &
                                            !fe%get_quadrature_degree())
        call this%cell_maps(current_quadrature_and_map)%create(this%cell_quadratures(current_quadrature_and_map),&
                                                             fe%get_reference_fe_geo())
        current_quadrature_and_map = current_quadrature_and_map + 1
     end if

     do field_id=1, this%get_num_fields()
        cell_integrators_position_key = &
             this%generate_cell_integrators_position_key(fe%get_reference_fe_geo_id(), &
                                                              fe%get_quadrature_degree(), &
                                                              this%field_cell_to_ref_fes(field_id, fe%get_gid()))
        
        call this%cell_integrators_position%put(key=cell_integrators_position_key, &
                                                     val=current_cell_integrator, &
                                                     stat=istat)
        if (istat == now_stored) then 
           quadrature => fe%get_quadrature()
           call this%cell_integrators(current_cell_integrator)%create(quadrature,&
                                                                             fe%get_reference_fe(field_id))
           current_cell_integrator = current_cell_integrator + 1
        end if
     end do
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
end subroutine serial_fe_space_set_up_cell_integration

subroutine serial_fe_space_free_fe_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)         :: i, istat

  class(reference_fe_t), pointer :: reference_fe

  call this%cell_quadratures_and_maps_position%free()
  call this%cell_integrators_position%free()

  if (allocated(this%cell_quadratures)) then
     do i=1, size(this%cell_quadratures)
        call this%cell_quadratures(i)%free()
     end do
     deallocate(this%cell_quadratures, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%cell_maps)) then
     do i=1, size(this%cell_maps)
        call this%cell_maps(i)%free()
     end do
     deallocate(this%cell_maps, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%cell_integrators)) then
     do i=1, size(this%cell_integrators)
        call this%cell_integrators(i)%free()
     end do
     deallocate(this%cell_integrators, stat=istat)
     check(istat==0)
  end if
  
  call this%free_cell_quadratures_degree()
  call this%free_max_order_reference_fe_id_x_cell()
  
end subroutine serial_fe_space_free_fe_integration


! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_num_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
function serial_fe_space_generate_cell_quadratures_position_key ( this, geo_reference_fe_id, quadrature_degree)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip) :: serial_fe_space_generate_cell_quadratures_position_key
  massert ( quadrature_degree >= -1,  "serial_fe_space_generate_cell_quadratures_position_key::Invalid quadrature degree")
  massert ( geo_reference_fe_id >= 1 .and. geo_reference_fe_id <= this%triangulation%get_num_reference_fes(), "serial_fe_space_generate_cell_quadratures_position_key::Invalid geo_reference_fe_id" )
  serial_fe_space_generate_cell_quadratures_position_key = quadrature_degree * this%triangulation%get_num_reference_fes() + geo_reference_fe_id + this%triangulation%get_num_reference_fes()
end function serial_fe_space_generate_cell_quadratures_position_key

! Some comments:
!   * geo_reference_fe_id can range from 1 to this%triangulation%get_num_reference_fes_geo()
!   * quadrature_degree can range from -1 to fe_space_max_quadrature_degree
!   * reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_generate_cell_integrators_position_key ( this, geo_reference_fe_id, quadrature_degree, reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: geo_reference_fe_id
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: reference_fe_id
  integer(ip) :: serial_fe_space_generate_cell_integrators_position_key
  massert ( reference_fe_id >= 1 .and. reference_fe_id <= this%get_num_reference_fes(), "serial_fe_space_generate_cell_integrators_position_key::Invalid reference_fe_id" )
  serial_fe_space_generate_cell_integrators_position_key =  reference_fe_id + &
       this%generate_cell_quadratures_position_key(geo_reference_fe_id,quadrature_degree) * this%get_num_reference_fes()
end function serial_fe_space_generate_cell_integrators_position_key

subroutine serial_fe_space_allocate_facet_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_facet_quadratures_degree()
  call memalloc ( this%facet_gids%size(), this%facet_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_facet_quadratures_degree 

subroutine serial_fe_space_clear_facet_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  assert ( allocated(this%facet_quadratures_degree) )
  this%facet_quadratures_degree = fe_space_default_quadrature_degree_flag
end subroutine serial_fe_space_clear_facet_quadratures_degree

subroutine serial_fe_space_free_facet_quadratures_degree ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%facet_quadratures_degree)) call memfree ( this%facet_quadratures_degree, __FILE__, __LINE__ )
end subroutine serial_fe_space_free_facet_quadratures_degree

subroutine serial_fe_space_allocate_max_order_field_cell_to_ref_fes_face ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%free_max_order_field_cell_to_ref_fes_face()
  call memalloc ( this%facet_gids%size(), this%max_order_field_cell_to_ref_fes_face , __FILE__, __LINE__ )
end subroutine serial_fe_space_allocate_max_order_field_cell_to_ref_fes_face  

subroutine serial_fe_space_free_max_order_field_cell_to_ref_fes_face  ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if (allocated(this%max_order_field_cell_to_ref_fes_face)) call memfree ( this%max_order_field_cell_to_ref_fes_face , __FILE__, __LINE__ )
end subroutine serial_fe_space_free_max_order_field_cell_to_ref_fes_face  

subroutine serial_fe_space_compute_max_order_field_cell_to_ref_fes_face ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_facet_iterator_t), allocatable :: fe_face
  class(fe_cell_iterator_t)     , allocatable :: fe
  integer(ip) :: max_order, max_order_reference_fe_id, reference_fe_id
  integer(ip) :: max_order_fes_around_fe_face
  integer(ip) :: field_id, icell_around
  
  call this%create_fe_facet_iterator(fe_face)
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe_face%has_finished())
     max_order_fes_around_fe_face = -1
     max_order_reference_fe_id    =  1 
     do icell_around = 1, fe_face%get_num_cells_around()
        call fe_face%get_cell_around(icell_around, fe)
        do field_id=1, fe%get_num_fields()
           if ( max_order_fes_around_fe_face <= fe%get_max_order_single_field(field_id) ) then
              max_order_fes_around_fe_face = fe%get_max_order_single_field(field_id)
              max_order_reference_fe_id = fe%get_reference_fe_id(field_id)
           end if
        end do
     end do
     this%max_order_field_cell_to_ref_fes_face(fe_face%facet_gid) = max_order_reference_fe_id 
     call fe_face%next()
  end do
  call this%free_fe_facet_iterator(fe_face)
  call this%free_fe_cell_iterator(fe)
end subroutine serial_fe_space_compute_max_order_field_cell_to_ref_fes_face  

subroutine serial_fe_space_fill_facet_gids ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  type(fe_vef_iterator_t) :: fe_vef
  call this%facet_gids%resize(0)
  call this%create_fe_vef_iterator(fe_vef)
  do while ( .not. fe_vef%has_finished() )
    if ( fe_vef%is_facet() ) then
      call this%facet_gids%push_back(fe_vef%get_gid())
    end if
    call fe_vef%next()
  end do
  call this%free_fe_vef_iterator(fe_vef)
  call this%facet_gids%shrink_to_fit()
end subroutine serial_fe_space_fill_facet_gids

subroutine serial_fe_space_free_facet_gids ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_gids%free()
end subroutine serial_fe_space_free_facet_gids

subroutine serial_fe_space_compute_facet_permutation_indices ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  class(fe_facet_iterator_t)       , allocatable :: fe_face
  class(fe_cell_iterator_t)            , allocatable :: first_fe
  class(fe_cell_iterator_t)            , allocatable :: second_fe
  integer(ip) :: fe_facet_permutation_index
  
  call this%facet_permutation_indices%resize(this%facet_gids%size(),-1)
  call this%create_fe_cell_iterator(first_fe)
  call this%create_fe_cell_iterator(second_fe)
  call this%create_fe_facet_iterator(fe_face)
  do while ( .not. fe_face%has_finished() )
    if ( .not. fe_face%is_ghost() .and. fe_face%get_num_cells_around() == 2 ) then
      fe_facet_permutation_index = fe_face%compute_fe_facet_permutation_index(first_fe,second_fe)
      call this%facet_permutation_indices%set(fe_face%facet_gid,fe_facet_permutation_index)
    end if
    call fe_face%next()
  end do
  call this%free_fe_facet_iterator(fe_face)
  call this%free_fe_cell_iterator(second_fe)
  call this%free_fe_cell_iterator(first_fe)

end subroutine serial_fe_space_compute_facet_permutation_indices

subroutine serial_fe_space_free_facet_permutation_indices ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  call this%facet_permutation_indices%free()
end subroutine serial_fe_space_free_facet_permutation_indices

subroutine serial_fe_space_set_up_facet_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  class(fe_facet_iterator_t), allocatable :: fe_face
  class(fe_cell_iterator_t)     , allocatable :: fe

  integer(ip) :: current_facet_quadrature
  integer(ip) :: current_facet_map
  integer(ip) :: current_facet_integrator

  integer(ip)            :: max_order_fes_around_fe_face
  integer(ip)            :: reference_fes_geo_id(2)
  type(p_reference_fe_t) :: reference_fes_geo(2)

  integer(ip)            :: reference_fes_id(2)
  type(p_reference_fe_t) :: reference_fes(2)

  integer(ip) :: facet_quadratures_position_key
  integer(ip) :: facet_integrators_position_key

  integer(ip) :: field_id, istat, icell_around

  class(reference_fe_t), pointer :: reference_fe

  call this%free_facet_integration()

  call this%compute_facet_permutation_indices()
  
  call this%allocate_max_order_field_cell_to_ref_fes_face()
  call this%compute_max_order_field_cell_to_ref_fes_face()
  
  ! Determine the size of facet_quadratures, facet_maps, 
  ! and facet_integrators while filling the corresponding hash tables
  call this%facet_quadratures_position%init()
  call this%facet_integrators_position%init()
  current_facet_quadrature = 1
  current_facet_map = 1
  current_facet_integrator = 1

  call this%create_fe_cell_iterator(fe)
  call this%create_fe_facet_iterator(fe_face)
  do while ( .not. fe_face%has_finished() ) 
     reference_fes_geo_id(2) = 0 
     do icell_around = 1, fe_face%get_num_cells_around()
        call fe_face%get_cell_around(icell_around, fe)
        reference_fes_geo_id(icell_around) = fe%get_reference_fe_geo_id()
     end do

     facet_quadratures_position_key = &
          this%generate_facet_quadratures_position_key(fe_face%get_quadrature_degree(), &
                                                         reference_fes_geo_id(1), &
                                                         reference_fes_geo_id(2) )
          
     call this%facet_quadratures_position%put(key  = facet_quadratures_position_key, &
                                                val  = current_facet_quadrature, &
                                                stat = istat)  
     
     if (istat == now_stored) then
        current_facet_quadrature = current_facet_quadrature + 1
        current_facet_map = current_facet_map + 1
     end if

     do field_id=1, this%get_num_fields()
        reference_fes_id(2) = 0  
        do icell_around = 1, fe_face%get_num_cells_around()
           call fe_face%get_cell_around(icell_around, fe)
           reference_fes_id(icell_around) = this%field_cell_to_ref_fes(field_id, fe%get_gid())
        end do

        facet_integrators_position_key = &
             this%generate_facet_integrators_position_key(fe_face%get_quadrature_degree(), &
                                                            reference_fes_id(1), &
                                                            reference_fes_id(2) )

        call this%facet_integrators_position%put(key=facet_integrators_position_key, &
                                                   val=current_facet_integrator, &
                                                   stat=istat)
        if (istat == now_stored) then
           current_facet_integrator = current_facet_integrator + 1
        end if
     end do
     call fe_face%next()
  end do

  allocate ( this%facet_quadratures(current_facet_quadrature-1), stat=istat)
  check (istat==0)

  allocate ( this%facet_maps(current_facet_map-1), stat=istat)
  check (istat==0)

  allocate ( this%facet_integrators(current_facet_integrator-1), stat=istat)
  check (istat==0)

  call this%facet_quadratures_position%init()
  call this%facet_integrators_position%init()
  current_facet_quadrature = 1
  current_facet_map = 1
  current_facet_integrator = 1

  call fe_face%first()
  do while ( .not. fe_face%has_finished() ) 
     reference_fes_geo_id(2) = 0
     nullify(reference_fes_geo(2)%p)
     do icell_around = 1, fe_face%get_num_cells_around()
        call fe_face%get_cell_around(icell_around, fe)
        reference_fes_geo_id(icell_around) =  fe%get_reference_fe_geo_id()
        reference_fes_geo(icell_around)%p  => fe%get_reference_fe_geo()
     end do

     facet_quadratures_position_key = &
          this%generate_facet_quadratures_position_key(fe_face%get_quadrature_degree(), &
                                                         reference_fes_geo_id(1), &
                                                         reference_fes_geo_id(2) )
     
     
     call this%facet_quadratures_position%put(key  = facet_quadratures_position_key, &
                                                val  = current_facet_quadrature, &
                                                stat = istat)  
     if (istat == now_stored) then
        reference_fe=>this%reference_fes( this%max_order_field_cell_to_ref_fes_face(fe_face%facet_gid) )%p
        call reference_fe%create_facet_quadrature(this%facet_quadratures(current_facet_quadrature),fe_face%get_quadrature_degree())
        call this%facet_maps(current_facet_map)%create(fe_face%get_quadrature(), &
                                                           reference_fes_geo(1)%p, &
                                                           reference_fes_geo(2)%p )
        current_facet_quadrature = current_facet_quadrature + 1
        current_facet_map = current_facet_map + 1
     end if

     do field_id=1, this%get_num_fields()
        reference_fes_id(2) = 0  
        nullify(reference_fes(2)%p)
        do icell_around = 1, fe_face%get_num_cells_around()
           call fe_face%get_cell_around(icell_around, fe)
           reference_fes_id(icell_around) = this%field_cell_to_ref_fes(field_id, fe%get_gid())
           reference_fes(icell_around)%p => fe%get_reference_fe(field_id)
        end do

        facet_integrators_position_key = &
             this%generate_facet_integrators_position_key(fe_face%get_quadrature_degree(), &
                                                            reference_fes_id(1), &
                                                            reference_fes_id(2) )

        call this%facet_integrators_position%put(key=facet_integrators_position_key, &
                                                   val=current_facet_integrator, &
                                                   stat=istat)
        if (istat == now_stored) then
           call this%facet_integrators(current_facet_integrator)%create(fe_face%get_quadrature(), &
                reference_fes(1)%p, &
                reference_fes(2)%p )
           current_facet_integrator = current_facet_integrator + 1
        end if
     end do
     call fe_face%next()
  end do
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_facet_iterator(fe_face)
end subroutine serial_fe_space_set_up_facet_integration

subroutine serial_fe_space_free_facet_integration ( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i, istat

  !if (allocated(this%max_order_x_fe_face)) call memfree ( this%max_order_x_fe_face, __FILE__, __LINE__ )

  call this%facet_quadratures_position%free()
  call this%facet_integrators_position%free()

  if (allocated(this%facet_quadratures)) then
     do i=1, size(this%facet_quadratures)
        call this%facet_quadratures(i)%free()
     end do
     deallocate(this%facet_quadratures, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%facet_maps)) then
     do i=1, size(this%facet_maps)
        call this%facet_maps(i)%free()
     end do
     deallocate(this%facet_maps, stat=istat)
     check(istat==0)
  end if

  if (allocated(this%facet_integrators)) then
     do i=1, size(this%facet_integrators)
        call this%facet_integrators(i)%free()
     end do
     deallocate(this%facet_integrators, stat=istat)
     check(istat==0)
  end if
  
  call this%free_facet_quadratures_degree()
  call this%free_max_order_field_cell_to_ref_fes_face()
  
  call this%free_facet_permutation_indices()
  
end subroutine serial_fe_space_free_facet_integration

! Provided the identifiers of the reference_fes_geo corresponding 
! to the cells around a fe_face, and the quadrature degree, computes a unique key 
! that is used to retrieve the position in the "this%facet_quadratures(:)" allocatable array through 
! the corresponding hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_geo_reference_fe_id can range from 0 to num_reference_fes_geo 
!      (with 0 for boundary fe_faces)
!    * left_geo_reference_fe_id can range from 1 to num_reference_fes_geo
function serial_fe_space_facet_quadratures_position_key ( this, quadrature_degree, left_geo_reference_fe_id, right_geo_reference_fe_id )
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_geo_reference_fe_id
  integer(ip)                 , intent(in) :: right_geo_reference_fe_id
  integer(ip) :: serial_fe_space_facet_quadratures_position_key
  integer(ip) :: num_reference_fes_geo

  num_reference_fes_geo = this%triangulation%get_num_reference_fes()
  serial_fe_space_facet_quadratures_position_key = left_geo_reference_fe_id + &
       (num_reference_fes_geo)*(right_geo_reference_fe_id) + &
       (num_reference_fes_geo)*(num_reference_fes_geo+1)*(quadrature_degree+1)
end function serial_fe_space_facet_quadratures_position_key

! For a given field, provided the identifiers of the reference_fes corresponding 
! to the cells around a fe_face, and the quadrature degree to be used, computes a unique key that 
! is used to retrieve the position in the "this%facet_integrators(:)" allocatable array through the corresponding 
! hash table. Some comments:
!    * [quadrature_degree >= -1]
!    * right_reference_fe_id can range from 1 to this%reference_fes_size 
!      (with 0 for boundary fe_faces)
!    * left_reference_fe_id can range from 1 to this%reference_fes_size
function serial_fe_space_facet_integrators_position_key(this, quadrature_degree, left_reference_fe_id, right_reference_fe_id)
  implicit none
  class(serial_fe_space_t)    , intent(in) :: this
  integer(ip)                 , intent(in) :: quadrature_degree
  integer(ip)                 , intent(in) :: left_reference_fe_id
  integer(ip)                 , intent(in) :: right_reference_fe_id
  integer(ip) :: serial_fe_space_facet_integrators_position_key
  serial_fe_space_facet_integrators_position_key = left_reference_fe_id + &
       (this%reference_fes_size)*(right_reference_fe_id) + &
       (this%reference_fes_size)*(this%reference_fes_size+1)*(quadrature_degree+1)
end function serial_fe_space_facet_integrators_position_key

subroutine serial_fe_space_create_dof_values(this, dof_values)
  implicit none
  class(serial_fe_space_t)    , intent(in)    :: this
  class(vector_t), allocatable, intent(inout) :: dof_values
  integer(ip) :: istat

  assert ( associated(this%block_layout) ) 
  
  if (allocated(dof_values)) then
     call dof_values%free()
     deallocate(dof_values, stat=istat); check(istat==0);
  end if

  if (this%block_layout%get_num_blocks() == 1) then
     allocate ( serial_scalar_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_scalar_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_block_num_dofs(1))
        class default
        check(.false.)
     end select
  else
     allocate ( serial_block_array_t  :: dof_values )
     select type(dof_values)
        class is(serial_block_array_t)
        call dof_values%create_and_allocate(this%block_layout%get_num_blocks(),this%block_layout%get_num_dofs_x_block())
        class default
        check(.false.)
     end select
  end if
end subroutine serial_fe_space_create_dof_values

subroutine serial_fe_space_generate_global_dof_numbering( this, block_layout )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  type(block_layout_t), target, intent(inout) :: block_layout
  logical :: perform_numbering
  
  perform_numbering = .not. associated(this%block_layout) 
  if (.not. perform_numbering) perform_numbering = .not. (this%block_layout == block_layout)
  if ( perform_numbering ) then
    this%block_layout => block_layout
    call this%allocate_num_dofs_x_field()
    if ( this%num_fields >= 1 ) then 
      call this%count_dofs()
    end if  
    call this%list_dofs()
  else
    call block_layout%copy_num_dofs_x_block(this%block_layout)
  end if
  
end subroutine serial_fe_space_generate_global_dof_numbering

subroutine serial_fe_space_count_dofs ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this   
  logical, allocatable :: per_field_vefs_visited(:,:)
  integer(ip) :: field_id, vef_lid, ivef, num_own_dofs_on_vef, iblock
  class(fe_cell_iterator_t), allocatable :: fe
  
  ! Count #DoFs per field
  this%num_dofs_x_field = 0
  
  call memalloc ( this%num_fields, this%triangulation%get_num_vefs(), per_field_vefs_visited,  __FILE__, __LINE__ )
  per_field_vefs_visited = .false.

  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        do field_id=1, this%num_fields
          if ( .not. fe%is_void(field_id)) then
            this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + &
                                                      fe%count_own_dofs_cell(field_id)
            if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
               do ivef = 1, fe%get_num_vefs()
                 vef_lid = fe%get_vef_gid(ivef)
                 if ( .not. per_field_vefs_visited (field_id,vef_lid) ) then
                    num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                    if (num_own_dofs_on_vef>0) then
                      per_field_vefs_visited (field_id,vef_lid) = .true.
                      this%num_dofs_x_field(field_id) = this%num_dofs_x_field(field_id) + &
                                                                  num_own_dofs_on_vef 
                    end if
                 end if
               end do           
            end if                                       
          end if
        end do
     end if
     call fe%next()
  end do
  
  ! Count #DoFs per block
  call this%block_layout%clear_num_dofs_x_block()
  do field_id=1, this%get_num_fields()
    iblock = this%block_layout%get_block_id(field_id) 
    call this%block_layout%add_to_block_num_dofs(iblock,this%num_dofs_x_field(field_id))     
  end do
  
  call this%free_fe_cell_iterator(fe)
  call memfree ( per_field_vefs_visited,  __FILE__, __LINE__ )
end subroutine serial_fe_space_count_dofs 

subroutine serial_fe_space_list_dofs ( this ) 
  implicit none
  class(serial_fe_space_t), intent(inout) :: this   
  
  integer(ip), allocatable :: owner_cell_gid_x_field_and_vef(:,:)
  integer(ip), allocatable :: per_field_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: blocks_current_num_dofs(:)
  integer(ip), allocatable :: fields_current_dof(:)
  class(fe_cell_iterator_t), allocatable :: fe, source_fe
  integer(ip) :: block_id, field_id
  integer(ip) :: ivef, vef_lid
  integer(ip) :: previous_dof_block
  
  call memalloc ( this%get_num_fields(), this%triangulation%get_num_vefs(), owner_cell_gid_x_field_and_vef,  __FILE__, __LINE__ )
  owner_cell_gid_x_field_and_vef = -1
  
  call memalloc ( this%get_num_fields(), this%triangulation%get_num_vefs(), per_field_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_vef_lid_in_owner_cell = -1
  
  call memalloc( this%block_layout%get_num_blocks(), blocks_current_num_dofs, __FILE__, __LINE__ )
  blocks_current_num_dofs = 0
  
  call memalloc( this%num_fields, fields_current_dof, __FILE__, __LINE__ )
  fields_current_dof = 0
  
  if (this%num_fields > 1) then
    do field_id=1, this%num_fields
       block_id = this%block_layout%get_block_id(field_id)
       fields_current_dof(field_id) = fields_current_dof(field_id) + blocks_current_num_dofs(block_id)
       blocks_current_num_dofs(block_id) = blocks_current_num_dofs(block_id) + this%num_dofs_x_field(field_id)
    end do
  end if
  
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
       do field_id=1, this%get_num_fields()
         if ( .not. fe%is_void(field_id)) then
           call fe%generate_own_dofs_cell ( field_id, fields_current_dof(field_id) )
           do ivef = 1, fe%get_num_vefs()
             vef_lid = fe%get_vef_gid(ivef)
             if ( owner_cell_gid_x_field_and_vef( field_id, vef_lid ) == -1 ) then
                previous_dof_block = fields_current_dof(field_id)
                call fe%generate_own_dofs_vef ( ivef, field_id, fields_current_dof(field_id), free_dofs_loop=.true.  )
                if (previous_dof_block < fields_current_dof(field_id)) then
                  owner_cell_gid_x_field_and_vef( field_id, vef_lid ) = fe%get_gid() 
                  per_field_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                end if
             else 
                call source_fe%set_gid(owner_cell_gid_x_field_and_vef(field_id, vef_lid))
                call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                                                              source_fe, &
                                                              per_field_vef_lid_in_owner_cell(field_id,vef_lid), &
                                                              field_id) 
             end if
           end do
         end if
       end do
     end if
     call fe%next()
  end do  
  
  ! Set #DoFs per field and block in case of single-field, single-block problem
  ! (as we did not call fe_space%count_dofs() in this case)
  if ( this%num_fields == 1 ) then
    field_id = 1
    block_id = 1
    this%num_dofs_x_field(field_id) = fields_current_dof(field_id)
    call this%block_layout%set_block_num_dofs(block_id,this%num_dofs_x_field(field_id))
  end if
  
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_cell_iterator(fe)
  call memfree( blocks_current_num_dofs, __FILE__, __LINE__ )
  call memfree( fields_current_dof     , __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_x_field_and_vef,  __FILE__, __LINE__ )
  call memfree ( per_field_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
end subroutine serial_fe_space_list_dofs 

subroutine serial_fe_space_allocate_num_dofs_x_field( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  if ( .not. allocated(this%num_dofs_x_field) ) & 
     call memalloc( this%get_num_fields(), this%num_dofs_x_field, __FILE__, __LINE__ )
  assert ( size(this%num_dofs_x_field) == this%get_num_fields() )
end subroutine serial_fe_space_allocate_num_dofs_x_field

subroutine serial_fe_space_fill_fe_dofs_and_count_dofs( this, field_id ) 
  implicit none
  ! Parameters
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip)                 ,  intent(in)   :: field_id

  ! Local variables
  integer(ip) :: ivef, vef_lid, ielem
  integer(ip) :: iblock, init_dof_block, current_dof_block, previous_dof_block
  integer(ip), allocatable :: visited_vef_to_cell_map(:,:)
  class(fe_cell_iterator_t), allocatable :: fe, source_fe

  iblock            = this%block_layout%get_block_id(field_id)
  init_dof_block    = this%block_layout%get_block_num_dofs(iblock)
  current_dof_block = init_dof_block

  if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
     call memalloc ( 2, this%triangulation%get_num_vefs(), visited_vef_to_cell_map,  __FILE__, __LINE__ )
     visited_vef_to_cell_map = -1

     call this%create_fe_cell_iterator(source_fe)
     call this%create_fe_cell_iterator(fe)
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
           do ivef = 1, fe%get_num_vefs()
              vef_lid = fe%get_vef_gid(ivef)
              if ( visited_vef_to_cell_map ( 1, vef_lid ) == -1 ) then
                 previous_dof_block = current_dof_block
                 call fe%generate_own_dofs_vef ( ivef, field_id, current_dof_block, free_dofs_loop=.true.  )
                 if (previous_dof_block < current_dof_block) then
                   visited_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                   visited_vef_to_cell_map ( 2, vef_lid ) = ivef
                 end if
              else 
                 call source_fe%set_gid(visited_vef_to_cell_map(1,vef_lid))
                 call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                      source_fe, &
                      visited_vef_to_cell_map(2,vef_lid), &
                      field_id) 
              end if
           end do
        end if
        call fe%next()
     end do
     call this%free_fe_cell_iterator(source_fe)
     call memfree ( visited_vef_to_cell_map,  __FILE__, __LINE__ )
  else 
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
        end if
        call fe%next()
     end do
  end if
  call this%free_fe_cell_iterator(fe)
  this%num_dofs_x_field(field_id) = current_dof_block - init_dof_block
  call this%block_layout%add_to_block_num_dofs(iblock,this%num_dofs_x_field(field_id))     
end subroutine serial_fe_space_fill_fe_dofs_and_count_dofs

subroutine serial_fe_space_renum_dofs_block (this, block_id, perm_old2new)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: block_id
  integer(ip)             , intent(in)    :: perm_old2new(this%block_layout%get_block_num_dofs(block_id))
  class(fe_cell_iterator_t), allocatable :: fe

  call this%create_fe_cell_iterator(fe)
  do while ( .not. fe%has_finished())
     call fe%renum_dofs_block ( block_id, perm_old2new )
     call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)

end subroutine serial_fe_space_renum_dofs_block

function serial_fe_space_get_num_dims ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)                          :: serial_fe_space_get_num_dims
  class(triangulation_t), pointer :: triangulation
  triangulation => this%get_triangulation()
  serial_fe_space_get_num_dims = triangulation%get_num_dims()
end function serial_fe_space_get_num_dims

function serial_fe_space_get_num_reference_fes ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_num_reference_fes
  serial_fe_space_get_num_reference_fes = size(this%reference_fes)
end function serial_fe_space_get_num_reference_fes

function serial_fe_space_get_reference_fe ( this, reference_fe_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: reference_fe_id
  class(reference_fe_t), pointer :: serial_fe_space_get_reference_fe
  assert ( reference_fe_id >=1 .and. reference_fe_id <= this%get_num_reference_fes() )
  serial_fe_space_get_reference_fe => this%reference_fes(reference_fe_id)%p
end function serial_fe_space_get_reference_fe

function serial_fe_space_get_field_type ( this, field_id )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: field_id
  character(:), pointer :: serial_fe_space_get_field_type
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe

  call this%create_fe_cell_iterator(fe)
  reference_fe => fe%get_reference_fe(field_id)
  serial_fe_space_get_field_type => reference_fe%get_field_type()
  call this%free_fe_cell_iterator(fe)
end function serial_fe_space_get_field_type

function serial_fe_space_get_num_components ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: serial_fe_space_get_num_components
  class(fe_cell_iterator_t), allocatable :: fe
  class(reference_fe_t), pointer :: reference_fe
  integer(ip) :: field_id

  call this%create_fe_cell_iterator(fe)
  serial_fe_space_get_num_components = 0
  do field_id = 1, this%get_num_fields()
     reference_fe => fe%get_reference_fe(field_id)
     serial_fe_space_get_num_components = serial_fe_space_get_num_components + &
          reference_fe%get_num_field_components()
  end do
  call this%free_fe_cell_iterator(fe)
end function serial_fe_space_get_num_components

function serial_fe_space_get_max_num_shape_functions( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_shape_functions
  integer(ip) :: irefe
  serial_fe_space_get_max_num_shape_functions = 0
  do irefe = 1, this%reference_fes_size
     serial_fe_space_get_max_num_shape_functions = max(serial_fe_space_get_max_num_shape_functions, &
          this%reference_fes(irefe)%p%get_num_shape_functions())
  end do
end function serial_fe_space_get_max_num_shape_functions

function serial_fe_space_get_max_num_dofs_on_a_cell( this ) result (max_dofs)
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip) :: max_dofs
  class(fe_cell_iterator_t), allocatable :: fe
  max_dofs = 0
  call this%create_fe_cell_iterator(fe)
  do while (.not. fe%has_finished())
    max_dofs = max(max_dofs,fe%get_num_dofs())
    call fe%next()
  end do
  call this%free_fe_cell_iterator(fe)
end function serial_fe_space_get_max_num_dofs_on_a_cell

function serial_fe_space_get_max_num_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_quadrature_points
  integer(ip) :: iquad
  serial_fe_space_get_max_num_quadrature_points = 0
  do iquad = 1, size(this%cell_quadratures)
     serial_fe_space_get_max_num_quadrature_points =       & 
          max(serial_fe_space_get_max_num_quadrature_points, &
          this%cell_quadratures(iquad)%get_num_quadrature_points())
  end do
end function serial_fe_space_get_max_num_quadrature_points

function serial_fe_space_get_max_num_nodal_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_nodal_quadrature_points
  integer(ip) :: i
  type(quadrature_t), pointer :: nodal_quadrature

  serial_fe_space_get_max_num_nodal_quadrature_points = 0
  do i= 1, this%reference_fes_size
     if (this%reference_fes(i)%p%has_nodal_quadrature()) then
        nodal_quadrature => this%reference_fes(i)%p%get_nodal_quadrature()
        serial_fe_space_get_max_num_nodal_quadrature_points =       & 
             max(serial_fe_space_get_max_num_nodal_quadrature_points, &
             nodal_quadrature%get_num_quadrature_points())
     end if
  end do
end function serial_fe_space_get_max_num_nodal_quadrature_points

function serial_fe_space_get_max_num_facet_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_num_facet_quadrature_points
  integer(ip) :: iquad
  serial_fe_space_get_max_num_facet_quadrature_points = 0
  do iquad = 1, size(this%facet_quadratures)
     serial_fe_space_get_max_num_facet_quadrature_points =       & 
          max(serial_fe_space_get_max_num_facet_quadrature_points, &
          this%facet_quadratures(iquad)%get_num_quadrature_points())
  end do
end function serial_fe_space_get_max_num_facet_quadrature_points

function serial_fe_space_get_max_order( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_order
  integer(ip) :: irefe
  serial_fe_space_get_max_order = 0
  do irefe = 1, this%reference_fes_size
     serial_fe_space_get_max_order = max(serial_fe_space_get_max_order, &
          this%reference_fes(irefe)%p%get_max_order())
  end do
end function serial_fe_space_get_max_order

function serial_fe_space_get_triangulation( this) result(triangulation)
  implicit none
  class(serial_fe_space_t)      , intent(in)    :: this 
  class(triangulation_t), pointer       :: triangulation
  assert ( associated(this%triangulation) )
  triangulation => this%triangulation
end function serial_fe_space_get_triangulation

subroutine serial_fe_space_set_triangulation( this, triangulation )
  implicit none
  class(serial_fe_space_t)                  , intent(inout) :: this 
  class(triangulation_t), target, intent(in)    :: triangulation
  this%triangulation => triangulation
end subroutine serial_fe_space_set_triangulation

function serial_fe_space_get_environment(this) result(environment)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  class(environment_t), pointer:: environment 
  environment => this%triangulation%get_environment()
end function serial_fe_space_get_environment

function serial_fe_space_get_vef_gids_of_fe_faces( this) result(facet_gids)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this 
  type(std_vector_integer_ip_t), pointer :: facet_gids
  facet_gids => this%facet_gids
end function serial_fe_space_get_vef_gids_of_fe_faces

function serial_fe_space_get_conditions( this) result(conditions)
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this 
  class(conditions_t), pointer :: conditions
  assert ( associated(this%conditions) )
  conditions => this%conditions
end function serial_fe_space_get_conditions

subroutine serial_fe_space_set_conditions( this, conditions )
  implicit none
  class(serial_fe_space_t)        , intent(inout) :: this 
  class(conditions_t)     , target, intent(in)    :: conditions
  this%conditions => conditions
end subroutine serial_fe_space_set_conditions

function serial_fe_space_get_num_fixed_dofs(this)
  implicit none
  class(serial_fe_space_t), intent(in)    :: this 
  integer(ip) :: serial_fe_space_get_num_fixed_dofs
  serial_fe_space_get_num_fixed_dofs = this%num_fixed_dofs
end function serial_fe_space_get_num_fixed_dofs

function serial_fe_space_get_num_blocks( this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_num_blocks
  assert ( associated (this%block_layout) ) 
  serial_fe_space_get_num_blocks = this%block_layout%get_num_blocks()
end function serial_fe_space_get_num_blocks

function serial_fe_space_get_field_blocks( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip), pointer :: serial_fe_space_get_field_blocks(:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_blocks)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_blocks => this%block_layout%get_field_id_to_block_id()
  end if
end function serial_fe_space_get_field_blocks

function serial_fe_space_get_field_coupling( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  logical, pointer :: serial_fe_space_get_field_coupling(:,:)
  class(environment_t), pointer :: environment
  environment => this%get_environment()
  nullify(serial_fe_space_get_field_coupling)
  if ( environment%am_i_l1_task() ) then
     serial_fe_space_get_field_coupling => this%block_layout%get_field_coupling()
  end if
end function serial_fe_space_get_field_coupling

! Returns the number of DoFs associated to block with identifier block_id
function serial_fe_space_get_block_num_dofs ( this, block_id )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)          , intent(in) :: block_id
  integer(ip)                       :: serial_fe_space_get_block_num_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  serial_fe_space_get_block_num_dofs = 0
  if ( environment%am_i_l1_task() ) then 
     serial_fe_space_get_block_num_dofs  = this%block_layout%get_block_num_dofs(block_id)
  end if
end function serial_fe_space_get_block_num_dofs

! Sets the number of DoFs associated to block with identifier block_id to num_dofs
subroutine serial_fe_space_set_block_num_dofs ( this, block_id, num_dofs )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)             , intent(in) :: block_id
  integer(ip)             , intent(in) :: num_dofs
  class(environment_t), pointer  :: environment
  environment => this%get_environment()
  if ( environment%am_i_l1_task() ) then 
     call this%block_layout%set_block_num_dofs(block_id,num_dofs)
  end if
end subroutine serial_fe_space_set_block_num_dofs

! Returns a pointer to the block_layout member variable
function serial_fe_space_get_block_layout ( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  type(block_layout_t), pointer :: serial_fe_space_get_block_layout
  serial_fe_space_get_block_layout => this%block_layout
end function serial_fe_space_get_block_layout

! Sets the pointer block_layout member variable
subroutine serial_fe_space_set_block_layout ( this, block_layout )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  type(block_layout_t), target, intent(in)    :: block_layout
  this%block_layout => block_layout
end subroutine serial_fe_space_set_block_layout

! Nullifies the pointer block_layout member variable
subroutine serial_fe_space_nullify_block_layout ( this )
  implicit none
  class(serial_fe_space_t)    , intent(inout) :: this
  nullify(this%block_layout)
end subroutine serial_fe_space_nullify_block_layout

subroutine serial_fe_space_create_fe_cell_iterator ( this, fe )

  implicit none
  class(serial_fe_space_t)         , intent(in)  :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine serial_fe_space_create_fe_cell_iterator

subroutine serial_fe_space_free_fe_cell_iterator ( this, fe )
  implicit none
  class(serial_fe_space_t)         , intent(in)  :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  if(allocated(fe)) then
     call fe%free()
     deallocate(fe, stat=istat); check(istat==0)
  end if
end subroutine serial_fe_space_free_fe_cell_iterator

subroutine serial_fe_space_create_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  class(triangulation_t), pointer :: triangulation
  class(vef_iterator_t), allocatable :: vef
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  call fe_vef%free()
  call fe_vef%create(this,vef)
  call triangulation%free_vef_iterator(vef)
end subroutine serial_fe_space_create_fe_vef_iterator

subroutine serial_fe_space_create_itfc_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), target, intent(in)    :: this
  type(fe_vef_iterator_t)         , intent(inout) :: fe_vef
  type(itfc_vef_iterator_t) :: vef
  call fe_vef%free()
  call fe_vef%create(this,vef)
end subroutine serial_fe_space_create_itfc_fe_vef_iterator

subroutine serial_fe_space_free_fe_vef_iterator ( this, fe_vef )
  implicit none
  class(serial_fe_space_t), intent(in)    :: this
  class(fe_vef_iterator_t), intent(inout) :: fe_vef
  call fe_vef%free()
end subroutine serial_fe_space_free_fe_vef_iterator

subroutine serial_fe_space_create_fe_facet_iterator ( this, fe_face )
  implicit none
  class(serial_fe_space_t) , target     , intent(in)    :: this
  class(fe_facet_iterator_t), allocatable, intent(inout) :: fe_face
  class(vef_iterator_t), allocatable :: vef
  class(triangulation_t), pointer :: triangulation
  integer(ip)          :: istat
  call this%free_fe_facet_iterator(fe_face)
  triangulation => this%get_triangulation()
  call triangulation%create_vef_iterator(vef)
  allocate(fe_facet_iterator_t :: fe_face, stat=istat); check(istat==0)
  call fe_face%create(this,vef)
  call triangulation%free_vef_iterator(vef)
end subroutine serial_fe_space_create_fe_facet_iterator

subroutine serial_fe_space_free_fe_facet_iterator ( this, fe_face )
  implicit none
  class(serial_fe_space_t)              , intent(in)    :: this
  class(fe_facet_iterator_t), allocatable, intent(inout) :: fe_face
  integer(ip) :: istat
  if (allocated(fe_face)) then
    call fe_face%free()
    deallocate(fe_face, stat=istat); check(istat==0);
  end if
end subroutine serial_fe_space_free_fe_facet_iterator
