! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================
subroutine tet_lagrangian_reference_fe_free(this) 
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout) ::  this
  integer(ip) :: i

  ! Free member variables of raviart_thomas_reference_fe_t
  if ( allocated(this%change_basis_matrix) ) &
       call memfree ( this%change_basis_matrix, __FILE__, __LINE__ )     

  this%basis_changed = .false. 

  ! Free member variables of lagrangian_reference_fe_t
  ! (and those of its ancestors)
  call lagrangian_reference_fe_free ( this )  
end subroutine tet_lagrangian_reference_fe_free

!==================================================================================================
subroutine tet_lagrangian_reference_fe_create( this, topology, number_dimensions, order, field_type, & 
     &  conformity, continuity )
  implicit none 
  class(tet_lagrangian_reference_fe_t), intent(inout) :: this
  character(*)                            , intent(in)    :: topology
  integer(ip)                             , intent(in)    :: number_dimensions
  integer(ip)                             , intent(in)    :: order
  character(*)                            , intent(in)    :: field_type
  logical                                 , intent(in)    :: conformity
  logical                      , optional , intent(in)    :: continuity

  assert ( order >= 0 )

  call this%free()
  call this%set_common_data(number_dimensions,order,field_type,conformity,continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_lagrangian )
  call this%fill()
  call this%create_nodal_quadrature()
  call this%change_basis()

end subroutine tet_lagrangian_reference_fe_create

!==================================================================================================
function tet_lagrangian_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: tet_lagrangian_reference_fe_check_compatibility_of_n_faces 
  integer(ip) :: idime

  select type(source_reference_fe)
     class is(tet_lagrangian_reference_fe_t)
        ! Get number nodes per dimension
     assert (target_reference_fe%number_dimensions == source_reference_fe%number_dimensions)
     do idime = 1, target_reference_fe%number_dimensions
        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
     end do
     assert (target_reference_fe%get_n_face_dimension(target_n_face_id) ==  source_reference_fe%get_n_face_dimension(source_n_face_id))
     assert (target_reference_fe%get_n_face_dimension(target_n_face_id) < 3)
     assert (target_reference_fe%number_field_components == source_reference_fe%number_field_components)
     assert (target_reference_fe%get_number_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_number_own_dofs_n_face(source_n_face_id))
     tet_lagrangian_reference_fe_check_compatibility_of_n_faces = .true.
     class default
     tet_lagrangian_reference_fe_check_compatibility_of_n_faces = .false.
  end select

end function tet_lagrangian_reference_fe_check_compatibility_of_n_faces

!=================================================================================================
function tet_lagrangian_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(tet_lagrangian_reference_fe_t), intent(in) :: this 
  real(rp)  :: tet_lagrangian_reference_fe_get_characteristic_length 
  tet_lagrangian_reference_fe_get_characteristic_length =   &
       &   real(get_factorial(this%number_dimensions),rp)**(-1.0_rp/real(this%number_dimensions,rp))
end function tet_lagrangian_reference_fe_get_characteristic_length

!==================================================================================================
function tet_lagrangian_reference_fe_get_number_subcells(this, num_refinements) result(num_subcells)
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                                         :: num_subcells
  num_subcells = (num_refinements+1)**this%number_dimensions
end function tet_lagrangian_reference_fe_get_number_subcells

!==================================================================================================
subroutine tet_lagrangian_reference_fe_get_subcells_connectivity(this, num_refinements, connectivity)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  integer(ip) :: order_vector(SPACE_DIM)
  integer(ip) :: num_subelems
  integer(ip) :: subelem
  integer(ip) :: geo_nnodes
  integer(ip) :: local_node
  integer(ip) :: first_coord(this%number_dimensions)
  integer(ip) :: local_coord(this%number_dimensions)
  integer(ip) :: global_coord(this%number_dimensions)
  integer(ip) :: ones_dim(this%number_dimensions)

  if(num_refinements > 0) then
     ! this subroutine is not implemented for tet_lagrangrian
     ! but magically wors for order 1 tets
     check(.false.) !Not working
  endif
  ones_dim = 1
  num_subelems = this%get_number_subcells(num_refinements=num_refinements)
  geo_nnodes = this%get_number_vertices()
  assert(size(connectivity,1) == geo_nnodes)
  assert(size(connectivity,2) == num_subelems)
  order_vector = num_refinements+1


  do subelem = 1, num_subelems
     !call this%get_node_local_coordinates(first_coord,subelem, & 
     !                                      & this%number_dimensions,this%order(1)-1)
     call index_to_ijk( subelem, this%number_dimensions, order_vector, first_coord )

     do local_node = 1, geo_nnodes
        !call this%get_node_local_coordinates(local_coord,local_node,this%number_dimensions,1)
        call index_to_ijk( local_node, this%number_dimensions, 2*ones_dim, local_coord )

        global_coord = first_coord + local_coord 
        !connectivity(local_node, subelem) = this%get_node_local_id(global_coord, &
        !                                                   & this%number_dimensions,this%order(1)) ! 
        connectivity(local_node, subelem) = ijk_to_index(global_coord, order_vector,this%number_dimensions)+1
     end do
  end do
end subroutine tet_lagrangian_reference_fe_get_subcells_connectivity

!==================================================================================================
subroutine tet_lagrangian_reference_fe_get_subelements_connectivity ( this, connectivity )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip),                          intent(inout) :: connectivity(:,:)
  integer(ip) :: num_subelems
  integer(ip) :: subelem
  integer(ip) :: geo_nnodes
  integer(ip) :: local_node
  integer(ip) :: first_coord(this%number_dimensions)
  integer(ip) :: local_coord(this%number_dimensions)
  integer(ip) :: global_coord(this%number_dimensions)

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for triangles/tetrahedra '
  check( .false. )

end subroutine tet_lagrangian_reference_fe_get_subelements_connectivity

!==================================================================================================
subroutine tet_lagrangian_reference_fe_blending(this,values)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(point_t)                       , intent(inout) :: values(:)
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for triangles/tetrahedra '
  check(.false.)
end subroutine tet_lagrangian_reference_fe_blending

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_own_dof_permutations (this)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip) :: idime
  ! Create emtpy permutation table, we do not want to fill own node permutations for tets since 
  ! meshes are ordered.
  do idime=1,this%number_dimensions-1
     this%own_dof_permutations(idime)%nd1 = 0
     this%own_dof_permutations(idime)%nd2 = 0
  end do
end subroutine tet_lagrangian_reference_fe_fill_own_dof_permutations

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_qpoints_permutations (this, quadrature, qpoints_perm)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
  integer(ip)    :: ndime, n_q_points, i

  ndime      = quadrature%get_number_dimensions()
  n_q_points = quadrature%get_number_quadrature_points()


  call qpoints_perm%create(n_q_points, &    !> Number of quadrature points
       &                ndime*2**ndime)  !> Number of possible permutations x possible rotations
  forall (i = 1:qpoints_perm%nd1) qpoints_perm%a(i,:) = i

end subroutine tet_lagrangian_reference_fe_fill_qpoints_permutations

!**************************************************************************************************
! Deferred TBP implementors from lagrangian_reference_fe_t
!**************************************************************************************************

!==================================================================================================
subroutine tet_lagrangian_create_data_out_quadrature ( this, num_refinements, quadrature )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip)                                         :: order_vector(SPACE_DIM)
  type(node_array_t)                                  :: node_array 
  integer(ip)                                         :: i

  if(num_refinements > 0) then
     ! this subroutine is not tested yet for tet_lagrangrian
     check(.false.) !Not working
  endif

  assert ( num_refinements >= 0 )

  call quadrature%free()

  order_vector = num_refinements+1
  call node_array%create( this%polytope, order_vector ) 
  call quadrature%create( this%number_dimensions, node_array%number_nodes )

  do i=1,this%number_dimensions
     quadrature%coordinates(i,:) = node_array%coordinates(i,:)*(1.0_rp/order_vector(i))
  end do
  quadrature%weight = 1.0_rp
  call node_array%free()
end subroutine tet_lagrangian_create_data_out_quadrature

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  ! 
  !     This routine sets up the integration constants of open rules for
  !     triangles and tetrahedra mapping hexahedra quadratures
  !
  !-----------------------------------------------------------------------
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  type(hex_lagrangian_reference_fe_t)                :: hex_lagrangian_rfe

  if (get_quadratures_from_hex(quadrature)) then
     call hex_lagrangian_rfe%fill_quadrature ( quadrature ) 
     if (quadrature%number_dimensions==1) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp        
        ! w' = w/2
        quadrature%weight = quadrature%weight / 2.0_rp
     elseif (quadrature%number_dimensions==2) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp
        ! y' = (1-x')(y+1)/2
        quadrature%coordinates(2,:) = (1.0_rp - quadrature%coordinates(1,:)) * &
             ((1.0_rp + quadrature%coordinates(2,:)) / 2.0_rp)
        ! w' = (1-x')/4
        quadrature%weight = (1.0_rp - quadrature%coordinates(1,:)) /4.0_rp * &
             quadrature%weight

     elseif (quadrature%number_dimensions==3) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp
        ! y' = (1-x')(y+1)/2
        quadrature%coordinates(2,:) = (1.0_rp - quadrature%coordinates(1,:)) * &
             ((1.0_rp + quadrature%coordinates(2,:)) / 2.0_rp)
        ! z' = (1-x'-y')(z+1)/2
        quadrature%coordinates(3,:) = (1.0_rp - quadrature%coordinates(1,:)    &
             - quadrature%coordinates(2,:)) * &
             ((1.0_rp + quadrature%coordinates(3,:)) / 2.0_rp)
        ! w' = ((1-x')^2+y'(x'-1))/8
        quadrature%weight = ((1.0_rp - quadrature%coordinates(1,:))**2.0_rp + &
             quadrature%coordinates(2,:)*(quadrature%coordinates(1,:) - 1.0_rp)) / 8.0_rp * &
             quadrature%weight
     end if
  else 
     call tet_lagrangian_reference_fe_fill_symmetric_quadrature ( this, quadrature ) 
  end if
end subroutine tet_lagrangian_reference_fe_fill_quadrature

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_nodal_quadrature( this, quadrature )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip) :: i

  do i=1,this%number_dimensions
     if ( this%order_vector(i) > 0 ) then 
        quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)*(1.0_rp/this%order_vector(i))
     else 
        quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)
     end if
  end do
  quadrature%weight = 1.0_rp
end subroutine tet_lagrangian_reference_fe_fill_nodal_quadrature

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)                      , intent(in)         :: quadrature
  type(interpolation_t)                   , intent(inout)      :: interpolation    
  integer(ip)                  , optional , intent(in)         :: order_vector(SPACE_DIM)

  type(interpolation_t) :: interpolation_pre_basis

  if ( .not. this%basis_changed ) then
     call this%fill_interpolation_pre_basis ( quadrature, interpolation, order_vector )
  else
     call interpolation_pre_basis%clone(interpolation)
     call this%fill_interpolation_pre_basis ( quadrature, interpolation_pre_basis, order_vector ) 
     call this%apply_change_basis_matrix_to_interpolation ( interpolation_pre_basis, interpolation )
     call interpolation_pre_basis%free()
  end if
end subroutine tet_lagrangian_reference_fe_fill_interpolation

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_face_interpolation (this, local_quadrature, local_face_id, face_interpolation)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  integer(ip)                             , intent(in)    :: local_face_id
  type(interpolation_t)                   , intent(inout) :: face_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c,idime,iface,n_face_index
  ! Add offset to have same numbering as in polytope
  n_face_index = local_face_id+this%get_first_face_id()-1

  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%number_dimensions, local_quadrature%number_quadrature_points )
  c = 0
  do idime = 0,this%number_dimensions-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = 0.0_rp
     else 
        aux_quadrature%coordinates(idime+1,:) = 1 - sum(local_quadrature%coordinates(:,:),1)
     end if
  end do

  !if ( .not. this%basis_changed ) call this%fill_interpolation_pre_basis ( aux_quadrature, face_interpolation ) !( aux_quadrature, face_interpolation ) 
  call this%fill_interpolation( aux_quadrature, face_interpolation ) 
  call aux_quadrature%free()

end subroutine tet_lagrangian_reference_fe_fill_face_interpolation

!=================================================================================================
function tet_lagrangian_reference_fe_compute_number_quadrature_points( this, degree, dimension )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                             , intent(in)    :: degree
  integer(ip)                             , intent(in)    :: dimension
  integer(ip) :: tet_lagrangian_reference_fe_compute_number_quadrature_points

  if( dimension == 1 ) then
     tet_lagrangian_reference_fe_compute_number_quadrature_points = int(ceiling(real(degree,rp)/2.0_rp),ip)+1
  elseif( dimension == 2 ) then
     !*************************************************************************
     ! Using efficent symmetrical gaussian quadrature rules (when available). 
     if( degree <= 2 ) then
        tet_lagrangian_reference_fe_compute_number_quadrature_points = 3
     elseif( degree <= 4 ) then
        tet_lagrangian_reference_fe_compute_number_quadrature_points = 6
     elseif( degree <= 6 ) then
        tet_lagrangian_reference_fe_compute_number_quadrature_points = 13
     elseif( degree <= 8 ) then
        tet_lagrangian_reference_fe_compute_number_quadrature_points = 19
     elseif( degree <= 10 ) then
        tet_lagrangian_reference_fe_compute_number_quadrature_points = 28
     else ! Quadratures based on brick quadratures transformation
        tet_lagrangian_reference_fe_compute_number_quadrature_points = int((ceiling(real(degree,rp)/2.0_rp) + 1.0_rp )**2.0_rp,ip)
     end if
  elseif( dimension == 3 ) then
     !*************************************************************************
     ! Using efficent symmetrical gaussian quadrature rules (when available). 
     if( degree <= 2 ) then
        tet_lagrangian_reference_fe_compute_number_quadrature_points = 4
     elseif( degree <= 4) then
        tet_lagrangian_reference_fe_compute_number_quadrature_points = 11
     else ! Quadratures based on brick quadratures transformation
        tet_lagrangian_reference_fe_compute_number_quadrature_points = int((ceiling(real(degree,rp)/2.0_rp) + 2.0_rp )**3.0_rp,ip)
     end if
  end if

end function tet_lagrangian_reference_fe_compute_number_quadrature_points

!==================================================================================================
function tet_lagrangian_reference_fe_get_node_local_id (this, local_coordinates, & 
     & number_of_dimensions, order)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: local_coordinates(:)
  integer(ip)                         , intent(in)    :: number_of_dimensions
  integer(ip)                         , intent(in)    :: order
  integer(ip) :: tet_lagrangian_reference_fe_get_node_local_id
  integer(ip) :: k,q

  if (sum(local_coordinates)>order) then
     write(*,*) 'ijk', local_coordinates
     write(*,*) 'tets_setting:: gijk:: ERROR i+j+k<=p'
     check(.false.)
  end if

  tet_lagrangian_reference_fe_get_node_local_id = 1
  do k =1,number_of_dimensions-1
     q = order-local_coordinates(k+1)
     tet_lagrangian_reference_fe_get_node_local_id =   & 
          & tet_lagrangian_reference_fe_get_node_local_id + & 
          & this%compute_sum_of_dofs_in_simplices(k,q-local_coordinates(k)+1,q)
  end do
  tet_lagrangian_reference_fe_get_node_local_id =   & 
       & tet_lagrangian_reference_fe_get_node_local_id + & 
       & this%compute_sum_of_dofs_in_simplices(k,order-local_coordinates(number_of_dimensions)+1,order)

end function tet_lagrangian_reference_fe_get_node_local_id

!=================================================================================================
subroutine tet_lagrangian_reference_fe_set_permutation_2D( this, permutation, number_nodes_x_dim, &
     & orientation, rotation )
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(inout) :: permutation(:)
  integer(ip)                         , intent(in)    :: number_nodes_x_dim,orientation,rotation
  integer(ip) :: o_r,i,j,ij_t(3)     ! ij_t = (i,j,p-i-j)
  integer(ip) :: ij_n(2),go,gn
  integer(ip) :: ij_perm_tet(2,6) = reshape((/ 1, 2, 2, 3, 3, 1, 2, 1, 3, 2, 1, 3/), (/2,6/) )

  ! Generic loop+rotation identifier  
  o_r = 3*(orientation-1)+rotation
  do j = 0,number_nodes_x_dim-1
     ij_t(2) = j
     do i = 0,number_nodes_x_dim-j-1
        ij_t(1) = i
        ij_t(3) = number_nodes_x_dim-i-j-1
        ! Get the global numbering of node (i,j)
        go = this%get_node_local_id(ij_t(1:2),2,number_nodes_x_dim-1)
        ! i,j coordinates for the o_r permutation
        ij_n(1:2) = ij_t(ij_perm_tet(1:2,o_r)) 
        ! Store the global numbering of node ij_n 
        permutation(go) = this%get_node_local_id(ij_n,2,number_nodes_x_dim-1)
     end do
  end do

end subroutine tet_lagrangian_reference_fe_set_permutation_2D

!=================================================================================================
recursive function tet_lagrangian_reference_fe_compute_number_nodes_scalar(this, order, dimension)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip)                         , intent(in)    :: dimension
  integer(ip)                         , intent(in)    :: order
  integer(ip) :: tet_lagrangian_reference_fe_compute_number_nodes_scalar
  integer(ip) :: q
  if (dimension == 0) then
     tet_lagrangian_reference_fe_compute_number_nodes_scalar = 1
  elseif (order == 0) then
     tet_lagrangian_reference_fe_compute_number_nodes_scalar = 1
  elseif (dimension == 1) then
     tet_lagrangian_reference_fe_compute_number_nodes_scalar = order+1
  elseif (dimension == 2) then
     tet_lagrangian_reference_fe_compute_number_nodes_scalar = int((order+1)*(order+2)/2)
  else
     tet_lagrangian_reference_fe_compute_number_nodes_scalar = & 
          & this%compute_number_nodes_scalar(dimension-1,0)
     do q=1,order
        tet_lagrangian_reference_fe_compute_number_nodes_scalar = & 
             & tet_lagrangian_reference_fe_compute_number_nodes_scalar + & 
             & this%compute_number_nodes_scalar(dimension-1,q)
     end do
  end if
end function tet_lagrangian_reference_fe_compute_number_nodes_scalar

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_symmetric_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  ! 
  !     This routine sets up the integration constants of open rules for
  !     triangles and tetrahedra
  ! 
  !             NDIME = 2             NDIME = 3
  ! 
  !          NGAUS  EXACT POL.     NGAUS  EXACT POL. 
  !          -----  ----------     -----  ----------
  !            1       p1            1       p1
  !            3       p2            4       p2
  !            4       p3            5       p3
  !            6       p4           11       p4
  !            7       p5           14       p5
  !           13       p7
  !           19       p9
  !           28       p11
  !
  !-----------------------------------------------------------------------
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  real(rp)    :: a,b,c,d,e,f,g,h,p,q,r,s,t,u,v,w,x,y,z
  real(rp)    :: w1,w2,w3,w4,w5,w6,w7,w8
  real(rp)    :: ex1,et1,ez1,ex2,et2,ez2
  integer(ip) :: ndime,ngaus

  ndime = quadrature%number_dimensions
  ngaus = quadrature%number_quadrature_points

  ! Line integral (the same as for brick elements)
  if(ndime==1) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)=0.5_rp
        quadrature%weight(  1)=1.0_rp
     else if(ngaus==2) then
        quadrature%coordinates(1,1)= 0.211324865405187_rp
        quadrature%coordinates(1,2)= 0.788675134594813_rp
        quadrature%weight(  1)= 0.5_rp
        quadrature%weight(  2)= 0.5_rp
     else if(ngaus==3) then
        quadrature%coordinates(1,1)= 0.112701665379258_rp
        quadrature%coordinates(1,2)= 0.5_rp
        quadrature%coordinates(1,3)= 0.887298334620742_rp
        quadrature%weight(  1)= 0.277777777777778_rp
        quadrature%weight(  2)= 0.444444444444444_rp
        quadrature%weight(  3)= 0.277777777777778_rp
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        check(.false.)
     end if

     ! Area integral (triangles)
  else if(ndime==2) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/3.0_rp
        quadrature%weight(  1)= 1.0_rp/2.0_rp
     else if(ngaus==3) then
        quadrature%coordinates(1,2)= 2.0_rp/3.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,3)= 2.0_rp/3.0_rp
        quadrature%coordinates(1,1)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/6.0_rp
        quadrature%weight(  2)= 1.0_rp/6.0_rp
        quadrature%weight(  3)= 1.0_rp/6.0_rp
        quadrature%weight(  1)= 1.0_rp/6.0_rp
     else if(ngaus==4) then
        quadrature%coordinates(1,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(1,2)= 1.0_rp/5.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/5.0_rp
        quadrature%coordinates(1,3)= 3.0_rp/5.0_rp
        quadrature%coordinates(2,3)= 1.0_rp/5.0_rp
        quadrature%coordinates(1,4)= 1.0_rp/5.0_rp
        quadrature%coordinates(2,4)= 3.0_rp/5.0_rp
        quadrature%weight(  1)=-27.0_rp/96.0_rp
        quadrature%weight(  2)= 25.0_rp/96.0_rp
        quadrature%weight(  3)= 25.0_rp/96.0_rp
        quadrature%weight(  4)= 25.0_rp/96.0_rp 
     else if(ngaus==6) then
        ex1 = 0.816847572980459_rp
        et1 = 0.091576213509771_rp
        ez1 = 0.091576213509771_rp
        ex2 = 0.108103018168070_rp
        et2 = 0.445948490915965_rp
        ez2 = 0.445948490915965_rp
        quadrature%coordinates(1,3)= ex1
        quadrature%coordinates(2,3)= et1
        quadrature%coordinates(1,1)= et1
        quadrature%coordinates(2,1)= ez1
        quadrature%coordinates(1,6)= ez1
        quadrature%coordinates(2,6)= ex1
        quadrature%coordinates(1,4)= ex2
        quadrature%coordinates(2,4)= et2
        quadrature%coordinates(1,5)= et2
        quadrature%coordinates(2,5)= ez2
        quadrature%coordinates(1,2)= ez2
        quadrature%coordinates(2,2)= ex2
        a = 0.054975870996713638_rp
        b = 0.1116907969117165_rp    
        quadrature%weight(3)  = a
        quadrature%weight(1)  = a
        quadrature%weight(6)  = a
        quadrature%weight(4)  = b
        quadrature%weight(5)  = b
        quadrature%weight(2)  = b
     else if(ngaus==7) then
        a = 1.0_rp / 3.0_rp
        b = ( 9.0_rp + 2.0_rp * sqrt ( 15.0_rp ) ) / 21.0_rp
        c = ( 6.0_rp -          sqrt ( 15.0_rp ) ) / 21.0_rp
        d = ( 9.0_rp - 2.0_rp * sqrt ( 15.0_rp ) ) / 21.0_rp
        e = ( 6.0_rp +          sqrt ( 15.0_rp ) ) / 21.0_rp
        w1 = 0.1125_rp
        w2 = ( 155.0_rp - sqrt ( 15.0_rp ) ) / 2400.0_rp
        w3 = ( 155.0_rp + sqrt ( 15.0_rp ) ) / 2400.0_rp
        quadrature%coordinates(1,1)= a
        quadrature%coordinates(2,1)= a
        quadrature%coordinates(1,2)= b
        quadrature%coordinates(2,2)= c
        quadrature%coordinates(1,3)= c
        quadrature%coordinates(2,3)= b
        quadrature%coordinates(1,4)= c
        quadrature%coordinates(2,4)= c
        quadrature%coordinates(1,5)= d
        quadrature%coordinates(2,5)= e
        quadrature%coordinates(1,6)= e
        quadrature%coordinates(2,6)= d
        quadrature%coordinates(1,7)= e
        quadrature%coordinates(2,7)= e
        quadrature%weight(  1)= w1
        quadrature%weight(  2)= w2
        quadrature%weight(  3)= w2
        quadrature%weight(  4)= w2
        quadrature%weight(  5)= w3
        quadrature%weight(  6)= w3
        quadrature%weight(  7)= w3
     else if(ngaus==13) then
        a = 0.333333333333333_rp
        b = 0.479308067841923_rp
        c = 0.869739794195568_rp
        d = 0.638444188569809_rp
        e = 0.260345966079038_rp
        f = 0.065130102902216_rp
        g = 0.312865496004875_rp
        h = 0.048690315425316_rp
        w1=-0.149570044467670_rp/2.0_rp
        w2= 0.175615257433204_rp/2.0_rp
        w3= 0.053347235608839_rp/2.0_rp
        w4= 0.077113760890257_rp/2.0_rp
        quadrature%coordinates(1, 1)= a
        quadrature%coordinates(2, 1)= a         
        quadrature%coordinates(1, 2)= e
        quadrature%coordinates(2, 2)= e
        quadrature%coordinates(1, 3)= b
        quadrature%coordinates(2, 3)= e        
        quadrature%coordinates(1, 4)= e
        quadrature%coordinates(2, 4)= b        
        quadrature%coordinates(1, 5)= f
        quadrature%coordinates(2, 5)= f        
        quadrature%coordinates(1, 6)= c
        quadrature%coordinates(2, 6)= f        
        quadrature%coordinates(1, 7)= f
        quadrature%coordinates(2, 7)= c        
        quadrature%coordinates(1, 8)= d
        quadrature%coordinates(2, 8)= g        
        quadrature%coordinates(1, 9)= d
        quadrature%coordinates(2, 9)= h        
        quadrature%coordinates(1,10)= g
        quadrature%coordinates(2,10)= d        
        quadrature%coordinates(1,11)= g
        quadrature%coordinates(2,11)= h        
        quadrature%coordinates(1,12)= h
        quadrature%coordinates(2,12)= d        
        quadrature%coordinates(1,13)= h
        quadrature%coordinates(2,13)= g
        quadrature%weight( 1) = w1
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2
        quadrature%weight( 4) = w2
        quadrature%weight( 5) = w3
        quadrature%weight( 6) = w3
        quadrature%weight( 7) = w3
        quadrature%weight( 8) = w4
        quadrature%weight( 9) = w4
        quadrature%weight(10) = w4
        quadrature%weight(11) = w4
        quadrature%weight(12) = w4
        quadrature%weight(13) = w4
     else if(ngaus==19) then
        a = 1.0_rp / 3.0_rp
        b = 0.02063496160252593_rp
        c = 0.4896825191987370_rp
        d = 0.1258208170141290_rp
        e = 0.4370895914929355_rp
        f = 0.6235929287619356_rp
        g = 0.1882035356190322_rp
        r = 0.9105409732110941_rp
        s = 0.04472951339445297_rp
        t = 0.7411985987844980_rp
        u = 0.03683841205473626_rp
        v = 0.22196298916076573_rp

        w1 = 0.09713579628279610_rp/2.0_rp
        w2 = 0.03133470022713983_rp/2.0_rp
        w3 = 0.07782754100477543_rp/2.0_rp
        w4 = 0.07964773892720910_rp/2.0_rp
        w5 = 0.02557767565869810_rp/2.0_rp
        w6 = 0.04328353937728940_rp/2.0_rp

        quadrature%coordinates(1, 1) = a 
        quadrature%coordinates(1, 2) = b
        quadrature%coordinates(1, 3) = c 
        quadrature%coordinates(1, 4) = c 
        quadrature%coordinates(1, 5) = d 
        quadrature%coordinates(1, 6) = e
        quadrature%coordinates(1, 7) = e
        quadrature%coordinates(1, 8) = f 
        quadrature%coordinates(1, 9) = g 
        quadrature%coordinates(1,10) = g
        quadrature%coordinates(1,11) = r
        quadrature%coordinates(1,12) = s
        quadrature%coordinates(1,13) = s
        quadrature%coordinates(1,14) = t
        quadrature%coordinates(1,15) = t
        quadrature%coordinates(1,16) = u
        quadrature%coordinates(1,17) = u
        quadrature%coordinates(1,18) = v
        quadrature%coordinates(1,19) = v

        quadrature%coordinates(2, 1) = a
        quadrature%coordinates(2, 2) = c
        quadrature%coordinates(2, 3) = b
        quadrature%coordinates(2, 4) = c
        quadrature%coordinates(2, 5) = e
        quadrature%coordinates(2, 6) = d
        quadrature%coordinates(2, 7) = e
        quadrature%coordinates(2, 8) = g
        quadrature%coordinates(2, 9) = f
        quadrature%coordinates(2,10) = g
        quadrature%coordinates(2,11) = s
        quadrature%coordinates(2,12) = r
        quadrature%coordinates(2,13) = s
        quadrature%coordinates(2,14) = u
        quadrature%coordinates(2,15) = v
        quadrature%coordinates(2,16) = t
        quadrature%coordinates(2,17) = v
        quadrature%coordinates(2,18) = t
        quadrature%coordinates(2,19) = u

        quadrature%weight( 1) = w1
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2
        quadrature%weight( 4) = w2
        quadrature%weight( 5) = w3
        quadrature%weight( 6) = w3
        quadrature%weight( 7) = w3
        quadrature%weight( 8) = w4
        quadrature%weight( 9) = w4
        quadrature%weight(10) = w4
        quadrature%weight(11) = w5
        quadrature%weight(12) = w5
        quadrature%weight(13) = w5
        quadrature%weight(14) = w6
        quadrature%weight(15) = w6
        quadrature%weight(16) = w6
        quadrature%weight(17) = w6
        quadrature%weight(18) = w6
        quadrature%weight(19) = w6
     else if(ngaus==28) then
        a = 1.0_rp / 3.0_rp
        b = 0.9480217181434233_rp
        c = 0.02598914092828833_rp
        d = 0.8114249947041546_rp
        e = 0.09428750264792270_rp
        f = 0.01072644996557060_rp
        g = 0.4946367750172147_rp
        p = 0.5853132347709715_rp
        q = 0.2073433826145142_rp
        r = 0.1221843885990187_rp
        s = 0.4389078057004907_rp
        t = 0.6779376548825902_rp
        u = 0.04484167758913055_rp
        v = 0.27722066752827925_rp
        w = 0.8588702812826364_rp
        x = 0.0_rp
        y = 0.1411297187173636_rp

        w1 = 0.08797730116222190_rp/2.0_rp
        w2 = 0.008744311553736190_rp/2.0_rp
        w3 = 0.03808157199393533_rp/2.0_rp
        w4 = 0.01885544805613125_rp/2.0_rp
        w5 = 0.07215969754474100_rp/2.0_rp
        w6 = 0.06932913870553720_rp/2.0_rp
        w7 = 0.04105631542928860_rp/2.0_rp
        w8 = 0.007362383783300573_rp/2.0_rp

        quadrature%coordinates(1, 1) = a  
        quadrature%coordinates(1, 2) = b  
        quadrature%coordinates(1, 3) = c  
        quadrature%coordinates(1, 4) = c  
        quadrature%coordinates(1, 5) = d  
        quadrature%coordinates(1, 6) = e  
        quadrature%coordinates(1, 7) = e  
        quadrature%coordinates(1, 8) = f  
        quadrature%coordinates(1, 9) = g
        quadrature%coordinates(1,10) = g
        quadrature%coordinates(1,11) = p 
        quadrature%coordinates(1,12) = q 
        quadrature%coordinates(1,13) = q
        quadrature%coordinates(1,14) = r 
        quadrature%coordinates(1,15) = s 
        quadrature%coordinates(1,16) = s 
        quadrature%coordinates(1,17) = t 
        quadrature%coordinates(1,18) = t 
        quadrature%coordinates(1,19) = u 
        quadrature%coordinates(1,20) = u 
        quadrature%coordinates(1,21) = v 
        quadrature%coordinates(1,22) = v 
        quadrature%coordinates(1,23) = w 
        quadrature%coordinates(1,24) = w 
        quadrature%coordinates(1,25) = x 
        quadrature%coordinates(1,26) = x 
        quadrature%coordinates(1,27) = y 
        quadrature%coordinates(1,28) = y

        quadrature%coordinates(2, 1) = a  
        quadrature%coordinates(2, 2) = c  
        quadrature%coordinates(2, 3) = b  
        quadrature%coordinates(2, 4) = c  
        quadrature%coordinates(2, 5) = e  
        quadrature%coordinates(2, 6) = d  
        quadrature%coordinates(2, 7) = e  
        quadrature%coordinates(2, 8) = g  
        quadrature%coordinates(2, 9) = f  
        quadrature%coordinates(2,10) = g  
        quadrature%coordinates(2,11) = q  
        quadrature%coordinates(2,12) = p  
        quadrature%coordinates(2,13) = q
        quadrature%coordinates(2,14) = s  
        quadrature%coordinates(2,15) = r  
        quadrature%coordinates(2,16) = s  
        quadrature%coordinates(2,17) = u  
        quadrature%coordinates(2,18) = v  
        quadrature%coordinates(2,19) = t  
        quadrature%coordinates(2,20) = v  
        quadrature%coordinates(2,21) = t  
        quadrature%coordinates(2,22) = u  
        quadrature%coordinates(2,23) = x  
        quadrature%coordinates(2,24) = y  
        quadrature%coordinates(2,25) = w  
        quadrature%coordinates(2,26) = y  
        quadrature%coordinates(2,27) = w  
        quadrature%coordinates(2,28) = x

        quadrature%weight( 1) = w1 
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2 
        quadrature%weight( 4) = w2 
        quadrature%weight( 5) = w3 
        quadrature%weight( 6) = w3 
        quadrature%weight( 7) = w3 
        quadrature%weight( 8) = w4 
        quadrature%weight( 9) = w4 
        quadrature%weight(10) = w4 
        quadrature%weight(11) = w5 
        quadrature%weight(12) = w5 
        quadrature%weight(13) = w5
        quadrature%weight(14) = w6 
        quadrature%weight(15) = w6 
        quadrature%weight(16) = w6 
        quadrature%weight(17) = w7 
        quadrature%weight(18) = w7 
        quadrature%weight(19) = w7 
        quadrature%weight(20) = w7 
        quadrature%weight(21) = w7 
        quadrature%weight(22) = w7 
        quadrature%weight(23) = w8 
        quadrature%weight(24) = w8 
        quadrature%weight(25) = w8 
        quadrature%weight(26) = w8 
        quadrature%weight(27) = w8 
        quadrature%weight(28) = w8
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        check(.false.)
     end if

     ! Volume integral ( tetrahedra )
  else if(ndime==3) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(3,1)= 1.0_rp/4.0_rp
        quadrature%weight(1)  = 1.0_rp/6.0_rp
     else if(ngaus==4) then
        a=0.5854101966249685_rp
        b=0.1381966011250105_rp
        quadrature%coordinates(1,1)= b
        quadrature%coordinates(2,1)= b
        quadrature%coordinates(3,1)= b
        quadrature%coordinates(1,2)= a
        quadrature%coordinates(2,2)= b
        quadrature%coordinates(3,2)= b
        quadrature%coordinates(1,3)= b
        quadrature%coordinates(2,3)= a
        quadrature%coordinates(3,3)= b
        quadrature%coordinates(1,4)= b
        quadrature%coordinates(2,4)= b
        quadrature%coordinates(3,4)= a
        quadrature%weight(  1)= 1.0_rp/24.0_rp
        quadrature%weight(  2)= 1.0_rp/24.0_rp
        quadrature%weight(  3)= 1.0_rp/24.0_rp
        quadrature%weight(  4)= 1.0_rp/24.0_rp
     else if(ngaus==5) then
        quadrature%coordinates(1,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(3,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(1,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,3)= 1.0_rp/2.0_rp
        quadrature%coordinates(2,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,4)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,4)= 1.0_rp/2.0_rp
        quadrature%coordinates(3,4)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,5)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,5)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,5)= 1.0_rp/2.0_rp
        quadrature%weight(  1)=-2.0_rp/15.0_rp
        quadrature%weight(  2)= 1.5_rp/20.0_rp
        quadrature%weight(  3)= 1.5_rp/20.0_rp
        quadrature%weight(  4)= 1.5_rp/20.0_rp
        quadrature%weight(  5)= 1.5_rp/20.0_rp
     else if(ngaus==11) then
        a=0.3994035761667992_rp
        b=0.1005964238332008_rp
        c=343.0_rp/7500.0_rp/6.0_rp
        d=56.0_rp/375.0_rp/6.0_rp
        quadrature%coordinates(1,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(2,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(3,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(1,2) = 11.0_rp/14.0_rp
        quadrature%coordinates(2,2) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,2) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,3) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,3) = 11.0_rp/14.0_rp
        quadrature%coordinates(3,3) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,4) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,4) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,4) = 11.0_rp/14.0_rp
        quadrature%coordinates(1,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,6) = a
        quadrature%coordinates(2,6) = a
        quadrature%coordinates(3,6) = b
        quadrature%coordinates(1,7) = a
        quadrature%coordinates(2,7) = b
        quadrature%coordinates(3,7) = a
        quadrature%coordinates(1,8) = a
        quadrature%coordinates(2,8) = b
        quadrature%coordinates(3,8) = b
        quadrature%coordinates(1,9) = b
        quadrature%coordinates(2,9) = a
        quadrature%coordinates(3,9) = a
        quadrature%coordinates(1,10)= b
        quadrature%coordinates(2,10)= a
        quadrature%coordinates(3,10)= b
        quadrature%coordinates(1,11)= b
        quadrature%coordinates(2,11)= b
        quadrature%coordinates(3,11)= a
        quadrature%weight(1)   =-148.0_rp/1875.0_rp/6.0_rp
        quadrature%weight(2)   = c
        quadrature%weight(3)   = c
        quadrature%weight(4)   = c
        quadrature%weight(5)   = c
        quadrature%weight(6)   = d
        quadrature%weight(7)   = d
        quadrature%weight(8)   = d
        quadrature%weight(9)   = d
        quadrature%weight(10)  = d
        quadrature%weight(11)  = d
     else if(ngaus==14) then
        a=0.0673422422100983_rp
        b=0.3108859192633005_rp
        c=0.7217942490673264_rp
        d=0.0927352503108912_rp
        e=0.4544962958743506_rp
        f=0.0455037041256494_rp
        p=0.1126879257180162_rp/6.0_rp
        q=0.0734930431163619_rp/6.0_rp
        r=0.0425460207770812_rp/6.0_rp
        quadrature%coordinates(1,1) = a
        quadrature%coordinates(2,1) = b
        quadrature%coordinates(3,1) = b
        quadrature%coordinates(1,2) = b
        quadrature%coordinates(2,2) = a
        quadrature%coordinates(3,2) = b
        quadrature%coordinates(1,3) = b
        quadrature%coordinates(2,3) = b
        quadrature%coordinates(3,3) = a
        quadrature%coordinates(1,4) = b
        quadrature%coordinates(2,4) = b
        quadrature%coordinates(3,4) = b
        quadrature%coordinates(1,5) = c
        quadrature%coordinates(2,5) = d
        quadrature%coordinates(3,5) = d
        quadrature%coordinates(1,6) = d
        quadrature%coordinates(2,6) = c
        quadrature%coordinates(3,6) = d
        quadrature%coordinates(1,7) = d
        quadrature%coordinates(2,7) = d
        quadrature%coordinates(3,7) = c
        quadrature%coordinates(1,8) = d
        quadrature%coordinates(2,8) = d
        quadrature%coordinates(3,8) = d
        quadrature%coordinates(1,9) = e
        quadrature%coordinates(2,9) = e
        quadrature%coordinates(3,9) = f
        quadrature%coordinates(1,10)= e
        quadrature%coordinates(2,10)= f
        quadrature%coordinates(3,10)= e
        quadrature%coordinates(1,11)= e
        quadrature%coordinates(2,11)= f
        quadrature%coordinates(3,11)= f
        quadrature%coordinates(1,12)= f
        quadrature%coordinates(2,12)= e
        quadrature%coordinates(3,12)= e
        quadrature%coordinates(1,13)= f
        quadrature%coordinates(2,13)= e
        quadrature%coordinates(3,13)= f
        quadrature%coordinates(1,14)= f
        quadrature%coordinates(2,14)= f
        quadrature%coordinates(3,14)= e
        quadrature%weight(1)   = p
        quadrature%weight(2)   = p
        quadrature%weight(3)   = p
        quadrature%weight(4)   = p
        quadrature%weight(5)   = q
        quadrature%weight(6)   = q
        quadrature%weight(7)   = q
        quadrature%weight(8)   = q
        quadrature%weight(9)   = r
        quadrature%weight(10)  = r
        quadrature%weight(11)  = r
        quadrature%weight(12)  = r
        quadrature%weight(13)  = r
        quadrature%weight(14)  = r
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        check(.false.)
     end if
  end if

end subroutine tet_lagrangian_reference_fe_fill_symmetric_quadrature

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
recursive subroutine tet_lagrangian_reference_fe_fill_nodes_n_face(this,ntxob,c3,ini,end, &
     & i,idm,nd,k,p,objec,nt)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: ini,end,nd,k,p,objec(nd,nd+1),nt,i
  integer(ip)                         , intent(inout) :: ntxob(nt),c3,idm(nd)
  integer(ip) :: j,ijk(nd),m

  if (k==0) then
     ! Dimension 0: objec gives the coordinates of the corner
     ijk = p*objec(:,1)
     ntxob(c3) = this%get_node_local_id(ijk,nd,p)
     c3 = c3 + 1
  else
     ! Loop over the possible values of the i-th factor
     do j=ini,end
        ! Assign value of the i-th factor
        idm(i) = j
        if (i<k) then
           ! Assign values of the i+1-th factor
           call this%fill_nodes_n_face(ntxob,c3,ini,end-j,i+1,idm,nd,k,p,objec,nt)
        else
           ! Compute the coordinate of the c3-th node: objec(:,1)+idm*objec(:,2:k)
           ijk = p*objec(:,1)
           do m=1,k
              ijk = ijk+idm(k-m+1)*objec(:,m+1)
           end do
           ! Store in ntxob the corresponding identifier of the node
           ntxob(c3) = this%get_node_local_id(ijk,nd,p)
           c3 = c3 + 1
        end if
     end do
  end if

end subroutine tet_lagrangian_reference_fe_fill_nodes_n_face

!==================================================================================================
recursive subroutine tet_lagrangian_reference_fe_fill_n_face_dimension_and_vertices (this,       &
     n_face_dimension,        &
     vertex_position,      &
     number_of_dimensions, &
     initial_vertex,       &
     number_of_n_faces,       &
     n_face_id,               &
     vertices_of_n_faces,      &
     n_face_dimension_and_vertices)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: n_face_dimension
  integer(ip)                         , intent(in)    :: vertex_position
  integer(ip)                         , intent(in)    :: number_of_dimensions
  integer(ip)                         , intent(in)    :: initial_vertex
  integer(ip)                         , intent(in)    :: number_of_n_faces
  integer(ip)                         , intent(inout) :: n_face_dimension_and_vertices(:,:)
  integer(ip)                         , intent(inout) :: vertices_of_n_faces(:)
  integer(ip)                         , intent(inout) :: n_face_id
  integer(ip) :: vertex_id

  do vertex_id=initial_vertex,number_of_dimensions+1
     vertices_of_n_faces(vertex_position) = vertex_id
     if(vertex_position+1<n_face_dimension+2) then
        call this%fill_n_face_dimension_and_vertices(n_face_dimension,                      &
             vertex_position+1,                  &
             number_of_dimensions,               &
             vertices_of_n_faces(vertex_position)+1, &
             number_of_n_faces,                     &
             n_face_id,                             &
             vertices_of_n_faces,                    &
             n_face_dimension_and_vertices)
     else
        n_face_dimension_and_vertices(1,n_face_id) = n_face_dimension
        n_face_dimension_and_vertices(2:n_face_dimension+2,n_face_id) = vertices_of_n_faces(1:n_face_dimension+1)
        n_face_id = n_face_id + 1
     end if
  end do

end subroutine tet_lagrangian_reference_fe_fill_n_face_dimension_and_vertices

!=================================================================================================
recursive function tet_lagrangian_reference_fe_compute_number_interior_dofs(this,dimension,order)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this  
  integer(ip)                         , intent(in)    :: dimension, order
  integer(ip) :: tet_lagrangian_reference_fe_compute_number_interior_dofs
  integer(ip) :: q
  if (dimension == 0) then
     tet_lagrangian_reference_fe_compute_number_interior_dofs = 1
  elseif (order == 1) then
     tet_lagrangian_reference_fe_compute_number_interior_dofs = 0
  elseif (dimension == 1) then
     tet_lagrangian_reference_fe_compute_number_interior_dofs = order-1
  elseif (dimension == 2) then
     tet_lagrangian_reference_fe_compute_number_interior_dofs = int((order-2)*(order-1)/2)
  else
     tet_lagrangian_reference_fe_compute_number_interior_dofs = & 
          & this%compute_number_interior_dofs(dimension-1,1)
     do q=2,order-1
        tet_lagrangian_reference_fe_compute_number_interior_dofs =    & 
             & tet_lagrangian_reference_fe_compute_number_interior_dofs + & 
             & this%compute_number_interior_dofs(dimension-1,q)
     end do
  end if
end function tet_lagrangian_reference_fe_compute_number_interior_dofs

!=================================================================================================
function tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices(this,dimension, & 
     & ini_order,end_order)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: dimension, ini_order, end_order
  integer(ip) :: tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices
  integer(ip) :: q
  if (dimension == 0) then
     tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices = 1
  elseif (ini_order > end_order) then
     tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices = 0
  else
     tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices = & 
          & this%compute_number_nodes_scalar(dimension-1,ini_order)
     do q = ini_order+1,end_order
        tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices =   & 
             & tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices + &
             & this%compute_number_nodes_scalar(dimension-1,q)
     end do
  end if
end function tet_lagrangian_reference_fe_compute_sum_of_dofs_in_simplices

!==================================================================================================
subroutine tet_lagrangian_reference_fe_get_n_face_orientation(this,o,od,nd,io)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(inout) :: o
  integer(ip)                         , intent(in)    :: od
  integer(ip)                         , intent(in)    :: nd
  integer(ip)                         , intent(in)    :: io  ! io=numbering of the n-face in the od dimension
  if (nd == 3 .and. od == 2) then
     o = modulo(io+1,2)
  elseif (nd>3) then
     write(*,*) __FILE__,__LINE__,'WARNING!! the orientation is not defined for dimension >3'
  else
     o = 0
  end if
end subroutine tet_lagrangian_reference_fe_get_n_face_orientation

!==================================================================================================
subroutine tet_lagrangian_reference_fe_fill_interpolation_pre_basis ( this, quadrature, interpolation, order_vector ) 
  implicit none 
  class(tet_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)

  type(truncated_tensor_product_polynomial_space_t)        :: tet_polynomial_prebase
  type(polynomial_allocatable_array_t)  :: monomial_1D_basis(SPACE_DIM)
  type(monomial_t)                      :: monomial_1D

  real(rp), allocatable :: values(:)
  real(rp), allocatable :: gradients(:,:)
  integer(ip) :: idime, q_point

  do idime=1,interpolation%number_dimensions
     call monomial_1D%generate_basis(this%order_vector(idime), monomial_1D_basis(idime) )
  end do

  call tet_polynomial_prebase%create(interpolation%number_dimensions,monomial_1D_basis)
  call tet_polynomial_prebase%fill( quadrature%get_coordinates() )

  call memalloc(tet_polynomial_prebase%get_number_polynomials(),values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,tet_polynomial_prebase%get_number_polynomials(),gradients,__FILE__,__LINE__)

  do q_point=1, quadrature%get_number_quadrature_points()
     call tet_polynomial_prebase%evaluate(q_point, values, gradients)
     interpolation%shape_functions(1,:,q_point) = values(:)
     interpolation%shape_derivatives(1,:,:,q_point) = gradients(:,:)
  end do

  ! Free auxiliary memory
  if(allocated(values))    call memfree(values,__FILE__,__LINE__)
  if(allocated(gradients)) call memfree(gradients,__FILE__,__LINE__)

  do idime=1,interpolation%number_dimensions
     call monomial_1D_basis(idime)%free()
  end do
  call monomial_1D%free()
  call tet_polynomial_prebase%free()
end subroutine tet_lagrangian_reference_fe_fill_interpolation_pre_basis

!==================================================================================================
subroutine tet_lagrangian_reference_fe_change_basis(this) 
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout) ::  this

  type(interpolation_t)   :: interpolation
  integer(ip)             :: i, j, number_shape_functions_per_component

  number_shape_functions_per_component = this%number_shape_functions/this%number_field_components
  call memalloc(number_shape_functions_per_component,number_shape_functions_per_component,this%change_basis_matrix,__FILE__,__LINE__)
  call this%create_interpolation(this%nodal_quadrature,interpolation)
  do i=1,number_shape_functions_per_component
     do j=1,number_shape_functions_per_component
        !write(*,*) 'Shape',j,'point',i
        !write(*,*) interpolation%shape_functions(1,j,i)
        this%change_basis_matrix(i,j) = interpolation%shape_functions(1,j,i)
     end do
  end do
  call interpolation%free()
  call this%invert_change_basis_matrix()
  this%basis_changed = .true.
end subroutine tet_lagrangian_reference_fe_change_basis

!==================================================================================================
subroutine tet_lagrangian_reference_fe_invert_change_basis_matrix(this)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(inout) :: this 

  integer(ip) :: error
  integer(ip), allocatable :: ipiv(:)
  real(rp), allocatable :: inverse_change_basis_matrix(:,:)  
  integer(ip) :: i, number_shape_functions_per_component

  number_shape_functions_per_component = this%number_shape_functions/this%number_field_components
  assert ( allocated(this%change_basis_matrix) )
  assert ( size(this%change_basis_matrix,1) == number_shape_functions_per_component )
  assert ( size(this%change_basis_matrix,2) == number_shape_functions_per_component )

  ! Solve linear system with several RHS
  ! Compute LU factorization of this%change_basis_matrix
#ifdef ENABLE_LAPACK
  call memalloc ( number_shape_functions_per_component, ipiv, __FILE__,__LINE__ )

  call memalloc ( number_shape_functions_per_component, & 
       number_shape_functions_per_component, &
       inverse_change_basis_matrix, &
       __FILE__,__LINE__ )

  call DGETRF( number_shape_functions_per_component, & 
       number_shape_functions_per_component, &
       this%change_basis_matrix, &
       number_shape_functions_per_component, &
       ipiv, &
       error )
  check ( error == 0 )

  inverse_change_basis_matrix = 0.0_rp
  do i=1, number_shape_functions_per_component
     inverse_change_basis_matrix(i,i) = 1.0_rp
  end do

  call DGETRS( 'N', & 
       number_shape_functions_per_component, &
       number_shape_functions_per_component, &
       this%change_basis_matrix, &
       number_shape_functions_per_component, &
       ipiv, &
       inverse_change_basis_matrix, &
       number_shape_functions_per_component, &
       error )
  check ( error == 0 )

  !do i=1, this%number_shape_functions
  !   this%change_basis_matrix(i,:) = 0.0_rp!inverse_change_basis_matrix(:,i)
  !end do

  !call memfree (  inverse_change_basis_matrix, __FILE__, __LINE__  )

  if ( allocated(this%change_basis_matrix) ) call memfree (  this%change_basis_matrix, __FILE__, __LINE__  )

  call memmovealloc(inverse_change_basis_matrix, &
       this%change_basis_matrix, __FILE__, __LINE__ )
  !write(*,*) this%change_basis_matrix(1,:)
  !write(*,*) this%change_basis_matrix(2,:)
  !write(*,*) this%change_basis_matrix(3,:)
  call memfree ( ipiv, __FILE__,__LINE__ )
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_LAPACK.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the LAPACK'
  check(.false.)
#endif 

end subroutine tet_lagrangian_reference_fe_invert_change_basis_matrix

!==================================================================================================
subroutine tet_lagrangian_ref_fe_apply_change_basis_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)                   , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)                   , intent(inout) :: interpolation

  integer(ip)           :: i, j, jdime, qpoint, number_shape_functions_per_component

  ! Initialize both shape functions and derivatives to zero.
  interpolation%shape_functions   = 0.0_rp
  interpolation%shape_derivatives = 0.0_rp
  number_shape_functions_per_component = this%number_shape_functions/this%number_field_components

  ! Compute shape functions
  do qpoint = 1, interpolation%number_quadrature_points
     do i=1, number_shape_functions_per_component
        do j=1, number_shape_functions_per_component
           interpolation%shape_functions(1, i, qpoint) = interpolation%shape_functions(1, i, qpoint) + &
                this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(1, j, qpoint)
        end do
     end do
  end do

  ! Compute shape derivatives
  do qpoint = 1, interpolation%number_quadrature_points
     do i=1, number_shape_functions_per_component
        do j=1, number_shape_functions_per_component
           do jdime=1, this%number_dimensions
              interpolation%shape_derivatives(1, jdime, i, qpoint) = interpolation%shape_derivatives(1, jdime, i, qpoint) + &
                   this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(1, jdime, j, qpoint)
           end do
        end do
     end do
  end do
end subroutine tet_lagrangian_ref_fe_apply_change_basis_to_interpolation

!==================================================================================================
function tet_lagrangian_reference_fe_compute_permutation_index(source_reference_fe, target_reference_fe,          &
     &                                          source_n_face_id, target_n_face_id,         &
     &                                          source_n_faces, target_n_faces)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)  :: source_reference_fe
  class(reference_fe_t)               , intent(in)  :: target_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: source_n_faces(:)
  integer(ip)                         , intent(in)  :: target_n_faces(:) 
  integer(ip) :: tet_lagrangian_reference_fe_compute_permutation_index
  tet_lagrangian_reference_fe_compute_permutation_index = 1
end function tet_lagrangian_reference_fe_compute_permutation_index

!==================================================================================================
function tet_lagrangian_reference_fe_permute_dof_LID_n_face(this,source_dof_lid_n_face,n_face_dimension,permutation_index)
  implicit none
  class(tet_lagrangian_reference_fe_t), intent(in)  :: this
  integer(ip)                         , intent(in)  :: source_dof_lid_n_face
  integer(ip)                         , intent(in)  :: n_face_dimension
  integer(ip)                         , intent(in)  :: permutation_index
  integer(ip) :: tet_lagrangian_reference_fe_permute_dof_LID_n_face
  tet_lagrangian_reference_fe_permute_dof_LID_n_face = source_dof_lid_n_face
end function tet_lagrangian_reference_fe_permute_dof_LID_n_face


