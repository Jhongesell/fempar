! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine interpolation_create( this, &
                                 num_dims, &
                                 num_shape_functions, &
                                 num_quadrature_points, & 
                                 num_entries_symmetric_tensor, &
                                 compute_hessian )
  implicit none
  class(interpolation_t), intent(inout) :: this
  integer(ip)              , intent(in)    :: num_dims, & 
                                              num_shape_functions, & 
                                              num_quadrature_points
  integer(ip)              , intent(in)    :: num_entries_symmetric_tensor
  logical, optional        , intent(in)    :: compute_hessian

  if (.not. this%is_needed_to_allocate( num_dims,        &
                                        num_shape_functions,   &
                                        num_quadrature_points, &
                                        num_entries_symmetric_tensor,&
                                        compute_hessian&
                                      ) ) return

  call this%free()

  this%num_dims = num_dims
  this%num_shape_functions = num_shape_functions
  this%num_quadrature_points = num_quadrature_points
  this%num_entries_symmetric_tensor = num_entries_symmetric_tensor
  call memalloc(SPACE_DIM, num_shape_functions, &
                num_quadrature_points, &
                this%shape_functions, __FILE__,__LINE__, 0.0_rp)
  call memalloc(SPACE_DIM,SPACE_DIM, &
                num_shape_functions, &
                num_quadrature_points, &
                this%shape_derivatives, __FILE__, __LINE__, 0.0_rp)
  if ( present(compute_hessian) ) then
     if ( compute_hessian ) then 
        call memalloc(SPACE_DIM,num_entries_symmetric_tensor,&
                      num_shape_functions,&
                      num_quadrature_points, &
                      this%hessian,__FILE__,__LINE__) 
     end if
  end if
  
end subroutine interpolation_create

subroutine interpolation_free( this)
  implicit none
  class(interpolation_t), intent(inout) :: this
  this%num_dims = 0
  this%num_shape_functions = 0
  this%num_quadrature_points = 0
  this%num_entries_symmetric_tensor = 0
  if(allocated(this%shape_functions)) call memfree(this%shape_functions,__FILE__,__LINE__)
  if(allocated(this%shape_derivatives)) call memfree(this%shape_derivatives,   __FILE__,__LINE__)
  if(allocated(this%hessian)) call memfree(this%hessian,   __FILE__,__LINE__)
end subroutine interpolation_free

subroutine interpolation_copy(this, source_interpolation)
  implicit none
  class(interpolation_t), intent(inout) :: this
  type(interpolation_t), intent(in)     :: source_interpolation

  call this%clone(source_interpolation)

  this%shape_functions = source_interpolation%shape_functions
  this%shape_derivatives = source_interpolation%shape_derivatives
  if ( allocated(source_interpolation%hessian) ) then
				this%hessian = source_interpolation%hessian
  end if

end subroutine interpolation_copy

subroutine interpolation_clone(this, source_interpolation)
  implicit none
  class(interpolation_t), intent(inout) :: this
		type(interpolation_t), intent(in)     :: source_interpolation

  if (.not. this%is_needed_to_allocate( source_interpolation%num_dims,        & 
                                        source_interpolation%num_shape_functions,   &
                                        source_interpolation%num_quadrature_points, & 
                                        source_interpolation%num_entries_symmetric_tensor,&
                                        allocated(source_interpolation%hessian)&
                                        ) ) return
	
  call this%free()
  this%num_dims = source_interpolation%num_dims
  this%num_shape_functions = source_interpolation%num_shape_functions
  this%num_quadrature_points = source_interpolation%num_quadrature_points
  this%num_entries_symmetric_tensor = source_interpolation%num_entries_symmetric_tensor
  call memalloc(SPACE_DIM,this%num_shape_functions,this%num_quadrature_points, &
																this%shape_functions,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,SPACE_DIM,this%num_shape_functions,&
																this%num_quadrature_points,this%shape_derivatives,   __FILE__,__LINE__)
  if ( allocated(source_interpolation%hessian) ) then
    call memalloc(this%num_dims,this%num_entries_symmetric_tensor,this%num_shape_functions,&
																		this%num_quadrature_points,this%hessian,   __FILE__,__LINE__) 
  end if
end subroutine interpolation_clone



subroutine interpolation_print ( this )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip) :: i,j,k,l
  write(*,*) 'num_dims: ', this%num_dims
  write(*,*) 'num_shape_functions: ', this%num_shape_functions
  write(*,*) 'num_quadrature_points: ', this%num_quadrature_points
  write(*,*) 'num_entries_symmetric_tensor: ', this%num_entries_symmetric_tensor
  write(*,*) '*************** SHAPE FUNCTIONS ******************'
  do i = 1, size(this%shape_functions,1)
     do j = 1, size(this%shape_functions,2)
        do k = 1, size(this%shape_functions,3)
           write(*,*) 'shape function phi^',j,'_(dim_',i,')','(gp=',k,')= ',this%shape_functions(i,j,k)
        end do
     end do
  end do

  write(*,*) '*************** SHAPE DERIVATIVES ******************'                      

  do i = 1, size(this%shape_derivatives,1)                                                             
     do j = 1, size(this%shape_derivatives,2)                                                         
        do k = 1, size(this%shape_derivatives,3)                                                     
           do l = 1, size(this%shape_derivatives,4)                                                        
              write(*,*) 'shape derivative D_',j,'phi^',k,'_(dim_',i,')','(gp=',l,')= ',this%shape_derivatives(i,j,k,l)
           end do
        end do
     end do
  end do
  write(*,*) 'shape_derivatives: ', this%shape_derivatives
  if ( allocated( this%hessian ) ) then
     write(*,*) 'hessian: ', this%hessian
  else
     write(*,*) 'hessian not computed '
  end if
end subroutine interpolation_print

function interpolation_is_needed_to_allocate(              &
                                 this,                     &
                                 num_dims,        &
                                 num_shape_functions,   &
                                 num_quadrature_points, &
                                 num_entries_symmetric_tensor,&
                                 compute_hessian ) result ( is_needed )
  implicit none
  class(interpolation_t), intent(inout) :: this
  integer(ip),            intent(in)    :: num_dims
  integer(ip),            intent(in)    :: num_shape_functions
  integer(ip),            intent(in)    :: num_quadrature_points
  integer(ip),            intent(in)    :: num_entries_symmetric_tensor
  logical, optional,      intent(in)    :: compute_hessian
  logical :: is_needed

  ! We rely on the stored integers.
  ! Its is important that calling free() will set them to 0.
  ! And that they always have a valid numerical value
  is_needed = .false.
  if (this%num_dims .ne. num_dims)               is_needed = .true.
  if (this%num_shape_functions .ne. num_shape_functions)     is_needed = .true.
  if (this%num_quadrature_points .ne. num_quadrature_points) is_needed = .true.
  if (present(compute_hessian)) then
    if (compute_hessian .and. (this%num_entries_symmetric_tensor .ne. num_entries_symmetric_tensor))&
    is_needed = .true.
  end if

end function interpolation_is_needed_to_allocate
