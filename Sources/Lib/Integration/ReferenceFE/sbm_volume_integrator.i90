! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!fe_map_t type procedures
subroutine fe_map_create( this, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(fe_map_t)      , intent(inout) :: this
  type(quadrature_t)   , intent(in)    :: quadrature
  class(lagrangian_reference_fe_t), intent(in)    :: reference_fe_geometry

  integer(ip) :: number_nodes
  integer(ip) :: istat

  call this%free()
  this%number_dimensions        = reference_fe_geometry%number_dimensions
  this%number_quadrature_points = quadrature%number_quadrature_points

  call reference_fe_geometry%create_interpolation( quadrature, this%interpolation_geometry )

  call memalloc(this%number_dimensions, &
                this%number_dimensions, &
                this%number_quadrature_points, &
                this%jacobian,__FILE__,__LINE__)

  call memalloc(this%number_dimensions, &
                this%number_dimensions, &
                this%number_quadrature_points, &
                this%inv_jacobian,__FILE__,__LINE__)

  call memalloc(this%number_quadrature_points, &
                this%det_jacobian,__FILE__,__LINE__)


  allocate(this%coordinates_quadrature(this%number_quadrature_points), stat=istat)
  check(istat==0)

  number_nodes = reference_fe_geometry%get_number_shape_functions()
  allocate(this%coordinates_nodes(number_nodes), stat=istat)
  check(istat==0)

  this%reference_fe_characteristic_length = reference_fe_geometry%get_characteristic_length()
end subroutine fe_map_create

!==================================================================================================
subroutine fe_map_create_on_face( this, local_face_id, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(fe_map_t)      , intent(inout) :: this
  integer(ip)          , intent(in)    :: local_face_id
  type(quadrature_t), intent(in)    :: quadrature
  class(lagrangian_reference_fe_t), intent(in)    :: reference_fe_geometry

  integer(ip) :: number_nodes
  integer(ip) :: istat

  call this%free()
  this%number_dimensions        = reference_fe_geometry%number_dimensions
  this%number_quadrature_points = quadrature%number_quadrature_points

  call reference_fe_geometry%create_face_interpolation( local_face_id, quadrature,                &
       &                                                this%interpolation_geometry )

  call memalloc(this%number_dimensions, &
                this%number_dimensions, &
                this%number_quadrature_points, &
                this%jacobian,__FILE__,__LINE__)

  call memalloc(this%number_dimensions, &
                this%number_dimensions, &
                this%number_quadrature_points, &
                this%inv_jacobian,__FILE__,__LINE__)

  call memalloc(this%number_quadrature_points, &
                this%det_jacobian,__FILE__,__LINE__)

  allocate(this%coordinates_quadrature(this%number_quadrature_points), stat=istat)
  check(istat==0)

  number_nodes = reference_fe_geometry%get_number_shape_functions()
  allocate(this%coordinates_nodes(number_nodes), stat=istat)
  check(istat==0)

  this%reference_fe_characteristic_length = reference_fe_geometry%get_characteristic_length()
end subroutine fe_map_create_on_face

!==================================================================================================
subroutine fe_map_create_face_map(this,quadrature,reference_fe_geo )
  implicit none
  ! Parameters
  class(fe_map_t)                  , intent(inout) :: this
  type(quadrature_t)               , intent(in)    :: quadrature
  class(lagrangian_reference_fe_t) , intent(in)    :: reference_fe_geo

  integer(ip)           :: number_face_dimensions
  integer(ip)           :: number_vertices_face
  integer(ip)           :: istat
  integer(ip)           :: number_dofs_on_face
  
  call this%free()
  this%number_dimensions        = reference_fe_geo%number_dimensions
  this%number_quadrature_points = quadrature%number_quadrature_points
  number_face_dimensions        = reference_fe_geo%number_dimensions - 1

  call reference_fe_geo%create_face_local_interpolation &
       &                ( quadrature, this%interpolation_geometry)

  call memalloc(this%number_dimensions, &
                number_face_dimensions, &
                this%number_quadrature_points, &
                this%jacobian,__FILE__,__LINE__)

  call memalloc(this%number_quadrature_points, &
       this%det_jacobian,__FILE__,__LINE__)

  call memalloc(this%number_dimensions, &
                this%number_quadrature_points, &
                this%normals,__FILE__,__LINE__)

  allocate(this%coordinates_quadrature(this%number_quadrature_points), stat=istat)
  check(istat==0)

  number_dofs_on_face = reference_fe_geo%get_number_dofs_on_n_face(reference_fe_geo%get_first_face_id())
  allocate(this%coordinates_nodes(number_dofs_on_face), stat=istat)
  check(istat==0)

  this%reference_fe_characteristic_length = reference_fe_geo%get_characteristic_length()
end subroutine fe_map_create_face_map

!==================================================================================================
subroutine fe_map_create_edge_map(this, quadrature, reference_fe_geo)
  implicit none
  ! Parameters
  class(fe_map_t)                  , intent(inout) :: this
  type(quadrature_t)               , intent(in)    :: quadrature
  class(lagrangian_reference_fe_t) , intent(in)    :: reference_fe_geo

  integer(ip)           :: number_edge_dimensions
  integer(ip)           :: number_vertices_face
  integer(ip)           :: istat
  integer(ip)           :: number_dofs_on_edge
  
  call this%free()
  this%number_dimensions        = reference_fe_geo%number_dimensions
  this%number_quadrature_points = quadrature%number_quadrature_points
  number_edge_dimensions        = 1

  call reference_fe_geo%create_edge_local_interpolation &
       &                ( quadrature, this%interpolation_geometry)

  call memalloc(this%number_dimensions, &
                number_edge_dimensions, &
                this%number_quadrature_points, &
                this%jacobian,__FILE__,__LINE__)

  call memalloc(this%number_quadrature_points, &
                this%det_jacobian,__FILE__,__LINE__)

  call memalloc(this%number_dimensions, &
                this%number_quadrature_points, &
                this%tangents,__FILE__,__LINE__)

  allocate(this%coordinates_quadrature(this%number_quadrature_points), stat=istat)
  check(istat==0)

  number_dofs_on_edge = reference_fe_geo%get_number_dofs_on_n_face(reference_fe_geo%get_first_n_face_id_of_dimension(1))
  allocate(this%coordinates_nodes(number_dofs_on_edge), stat=istat)
  check(istat==0)

  this%reference_fe_characteristic_length = reference_fe_geo%get_characteristic_length()
end subroutine fe_map_create_edge_map

!==================================================================================================
subroutine fe_map_update( this, quadrature)
  !-----------------------------------------------------------------------
  ! A map obtained from the (usually isoparametric) interpolation of the geometry
  !-----------------------------------------------------------------------
  implicit none    
  class(fe_map_t)      , intent(inout) :: this
  type(quadrature_t), intent(in)    :: quadrature

  ! Locals
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  real(rp)    :: hnatu
  real(rp)    :: enor0,h_tem
  integer(ip) :: ndime,nnode,nlocs,ntens
  integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
  logical :: khes
  type(vector_field_t) :: aux_vector

  khes = .false.
  if ( allocated( this%interpolation_geometry%hessian ) ) then 
     khes = .true.
  end if

  ndime = this%interpolation_geometry%number_dimensions
  nnode = size(this%interpolation_geometry%shape_functions,2)
  nlocs = this%interpolation_geometry%number_quadrature_points

  do ilocs=1,nlocs
     ! Matmul is not thread safe
     !map%jacob(:,:,ilocs)=matmul(elcod,transpose(int%deriv(:,:,ilocs)))
     do jdime=1,ndime
        aux_vector = 0.0_rp
        do inode=1,nnode
           aux_vector = aux_vector + this%coordinates_nodes(inode) * &
                & this%interpolation_geometry%shape_derivatives(1,jdime,inode,ilocs)
        end do
        do idime=1,ndime
           this%jacobian(idime,jdime,ilocs) = aux_vector%get(idime)
        end do
     end do
     ! J^(-t)
     call invmtx(this%jacobian(:,:,ilocs),this%inv_jacobian(:,:,ilocs),this%det_jacobian(ilocs),ndime)
  end do

  ! Evaluation (Gauss) point coordinates
  call this%compute_quadrature_coordinates()

  ! ! Second derivatives of the map
  if( khes ) then
     ntens=this%interpolation_geometry%number_entries_symmetric_tensor
     ! Check that second derivativesof the map have been allocated.
     assert(ndime==size(this%d2sdx,dim=1))
     assert(nlocs==size(this%d2sdx,dim=4))

     call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
     call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
     call memalloc(ntens,wvec1,__FILE__,__LINE__)

     do ilocs=1,nlocs
        ! Transforms the array HESSI to a symmetric matrix WMAT1
        do inode=1,nnode
           do itens = 1, ntens
              wvec1(itens) = this%interpolation_geometry%hessian(1,itens,inode,ilocs)
           end do
           call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
        end do

        ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for
        ! each node
        do inode=1,nnode
           call btdbma(wmat2(1,1,inode),wmat1(1,1,inode), &
                &        this%inv_jacobian(:,:,ilocs),ndime,ndime)
        end do

        ! Obtains (d^2 s_k / d x_i d x_j) as the solution of the system
        ! (d x_l / d s_k) (d^2 s_k / d x_i d x_j) 
        !     = - (d^2 x_l / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j), 
        ! for l,i,j = 1,...,NDIME
        do kdime=1,ndime
           do idime=1,ndime
              do jdime=1,ndime
                 this%d2sdx(kdime,idime,jdime,ilocs)=0.0_rp
                 do ldime=1,ndime
                    do inode=1,nnode
                       this%d2sdx(kdime,idime,jdime,ilocs) =    &
                            & this%d2sdx(kdime,idime,jdime,ilocs) &
                            & - this%inv_jacobian(kdime,ldime,ilocs)     &
                            &   * wmat2(idime,jdime,inode) * quadrature%coordinates(ldime,inode)
                    end do
                 end do
              end do
           end do
        end do
     end do
     call memfree(wmat1,__FILE__,__LINE__)
     call memfree(wmat2,__FILE__,__LINE__)
  end if

end subroutine fe_map_update

!==================================================================================================
subroutine fe_map_update_face_map(this,local_face_id,reference_fe,quadrature)
  implicit none    
  class(fe_map_t)      , intent(inout) :: this
  integer(ip)          , intent(in)    :: local_face_id
  class(lagrangian_reference_fe_t), intent(in)    :: reference_fe
  type(quadrature_t), intent(in)    :: quadrature

  integer(ip) :: evaluation_point_id, node_id, idime, jdime, local_vef_id,  reorientation_factor
  integer(ip) :: number_face_dimensions, number_cell_dimensions, orientation_face
  type(vector_field_t) :: aux_vector

  number_face_dimensions = this%interpolation_geometry%number_dimensions
  number_cell_dimensions = reference_fe%number_dimensions
  local_vef_id = reference_fe%number_n_faces_per_dimension(number_cell_dimensions) + local_face_id - 1
  orientation_face  = reference_fe%orientation%a(local_vef_id)
  reorientation_factor = (-1)**orientation_face
  ! See comment in facet_orientation (polytope module) about the reasoning behind this
  call this%compute_quadrature_coordinates()
  ! Initialize values
  this%jacobian           = 0.0_rp
  do evaluation_point_id = 1, quadrature%number_quadrature_points

     ! Update the Jacobian Matrix
     do jdime=1, number_face_dimensions
        aux_vector = 0.0_rp
        do node_id = 1, this%interpolation_geometry%number_shape_functions
           aux_vector = aux_vector + this%coordinates_nodes(node_id) * &
                & this%interpolation_geometry%shape_derivatives(1,jdime,node_id,evaluation_point_id)
        end do
        do idime=1,number_cell_dimensions
           this%jacobian(idime,jdime,evaluation_point_id) = aux_vector%get(idime)
        end do

     end do

     ! Compute outside normals (using the Jacobian Matrix)
     if ( number_cell_dimensions == 1) then
        ! -1 and 1
        this%normals(1,evaluation_point_id) = -1.0_rp**(real(local_face_id))
     elseif ( number_cell_dimensions == 2) then
        ! dx x e_z = ( dx/dX, dx/dY, 0) x (0,0,1) = ( dx/dY, -dx/dX, 0)
        ! (normal component up to correction by orientation)
        this%normals (1,evaluation_point_id) = this%jacobian(2,1,evaluation_point_id)
        this%normals (2,evaluation_point_id) = -this%jacobian(1,1,evaluation_point_id)
     elseif ( number_cell_dimensions == 3) then
        ! dx x dy = (normal component up to correction by orientation)
        ! = (dx/dX, dx/dY, dx/dZ) x ( dy/dX, dy/dY, dy/dZ)
        call vecpro(this%jacobian(:,1,evaluation_point_id),this%jacobian(:,2,evaluation_point_id),&
             &                    this%normals(:,evaluation_point_id),3)
     end if

     ! Compute the measure of the face (= norm of the outside normal)
     this%det_jacobian(evaluation_point_id) =                                                     &
          &                         sqrt(dot_product(this%normals(:,evaluation_point_id),         &
          &                                          this%normals(:,evaluation_point_id)))

     ! Normalize the normal vector and make it point in the correct direction
     this%normals (:,evaluation_point_id) = this%normals (:,evaluation_point_id) *                &
          &                      real(reorientation_factor)/this%det_jacobian(evaluation_point_id) 
  end do
end subroutine fe_map_update_face_map

!==================================================================================================
subroutine fe_map_update_edge_map(this,local_edge_id,reference_fe,quadrature)
  implicit none    
  class(fe_map_t)      , intent(inout) :: this
  integer(ip)          , intent(in)    :: local_edge_id
  class(lagrangian_reference_fe_t), intent(in)    :: reference_fe
  type(quadrature_t), intent(in)    :: quadrature

  integer(ip) :: evaluation_point_id, node_id, idime, jdime, local_vef_id,  reorientation_factor
  integer(ip) :: number_edge_dimensions, number_cell_dimensions
  type(vector_field_t) :: aux_vector

  number_edge_dimensions = 1
  number_cell_dimensions = reference_fe%number_dimensions

  ! See comment in facet_orientation (polytope module) about the reasoning behind this
  call this%compute_quadrature_coordinates()

  ! Initialize values
  this%jacobian           = 0.0_rp
  do evaluation_point_id = 1, quadrature%number_quadrature_points
     ! Updating the Jacobian Matrix
     do jdime=1, number_edge_dimensions
        aux_vector = 0.0_rp
        do node_id = 1, this%interpolation_geometry%number_shape_functions
           aux_vector = aux_vector + this%coordinates_nodes(node_id) * &
                & this%interpolation_geometry%shape_derivatives(1,jdime,node_id,evaluation_point_id)
        end do
        do idime=1,number_cell_dimensions
           this%jacobian(idime,jdime,evaluation_point_id) = aux_vector%get(idime)
        end do

     end do

     this%tangents (:, evaluation_point_id) = this%jacobian(:, 1, evaluation_point_id)
     
     ! Compute the measure of the edge (= norm of the edge tangent)
     this%det_jacobian(evaluation_point_id) = &
          &                         sqrt(dot_product(this%tangents(:,evaluation_point_id), &
          &                                          this%tangents(:,evaluation_point_id)))

     ! Normalize the tangent vector 
     ! @amartin: How can we make the tangent to point in the right direction? 
     this%tangents (:,evaluation_point_id) = this%tangents (:,evaluation_point_id) * this%det_jacobian(evaluation_point_id) 
  end do
end subroutine fe_map_update_edge_map




!==================================================================================================
subroutine fe_map_free( this )
  implicit none
  class(fe_map_t), intent(inout) :: this
  if(allocated(this%jacobian)) call memfree(this%jacobian,__FILE__,__LINE__)
  if(allocated(this%inv_jacobian)) call memfree(this%inv_jacobian,__FILE__,__LINE__)
  if(allocated(this%det_jacobian)) call memfree(this%det_jacobian,__FILE__,__LINE__)
  if(allocated(this%d2sdx)) call memfree(this%d2sdx,__FILE__,__LINE__)
  if(allocated(this%coordinates_quadrature)) deallocate(this%coordinates_quadrature)
  if(allocated(this%coordinates_nodes)) deallocate(this%coordinates_nodes)
  if(allocated(this%normals)) call memfree(this%normals,__FILE__,__LINE__)
  if(allocated(this%tangents)) call memfree(this%tangents,__FILE__,__LINE__)
  call this%interpolation_geometry%free()
end subroutine fe_map_free

subroutine fe_map_print( this )
  implicit none
  class(fe_map_t) :: this
  integer(ip) :: i,j,k
  call this%interpolation_geometry%print()
  write(*,*) '%%%%%%%%%%%%%%%% JACOBIAN: %%%%%%%%%%%%%%%%'
  do i = 1, this%number_quadrature_points
     write(*,*) '%%%%%%%%%%%%%%%% Gauss point: ',i
     do j = 1, this%number_dimensions
        do k = 1, this%number_dimensions
           write(*,*) '%%%% (',j,',',k,') = ', this%jacobian(j,k,i)
        end do
     end do
  end do
end subroutine fe_map_print

function fe_map_get_det_jacobian ( this, i )
  implicit none
  class(fe_map_t), intent(in) :: this
  integer(ip)    , intent(in) :: i
  real(rp) :: fe_map_get_det_jacobian
  fe_map_get_det_jacobian = this%det_jacobian(i)
end function fe_map_get_det_jacobian

!==================================================================================================
function fe_map_compute_h ( this, qpoin)
  implicit none
  class(fe_map_t), intent(in) :: this
  integer(ip)    , intent(in) :: qpoin
  real(rp)                    :: fe_map_compute_h

  integer(ip) :: idime, jdime
  real(rp)    :: inverse_h(SPACE_DIM), volumetric_h
  integer(ip) :: i,j

  assert( qpoin>=1 .and. qpoin <= this%number_quadrature_points)

  inverse_h = 0.0_rp
  do idime = 1, this%number_dimensions
     do jdime = 1,  this%number_dimensions
        inverse_h(idime) = inverse_h(idime) + this%inv_jacobian(idime,jdime,qpoin)**2.0_rp
     end do
     inverse_h(idime) = sqrt(inverse_h(idime))
  end do

  volumetric_h = inverse_h(1)
  do j = 2, this%number_dimensions
     volumetric_h = volumetric_h * inverse_h(j)
  end do
  volumetric_h = 1.0_rp / volumetric_h
  volumetric_h = volumetric_h**(1.0_rp/real(this%number_dimensions))
  fe_map_compute_h = this%reference_fe_characteristic_length*volumetric_h
end function fe_map_compute_h

!==================================================================================================
function fe_map_compute_h_min ( this, qpoin)
  implicit none
  class(fe_map_t), intent(in) :: this
  integer(ip)    , intent(in) :: qpoin
  real(rp)                    :: fe_map_compute_h_min

  integer(ip) :: idime, jdime
  real(rp)    :: inverse_h(SPACE_DIM), minimum_h
  integer(ip) :: i,j

  assert( qpoin>=1 .and. qpoin <= this%number_quadrature_points)

  inverse_h = 0.0_rp
  do idime = 1, this%number_dimensions
     do jdime = 1,  this%number_dimensions
        inverse_h(idime) = inverse_h(idime) + this%inv_jacobian(idime,jdime,qpoin)**2.0_rp
     end do
     inverse_h(idime) = sqrt(inverse_h(idime))
  end do  

  minimum_h = 1.0_rp/inverse_h(1)
  do j = 2, this%number_dimensions
     minimum_h = min(minimum_h, 1.0_rp/inverse_h(j))
  end do
  fe_map_compute_h_min = this%reference_fe_characteristic_length*minimum_h
end function fe_map_compute_h_min

!==================================================================================================
function fe_map_compute_h_max ( this, qpoin)
  implicit none
  class(fe_map_t), intent(in) :: this
  integer(ip)    , intent(in) :: qpoin
  real(rp)                    :: fe_map_compute_h_max

  integer(ip) :: idime, jdime
  real(rp)    :: inverse_h(SPACE_DIM), maximum_h
  integer(ip) :: i,j

  assert( qpoin>=1 .and. qpoin <= this%number_quadrature_points)

  inverse_h = 0.0_rp
  do idime = 1, this%number_dimensions
     do jdime = 1,  this%number_dimensions
        inverse_h(idime) = inverse_h(idime) + this%inv_jacobian(idime,jdime,qpoin)**2.0_rp
     end do
     inverse_h(idime) = sqrt(inverse_h(idime))
  end do  

  maximum_h = 1.0_rp/inverse_h(1)
  do j = 2, this%number_dimensions
     maximum_h = max(maximum_h, 1.0_rp/inverse_h(j))
  end do
  fe_map_compute_h_max = this%reference_fe_characteristic_length*maximum_h
end function fe_map_compute_h_max

!==================================================================================================
function fe_map_get_coordinates(this)
  implicit none
  class(fe_map_t)   , target, intent(in) :: this
  type(point_t), pointer :: fe_map_get_coordinates(:)

  fe_map_get_coordinates => this%coordinates_nodes

end function fe_map_get_coordinates

!==================================================================================================
subroutine fe_map_get_inv_jacobian_tensor ( this, qpoin, inv_jacobian )
  implicit none
  class(fe_map_t)        , intent(in)  :: this
  integer(ip)            , intent(in)  :: qpoin
  type(tensor_field_t)   , intent(out) :: inv_jacobian
  ! Locals
  integer(ip) :: idime,jdime

  call inv_jacobian%init(0.0_rp)
  do jdime = 1, this%number_dimensions
     do idime = 1,  this%number_dimensions
        call inv_jacobian%set(idime,jdime,this%inv_jacobian(idime,jdime,qpoin))
     end do
  end do

end subroutine fe_map_get_inv_jacobian_tensor

!==================================================================================================
function fe_map_apply_inv_jacobian ( this, qpoin, v_in ) result ( v_out )
  implicit none
  class(fe_map_t)     , intent(in) :: this
  integer(ip)         , intent(in) :: qpoin
  type(vector_field_t), intent(in) :: v_in
  type(vector_field_t) :: v_out
  integer(ip)          :: idime,jdime
  real(rp)             :: vector_value

  assert( qpoin>=1 .and. qpoin <= this%number_quadrature_points)

  call v_out%init(0.0_rp)
  do jdime = 1, this%number_dimensions
     vector_value = v_in%get(jdime)
     do idime = 1,  this%number_dimensions
        call v_out%add(idime, this%inv_jacobian(idime,jdime,qpoin)*vector_value)
     end do
  end do  

end function fe_map_apply_inv_jacobian

!==================================================================================================
function fe_map_get_reference_h ( this )
  implicit none
  class(fe_map_t), intent(in) :: this
  real(rp) :: fe_map_get_reference_h
  fe_map_get_reference_h = this%reference_fe_characteristic_length
end function fe_map_get_reference_h

!==================================================================================================
subroutine fe_map_compute_quadrature_coordinates(this)
  implicit none
  class(fe_map_t), intent(inout) :: this
  integer(ip)   :: qpoin,inode,nnode,nquad

  nnode = this%interpolation_geometry%number_shape_functions
  nquad = this%number_quadrature_points
  do qpoin = 1,nquad
     call this%coordinates_quadrature(qpoin)%init(0.0_rp)
     do inode=1,nnode
        this%coordinates_quadrature(qpoin) = this%coordinates_quadrature(qpoin) + &
             & this%coordinates_nodes(inode) * this%interpolation_geometry%shape_functions(1,inode,qpoin)
     end do
  end do
  
end subroutine fe_map_compute_quadrature_coordinates

!==================================================================================================
function fe_map_get_quadrature_coordinates(this)
  implicit none
  class(fe_map_t)   , target, intent(in) :: this
  type(point_t), pointer :: fe_map_get_quadrature_coordinates(:)

  fe_map_get_quadrature_coordinates => this%coordinates_quadrature

end function fe_map_get_quadrature_coordinates

subroutine fe_map_get_normal(this, qpoint, normal)
 implicit none
 class(fe_map_t)     , intent(in)    :: this
 integer(ip)         , intent(in)    :: qpoint
 type(vector_field_t), intent(inout) :: normal
 integer(ip) :: idime
 assert ( allocated(this%normals) )
 do idime = 1, this%number_dimensions
   call normal%set(idime,this%normals(idime,qpoint))
 end do
end subroutine  fe_map_get_normal

subroutine fe_map_get_tangent(this, qpoint, tangent)
 implicit none
 class(fe_map_t)     , intent(in)    :: this
 integer(ip)         , intent(in)    :: qpoint
 type(vector_field_t), intent(inout) :: tangent 
 integer(ip) :: idime
 assert ( allocated(this%tangents) )
 do idime = 1, this%number_dimensions
   call tangent%set(idime,this%tangents(idime,qpoint))
 end do
end subroutine fe_map_get_tangent

subroutine fe_map_get_jacobian_normalized_column ( this, column_id, qpoint, normalized_column )
  implicit none
  class(fe_map_t)     , intent(in)    :: this
  integer(ip)         , intent(in)    :: column_id
  integer(ip)         , intent(in)    :: qpoint
  type(vector_field_t), intent(out)   :: normalized_column 
  
  integer(ip) :: idime
  
  call normalized_column%init(0.0_rp)
  do idime=1, this%number_dimensions
    call normalized_column%set(idime, this%jacobian(idime, column_id, qpoint))
  end do
  normalized_column = normalized_column * (1.0_rp/normalized_column%nrm2())
end subroutine fe_map_get_jacobian_normalized_column


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! p_fe_map_t type procedures
subroutine p_fe_map_allocate( this )
  implicit none
  class(p_fe_map_t), intent(inout) :: this
  allocate(this%p)
end subroutine p_fe_map_allocate

subroutine p_fe_map_free( this )
  implicit none
  class(p_fe_map_t), intent(inout) :: this
  call this%p%free()
  deallocate(this%p)
end subroutine p_fe_map_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! volume_integrator_t type procedures
subroutine volume_integrator_create( this, quadrature, reference_fe )
  implicit none
  ! Parameters
  class(volume_integrator_t), intent(inout) :: this 
  type(quadrature_t)        ,  intent(in)   :: quadrature
  class(reference_fe_t), target,  intent(in)   :: reference_fe  

  call this%free()
  
  this%number_quadrature_points = quadrature%number_quadrature_points
  this%number_shape_functions   = reference_fe%number_shape_functions
  this%reference_fe             => reference_fe

  call reference_fe%create_interpolation( quadrature, this%interpolation )
  call this%interpolation_o_map%copy(source_interpolation = this%interpolation)
end subroutine volume_integrator_create

subroutine volume_integrator_free( this )
  implicit none
  class(volume_integrator_t), intent(inout) :: this
  call this%interpolation%free()
  call this%interpolation_o_map%free()
  nullify(this%reference_fe)
  this%number_quadrature_points = 0
  this%number_shape_functions = 0
end subroutine volume_integrator_free

!==================================================================================================
subroutine volume_integrator_update( this, fe_map )
  implicit none
  class(volume_integrator_t), intent(inout) :: this
  type(fe_map_t)               , intent(in)    :: fe_map

  call this%reference_fe%update_interpolation(fe_map, this%interpolation,this%interpolation_o_map)
end subroutine volume_integrator_update
!==================================================================================================
subroutine volume_integrator_print( this )
  implicit none
  class(volume_integrator_t), intent(in) :: this
  write(*,*) 'PRINT VOLUME INTEGRATOR: '
  write(*,*) '%%%%%%%%%%%%%%%% interpolation: %%%%%%%%%%%%%%%%'
  call this%interpolation%print()
  write(*,*) '%%%%%%%%%%%%%%%% interpolation_o_map: %%%%%%%%%%%%%%%%'
  call this%interpolation_o_map%print()
end subroutine volume_integrator_print

!==================================================================================================
function volume_integrator_get_interpolation_reference_cell(this)
  implicit none
  class(volume_integrator_t), target, intent(in):: this
  type(interpolation_t), pointer ::  volume_integrator_get_interpolation_reference_cell

  volume_integrator_get_interpolation_reference_cell => this%interpolation
end function volume_integrator_get_interpolation_reference_cell

!==================================================================================================
function volume_integrator_get_interpolation_real_cell(this)
  implicit none
  class(volume_integrator_t), target, intent(in) :: this
  type(interpolation_t), pointer ::  volume_integrator_get_interpolation_real_cell

  volume_integrator_get_interpolation_real_cell => this%interpolation_o_map
end function volume_integrator_get_interpolation_real_cell

!==================================================================================================
subroutine volume_integrator_get_value_scalar (this, ishape, qpoint, scalar_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  real(rp)                     , intent(out)   :: scalar_field
  assert( this%reference_fe%field_type == field_type_scalar )
  call this%reference_fe%get_value(this%interpolation_o_map,ishape,qpoint,scalar_field)
end subroutine volume_integrator_get_value_scalar

subroutine volume_integrator_get_value_vector (this, ishape, qpoint, vector_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_vector )
  call this%reference_fe%get_value(this%interpolation_o_map,ishape,qpoint,vector_field)
end subroutine volume_integrator_get_value_vector

subroutine volume_integrator_get_value_tensor (this, ishape, qpoint, tensor_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(tensor_field_t)         , intent(out)   :: tensor_field
  assert( this%reference_fe%field_type == field_type_tensor )
end subroutine volume_integrator_get_value_tensor

subroutine volume_integrator_get_value_symmetric_tensor (this, ishape, qpoint, symmetric_tensor_field)
  implicit none
  class(volume_integrator_t)  , intent(in)    :: this
  integer(ip)                    , intent(in)    :: ishape
  integer(ip)                    , intent(in)    :: qpoint
  type(symmetric_tensor_field_t) , intent(out)   :: symmetric_tensor_field
  assert( this%reference_fe%field_type == field_type_tensor )
end subroutine volume_integrator_get_value_symmetric_tensor

subroutine volume_integrator_get_gradient_scalar (this, ishape, qpoint, vector_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_scalar )
  call this%reference_fe%get_gradient(this%interpolation_o_map,ishape,qpoint,vector_field)
end subroutine volume_integrator_get_gradient_scalar

subroutine volume_integrator_get_gradient_vector (this, ishape, qpoint, tensor_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(tensor_field_t)         , intent(out)   :: tensor_field
  assert( this%reference_fe%field_type == field_type_vector )
  call this%reference_fe%get_gradient(this%interpolation_o_map,ishape,qpoint,tensor_field)
end subroutine volume_integrator_get_gradient_vector

subroutine volume_integrator_get_symmetric_gradient_vector (this, ishape, qpoint, tensor_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: tensor_field
  assert( this%reference_fe%field_type == field_type_vector )  
end subroutine volume_integrator_get_symmetric_gradient_vector

subroutine volume_integrator_get_divergence_vector (this, ishape, qpoint, scalar_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  real(rp)                     , intent(out)   :: scalar_field
  assert( this%reference_fe%field_type == field_type_vector ) 
  call this%reference_fe%get_divergence(this%interpolation_o_map,ishape,qpoint,scalar_field)
end subroutine volume_integrator_get_divergence_vector

subroutine volume_integrator_get_divergence_tensor (this, ishape, qpoint, vector_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_tensor .or. this%reference_fe%field_type == field_type_symmetric_tensor  )
end subroutine volume_integrator_get_divergence_tensor

subroutine volume_integrator_get_curl_vector (this, ishape, qpoint, vector_field)
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_vector ) 
  call this%reference_fe%get_curl(this%interpolation_o_map,ishape,qpoint,vector_field)
end subroutine volume_integrator_get_curl_vector


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! procedures to evaluate the fe_function at the quadrature points

subroutine volume_integrator_evaluate_fe_function_scalar ( this, nodal_values, quadrature_points_values )
  implicit none
  class(volume_integrator_t), intent(in)    :: this
  real(rp)                  , intent(in)    :: nodal_values(:)
  real(rp), allocatable     , intent(inout) :: quadrature_points_values(:)

  call this%reference_fe%evaluate_fe_function ( this%interpolation_o_map, nodal_values, quadrature_points_values )
end subroutine volume_integrator_evaluate_fe_function_scalar

subroutine volume_integrator_evaluate_fe_function_vector ( this, nodal_values, quadrature_points_values )
  implicit none
  class(volume_integrator_t)       , intent(in)    :: this
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)

  call this%reference_fe%evaluate_fe_function ( this%interpolation_o_map, nodal_values, quadrature_points_values )
end subroutine volume_integrator_evaluate_fe_function_vector

subroutine volume_integrator_evaluate_fe_function_tensor ( this, nodal_values, quadrature_points_values )
  implicit none
  class(volume_integrator_t)       , intent(in)    :: this
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)

  call this%reference_fe%evaluate_fe_function ( this%interpolation_o_map, nodal_values, quadrature_points_values )
end subroutine volume_integrator_evaluate_fe_function_tensor

subroutine volume_integrator_evaluate_gradient_fe_function_scalar ( this, nodal_values, quadrature_points_values )
  implicit none
  class(volume_integrator_t)       , intent(in)    :: this
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)

  call this%reference_fe%evaluate_gradient_fe_function ( this%interpolation_o_map, nodal_values, quadrature_points_values )
end subroutine volume_integrator_evaluate_gradient_fe_function_scalar

subroutine volume_integrator_evaluate_gradient_fe_function_vector ( this, nodal_values, quadrature_points_values )
  implicit none
  class(volume_integrator_t)       , intent(in)    :: this
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)

  call this%reference_fe%evaluate_gradient_fe_function ( this%interpolation_o_map, nodal_values, quadrature_points_values )
end subroutine volume_integrator_evaluate_gradient_fe_function_vector

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! p_volume_integrator_t type procedures
subroutine p_volume_integrator_allocate( this )
  implicit none
  class(p_volume_integrator_t), intent(inout) :: this
  allocate(this%p)
end subroutine p_volume_integrator_allocate

subroutine p_volume_integrator_free( this )
  implicit none
  class(p_volume_integrator_t), intent(inout) :: this
  call this%p%free()
  deallocate(this%p)
end subroutine p_volume_integrator_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!Auxiliar routines
subroutine vecpro(v1,v2,v3,n)
  !-----------------------------------------------------------------------
  !
  ! Two and three-dimensional vectorial product of two vectors  v3 = v1 x v2.
  ! The same pointer as for v1 or v2 may be used for v3. If N = 2, it is
  !  assumed that v1 = (0,0,v1_3) and v2 = (v2_1,v2_2,0).      
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: n
  real(rp),    intent(in)  :: v2(n),v1(3)
  real(rp),    intent(out) :: v3(n)
  real(rp)                 :: c1,c2,c3

  if(n==2) then
     c1=-v1(3)*v2(2)
     c2= v1(3)*v2(1)
     v3(1)=c1
     v3(2)=c2
  else if(n==3) then
     c1=v1(2)*v2(3)-v1(3)*v2(2)
     c2=v1(3)*v2(1)-v1(1)*v2(3)
     c3=v1(1)*v2(2)-v1(2)*v2(1)
     v3(1)=c1
     v3(2)=c2
     v3(3)=c3
  end if

end subroutine vecpro

subroutine invmtx(a,b,deter,nsize)
  !-----------------------------------------------------------------------
  !
  ! This routine inverts a square matrix A -> Mat(nsize,nsize). The
  ! inverse is stored in B. Its determinant is DETER
  !    
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: nsize
  real(rp),    intent(in)  :: a(nsize,nsize)
  real(rp),    intent(out) :: b(nsize,nsize),deter
  integer(ip)              :: isize,jsize
  real(rp)                 :: denom,t1,t2,t3,t4

  select case (nsize)

  case(1)
     deter=a(1,1)
     if(deter==0.0_rp) return
     b(1,1) = 1.0_rp/a(1,1)

  case(2)
     deter=a(1,1)*a(2,2)-a(2,1)*a(1,2)
     if(deter/=0.0_rp) then
        denom=1.0_rp/deter
        b(1,1) = a(2,2)*denom
        b(2,2) = a(1,1)*denom
        b(2,1) =-a(2,1)*denom
        b(1,2) =-a(1,2)*denom 
     end if

  case(3)
     t1  = a(2,2)*a(3,3) - a(3,2)*a(2,3)
     t2  =-a(2,1)*a(3,3) + a(3,1)*a(2,3)
     t3  = a(2,1)*a(3,2) - a(3,1)*a(2,2)
     deter = a(1,1)*t1 + a(1,2)*t2 + a(1,3)*t3
     if(deter==0.0_rp) return
     denom = 1.0_rp/deter
     b(1,1) = t1*denom
     b(2,1) = t2*denom
     b(3,1) = t3*denom
     b(2,2) = ( a(1,1)*a(3,3) - a(3,1)*a(1,3))*denom
     b(3,2) = (-a(1,1)*a(3,2) + a(1,2)*a(3,1))*denom
     b(3,3) = ( a(1,1)*a(2,2) - a(2,1)*a(1,2))*denom
     b(1,2) = (-a(1,2)*a(3,3) + a(3,2)*a(1,3))*denom
     b(1,3) = ( a(1,2)*a(2,3) - a(2,2)*a(1,3))*denom
     b(2,3) = (-a(1,1)*a(2,3) + a(2,1)*a(1,3))*denom

  case(4)
     t1= a(2,2)*a(3,3)*a(4,4) + a(2,3)*a(3,4)*a(4,2)&
          + a(2,4)*a(3,2)*a(4,3) - a(2,3)*a(3,2)*a(4,4)&
          - a(2,2)*a(3,4)*a(4,3) - a(2,4)*a(3,3)*a(4,2)
     t2=-a(2,1)*a(3,3)*a(4,4) - a(2,3)*a(3,4)*a(4,1)&
          - a(2,4)*a(3,1)*a(4,3) + a(2,4)*a(3,3)*a(4,1)&
          + a(2,3)*a(3,1)*a(4,4) + a(2,1)*a(3,4)*a(4,3)
     t3=+a(2,1)*a(3,2)*a(4,4) + a(2,2)*a(3,4)*a(4,1)&
          + a(2,4)*a(3,1)*a(4,2) - a(2,4)*a(3,2)*a(4,1)&
          - a(2,2)*a(3,1)*a(4,4) - a(2,1)*a(3,4)*a(4,2)
     t4=-a(2,1)*a(3,2)*a(4,3) - a(2,2)*a(3,3)*a(4,1)&
          - a(2,3)*a(3,1)*a(4,2) + a(2,3)*a(3,2)*a(4,1)&
          + a(2,2)*a(3,1)*a(4,3) + a(2,1)*a(3,3)*a(4,2)
     deter= a(1,1)*t1 + a(1,2)*t2 + a(1,3)*t3 + a(1,4)*t4
     if(deter==0.0_rp) return
     denom=1.0_rp/deter
     b(1,1) = t1*denom
     b(2,1) = t2*denom
     b(3,1) = t3*denom
     b(4,1) = t4*denom
     b(1,2) =(- a(1,2)*a(3,3)*a(4,4) - a(1,3)*a(3,4)*a(4,2)&
          - a(1,4)*a(3,2)*a(4,3) + a(1,3)*a(3,2)*a(4,4)&
          + a(1,2)*a(3,4)*a(4,3) + a(1,4)*a(3,3)*a(4,2))*denom
     b(2,2) =(  a(1,1)*a(3,3)*a(4,4) + a(1,3)*a(3,4)*a(4,1)&
          + a(1,4)*a(3,1)*a(4,3) - a(1,4)*a(3,3)*a(4,1)&
          - a(1,3)*a(3,1)*a(4,4) - a(1,1)*a(3,4)*a(4,3))*denom
     b(3,2) =(- a(1,1)*a(3,2)*a(4,4) - a(1,2)*a(3,4)*a(4,1)&
          - a(1,4)*a(3,1)*a(4,2) + a(1,4)*a(3,2)*a(4,1)&
          + a(1,2)*a(3,1)*a(4,4) + a(1,1)*a(3,4)*a(4,2))*denom
     b(4,2) =(  a(1,1)*a(3,2)*a(4,3) + a(1,2)*a(3,3)*a(4,1)&
          + a(1,3)*a(3,1)*a(4,2) - a(1,3)*a(3,2)*a(4,1)&
          - a(1,2)*a(3,1)*a(4,3) - a(1,1)*a(3,3)*a(4,2))*denom
     b(1,3) =(  a(1,2)*a(2,3)*a(4,4) + a(1,3)*a(2,4)*a(4,2)&
          + a(1,4)*a(2,2)*a(4,3) - a(1,3)*a(2,2)*a(4,4)&
          - a(1,2)*a(2,4)*a(4,3) - a(1,4)*a(2,3)*a(4,2))*denom
     b(2,3) =(- a(1,1)*a(2,3)*a(4,4) - a(1,3)*a(2,4)*a(4,1)&
          - a(1,4)*a(2,1)*a(4,3) + a(1,4)*a(2,3)*a(4,1)&
          + a(1,3)*a(2,1)*a(4,4) + a(1,1)*a(2,4)*a(4,3))*denom
     b(3,3) =(  a(1,1)*a(2,2)*a(4,4) + a(1,2)*a(2,4)*a(4,1)&
          + a(1,4)*a(2,1)*a(4,2) - a(1,4)*a(2,2)*a(4,1)&
          - a(1,2)*a(2,1)*a(4,4) - a(1,1)*a(2,4)*a(4,2))*denom
     b(4,3) =(- a(1,1)*a(2,2)*a(4,3) - a(1,2)*a(2,3)*a(4,1)&
          - a(1,3)*a(2,1)*a(4,2) + a(1,3)*a(2,2)*a(4,1)&
          + a(1,2)*a(2,1)*a(4,3) + a(1,1)*a(2,3)*a(4,2))*denom
     b(1,4) =(- a(1,2)*a(2,3)*a(3,4) - a(1,3)*a(2,4)*a(3,2)&
          - a(1,4)*a(2,2)*a(3,3) + a(1,4)*a(2,3)*a(3,2)&
          + a(1,3)*a(2,2)*a(3,4) + a(1,2)*a(2,4)*a(3,3))*denom
     b(2,4) =(  a(1,1)*a(2,3)*a(3,4) + a(1,3)*a(2,4)*a(3,1)&
          + a(1,4)*a(2,1)*a(3,3) - a(1,4)*a(2,3)*a(3,1)&
          - a(1,3)*a(2,1)*a(3,4) - a(1,1)*a(2,4)*a(3,3))*denom
     b(3,4) =(- a(1,1)*a(2,2)*a(3,4) - a(1,2)*a(2,4)*a(3,1)&
          - a(1,4)*a(2,1)*a(3,2) + a(1,4)*a(2,2)*a(3,1)&
          + a(1,2)*a(2,1)*a(3,4) + a(1,1)*a(2,4)*a(3,2))*denom
     b(4,4) =(  a(1,1)*a(2,2)*a(3,3) + a(1,2)*a(2,3)*a(3,1)&
          + a(1,3)*a(2,1)*a(3,2) - a(1,3)*a(2,2)*a(3,1)&
          - a(1,2)*a(2,1)*a(3,3) - a(1,1)*a(2,3)*a(3,2))*denom

  case default
     b=a
     call invert(b,nsize,nsize)
  end select

end subroutine invmtx

!-----------------------------------------------------------------------
subroutine invert(a,nmax,ndm)
  !-----------------------------------------------------------------------
  !
  ! This routine performs the inversion of a ndm*ndm square matrix 
  ! or just part of it (nmax*nmax)
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)    :: ndm,nmax
  real(rp),    intent(inout) :: a(ndm,ndm)
  real(rp)                   :: d
  integer(ip)                :: n,j,i

  do n = 1,nmax
     d = a(n,n)
     do j = 1,nmax
        a(n,j) = -a(n,j)/d
     end do
     do i = 1,nmax
        if(n/=i) then
           do j = 1,nmax
              if(n/=j) a(i,j) = a(i,j) +a(i,n)*a(n,j)
           end do
        end if
        a(i,n) = a(i,n)/d
     end do
     a(n,n) = 1.0_rp/d
  end do

end subroutine invert


!-----------------------------------------------------------------------
subroutine vetoma(vecto,xmatr,ndime,ntens)
  !-----------------------------------------------------------------------
  !                                      
  ! This routine stores a vector VECTO as a symmetric matrix XMATR
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: ndime,ntens
  real(rp)   , intent(in)  :: vecto(ntens)
  real(rp)   , intent(out) :: xmatr(ndime,ndime)

  if(ndime.eq.2) then
     xmatr(1,1)=vecto(1)
     xmatr(1,2)=vecto(3)
     xmatr(2,1)=vecto(3)
     xmatr(2,2)=vecto(2)
  else
     xmatr(1,1)=vecto(1)
     xmatr(1,2)=vecto(4)
     xmatr(1,3)=vecto(5)
     xmatr(2,1)=vecto(4)
     xmatr(2,2)=vecto(2)
     xmatr(2,3)=vecto(6)
     xmatr(3,1)=vecto(5)
     xmatr(3,2)=vecto(6)
     xmatr(3,3)=vecto(3)
  end if

end subroutine vetoma

!-----------------------------------------------------------------------
subroutine btdbma(aglob,aloca,bmatr,n1,n2)
  !-----------------------------------------------------------------------
  !                                      
  ! This routine computes Ag = Bt Al B  when Ag and Al are stored as full
  ! matrices (Ag := aglob, Al := aloca, B := bmatr). The dimensions are
  ! Al -> Mat(n1,n1), Ag -> Mat(n2,n2), B -> Mat(n2,n1) 
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: n1,n2
  real(rp)   , intent(in)  :: aloca(n1,n1), bmatr(n1,n2)
  real(rp)   , intent(out) :: aglob(n2,n2)
  integer(ip)              :: i,j,k,l

  do i=1,n2
     do j=1,n2
        aglob(i,j)=0.0
        do k=1,n1
           do l=1,n1
              aglob(i,j)=aglob(i,j)+bmatr(k,i)*aloca(k,l)*bmatr(l,j)
           end do
        end do
     end do
  end do

end subroutine btdbma
