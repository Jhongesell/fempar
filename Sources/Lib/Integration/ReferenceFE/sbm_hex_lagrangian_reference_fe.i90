! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published byfill_inter
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================

subroutine hex_lagrangian_reference_fe_create(this, &
                                              topology, &
                                              number_dimensions, &
                                              order, &
                                              field_type, & 
                                              conformity, &
                                              continuity )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(inout)  :: this
  character(*)                        , intent(in)    :: topology
  integer(ip)                         , intent(in)    :: number_dimensions
  integer(ip)                         , intent(in)    :: order
  character(*)                        , intent(in)    :: field_type
  logical                             , intent(in)    :: conformity
  logical              , optional     , intent(in)    :: continuity
  call lagrangian_reference_fe_create(this,topology,number_dimensions,order,field_type,conformity,continuity)
  call this%fill_h_refinement_interpolation()
  call this%fill_h_refinement_permutations()
end subroutine hex_lagrangian_reference_fe_create

function hex_lagrangian_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: hex_lagrangian_reference_fe_check_compatibility_of_n_faces 
  integer(ip) :: idime

  select type(source_reference_fe)
     class is(hex_lagrangian_reference_fe_t)
        ! Get number nodes per dimension
     assert (target_reference_fe%number_dimensions == source_reference_fe%number_dimensions)
     do idime = 1, target_reference_fe%number_dimensions
        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
     end do
     assert (target_reference_fe%get_n_face_dimension(target_n_face_id) == source_reference_fe%get_n_face_dimension(source_n_face_id))
     assert (target_reference_fe%get_n_face_dimension(target_n_face_id) < 3)
     assert (target_reference_fe%number_field_components == source_reference_fe%number_field_components)
     assert (target_reference_fe%get_number_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_number_own_dofs_n_face(source_n_face_id))
     hex_lagrangian_reference_fe_check_compatibility_of_n_faces = .true.
     class default
     hex_lagrangian_reference_fe_check_compatibility_of_n_faces = .false.
  end select

end function hex_lagrangian_reference_fe_check_compatibility_of_n_faces

!==================================================================================================
function hex_lagrangian_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in) :: this 
  real(rp)  :: hex_lagrangian_reference_fe_get_characteristic_length 
  hex_lagrangian_reference_fe_get_characteristic_length =  2.0_rp
end function hex_lagrangian_reference_fe_get_characteristic_length

!**************************************************************************************************
! Deferred TBP implementors from lagrangian_reference_fe_t
!**************************************************************************************************

!==================================================================================================
function hex_lagrangian_reference_fe_get_number_subcells(this, num_refinements) result(num_subcells)
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                                         :: num_subcells
  num_subcells = (num_refinements+1)**this%number_dimensions
end function hex_lagrangian_reference_fe_get_number_subcells

!==================================================================================================
subroutine hex_lagrangian_reference_fe_get_subcells_connectivity(this, num_refinements, connectivity)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  integer(ip) :: order_vector(this%number_dimensions)
  integer(ip) :: num_subelems
  integer(ip) :: subelem
  integer(ip) :: geo_nnodes
  integer(ip) :: local_node
  integer(ip) :: first_coord(this%number_dimensions)
  integer(ip) :: local_coord(this%number_dimensions)
  integer(ip) :: global_coord(this%number_dimensions)
  integer(ip) :: ones_dim(this%number_dimensions)
  ones_dim = 1
  num_subelems = this%get_number_subcells(num_refinements=num_refinements)
  geo_nnodes = this%get_number_vertices()
  assert(size(connectivity,1) == geo_nnodes)
  assert(size(connectivity,2) == num_subelems)
  order_vector = num_refinements+1

  do subelem = 1, num_subelems
     !call this%get_node_local_coordinates(first_coord,subelem, & 
     !                                      & this%number_dimensions,this%order(1)-1)
     call index_to_ijk( subelem, this%number_dimensions, order_vector, first_coord )

     do local_node = 1, geo_nnodes
        !call this%get_node_local_coordinates(local_coord,local_node,this%number_dimensions,1)
        call index_to_ijk( local_node, this%number_dimensions, 2*ones_dim, local_coord )

        global_coord = first_coord + local_coord 
        !connectivity(local_node, subelem) = this%get_node_local_id(global_coord, &
        !                                                   & this%number_dimensions,this%order(1)) ! 
        connectivity(local_node, subelem) = ijk_to_index(global_coord, order_vector,this%number_dimensions)+1
     end do
  end do
end subroutine hex_lagrangian_reference_fe_get_subcells_connectivity

!==================================================================================================
subroutine hex_lagrangian_create_data_out_quadrature ( this, num_refinements, quadrature )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  type(quadrature_t)                  , intent(inout) :: quadrature

  integer(ip)        :: i
  type(node_array_t) :: node_array 
  integer(ip)        :: order_vector(SPACE_DIM)
  
  assert ( num_refinements >= 0 )

  call quadrature%free()
  
  order_vector = num_refinements+1
  call node_array%create( this%polytope, order_vector ) 

  call quadrature%create( this%number_dimensions, node_array%number_nodes )
  do i=1,this%number_dimensions
     quadrature%coordinates(i,:) = node_array%coordinates(i,:)*(2.0_rp/order_vector(i))-1.0_rp
  end do
  quadrature%weight = 1.0_rp
  
  call node_array%free()
end subroutine hex_lagrangian_create_data_out_quadrature

! @sbadia: Think about an automatic generation of gauss points for an arbitrary order
!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  !
  !     This routine sets up the integration constants of open
  !     integration rules for brick elements:
  ! 
  !          NDIME = 1             NDIME = 2             NDIME = 3
  ! 
  !      NGAUS  EXACT POL.     NGAUS  EXACT POL.     NGAUS  EXACT POL. 
  !      -----  ----------     -----  ----------     -----  ----------
  !        1      q1           1 x 1     q1          1x1x1     q1	
  !        2      q3           2 x 2     q3          2x2x2     q3   
  !        3      q5           3 x 3     q5          3x3x3     q5
  !        4      q7           4 x 4     q7          4x4x4     q7
  !        5      q9           5 x 5     q9          5x5x5     q9
  !        6      q11          6 x 6     q11         6x6x6     q11
  !        7      q13          7 x 7     q13         7x7x7     q13
  !        8      q15          8 x 8     q15         8x8x8     q15
  !       16      q31         16 x 16    q31        16x16x16   q31
  ! 
  !-----------------------------------------------------------------------
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  real(rp)    :: posgl(20),weigl(20)
  integer(ip) :: nlocs,qpoin,ilocs,jlocs,klocs,ndime,ngaus

  ndime = quadrature%number_dimensions
  ngaus = quadrature%number_quadrature_points

  if(ndime==1) then
     nlocs=ngaus
  else if(ndime==2) then
     nlocs=nint(sqrt(real(ngaus,rp)))
  else
     nlocs=nint(real(ngaus,rp)**(1.0_rp/3.0_rp))
  end if

  if(nlocs==1) then
     posgl(1)=0.0_rp
     weigl(1)=2.0_rp
  else if(nlocs==2) then
     posgl(1)=-0.577350269189626_rp
     posgl(2)= 0.577350269189626_rp
     weigl(1)= 1.0_rp
     weigl(2)= 1.0_rp
  else if(nlocs==3) then
     posgl(1)=-0.774596669241483_rp
     posgl(2)= 0.0_rp
     posgl(3)= 0.774596669241483_rp
     weigl(1)= 0.555555555555556_rp
     weigl(2)= 0.888888888888889_rp
     weigl(3)= 0.555555555555556_rp
  else if(nlocs==4)  then
     posgl(1)=-0.861136311594053_rp
     posgl(2)=-0.339981043584856_rp
     posgl(3)= 0.339981043584856_rp
     posgl(4)= 0.861136311594053_rp
     weigl(1)= 0.347854845137454_rp
     weigl(2)= 0.652145154862546_rp
     weigl(3)= 0.652145154862546_rp
     weigl(4)= 0.347854845137454_rp
  else if(nlocs==5)  then
     posgl(1) = -0.906179845938664_rp
     posgl(2) = -0.538469310105683_rp
     posgl(3) =  0.0_rp
     posgl(4) =  0.538469310105683_rp
     posgl(5) =  0.906179845938664_rp
     weigl(1) =  0.236926885056189_rp
     weigl(2) =  0.478628670499366_rp
     weigl(3) =  0.568888888888889_rp
     weigl(4) =  0.478628670499366_rp
     weigl(5) =  0.236926885056189_rp
  else if(nlocs==6)  then
     posgl(1) = -0.932469514203152_rp
     posgl(2) = -0.661209386466265_rp
     posgl(3) = -0.238619186083197_rp
     posgl(4) =  0.238619186083197_rp
     posgl(5) =  0.661209386466265_rp
     posgl(6) =  0.932469514203152_rp
     weigl(1) =  0.171324492379170_rp
     weigl(2) =  0.360761573048139_rp
     weigl(3) =  0.467913934572691_rp
     weigl(4) =  0.467913934572691_rp
     weigl(5) =  0.360761573048139_rp
     weigl(6) =  0.171324492379170_rp
  else if(nlocs==7)  then
     posgl(1) = -0.949107912342759_rp
     posgl(2) = -0.741531185599394_rp
     posgl(3) = -0.405845151377397_rp
     posgl(4) =  0.0_rp
     posgl(5) =  0.405845151377397_rp
     posgl(6) =  0.741531185599394_rp
     posgl(7) =  0.949107912342759_rp
     weigl(1) =  0.129484966168870_rp
     weigl(2) =  0.279705391489277_rp
     weigl(3) =  0.381830050505119_rp
     weigl(4) =  0.417959183673469_rp
     weigl(5) =  0.381830050505119_rp
     weigl(6) =  0.279705391489277_rp
     weigl(7) =  0.129484966168870_rp
  else if(nlocs==8)  then
     posgl(1) = -0.960289856497536_rp
     posgl(2) = -0.796666477413627_rp
     posgl(3) = -0.525532409916329_rp
     posgl(4) = -0.183434642495650_rp
     posgl(5) =  0.183434642495650_rp
     posgl(6) =  0.525532409916329_rp
     posgl(7) =  0.796666477413627_rp
     posgl(8) =  0.960289856497536_rp

     weigl(1) =  0.101228536290376_rp
     weigl(2) =  0.222381034453374_rp
     weigl(3) =  0.313706645877887_rp
     weigl(4) =  0.362683783378362_rp
     weigl(5) =  0.362683783378362_rp
     weigl(6) =  0.313706645877887_rp
     weigl(7) =  0.222381034453374_rp
     weigl(8) =  0.101228536290376_rp
  else if(nlocs== 9 )  then 
     posgl( 1 ) = 0.968160239507626_rp 
     posgl( 2 ) = 0.836031107326636_rp 
     posgl( 3 ) = 0.613371432700590_rp 
     posgl( 4 ) = 0.324253423403809_rp 
     posgl( 5 ) = 0.000000000000000_rp 
     posgl( 6 ) = -0.324253423403809_rp 
     posgl( 7 ) = -0.613371432700590_rp 
     posgl( 8 ) = -0.836031107326636_rp 
     posgl( 9 ) = -0.968160239507626_rp 

     weigl( 1 ) = 0.081274388361575_rp 
     weigl( 2 ) = 0.180648160694857_rp 
     weigl( 3 ) = 0.260610696402936_rp 
     weigl( 4 ) = 0.312347077040003_rp 
     weigl( 5 ) = 0.330239355001260_rp 
     weigl( 6 ) = 0.312347077040003_rp 
     weigl( 7 ) = 0.260610696402936_rp 
     weigl( 8 ) = 0.180648160694857_rp 
     weigl( 9 ) = 0.081274388361575_rp 
  else if(nlocs== 10 )  then 
     posgl( 1 ) = 0.973906528517172_rp 
     posgl( 2 ) = 0.865063366688985_rp 
     posgl( 3 ) = 0.679409568299024_rp 
     posgl( 4 ) = 0.433395394129247_rp 
     posgl( 5 ) = 0.148874338981631_rp 
     posgl( 6 ) = -0.148874338981631_rp 
     posgl( 7 ) = -0.433395394129247_rp 
     posgl( 8 ) = -0.679409568299024_rp 
     posgl( 9 ) = -0.865063366688985_rp 
     posgl( 10 ) = -0.973906528517172_rp 

     weigl( 1 ) = 0.066671344308688_rp 
     weigl( 2 ) = 0.149451349150581_rp 
     weigl( 3 ) = 0.219086362515982_rp 
     weigl( 4 ) = 0.269266719309996_rp 
     weigl( 5 ) = 0.295524224714753_rp 
     weigl( 6 ) = 0.295524224714753_rp 
     weigl( 7 ) = 0.269266719309996_rp 
     weigl( 8 ) = 0.219086362515982_rp 
     weigl( 9 ) = 0.149451349150581_rp 
     weigl( 10 ) = 0.066671344308688_rp 
  else if(nlocs== 11 )  then 
     posgl( 1 ) = 0.978228658146057_rp 
     posgl( 2 ) = 0.887062599768095_rp 
     posgl( 3 ) = 0.730152005574049_rp 
     posgl( 4 ) = 0.519096129206812_rp 
     posgl( 5 ) = 0.269543155952345_rp 
     posgl( 6 ) = 0.000000000000000_rp 
     posgl( 7 ) = -0.269543155952345_rp 
     posgl( 8 ) = -0.519096129206812_rp 
     posgl( 9 ) = -0.730152005574049_rp 
     posgl( 10 ) = -0.887062599768095_rp 
     posgl( 11 ) = -0.978228658146057_rp 

     weigl( 1 ) = 0.055668567116174_rp 
     weigl( 2 ) = 0.125580369464904_rp 
     weigl( 3 ) = 0.186290210927734_rp 
     weigl( 4 ) = 0.233193764591990_rp 
     weigl( 5 ) = 0.262804544510247_rp 
     weigl( 6 ) = 0.272925086777901_rp 
     weigl( 7 ) = 0.262804544510247_rp 
     weigl( 8 ) = 0.233193764591990_rp 
     weigl( 9 ) = 0.186290210927734_rp 
     weigl( 10 ) = 0.125580369464904_rp 
     weigl( 11 ) = 0.055668567116174_rp 
  else if(nlocs== 12 )  then 
     posgl( 1 ) = 0.981560634246719_rp 
     posgl( 2 ) = 0.904117256370475_rp 
     posgl( 3 ) = 0.769902674194305_rp 
     posgl( 4 ) = 0.587317954286617_rp 
     posgl( 5 ) = 0.367831498998180_rp 
     posgl( 6 ) = 0.125233408511469_rp 
     posgl( 7 ) = -0.125233408511469_rp 
     posgl( 8 ) = -0.367831498998180_rp 
     posgl( 9 ) = -0.587317954286617_rp 
     posgl( 10 ) = -0.769902674194305_rp 
     posgl( 11 ) = -0.904117256370475_rp 
     posgl( 12 ) = -0.981560634246719_rp 

     weigl( 1 ) = 0.047175336386512_rp 
     weigl( 2 ) = 0.106939325995318_rp 
     weigl( 3 ) = 0.160078328543346_rp 
     weigl( 4 ) = 0.203167426723066_rp 
     weigl( 5 ) = 0.233492536538355_rp 
     weigl( 6 ) = 0.249147045813403_rp 
     weigl( 7 ) = 0.249147045813403_rp 
     weigl( 8 ) = 0.233492536538355_rp 
     weigl( 9 ) = 0.203167426723066_rp 
     weigl( 10 ) = 0.160078328543346_rp 
     weigl( 11 ) = 0.106939325995318_rp 
     weigl( 12 ) = 0.047175336386512_rp 
  else if(nlocs== 13 )  then 
     posgl( 1 ) = 0.984183054718588_rp 
     posgl( 2 ) = 0.917598399222978_rp 
     posgl( 3 ) = 0.801578090733310_rp 
     posgl( 4 ) = 0.642349339440340_rp 
     posgl( 5 ) = 0.448492751036447_rp 
     posgl( 6 ) = 0.230458315955135_rp 
     posgl( 7 ) = 0.000000000000000_rp 
     posgl( 8 ) = -0.230458315955135_rp 
     posgl( 9 ) = -0.448492751036447_rp 
     posgl( 10 ) = -0.642349339440340_rp 
     posgl( 11 ) = -0.801578090733310_rp 
     posgl( 12 ) = -0.917598399222978_rp 
     posgl( 13 ) = -0.984183054718588_rp 

     weigl( 1 ) = 0.040484004765316_rp 
     weigl( 2 ) = 0.092121499837728_rp 
     weigl( 3 ) = 0.138873510219787_rp 
     weigl( 4 ) = 0.178145980761946_rp 
     weigl( 5 ) = 0.207816047536888_rp 
     weigl( 6 ) = 0.226283180262897_rp 
     weigl( 7 ) = 0.232551553230874_rp 
     weigl( 8 ) = 0.226283180262897_rp 
     weigl( 9 ) = 0.207816047536888_rp 
     weigl( 10 ) = 0.178145980761946_rp 
     weigl( 11 ) = 0.138873510219787_rp 
     weigl( 12 ) = 0.092121499837728_rp 
     weigl( 13 ) = 0.040484004765316_rp 
  else if(nlocs== 14 )  then 
     posgl( 1 ) = 0.986283808696812_rp 
     posgl( 2 ) = 0.928434883663574_rp 
     posgl( 3 ) = 0.827201315069765_rp 
     posgl( 4 ) = 0.687292904811685_rp 
     posgl( 5 ) = 0.515248636358154_rp 
     posgl( 6 ) = 0.319112368927890_rp 
     posgl( 7 ) = 0.108054948707344_rp 
     posgl( 8 ) = -0.108054948707344_rp 
     posgl( 9 ) = -0.319112368927890_rp 
     posgl( 10 ) = -0.515248636358154_rp 
     posgl( 11 ) = -0.687292904811685_rp 
     posgl( 12 ) = -0.827201315069765_rp 
     posgl( 13 ) = -0.928434883663574_rp 
     posgl( 14 ) = -0.986283808696812_rp 

     weigl( 1 ) = 0.035119460331752_rp 
     weigl( 2 ) = 0.080158087159760_rp 
     weigl( 3 ) = 0.121518570687903_rp 
     weigl( 4 ) = 0.157203167158194_rp 
     weigl( 5 ) = 0.185538397477938_rp 
     weigl( 6 ) = 0.205198463721296_rp 
     weigl( 7 ) = 0.215263853463158_rp 
     weigl( 8 ) = 0.215263853463158_rp 
     weigl( 9 ) = 0.205198463721296_rp 
     weigl( 10 ) = 0.185538397477938_rp 
     weigl( 11 ) = 0.157203167158194_rp 
     weigl( 12 ) = 0.121518570687903_rp 
     weigl( 13 ) = 0.080158087159760_rp 
     weigl( 14 ) = 0.035119460331752_rp 
  else if(nlocs== 15 )  then 
     posgl( 1 ) = 0.987992518020485_rp 
     posgl( 2 ) = 0.937273392400706_rp 
     posgl( 3 ) = 0.848206583410427_rp 
     posgl( 4 ) = 0.724417731360170_rp 
     posgl( 5 ) = 0.570972172608539_rp 
     posgl( 6 ) = 0.394151347077563_rp 
     posgl( 7 ) = 0.201194093997435_rp 
     posgl( 8 ) = 0.000000000000000_rp 
     posgl( 9 ) = -0.201194093997435_rp 
     posgl( 10 ) = -0.394151347077563_rp 
     posgl( 11 ) = -0.570972172608539_rp 
     posgl( 12 ) = -0.724417731360170_rp 
     posgl( 13 ) = -0.848206583410427_rp 
     posgl( 14 ) = -0.937273392400706_rp 
     posgl( 15 ) = -0.987992518020485_rp 

     weigl( 1 ) = 0.030753241996117_rp 
     weigl( 2 ) = 0.070366047488108_rp 
     weigl( 3 ) = 0.107159220467172_rp 
     weigl( 4 ) = 0.139570677926154_rp 
     weigl( 5 ) = 0.166269205816994_rp 
     weigl( 6 ) = 0.186161000015562_rp 
     weigl( 7 ) = 0.198431485327112_rp 
     weigl( 8 ) = 0.202578241925561_rp 
     weigl( 9 ) = 0.198431485327112_rp 
     weigl( 10 ) = 0.186161000015562_rp 
     weigl( 11 ) = 0.166269205816994_rp 
     weigl( 12 ) = 0.139570677926154_rp 
     weigl( 13 ) = 0.107159220467172_rp 
     weigl( 14 ) = 0.070366047488108_rp 
     weigl( 15 ) = 0.030753241996117_rp 
  else if(nlocs==16)  then
     posgl( 1) =-0.98940093499165_rp
     posgl( 2) =-0.94457502307323_rp
     posgl( 3) =-0.86563120238783_rp
     posgl( 4) =-0.75540440835500_rp
     posgl( 5) =-0.61787624440264_rp
     posgl( 6) =-0.45801677765723_rp
     posgl( 7) =-0.28160355077926_rp
     posgl( 8) =-0.09501250983764_rp
     posgl( 9) = 0.09501250983764_rp
     posgl(10) = 0.28160355077926_rp
     posgl(11) = 0.45801677765723_rp
     posgl(12) = 0.61787624440264_rp
     posgl(13) = 0.75540440835500_rp
     posgl(14) = 0.86563120238783_rp
     posgl(15) = 0.94457502307323_rp
     posgl(16) = 0.98940093499165_rp

     weigl( 1) =  0.02715245941175_rp
     weigl( 2) =  0.06225352393865_rp
     weigl( 3) =  0.09515851168249_rp
     weigl( 4) =  0.12462897125553_rp
     weigl( 5) =  0.14959598881658_rp
     weigl( 6) =  0.16915651939500_rp
     weigl( 7) =  0.18260341504492_rp
     weigl( 8) =  0.18945061045507_rp
     weigl( 9) =  0.18945061045507_rp
     weigl(10) =  0.18260341504492_rp
     weigl(11) =  0.16915651939500_rp
     weigl(12) =  0.14959598881658_rp
     weigl(13) =  0.12462897125553_rp
     weigl(14) =  0.09515851168249_rp
     weigl(15) =  0.06225352393865_rp
     weigl(16) =  0.02715245941175_rp
  else if(nlocs== 17 )  then 
     posgl( 1 ) = 0.990575475314417_rp 
     posgl( 2 ) = 0.950675521768768_rp 
     posgl( 3 ) = 0.880239153726986_rp 
     posgl( 4 ) = 0.781514003896801_rp 
     posgl( 5 ) = 0.657671159216691_rp 
     posgl( 6 ) = 0.512690537086477_rp 
     posgl( 7 ) = 0.351231763453876_rp 
     posgl( 8 ) = 0.178484181495848_rp 
     posgl( 9 ) = 0.000000000000000_rp 
     posgl( 10 ) = -0.178484181495848_rp 
     posgl( 11 ) = -0.351231763453876_rp 
     posgl( 12 ) = -0.512690537086477_rp 
     posgl( 13 ) = -0.657671159216691_rp 
     posgl( 14 ) = -0.781514003896801_rp 
     posgl( 15 ) = -0.880239153726986_rp 
     posgl( 16 ) = -0.950675521768768_rp 
     posgl( 17 ) = -0.990575475314417_rp 

     weigl( 1 ) = 0.024148302868548_rp 
     weigl( 2 ) = 0.055459529373987_rp 
     weigl( 3 ) = 0.085036148317179_rp 
     weigl( 4 ) = 0.111883847193404_rp 
     weigl( 5 ) = 0.135136368468525_rp 
     weigl( 6 ) = 0.154045761076810_rp 
     weigl( 7 ) = 0.168004102156450_rp 
     weigl( 8 ) = 0.176562705366993_rp 
     weigl( 9 ) = 0.179446470356207_rp 
     weigl( 10 ) = 0.176562705366993_rp 
     weigl( 11 ) = 0.168004102156450_rp 
     weigl( 12 ) = 0.154045761076810_rp 
     weigl( 13 ) = 0.135136368468525_rp 
     weigl( 14 ) = 0.111883847193404_rp 
     weigl( 15 ) = 0.085036148317179_rp 
     weigl( 16 ) = 0.055459529373987_rp 
     weigl( 17 ) = 0.024148302868548_rp 
  else if(nlocs== 18 )  then 
     posgl( 1 ) = 0.991565168420931_rp 
     posgl( 2 ) = 0.955823949571398_rp 
     posgl( 3 ) = 0.892602466497556_rp 
     posgl( 4 ) = 0.803704958972523_rp 
     posgl( 5 ) = 0.691687043060353_rp 
     posgl( 6 ) = 0.559770831073948_rp 
     posgl( 7 ) = 0.411751161462843_rp 
     posgl( 8 ) = 0.251886225691506_rp 
     posgl( 9 ) = 0.084775013041735_rp 
     posgl( 10 ) = -0.084775013041735_rp 
     posgl( 11 ) = -0.251886225691506_rp 
     posgl( 12 ) = -0.411751161462843_rp 
     posgl( 13 ) = -0.559770831073948_rp 
     posgl( 14 ) = -0.691687043060353_rp 
     posgl( 15 ) = -0.803704958972523_rp 
     posgl( 16 ) = -0.892602466497556_rp 
     posgl( 17 ) = -0.955823949571398_rp 
     posgl( 18 ) = -0.991565168420931_rp 

     weigl( 1 ) = 0.021616013526483_rp 
     weigl( 2 ) = 0.049714548894969_rp 
     weigl( 3 ) = 0.076425730254889_rp 
     weigl( 4 ) = 0.100942044106287_rp 
     weigl( 5 ) = 0.122555206711478_rp 
     weigl( 6 ) = 0.140642914670651_rp 
     weigl( 7 ) = 0.154684675126265_rp 
     weigl( 8 ) = 0.164276483745833_rp 
     weigl( 9 ) = 0.169142382963144_rp 
     weigl( 10 ) = 0.169142382963144_rp 
     weigl( 11 ) = 0.164276483745833_rp 
     weigl( 12 ) = 0.154684675126265_rp 
     weigl( 13 ) = 0.140642914670651_rp 
     weigl( 14 ) = 0.122555206711478_rp 
     weigl( 15 ) = 0.100942044106287_rp 
     weigl( 16 ) = 0.076425730254889_rp 
     weigl( 17 ) = 0.049714548894969_rp 
     weigl( 18 ) = 0.021616013526483_rp 
  else if(nlocs== 19 )  then 
     posgl( 1 ) = 0.992406843843584_rp 
     posgl( 2 ) = 0.960208152134830_rp 
     posgl( 3 ) = 0.903155903614818_rp 
     posgl( 4 ) = 0.822714656537143_rp 
     posgl( 5 ) = 0.720966177335229_rp 
     posgl( 6 ) = 0.600545304661681_rp 
     posgl( 7 ) = 0.464570741375961_rp 
     posgl( 8 ) = 0.316564099963630_rp 
     posgl( 9 ) = 0.160358645640225_rp 
     posgl( 10 ) = 0.000000000000000_rp 
     posgl( 11 ) = -0.160358645640225_rp 
     posgl( 12 ) = -0.316564099963630_rp 
     posgl( 13 ) = -0.464570741375961_rp 
     posgl( 14 ) = -0.600545304661681_rp 
     posgl( 15 ) = -0.720966177335229_rp 
     posgl( 16 ) = -0.822714656537143_rp 
     posgl( 17 ) = -0.903155903614818_rp 
     posgl( 18 ) = -0.960208152134830_rp 
     posgl( 19 ) = -0.992406843843584_rp 

     weigl( 1 ) = 0.019461788229726_rp 
     weigl( 2 ) = 0.044814226765699_rp 
     weigl( 3 ) = 0.069044542737641_rp 
     weigl( 4 ) = 0.091490021622450_rp 
     weigl( 5 ) = 0.111566645547334_rp 
     weigl( 6 ) = 0.128753962539336_rp 
     weigl( 7 ) = 0.142606702173607_rp 
     weigl( 8 ) = 0.152766042065860_rp 
     weigl( 9 ) = 0.158968843393954_rp 
     weigl( 10 ) = 0.161054449848784_rp 
     weigl( 11 ) = 0.158968843393954_rp 
     weigl( 12 ) = 0.152766042065860_rp 
     weigl( 13 ) = 0.142606702173607_rp 
     weigl( 14 ) = 0.128753962539336_rp 
     weigl( 15 ) = 0.111566645547334_rp 
     weigl( 16 ) = 0.091490021622450_rp 
     weigl( 17 ) = 0.069044542737641_rp 
     weigl( 18 ) = 0.044814226765699_rp 
     weigl( 19 ) = 0.019461788229726_rp 
  else if(nlocs== 20 )  then 
     posgl( 1 ) = 0.993128599185095_rp 
     posgl( 2 ) = 0.963971927277914_rp 
     posgl( 3 ) = 0.912234428251326_rp 
     posgl( 4 ) = 0.839116971822219_rp 
     posgl( 5 ) = 0.746331906460151_rp 
     posgl( 6 ) = 0.636053680726515_rp 
     posgl( 7 ) = 0.510867001950827_rp 
     posgl( 8 ) = 0.373706088715420_rp 
     posgl( 9 ) = 0.227785851141645_rp 
     posgl( 10 ) = 0.076526521133497_rp 
     posgl( 11 ) = -0.076526521133497_rp 
     posgl( 12 ) = -0.227785851141645_rp 
     posgl( 13 ) = -0.373706088715420_rp 
     posgl( 14 ) = -0.510867001950827_rp 
     posgl( 15 ) = -0.636053680726515_rp 
     posgl( 16 ) = -0.746331906460151_rp 
     posgl( 17 ) = -0.839116971822219_rp 
     posgl( 18 ) = -0.912234428251326_rp 
     posgl( 19 ) = -0.963971927277914_rp 
     posgl( 20 ) = -0.993128599185095_rp 

     weigl( 1 ) = 0.017614007139152_rp 
     weigl( 2 ) = 0.040601429800387_rp 
     weigl( 3 ) = 0.062672048334109_rp 
     weigl( 4 ) = 0.083276741576705_rp 
     weigl( 5 ) = 0.101930119817240_rp 
     weigl( 6 ) = 0.118194531961518_rp 
     weigl( 7 ) = 0.131688638449177_rp 
     weigl( 8 ) = 0.142096109318382_rp 
     weigl( 9 ) = 0.149172986472604_rp 
     weigl( 10 ) = 0.152753387130726_rp 
     weigl( 11 ) = 0.152753387130726_rp 
     weigl( 12 ) = 0.149172986472604_rp 
     weigl( 13 ) = 0.142096109318382_rp 
     weigl( 14 ) = 0.131688638449177_rp 
     weigl( 15 ) = 0.118194531961518_rp 
     weigl( 16 ) = 0.101930119817240_rp 
     weigl( 17 ) = 0.083276741576705_rp 
     weigl( 18 ) = 0.062672048334109_rp 
     weigl( 19 ) = 0.040601429800387_rp 
     weigl( 20 ) = 0.017614007139152_rp 
  else
     write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',nlocs
     check(.false.)
  end if

  if(ndime==1) then
     qpoin=0
     do ilocs=1,nlocs
        qpoin=qpoin+1
        quadrature%weight(  qpoin)=weigl(ilocs)
        quadrature%coordinates(1,qpoin)=posgl(ilocs)
     end do
  else if(ndime==2) then
     qpoin=0
     do jlocs=1,nlocs
        do ilocs=1,nlocs
           qpoin=qpoin+1
           quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)
           quadrature%coordinates(1,qpoin)=posgl(ilocs)
           quadrature%coordinates(2,qpoin)=posgl(jlocs)
        end do
     end do
  else if(ndime==3) then
     qpoin=0
     do klocs=1,nlocs
        do jlocs=1,nlocs
           do ilocs=1,nlocs
              qpoin=qpoin+1
              quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)*weigl(klocs)
              quadrature%coordinates(1,qpoin)=posgl(ilocs)
              quadrature%coordinates(2,qpoin)=posgl(jlocs)
              quadrature%coordinates(3,qpoin)=posgl(klocs)
           end do
        end do
     end do
  end if

end subroutine hex_lagrangian_reference_fe_fill_quadrature

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_nodal_quadrature( this, quadrature )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip) :: i
  do i=1,this%number_dimensions
     quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)*(2.0_rp/this%order_vector(i))-1.0_rp
  end do
  quadrature%weight = 1.0_rp
end subroutine hex_lagrangian_reference_fe_fill_nodal_quadrature

! This subroutine fills the interpolation using the polynomial_names machinery
!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation    
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)
  type(tensor_product_polynomial_space_t) :: tensor_product_polynomial_space
  type(polynomial_allocatable_array_t)    :: polynomial_1D_basis(SPACE_DIM)
  type(lagrange_polynomial_t)             :: polynomial_1D

  real(rp), allocatable :: tensor_product_values(:)
  real(rp), allocatable :: tensor_product_gradients(:,:)

  integer(ip) :: idime, q_point

  do idime=1,interpolation%number_dimensions
     call polynomial_1D%generate_basis( this%order_vector(idime), polynomial_1D_basis(idime) )
  end do

  call tensor_product_polynomial_space%create(interpolation%number_dimensions,polynomial_1D_basis)
  call tensor_product_polynomial_space%fill( quadrature%get_coordinates() )

  !assert ( interpolation%number_shape_functions == tensor_product_polynomial_space%get_number_polynomials() )

  call memalloc(tensor_product_polynomial_space%get_number_polynomials(),tensor_product_values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,tensor_product_polynomial_space%get_number_polynomials(),tensor_product_gradients,__FILE__,__LINE__)

  do q_point=1, quadrature%get_number_quadrature_points()
     do idime = 1, interpolation%number_dimensions
        call tensor_product_polynomial_space%evaluate(q_point, &
             tensor_product_values, &
             tensor_product_gradients)
        interpolation%shape_functions(1,:,q_point) = tensor_product_values(:)
        interpolation%shape_derivatives(1,:,:,q_point) = tensor_product_gradients(:,:)
     end do
  end do

  ! Free auxiliary memory
  if(allocated(tensor_product_values))    call memfree(tensor_product_values,__FILE__,__LINE__)
  if(allocated(tensor_product_gradients)) call memfree(tensor_product_gradients,__FILE__,__LINE__)
  do idime=1,interpolation%number_dimensions
     call polynomial_1D_basis(idime)%free()
  end do
  call polynomial_1D%free()
  call tensor_product_polynomial_space%free()

end subroutine hex_lagrangian_reference_fe_fill_interpolation

! Here we define the dim-1 quadrature and next translate the nodes
! using the facet type to dim. Next, use the same machinary as for the volume with this new quadrature.
!!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_face_interpolation( this, local_quadrature, local_face_id, face_interpolation )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: local_quadrature
  integer(ip)                         , intent(in)    :: local_face_id
  type(interpolation_t)               , intent(inout) :: face_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c,idime,iface,n_face_index
  ! Add offset to have same numbering as in polytope
  n_face_index = local_face_id+this%get_first_face_id()-1
  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%number_dimensions, local_quadrature%number_quadrature_points )
  c = 0
  do idime = 0,this%number_dimensions-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = -1.0_rp
     else
        aux_quadrature%coordinates(idime+1,:) = 1.0_rp
     end if
  end do
  call this%fill_interpolation( aux_quadrature, face_interpolation ) 
  call aux_quadrature%free()
end subroutine hex_lagrangian_reference_fe_fill_face_interpolation

!==================================================================================================
subroutine index_to_ijk( index, ndime, n_pols_dim, ijk )
  implicit none
  integer(ip)                         , intent(in) :: index
  integer(ip)                         , intent(in) :: ndime
  integer(ip)                         , intent(in) :: n_pols_dim(SPACE_DIM)
  integer(ip)                         , intent(inout) :: ijk(SPACE_DIM)
  integer(ip) :: i,aux
  ijk = 0
  aux = (index-1)
  do i = 1,ndime-1
     ijk(i) = mod(aux, n_pols_dim(i))
     aux = aux/n_pols_dim(i)
  end do
  ijk(ndime) = aux
  !ijk(1:ndime) = ijk(1:ndime)
end subroutine index_to_ijk

! @sbadia: It could be replaced by an anisotropic quadrature
!==================================================================================================
function hex_lagrangian_reference_fe_compute_number_quadrature_points( this, degree, dimension )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: degree
  integer(ip)                         , intent(in)    :: dimension
  integer(ip) :: hex_lagrangian_reference_fe_compute_number_quadrature_points
  hex_lagrangian_reference_fe_compute_number_quadrature_points = int(ceiling(real(degree + 1,rp)/2.0_rp)**real(dimension,rp),ip)
end function hex_lagrangian_reference_fe_compute_number_quadrature_points

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_qpoints_permutations(this, quadrature, qpoints_perm)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
  integer(ip)    :: ndime, n_q_points, order
  
  ndime      = quadrature%get_number_dimensions()
  n_q_points = quadrature%get_number_quadrature_points()
  order      = int(real(n_q_points,rp)**(1.0_rp/real(ndime,rp)),ip)+1
  
  call this%node_array%fill_permutations( order, &
                                          ndime, &
                                          this%polytope, &
                                          qpoints_perm )
  
end subroutine hex_lagrangian_reference_fe_fill_qpoints_permutations


!==================================================================================================
subroutine hex_lagrangian_reference_fe_free ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this 
  call this%h_refinement_interpolation%free()
  if ( allocated(this%h_refinement_subface_permutation) ) then
     call memfree(this%h_refinement_subface_permutation,__FILE__,__LINE__)
  end if
  if ( allocated(this%h_refinement_subedge_permutation) ) then
     call memfree(this%h_refinement_subedge_permutation,__FILE__,__LINE__)
  end if
  call lagrangian_reference_fe_free ( this )
end subroutine hex_lagrangian_reference_fe_free

! Subroutine to deal with high order parametrizations of the boundary
!==================================================================================================
subroutine hex_lagrangian_reference_fe_blending(this,values)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(point_t)                       , intent(inout) :: values(:)

  integer(ip) :: i,j, ipoin, nlocs, ndime,nnode

  assert(size(values) == this%node_array%number_nodes)

  ndime = this%number_dimensions
  nnode = this%node_array%number_nodes

  if(ndime==1) then
     nlocs=nnode
  else if(ndime==2) then
     nlocs=nint(sqrt(real(nnode,rp)))
  else
     nlocs=nint(real(nnode,rp)**(1.0_rp/3.0_rp))
  end if

  if(ndime==2) then
     !ipoin=0
     do j = 2, nlocs - 1
        do i = 2, nlocs - 1
           ipoin = nlocs*(j-1)+i
           !ipoin = ipoin + 1
           call blend_2D(this%nodal_quadrature%coordinates(1,ipoin), & ! reference coordinates
                &        this%nodal_quadrature%coordinates(2,ipoin), &
                &        values(1), &                 ! value at vertex 1
                &        values(nlocs), &             ! value at vertex 2
                &        values(nlocs*(nlocs-1)+1), & ! value at vertex 3
                &        values(nlocs*nlocs), &       ! value at vertex 4
                &        values(i), &                 ! value at edge 5
                &        values(nlocs*(nlocs-1)+i), & ! value at edge 6
                &        values(nlocs*(j-1)+1), &     ! value at edge 7
                &        values(nlocs*j), &           ! value at edge 8
                &        values(ipoin))               ! interpolated value

        end do
     end do
  end if

end subroutine hex_lagrangian_reference_fe_blending

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_h_refinement_interpolation ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this
  type(quadrature_t) :: h_refined_quadrature
  integer(ip)        :: num_refinements
  num_refinements = 1
  call this%create_data_out_quadrature( (num_refinements+1)*this%order-1, h_refined_quadrature )
  call this%create_interpolation( h_refined_quadrature, this%h_refinement_interpolation )
  call h_refined_quadrature%free()
end subroutine hex_lagrangian_reference_fe_fill_h_refinement_interpolation

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_h_refinement_permutations ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this
  call this%fill_n_subface_permutation(this%number_dimensions-1, &
                                       this%h_refinement_subface_permutation)
  if ( this%number_dimensions == 3 ) then
     call this%fill_n_subface_permutation(this%number_dimensions-2, &
                                          this%h_refinement_subedge_permutation)
  end if
end subroutine hex_lagrangian_reference_fe_fill_h_refinement_permutations

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_n_subface_permutation ( this, n_face_dimension, permutation_array )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this              
  integer(ip)                         , intent(in)    :: n_face_dimension
  integer(ip)           , allocatable , intent(inout) :: permutation_array(:,:,:)
  integer(ip)           :: num_refinements, num_n_faces, num_n_subfaces, num_dofs_on_n_face
  integer(ip)           :: first_n_face_id, n_face_id, n_subface_id, dof_on_n_subface_id, icomp
  type(node_array_t)    :: h_refinement_node_array   
  type(node_iterator_t) :: node_iterator_on_n_subface
  
  num_refinements    = 1
  num_n_faces        = this%get_number_n_faces_of_dimension(n_face_dimension)
  num_n_subfaces     = ( num_refinements + 1 ) ** n_face_dimension      ! Topology-dependent
  first_n_face_id    = this%get_first_n_face_id_of_dimension(n_face_dimension)
  num_dofs_on_n_face = this%get_number_dofs_on_n_face(first_n_face_id) ! Only cubes and simplices

  call memalloc(num_n_faces,num_n_subfaces,num_dofs_on_n_face,permutation_array,__FILE__,__LINE__)

  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  do n_face_id = first_n_face_id, first_n_face_id+num_n_faces-1
     do n_subface_id = 0, num_n_subfaces-1
        dof_on_n_subface_id = 0
        node_iterator_on_n_subface = h_refinement_node_array%create_node_iterator ( this%polytope%get_n_face(n_face_id), & 
                                                                                    n_subface_id, own_boundary = .true. )
        do icomp = 1, this%number_field_components
           call node_iterator_on_n_subface%init()
           do while (.not. node_iterator_on_n_subface%has_finished() )
              dof_on_n_subface_id = dof_on_n_subface_id + 1
              permutation_array(n_face_id-first_n_face_id+1,n_subface_id+1,dof_on_n_subface_id) = node_iterator_on_n_subface%current()
              call node_iterator_on_n_subface%next()
           end do
        end do
        assert( dof_on_n_subface_id == num_dofs_on_n_face )
     end do
  end do

  call h_refinement_node_array%free()
  
end subroutine hex_lagrangian_reference_fe_fill_n_subface_permutation

!==================================================================================================
subroutine hex_lagrangian_reference_fe_interpolate_nodal_values_on_subcell ( this,                   &
                                                                             subcell_id,             &
                                                                             nodal_values_on_parent, & 
                                                                             nodal_values_on_child )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this              
  integer(ip)                         , intent(in)    :: subcell_id
  real(rp)                            , intent(in)    :: nodal_values_on_parent(:)
  real(rp)                            , intent(inout) :: nodal_values_on_child(:)
  integer(ip)           :: num_refinements
  integer(ip)           :: icomp, ishape_fe, ishape_coarser_fe, qpoint
  real(rp)              :: coefficient
  type(node_array_t)    :: h_refinement_node_array
  type(node_iterator_t) :: node_iterator_on_subcell
  
  num_refinements = 1
  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  node_iterator_on_subcell = h_refinement_node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%number_n_faces), &
                                                                subcell_id, own_boundary = .true. )
  
  nodal_values_on_child = 0.0_rp
  ishape_fe = 0
  do icomp = 0, this%number_field_components-1
     call node_iterator_on_subcell%init()
     do while (.not. node_iterator_on_subcell%has_finished() )
        qpoint = node_iterator_on_subcell%current()
        ishape_fe = ishape_fe + 1
        do ishape_coarser_fe = 1, this%get_number_shape_functions()
           call this%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient)
           nodal_values_on_child(ishape_fe) = nodal_values_on_child(ishape_fe) + &
                                      coefficient * nodal_values_on_parent(ishape_coarser_fe)
        end do
        call node_iterator_on_subcell%next()
     end do
  end do
  assert( ishape_fe == this%get_number_shape_functions() )
  
  call h_refinement_node_array%free()
  
end subroutine hex_lagrangian_reference_fe_interpolate_nodal_values_on_subcell

!==================================================================================================
subroutine hex_lagrangian_reference_fe_project_nodal_values_on_cell ( this,                     &
                                                                      nodal_values_on_children, &
                                                                      nodal_values_on_parent )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this  
  real(rp)                            , intent(in)    :: nodal_values_on_children(:,:)
  real(rp)                            , intent(inout) :: nodal_values_on_parent(:)
  type(node_iterator_t) :: node_iterator
  integer(ip)           :: parent_index, parent_ijk, parent_coordinate(0:SPACE_DIM-1)
  integer(ip)           :: child_coordinate(0:SPACE_DIM-1), child_index, subcell_id
  integer(ip)           :: i, icomp
  
  node_iterator = this%node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%number_n_faces), &
                                                        own_boundary = .true. )
  
  do icomp = 0, this%number_field_components-1
     call node_iterator%init()
     do while (.not. node_iterator%has_finished() )
        subcell_id        = 0
        parent_index      = node_iterator%current()
        parent_ijk        = node_iterator%current_ijk()
        parent_coordinate = node_iterator%coordinate
        child_coordinate  = 2 * parent_coordinate
        do i = 0,this%node_array%polytope%number_dimensions-1
           if ( child_coordinate(i) .ge. this%order_vector(i+1) ) then
              child_coordinate(i) = child_coordinate(i) - this%order_vector(i+1)
              subcell_id = IBSET(subcell_id,i)
           end if
        end do
        child_index = ijk_to_index( child_coordinate,      &
                                    this%node_array%order, &
                                    this%node_array%polytope%number_dimensions )
        child_index = this%node_array%ijk_to_index( child_index ) + &
                      icomp * this%node_array%number_nodes
        parent_index = parent_index + icomp * this%node_array%number_nodes
        nodal_values_on_parent( parent_index ) = nodal_values_on_children( subcell_id+1, &
                                                                           child_index )
        call node_iterator%next()
     end do
  end do
  
end subroutine hex_lagrangian_reference_fe_project_nodal_values_on_cell

!==================================================================================================
subroutine hex_lagrangian_reference_fe_get_h_refinement_coefficient ( this, ishape_fe,   & 
                                                                      ishape_coarser_fe, & 
                                                                      qpoint, coefficient )
  implicit none 
  class(hex_lagrangian_reference_fe_t), target, intent(in)    :: this
  integer(ip)                                 , intent(in)    :: ishape_fe
  integer(ip)                                 , intent(in)    :: ishape_coarser_fe
  integer(ip)                                 , intent(in)    :: qpoint
  real(rp)                                    , intent(inout) :: coefficient
  assert( ishape_fe >= 1 .and. ishape_fe <= this%number_shape_functions )
  assert( ishape_coarser_fe >= 1 .and. ishape_coarser_fe <= this%number_shape_functions )
  assert( qpoint >= 1 )
  if ( this%node_component_array(ishape_fe,2) == & 
       this%node_component_array(ishape_coarser_fe,2) ) then
     coefficient = this%h_refinement_interpolation%shape_functions(1, & 
                               this%node_component_array(ishape_coarser_fe,1),qpoint)
  else
     coefficient = 0.0_rp
  end if
end subroutine hex_lagrangian_reference_fe_get_h_refinement_coefficient

!==================================================================================================
function hex_lagrangian_reference_fe_get_h_refinement_interpolation ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), target, intent(in) :: this
  type(interpolation_t), pointer :: hex_lagrangian_reference_fe_get_h_refinement_interpolation
  hex_lagrangian_reference_fe_get_h_refinement_interpolation => this%h_refinement_interpolation
end function hex_lagrangian_reference_fe_get_h_refinement_interpolation

!==================================================================================================
function hex_lagrangian_reference_fe_get_h_refinement_subedge_perm ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), target, intent(in) :: this
  integer(ip), pointer :: hex_lagrangian_reference_fe_get_h_refinement_subedge_perm(:,:,:)
  hex_lagrangian_reference_fe_get_h_refinement_subedge_perm => this%h_refinement_subedge_permutation
end function hex_lagrangian_reference_fe_get_h_refinement_subedge_perm

!==================================================================================================
function hex_lagrangian_reference_fe_get_h_refinement_subface_perm ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), target, intent(in) :: this
  integer(ip), pointer :: hex_lagrangian_reference_fe_get_h_refinement_subface_perm(:,:,:)
  hex_lagrangian_reference_fe_get_h_refinement_subface_perm => this%h_refinement_subface_permutation
end function hex_lagrangian_reference_fe_get_h_refinement_subface_perm

!**************************************************************************************************
! Support functions
!**************************************************************************************************

! Subroutine to deal with high order parametrizations of the boundary
! Only implemented in 2D
!==================================================================================================
subroutine blend_2D(r,s,x1,x2,x3,x4,x5,x6,x7,x8,x)
  implicit none
  real(rp), intent(in)  :: r,s
  type(point_t), intent(in)  :: x1,x2,x3,x4,x5,x6,x7,x8
  type(point_t), intent(out) :: x

  !     3---6---------4
  !     |   .         |
  !     |   .         |
  !     |   .         |
  !     7...x........ 8
  !     |   .         |
  !     1---5---------2

  x =   ( - 0.25_rp * (1-r) * (1-s)) *x1 &
       & + ( - 0.25_rp * (1+r) * (1-s)) *x2 &
       & + ( - 0.25_rp * (1-r) * (1+s)) *x3 &
       & + ( - 0.25_rp * (1+r) * (1+s)) *x4 &
       & + ( 0.5_rp * (1-s)) * x5 &
       & + ( 0.5_rp * (1+s)) * x6 &
       & + ( 0.5_rp * (1-r)) * x7 &
       & + ( 0.5_rp * (1+r)) * x8

end subroutine blend_2D

