! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published byfill_inter
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================

subroutine hex_lagrangian_reference_fe_create(this, &
                                              topology, &
                                              num_dims, &
                                              order, &
                                              field_type, & 
                                              conformity, &
                                              continuity )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(inout)  :: this
  character(*)                        , intent(in)    :: topology
  integer(ip)                         , intent(in)    :: num_dims
  integer(ip)                         , intent(in)    :: order
  character(*)                        , intent(in)    :: field_type
  logical                             , intent(in)    :: conformity
  logical              , optional     , intent(in)    :: continuity
  integer(ip)        :: num_refinements
  num_refinements = 1
  call lagrangian_reference_fe_create(this,topology,num_dims,order,field_type,conformity,continuity)
  call this%fill_h_refinement_interpolation()
  call this%fill_h_refinement_permutations()
end subroutine hex_lagrangian_reference_fe_create

function hex_lagrangian_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: hex_lagrangian_reference_fe_check_compatibility_of_n_faces 
  integer(ip) :: idime

  select type(source_reference_fe)
     class is(hex_lagrangian_reference_fe_t)
        ! Get number nodes per dimension
     assert (target_reference_fe%num_dims == source_reference_fe%num_dims)
     do idime = 1, target_reference_fe%num_dims
        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
     end do
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) == source_reference_fe%get_n_face_dim(source_n_face_id))
     assert (target_reference_fe%get_n_face_dim(target_n_face_id) < 3)
     assert (target_reference_fe%num_field_components == source_reference_fe%num_field_components)
     assert (target_reference_fe%get_num_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_num_own_dofs_n_face(source_n_face_id))
     hex_lagrangian_reference_fe_check_compatibility_of_n_faces = .true.
     class default
     hex_lagrangian_reference_fe_check_compatibility_of_n_faces = .false.
  end select

end function hex_lagrangian_reference_fe_check_compatibility_of_n_faces

!==================================================================================================
function hex_lagrangian_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in) :: this 
  real(rp)  :: hex_lagrangian_reference_fe_get_characteristic_length 
  hex_lagrangian_reference_fe_get_characteristic_length =  2.0_rp
end function hex_lagrangian_reference_fe_get_characteristic_length

!**************************************************************************************************
! Deferred TBP implementors from lagrangian_reference_fe_t
!**************************************************************************************************

!==================================================================================================
function hex_lagrangian_reference_fe_get_num_subcells(this, num_refinements) result(num_subcells)
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                                         :: num_subcells
  num_subcells = (num_refinements+1)**this%num_dims
end function hex_lagrangian_reference_fe_get_num_subcells

!==================================================================================================
subroutine hex_lagrangian_reference_fe_get_subcells_connectivity(this, num_refinements, connectivity)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  integer(ip) :: order_vector(this%num_dims)
  integer(ip) :: num_subelems
  integer(ip) :: subelem
  integer(ip) :: geo_nnodes
  integer(ip) :: local_node
  integer(ip) :: first_coord(this%num_dims)
  integer(ip) :: local_coord(this%num_dims)
  integer(ip) :: global_coord(this%num_dims)
  integer(ip) :: ones_dim(this%num_dims)
  ones_dim = 1
  num_subelems = this%get_num_subcells(num_refinements=num_refinements)
  geo_nnodes = this%get_num_vertices()
  assert(size(connectivity,1) == geo_nnodes)
  assert(size(connectivity,2) == num_subelems)
  order_vector = num_refinements+1

  do subelem = 1, num_subelems
     !call this%get_node_local_coordinates(first_coord,subelem, & 
     !                                      & this%num_dims,this%order(1)-1)
     call index_to_ijk( subelem, this%num_dims, order_vector, first_coord )

     do local_node = 1, geo_nnodes
        !call this%get_node_local_coordinates(local_coord,local_node,this%num_dims,1)
        call index_to_ijk( local_node, this%num_dims, 2*ones_dim, local_coord )

        global_coord = first_coord + local_coord 
        !connectivity(local_node, subelem) = this%get_node_local_id(global_coord, &
        !                                                   & this%num_dims,this%order(1)) ! 
        connectivity(local_node, subelem) = ijk_to_index(global_coord, order_vector,this%num_dims)+1
     end do
  end do
end subroutine hex_lagrangian_reference_fe_get_subcells_connectivity

!==================================================================================================
subroutine hex_lagrangian_create_data_out_quadrature ( this, num_refinements, quadrature )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: num_refinements
  type(quadrature_t)                  , intent(inout) :: quadrature

  integer(ip)        :: i
  type(node_array_t) :: node_array 
  integer(ip)        :: order_vector(SPACE_DIM)
  
  assert ( num_refinements >= 0 )

  call quadrature%free()
  
  order_vector = num_refinements+1
  call node_array%create( this%polytope, order_vector ) 

  call quadrature%create( this%num_dims, node_array%num_nodes )
  do i=1,this%num_dims
     quadrature%coordinates(i,:) = node_array%coordinates(i,:)*(2.0_rp/order_vector(i))-1.0_rp
  end do
  quadrature%weight = 1.0_rp
  
  call node_array%free()
end subroutine hex_lagrangian_create_data_out_quadrature

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  call quadrature%fill_hex_gauss_legendre()
end subroutine hex_lagrangian_reference_fe_fill_quadrature

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_nodal_quadrature( this, quadrature )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip) :: i
  do i=1,this%num_dims
     if (this%order_vector(i) > 0 ) then 
     quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)*(2.0_rp/this%order_vector(i))-1.0_rp
  else 
  quadrature%coordinates(i,:) = this%node_array%coordinates(i,:)
  end if 
  end do
  quadrature%weight = 1.0_rp
end subroutine hex_lagrangian_reference_fe_fill_nodal_quadrature

! This subroutine fills the interpolation using the polynomial_names machinery
!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation    
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)
  type(tensor_product_polynomial_space_t) :: tensor_product_polynomial_space
  type(polynomial_basis_t)    :: polynomial_1D_basis(SPACE_DIM)
  type(lagrange_polynomial_t)             :: polynomial_1D

  real(rp), allocatable :: tensor_product_values(:)
  real(rp), allocatable :: tensor_product_gradients(:,:)

  integer(ip) :: idime, q_point

  do idime=1,interpolation%num_dims
     call polynomial_1D%generate_basis( this%order_vector(idime), polynomial_1D_basis(idime) )
  end do

  call tensor_product_polynomial_space%create(interpolation%num_dims,polynomial_1D_basis)
  call tensor_product_polynomial_space%fill( quadrature%get_coordinates() )

  !assert ( interpolation%num_shape_functions == tensor_product_polynomial_space%get_num_polynomials() )

  call memalloc(tensor_product_polynomial_space%get_num_polynomials(),tensor_product_values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,tensor_product_polynomial_space%get_num_polynomials(),tensor_product_gradients,__FILE__,__LINE__)

  do q_point=1, quadrature%get_num_quadrature_points()
     do idime = 1, interpolation%num_dims
        call tensor_product_polynomial_space%evaluate(q_point, &
             tensor_product_values, &
             tensor_product_gradients)
        interpolation%shape_functions(1,:,q_point) = tensor_product_values(:)
        interpolation%shape_derivatives(1,:,:,q_point) = tensor_product_gradients(:,:)
     end do
  end do

  ! Free auxiliary memory
  if(allocated(tensor_product_values))    call memfree(tensor_product_values,__FILE__,__LINE__)
  if(allocated(tensor_product_gradients)) call memfree(tensor_product_gradients,__FILE__,__LINE__)
  do idime=1,interpolation%num_dims
     call polynomial_1D_basis(idime)%free()
  end do
  call polynomial_1D%free()
  call tensor_product_polynomial_space%free()

end subroutine hex_lagrangian_reference_fe_fill_interpolation

! Here we define the dim-1 quadrature and next translate the nodes
! using the facet type to dim. Next, use the same machinary as for the volume with this new quadrature.
!!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_interp_restricted_to_facet( this, local_quadrature, & 
     & facet_lid, subfacet_lid, facet_interpolation )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: local_quadrature
  integer(ip)                         , intent(in)    :: facet_lid
  integer(ip)                         , intent(in)    :: subfacet_lid
  type(interpolation_t)               , intent(inout) :: facet_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c,idime,iface,n_face_index
  ! Add offset to have same numbering as in polytope
  n_face_index = facet_lid+this%get_first_facet_id()-1
  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%num_dims, local_quadrature%num_quadrature_points )
  c = 0
  do idime = 0,this%num_dims-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
        if ( subfacet_lid >= 0 ) then
          aux_quadrature%coordinates(idime+1,:) =                         &
            ( aux_quadrature%coordinates(idime+1,:) - 1.0_rp ) / 2.0_rp + &
            real( IBITS( subfacet_lid, c-1 , 1 ), rp )
        end if
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = -1.0_rp
     else
        aux_quadrature%coordinates(idime+1,:) = 1.0_rp
     end if
  end do
  call this%fill_interpolation( aux_quadrature, facet_interpolation ) 
  call aux_quadrature%free()
end subroutine hex_lagrangian_reference_fe_fill_interp_restricted_to_facet

!==================================================================================================
subroutine index_to_ijk( index, ndime, n_pols_dim, ijk )
  implicit none
  integer(ip)                         , intent(in) :: index
  integer(ip)                         , intent(in) :: ndime
  integer(ip)                         , intent(in) :: n_pols_dim(SPACE_DIM)
  integer(ip)                         , intent(inout) :: ijk(SPACE_DIM)
  integer(ip) :: i,aux
  ijk = 0
  aux = (index-1)
  do i = 1,ndime-1
     ijk(i) = mod(aux, n_pols_dim(i))
     aux = aux/n_pols_dim(i)
  end do
  ijk(ndime) = aux
  !ijk(1:ndime) = ijk(1:ndime)
end subroutine index_to_ijk

! @sbadia: It could be replaced by an anisotropic quadrature
!==================================================================================================
function hex_lagrangian_reference_fe_compute_num_quadrature_points( this, degree, dimension )
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: degree
  integer(ip)                         , intent(in)    :: dimension
  integer(ip) :: hex_lagrangian_reference_fe_compute_num_quadrature_points
  hex_lagrangian_reference_fe_compute_num_quadrature_points = int(ceiling(real(degree + 1,rp)/2.0_rp)**real(dimension,rp),ip)
end function hex_lagrangian_reference_fe_compute_num_quadrature_points

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_qpoints_permutations(this, quadrature, qpoints_perm)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
  integer(ip)    :: ndime, n_q_points, order
  
  ndime      = quadrature%get_num_dims()
  n_q_points = quadrature%get_num_quadrature_points()
  order      = int(real(n_q_points,rp)**(1.0_rp/real(ndime,rp)),ip)+1
  
  call this%node_array%fill_permutations( order, &
                                          ndime, &
                                          this%polytope, &
                                          qpoints_perm )
  
end subroutine hex_lagrangian_reference_fe_fill_qpoints_permutations

!==================================================================================================
subroutine hex_lagrangian_reference_fe_free ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this 
  call lagrangian_reference_fe_free ( this )
end subroutine hex_lagrangian_reference_fe_free

! Subroutine to deal with high order parametrizations of the boundary
!==================================================================================================
subroutine hex_lagrangian_reference_fe_blending(this,values)
  implicit none
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this
  type(point_t)                       , intent(inout) :: values(:)

  integer(ip) :: i,j, ipoin, nlocs, ndime,nnode

  assert(size(values) == this%node_array%num_nodes)

  ndime = this%num_dims
  nnode = this%node_array%num_nodes

  if(ndime==1) then
     nlocs=nnode
  else if(ndime==2) then
     nlocs=nint(sqrt(real(nnode,rp)))
  else
     nlocs=nint(real(nnode,rp)**(1.0_rp/3.0_rp))
  end if

  if(ndime==2) then
     !ipoin=0
     do j = 2, nlocs - 1
        do i = 2, nlocs - 1
           ipoin = nlocs*(j-1)+i
           !ipoin = ipoin + 1
           call blend_2D(this%nodal_quadrature%coordinates(1,ipoin), & ! reference coordinates
                &        this%nodal_quadrature%coordinates(2,ipoin), &
                &        values(1), &                 ! value at vertex 1
                &        values(nlocs), &             ! value at vertex 2
                &        values(nlocs*(nlocs-1)+1), & ! value at vertex 3
                &        values(nlocs*nlocs), &       ! value at vertex 4
                &        values(i), &                 ! value at edge 5
                &        values(nlocs*(nlocs-1)+i), & ! value at edge 6
                &        values(nlocs*(j-1)+1), &     ! value at edge 7
                &        values(nlocs*j), &           ! value at edge 8
                &        values(ipoin))               ! interpolated value

        end do
     end do
  end if

end subroutine hex_lagrangian_reference_fe_blending

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_h_refinement_interpolation ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this
  type(quadrature_t) :: h_refined_quadrature
  integer(ip)        :: num_refinements
  num_refinements = 1
  call this%create_data_out_quadrature( max((num_refinements+1)*this%order-1,0), h_refined_quadrature )
  call this%create_interpolation( h_refined_quadrature, this%h_refinement_interpolation )
  call h_refined_quadrature%free()
end subroutine hex_lagrangian_reference_fe_fill_h_refinement_interpolation

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_h_refinement_permutations ( this )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(inout) :: this
  call this%fill_n_subfacet_permutation(this%num_dims-1, &
                                       this%h_refinement_subfacet_permutation)
  if ( this%num_dims == 3 ) then
     call this%fill_n_subfacet_permutation(this%num_dims-2, &
                                          this%h_refinement_subedge_permutation)
  end if
end subroutine hex_lagrangian_reference_fe_fill_h_refinement_permutations

!==================================================================================================
subroutine hex_lagrangian_reference_fe_fill_n_subfacet_permutation ( this, n_face_dime, permutation_array )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this              
  integer(ip)                         , intent(in)    :: n_face_dime
  integer(ip)           , allocatable , intent(inout) :: permutation_array(:,:,:)
  integer(ip)           :: num_refinements, num_n_faces, num_n_subfaces, num_dofs_on_n_face
  integer(ip)           :: first_n_face_id, n_face_id, n_subface_id, dof_on_n_subface_id, icomp
  type(node_array_t)    :: h_refinement_node_array   
  type(node_iterator_t) :: node_iterator_on_n_subface
  
  num_refinements    = 1
  num_n_faces        = this%get_num_n_faces_of_dim(n_face_dime)
  num_n_subfaces     = ( num_refinements + 1 ) ** n_face_dime     ! Topology-dependent
  first_n_face_id    = this%get_first_n_face_id_of_dim(n_face_dime)
  num_dofs_on_n_face = this%get_num_dofs_on_n_face(first_n_face_id) ! Only cubes and simplices

  call memalloc(num_n_faces,num_n_subfaces,num_dofs_on_n_face,permutation_array,__FILE__,__LINE__)

  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  do n_face_id = first_n_face_id, first_n_face_id+num_n_faces-1
     do n_subface_id = 0, num_n_subfaces-1
        dof_on_n_subface_id = 0
        node_iterator_on_n_subface = h_refinement_node_array%create_node_iterator ( this%polytope%get_n_face(n_face_id), & 
                                                                                    n_subface_id, own_boundary = .true. )
        do icomp = 1, this%num_field_components
           call node_iterator_on_n_subface%init()
           do while (.not. node_iterator_on_n_subface%has_finished() )
              dof_on_n_subface_id = dof_on_n_subface_id + 1
              permutation_array(n_face_id-first_n_face_id+1,n_subface_id+1,dof_on_n_subface_id) = node_iterator_on_n_subface%current()
              call node_iterator_on_n_subface%next()
           end do
        end do
        assert( dof_on_n_subface_id == num_dofs_on_n_face )
     end do
  end do

  call h_refinement_node_array%free()
  
end subroutine hex_lagrangian_reference_fe_fill_n_subfacet_permutation

!==================================================================================================
subroutine hex_lagrangian_reference_fe_interpolate_nodal_values_on_subcell ( this,                   &
                                                                             subcell_id,             &
                                                                             nodal_values_on_parent, & 
                                                                             nodal_values_on_child )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this              
  integer(ip)                         , intent(in)    :: subcell_id
  real(rp)                            , intent(in)    :: nodal_values_on_parent(:)
  real(rp)                            , intent(inout) :: nodal_values_on_child(:)
  integer(ip)           :: num_refinements
  integer(ip)           :: icomp, ishape_fe, ishape_coarser_fe, qpoint
  real(rp)              :: coefficient
  type(node_array_t)    :: h_refinement_node_array
  type(node_iterator_t) :: node_iterator_on_subcell
  
  num_refinements = 1
  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
  
  node_iterator_on_subcell = h_refinement_node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
                                                                subcell_id, own_boundary = .true. )
  
  nodal_values_on_child = 0.0_rp
  ishape_fe = 0
  do icomp = 0, this%num_field_components-1
     call node_iterator_on_subcell%init()
     do while (.not. node_iterator_on_subcell%has_finished() )
        qpoint = node_iterator_on_subcell%current()
        ishape_fe = ishape_fe + 1
        do ishape_coarser_fe = 1, this%get_num_shape_functions()
           call this%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient)
           nodal_values_on_child(ishape_fe) = nodal_values_on_child(ishape_fe) + &
                                      coefficient * nodal_values_on_parent(ishape_coarser_fe)
        end do
        call node_iterator_on_subcell%next()
     end do
  end do
  assert( ishape_fe == this%get_num_shape_functions() )
  
  call h_refinement_node_array%free()
  
end subroutine hex_lagrangian_reference_fe_interpolate_nodal_values_on_subcell

!==================================================================================================
subroutine hex_lagrangian_reference_fe_project_nodal_values_on_cell ( this,                     &
                                                                      nodal_values_on_children, &
                                                                      nodal_values_on_parent )
  implicit none 
  class(hex_lagrangian_reference_fe_t), intent(in)    :: this  
  real(rp)                            , intent(in)    :: nodal_values_on_children(:,:)
  real(rp)                            , intent(inout) :: nodal_values_on_parent(:)
  type(node_iterator_t) :: node_iterator
  integer(ip)           :: parent_index, parent_ijk, parent_coordinate(0:SPACE_DIM-1)
  integer(ip)           :: child_coordinate(0:SPACE_DIM-1), child_index, subcell_id
  integer(ip)           :: i, icomp
  
  node_iterator = this%node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
                                                        own_boundary = .true. )
  
  do icomp = 0, this%num_field_components-1
     call node_iterator%init()
     do while (.not. node_iterator%has_finished() )
        subcell_id        = 0
        parent_index      = node_iterator%current()
        parent_ijk        = node_iterator%current_ijk()
        parent_coordinate = node_iterator%coordinate
        child_coordinate  = 2 * parent_coordinate
        do i = 0,this%node_array%polytope%num_dims-1
           if ( child_coordinate(i) .ge. this%order_vector(i+1) ) then
              child_coordinate(i) = child_coordinate(i) - this%order_vector(i+1)
              subcell_id = IBSET(subcell_id,i)
           end if
        end do
        child_index = ijk_to_index( child_coordinate,      &
                                    this%node_array%order, &
                                    this%node_array%polytope%num_dims )
        child_index = this%node_array%ijk_to_index( child_index ) + &
                      icomp * this%node_array%num_nodes
        parent_index = parent_index + icomp * this%node_array%num_nodes
        nodal_values_on_parent( parent_index ) = nodal_values_on_children( subcell_id+1, &
                                                                           child_index )
        call node_iterator%next()
     end do
  end do
  
end subroutine hex_lagrangian_reference_fe_project_nodal_values_on_cell

!==================================================================================================
subroutine hex_lagrangian_reference_fe_get_h_refinement_coefficient ( this, ishape_fe,   & 
                                                                      ishape_coarser_fe, & 
                                                                      qpoint, coefficient )
  implicit none 
  class(hex_lagrangian_reference_fe_t), target, intent(in)    :: this
  integer(ip)                                 , intent(in)    :: ishape_fe
  integer(ip)                                 , intent(in)    :: ishape_coarser_fe
  integer(ip)                                 , intent(in)    :: qpoint
  real(rp)                                    , intent(inout) :: coefficient
  assert( ishape_fe >= 1 .and. ishape_fe <= this%num_shape_functions )
  assert( ishape_coarser_fe >= 1 .and. ishape_coarser_fe <= this%num_shape_functions )
  assert( qpoint >= 1 )
  if ( this%node_component_array(ishape_fe,2) == & 
       this%node_component_array(ishape_coarser_fe,2) ) then
     coefficient = this%h_refinement_interpolation%shape_functions(1, & 
                               this%node_component_array(ishape_coarser_fe,1),qpoint)
  else
     coefficient = 0.0_rp
  end if
end subroutine hex_lagrangian_reference_fe_get_h_refinement_coefficient

!**************************************************************************************************
! Support functions
!**************************************************************************************************

! Subroutine to deal with high order parametrizations of the boundary
! Only implemented in 2D
!==================================================================================================
subroutine blend_2D(r,s,x1,x2,x3,x4,x5,x6,x7,x8,x)
  implicit none
  real(rp), intent(in)  :: r,s
  type(point_t), intent(in)  :: x1,x2,x3,x4,x5,x6,x7,x8
  type(point_t), intent(out) :: x

  !     3---6---------4
  !     |   .         |
  !     |   .         |
  !     |   .         |
  !     7...x........ 8
  !     |   .         |
  !     1---5---------2

  x =   ( - 0.25_rp * (1-r) * (1-s)) *x1 &
       & + ( - 0.25_rp * (1+r) * (1-s)) *x2 &
       & + ( - 0.25_rp * (1-r) * (1+s)) *x3 &
       & + ( - 0.25_rp * (1+r) * (1+s)) *x4 &
       & + ( 0.5_rp * (1-s)) * x5 &
       & + ( 0.5_rp * (1+s)) * x6 &
       & + ( 0.5_rp * (1-r)) * x7 &
       & + ( 0.5_rp * (1+r)) * x8

end subroutine blend_2D
