! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
module reference_fe_names
  use allocatable_array_ip1_names
  use allocatable_array_ip2_names
  use field_names
  use types_names
  use list_types_names
  use memor_names
  use sort_names
  use polynomial_names
  
#ifdef ENABLE_BLAS
 use blas77_interfaces_names
#endif
  
#ifdef ENABLE_LAPACK   
 use lapack77_interfaces_names
#endif  
  
  
  implicit none
# include "debug.i90"

  private

  ! This module includes all the reference FE related machinery that is required
  ! to integrate FE schemes. It includes the following types:
  !
  ! * reference_fe_t: the basic reference_fe object, which is an abstract type
  ! * lagrangian_reference_fe_t: an intermediate abstract class 
  ! * hex_lagrangian_reference_fe_t: one particular concrete version of the 
  !   lagrangian_reference_fe_t for quadrilaterals and hexahedra
  ! * hex_lagrangian_reference_fe_t: one particular concrete version of the 
  !   lagrangian_reference_fe_t for triangles and tetrahedra
  ! * quadrature_t: Set of points and weights to perform numerical integration.
  !   It is created by the concrete reference_fe_t by providing the maximum order
  !   to be integrated exactly for zero order terms, e.g., mass matrix
  ! * interpolation_t: The value of the reference FE shape functions (first and second
  !   order derivatives) on the quadrature points. It is generated by a concrete 
  !   reference_fe_t and a quadrature_t. It is computed in the concrete reference_fe_t
  ! * fe_map_t: It provides the mapping from a physical FE to the reference FE
  !   (jacobian, etc.)
  ! * volume_integrator_t: It aggregates all the aforementioned structures to be
  !   used in the FE element integration subroutine. In particular, one 
  !   reference_fe_t for the unknowns and one for the geometry (for non-isoparametric
  !   cases), one quadrature, and the corresponding interpolation. Further, it 
  !   includes the physical FE to the reference one in a fe_map_t and the
  !   composition of the FE map and the interpolation, to provide derivatives in the
  !   physical space

  type quadrature_t
     !private
     integer(ip)           ::   &
          number_dimensions,    &
          number_quadrature_points
     real(rp), allocatable :: &
          coordinates(:,:),   &   
          weight(:)                         
   contains
     procedure, non_overridable :: create => quadrature_create
     procedure, non_overridable :: free   => quadrature_free
     procedure, non_overridable :: print  => quadrature_print
     procedure, non_overridable :: get_number_dimensions => quadrature_get_number_dimensions
     procedure, non_overridable :: get_number_quadrature_points => quadrature_get_number_quadrature_points
     procedure, non_overridable :: get_coordinates => quadrature_get_coordinates     
     procedure, non_overridable :: get_weight => quadrature_get_weight
  end type quadrature_t

  type p_quadrature_t
     type(quadrature_t), pointer :: p => NULL()
   contains
     procedure :: allocate => p_quadrature_allocate
     procedure :: free     => p_quadrature_free
  end type p_quadrature_t

  ! Types
  public :: quadrature_t, p_quadrature_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type interpolation_t
     private
     integer(ip)                ::  &
          number_dimensions,        &      
          number_shape_functions,   &      
          number_quadrature_points, &      
          number_entries_symmetric_tensor
     real(rp), allocatable      ::  &
          shape_functions(:,:,:),     &   
          shape_derivatives(:,:,:,:), &   
          hessian(:,:,:,:)     
   contains
     procedure, non_overridable :: create => interpolation_create
     procedure, non_overridable :: free   => interpolation_free
     procedure, non_overridable :: copy   => interpolation_copy
     procedure, non_overridable :: clone  => interpolation_clone
     procedure, non_overridable :: print  => interpolation_print
  end type interpolation_t

  public :: interpolation_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type fe_map_t
     private
     ! Map's Jacobian (number_dimensions,number_dimensions,number_quadrature_points)
     real(rp), allocatable    :: jacobian(:,:,:)    
     ! Map's Jacobian inverse (number_dimensions,number_dimensions,number_quadrature_points)       
     real(rp), allocatable    :: inv_jacobian(:,:,:)     
     ! Map's Jacobian det (number_quadrature_points)  
     real(rp), allocatable    :: det_jacobian(:)  
     ! Map's 2nd derivatives (number_dime,number_dime,number_dime,number_quadrature_points)         
     real(rp), allocatable    :: d2sdx(:,:,:,:)     
     ! Coordinates of git  points (number_dimensions,number_quadrature_points)       
     type(point_t), allocatable    :: coordinates_quadrature(:)  
     ! Coordinates of evaluation points (number_dimensions,number_corners of element/face)  
     type(point_t), allocatable    :: coordinates_nodes(:)  
     ! Vector normals outside the face (only allocated when using fe_map to integrate on faces) 
     real(rp), allocatable    :: normals(:,:)  
     ! Vector tangents to edges (only allocated when using fe_map to integrate on edges)
     ! Vector tangents to edges are required e.g. by type(hex_nedelec_reference_fe_t) on 
     ! the reference cell.
     real(rp), allocatable    :: tangents(:,:)  
     ! Geometry interpolation_t in the reference element domain    
     type(interpolation_t) :: interpolation_geometry   
     ! Characteristic length of the reference element
     real(rp)                 :: reference_fe_characteristic_length
     ! Number of dimensions
     integer(ip)              :: number_dimensions
     ! Number of quadrature points
     integer(ip)              :: number_quadrature_points
   contains
     procedure, non_overridable :: create                            => fe_map_create
     procedure, non_overridable :: create_on_face                    => fe_map_create_on_face
     procedure, non_overridable :: create_face_map                   => fe_map_create_face_map
     procedure, non_overridable :: create_edge_map                   => fe_map_create_edge_map
     procedure, non_overridable :: update                            => fe_map_update
     procedure, non_overridable :: update_face_map                   => fe_map_update_face_map
     procedure, non_overridable :: update_edge_map                   => fe_map_update_edge_map
     procedure, non_overridable :: free                              => fe_map_free
     procedure, non_overridable :: print                             => fe_map_print
     procedure, non_overridable :: get_det_jacobian                  => fe_map_get_det_jacobian
     procedure, non_overridable :: compute_h                         => fe_map_compute_h
     procedure, non_overridable :: compute_h_min                     => fe_map_compute_h_min
     procedure, non_overridable :: compute_h_max                     => fe_map_compute_h_max
     procedure, non_overridable :: get_coordinates                   => fe_map_get_coordinates
     procedure, non_overridable :: get_quadrature_points_coordinates => fe_map_get_quadrature_points_coordinates
     procedure, non_overridable :: get_inv_jacobian_tensor           => fe_map_get_inv_jacobian_tensor
     procedure, non_overridable :: get_reference_h                   => fe_map_get_reference_h
     procedure, non_overridable :: apply_inv_jacobian                => fe_map_apply_inv_jacobian
     procedure, non_overridable :: compute_quadrature_coordinates    => fe_map_compute_quadrature_coordinates
     procedure, non_overridable :: get_quadrature_coordinates        => fe_map_get_quadrature_coordinates
     procedure, non_overridable :: get_normal                        => fe_map_get_normal
     procedure, non_overridable :: get_tangent                       => fe_map_get_tangent
     procedure, non_overridable :: get_jacobian_normalized_column    => fe_map_get_jacobian_normalized_column
  end type fe_map_t

  type p_fe_map_t
     class(fe_map_t), pointer :: p => NULL()   
   contains
     procedure :: allocate => p_fe_map_allocate
     procedure :: free     => p_fe_map_free
  end type p_fe_map_t

  public :: fe_map_t, p_fe_map_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  type fe_map_face_restriction_t
     private
     integer(ip)                 :: number_faces = 0
     integer(ip)                 :: active_face_lid
     type(fe_map_t), allocatable :: fe_map(:)
   contains
     procedure, non_overridable :: create            => fe_map_face_restriction_create
     procedure, non_overridable :: update            => fe_map_face_restriction_update
     procedure, non_overridable :: free              => fe_map_face_restriction_free
     procedure, non_overridable :: get_coordinates   => fe_map_face_restriction_get_coordinates
     procedure, non_overridable :: get_active_fe_map => fe_map_face_restriction_get_active_fe_map 
  end type fe_map_face_restriction_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  type polytope_tree_t
     private
     integer(ip)              :: number_dimensions
     integer(ip)              :: topology
     integer(ip)              :: root
     integer(ip)              :: number_n_faces 
     integer(ip), allocatable :: n_face_array(:)     
     integer(ip), allocatable :: ijk_to_index(:)
   contains
     procedure          :: create                   => polytope_tree_create 
     procedure          :: create_facet_iterator    => polytope_tree_create_facet_iterator
     procedure          :: get_n_face               => polytope_tree_get_n_face
     procedure          :: get_n_face_dimension     => polytope_tree_get_n_face_dimension
     procedure          :: n_face_type              => polytope_tree_n_face_type
     procedure          :: n_face_dir_is_fixed      => polytope_tree_n_face_dir_is_fixed 
     procedure          :: n_face_dir_coordinate    => polytope_tree_n_face_dir_coordinate
     procedure          :: n_face_coordinate        => polytope_tree_n_face_coordinate
     procedure          :: get_number_n_faces       => polytope_tree_get_number_n_faces
     procedure          :: get_ijk_to_index         => polytope_tree_get_ijk_to_index
     procedure          :: print                    => polytope_tree_print
     procedure          :: free                     => polytope_tree_free
     procedure, private :: fill_polytope_chain 
  end type polytope_tree_t

  public :: polytope_tree_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type node_array_t
     private
     type(polytope_tree_t), pointer :: polytope_tree
     integer(ip)                    :: order(SPACE_DIM)
     integer(ip)                    :: number_nodes
     integer(ip), allocatable       :: node_array(:)
     integer(ip), allocatable       :: ijk_to_index(:)
     integer(ip), allocatable       :: coordinates(:,:)
   contains
     procedure                  :: create                   => node_array_create
     procedure                  :: print                    => node_array_print
     procedure                  :: free                     => node_array_free
     procedure                  :: create_node_iterator     => node_array_create_node_iterator
     procedure                  :: get_number_nodes         => node_array_get_number_nodes
     procedure        , private :: fill                     => node_array_fill
     procedure, nopass, private :: fill_permutations        => node_array_fill_permutations
     procedure, nopass, private :: compute_num_rot_and_perm => node_array_compute_num_rot_and_perm
  end type node_array_t

  public :: node_array_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type facet_iterator_t
     private 
     type(polytope_tree_t), pointer :: polytope_tree
     integer(ip)                  :: root
     integer(ip)                  :: component
     integer(ip)                  :: coordinate
   contains
     procedure :: create        => facet_iterator_create     
     procedure :: current       => facet_iterator_current
     procedure :: init          => facet_iterator_init
     procedure :: next          => facet_iterator_next
     procedure :: has_finished  => facet_iterator_has_finished
     procedure :: print         => facet_iterator_print
     procedure, private :: current_ijk   => facet_iterator_current_ijk 
     procedure, private :: is_admissible => facet_iterator_is_admissible   
  end type facet_iterator_t

  public :: facet_iterator_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type node_iterator_t
     private 
     type(node_array_t), pointer :: node_array
     logical                     :: own_boundary
     integer(ip)                 :: n_face
     integer(ip)                 :: topology
     integer(ip)                 :: displacement(0:SPACE_DIM-1)
     integer(ip)                 :: coordinate(0:SPACE_DIM-1)
     logical                     :: overflow
     integer(ip)                  :: min_value ! 0 or 1
     integer(ip)                  :: max_value(0:SPACE_DIM-1) ! order or order-1
   contains
     procedure :: create        => node_iterator_create     
     procedure :: current       => node_iterator_current
     procedure :: init          => node_iterator_init
     procedure :: next          => node_iterator_next
     procedure :: has_finished  => node_iterator_has_finished
     !procedure :: free          => node_iterator_free
     procedure :: print         => node_iterator_print
     procedure, private :: current_ijk => node_iterator_current_ijk  
     procedure, private :: in_bound    => node_iterator_in_bound 
  end type node_iterator_t

  public :: node_iterator_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  character(*), parameter :: field_type_scalar           = 'scalar'
  character(*), parameter :: field_type_vector           = 'vector'
  character(*), parameter :: field_type_tensor           = 'tensor'
  character(*), parameter :: field_type_symmetric_tensor = 'symmetric_tensor'

  character(*), parameter :: topology_hex = "hex"
  character(*), parameter :: topology_tet = "tet"
  character(*), parameter :: fe_type_lagrangian = "Lagrangian"
  character(*), parameter :: fe_type_raviart_thomas = "Raviart_Thomas"
  character(*), parameter :: fe_type_nedelec = "Nedelec"
  character(*), parameter :: fe_type_new_tet = "New_tet"


  ! Abstract reference_fe
  type, abstract ::  reference_fe_t
     private
     character(:), allocatable :: &
          topology,               &    ! topology of element, 'tet', 'quad', 'prism', ...
          fe_type,                &    ! 'Lagrangian', 'RT', ...
          field_type                   ! 'scalar', 'vector', 'tensor', 'symmetric_tensor'

     integer(ip)              ::    &        
          number_dimensions,        &
          order,                    &
          number_field_components

     logical                  ::    &
          continuity,               &      ! CG(.true.)/DG(.false.)
          conformity                       ! .true. for discontinuous L2 conforming spaces 
     ! that do not require to enforce weakly continuity

     integer(ip)              ::    &
          number_n_faces,              &        
          number_shape_functions,             &        
          number_n_faces_per_dimension(5)

     type(polytope_tree_t)         :: polytope
     type(node_array_t)            :: node_array
     type(node_array_t)            :: vertex_array

     type(allocatable_array_ip1_t)  :: orientation           ! orientation of the n-faces 
     type(list_t)                   :: interior_nodes_n_face ! interior nodes per n-face
     type(list_t)                   :: nodes_n_face          ! all nodes per n-face
     type(list_t)                   :: vertices_n_face       ! vertices per n-face
     type(list_t)                   :: n_faces_n_face        ! all n-faces per n-face
     type(list_t)                   :: own_nodes_n_faces
     type(list_t)                   :: face_integration_coupling_nodes_facet

     integer(ip), allocatable :: number_rotations_per_dimension(:)
     integer(ip), allocatable :: number_orientations_per_dimension(:)
     type(allocatable_array_ip2_t), allocatable :: own_node_permutations(:)
   contains
     ! TBPs
     ! Fill topology, fe_type, number_dimensions, order, continuity                                                              
     procedure(create_interface), private, deferred :: create 
     ! TBP to create a quadrature for a reference_fe_t
     procedure(create_quadrature_interface)             , deferred :: create_quadrature
     !procedure(create_quadrature_on_faces_interface)    , deferred :: create_quadrature_on_faces
     procedure(create_face_quadrature_interface)        , deferred :: create_face_quadrature
     ! TBP to create an interpolation from a quadrature_t and reference_fe_t, 
     ! i.e., the value of the shape functions of the reference element on the quadrature points. 
     procedure(create_interpolation_interface)          , deferred :: create_interpolation 
     procedure(create_face_interpolation_interface)     , deferred :: create_face_interpolation
     procedure(update_interpolation_interface)          , deferred :: update_interpolation
     procedure(get_component_node_interface)            , deferred :: get_component_node
     procedure(get_scalar_from_vector_node_interface)   , deferred :: get_scalar_from_vector_node
     
     ! Returns the maximum order among the orders of the polynomial spaces associated to the components of the FE space
     procedure(get_max_order_interface)                 , deferred :: get_max_order

     procedure(get_value_scalar_interface)              , deferred :: get_value_scalar
     procedure(get_value_vector_interface)              , deferred :: get_value_vector
     !procedure(get_value_tensor_interface)             , deferred :: get_value_tensor           ! Pending
     !procedure(get_value_symmetric_tensor_interface)   , deferred :: get_value_symmetric_tensor ! Pending
     generic :: get_value => get_value_scalar,get_value_vector!                                      &
     !          &                !,get_value_tensor,get_value_symmetric_tensor
     
     procedure(get_values_scalar_interface)              , deferred :: get_values_scalar
     procedure(get_values_vector_interface)              , deferred :: get_values_vector
     !procedure(get_value_tensor_interface)             , deferred :: get_value_tensor           ! Pending
     !procedure(get_value_symmetric_tensor_interface)   , deferred :: get_value_symmetric_tensor ! Pending
     generic :: get_values => get_values_scalar,get_values_vector!                                      &
     !          &                !,get_value_tensor,get_value_symmetric_tensor

     procedure(get_gradient_scalar_interface)          , deferred :: get_gradient_scalar
     procedure(get_gradient_vector_interface)          , deferred :: get_gradient_vector
     !procedure(get_gradient_tensor_interface)          , deferred :: get_gradient_tensor ! Pending
     generic :: get_gradient => get_gradient_scalar,get_gradient_vector!                             &
     !          &                   !,get_value_tensor,get_value_symmetric_tensor
     
     procedure(get_gradients_scalar_interface)          , deferred :: get_gradients_scalar
     procedure(get_gradients_vector_interface)          , deferred :: get_gradients_vector
     !procedure(get_gradient_tensor_interface)          , deferred :: get_gradient_tensor ! Pending
     generic :: get_gradients => get_gradients_scalar, get_gradients_vector!                             &
     !          &                   !,get_value_tensor,get_value_symmetric_tensor
     

     !procedure(get_symmetric_gradient_vector_interface), deferred :: get_symmetric_gradient_vector ! Pending
     !generic :: get_symmetric_gradient => get_symmetric_gradient_scalar

     procedure(get_divergence_vector_interface)        , deferred :: get_divergence_vector
     !  procedure(get_divergence_tensor_interface)        , deferred :: get_divergence_tensor ! Pending
     generic :: get_divergence => get_divergence_vector !, get_divergence_tensor
     
     procedure(get_divergences_vector_interface)        , deferred :: get_divergences_vector
     !  procedure(get_divergence_tensor_interface)        , deferred :: get_divergence_tensor ! Pending
     generic :: get_divergences => get_divergences_vector !, get_divergence_tensor

     procedure(get_curl_vector_interface)              , deferred :: get_curl_vector
     generic :: get_curl => get_curl_vector
     
     procedure(get_curls_vector_interface)              , deferred :: get_curls_vector
     generic :: get_curls => get_curls_vector

     procedure(evaluate_fe_function_scalar_interface), deferred :: evaluate_fe_function_scalar
     procedure(evaluate_fe_function_vector_interface), deferred :: evaluate_fe_function_vector
     procedure(evaluate_fe_function_tensor_interface), deferred :: evaluate_fe_function_tensor
     generic :: evaluate_fe_function => evaluate_fe_function_scalar, &
          & evaluate_fe_function_vector, &
          & evaluate_fe_function_tensor

     procedure(evaluate_gradient_fe_function_scalar_interface), deferred :: evaluate_gradient_fe_function_scalar
     procedure(evaluate_gradient_fe_function_vector_interface), deferred :: evaluate_gradient_fe_function_vector
     generic :: evaluate_gradient_fe_function => evaluate_gradient_fe_function_scalar, &
          & evaluate_gradient_fe_function_vector
		  
     ! This subroutine gives the reodering (o2n) of the nodes of an n-face given an orientation 'o'
     ! and a delay 'r' wrt to a refence element sharing the same n-face.
     procedure (check_compatibility_of_n_faces_interface), deferred :: &
          &     check_compatibility_of_n_faces
     procedure (get_characteristic_length_interface) , deferred :: get_characteristic_length

     ! generic part of the subroutine above
     procedure :: free  => reference_fe_free
     procedure :: print => reference_fe_print

     ! Set number_dimensions, order, continuity, field_type, number_field_components
     procedure :: set_common_data => reference_fe_set_common_data
     procedure :: set_topology => reference_fe_set_topology
     procedure :: set_fe_type => reference_fe_set_fe_type

     ! Getters
     procedure :: get_topology => reference_fe_get_topology
     !procedure :: get_fe_type => reference_fe_get_fe_type
     procedure :: get_field_type => reference_fe_get_field_type
     procedure :: get_number_dimensions => reference_fe_get_number_dimensions
     procedure :: get_order => reference_fe_get_order
     procedure :: get_continuity => reference_fe_get_continuity
     procedure :: get_conformity => reference_fe_get_conformity
     procedure :: get_number_field_components => reference_fe_get_number_field_components
     procedure :: get_number_n_faces => reference_fe_get_number_n_faces
     procedure :: get_number_vertices => reference_fe_get_number_vertices
     !procedure :: get_first_vertex_id => reference_fe_get_first_vertex_id
     !procedure :: get_number_vertices_per_edge => reference_fe_get_number_vertices_per_edge
     !procedure :: get_number_vertices_per_face => reference_fe_get_number_vertices_per_face
     !procedure :: get_number_edges => reference_fe_get_number_edges
     !procedure :: get_first_edge_id => reference_fe_get_first_edge_id
     procedure :: get_number_faces => reference_fe_get_number_faces
     procedure :: get_first_face_id => reference_fe_get_first_face_id
     procedure :: get_number_n_faces_of_dimension  => reference_fe_get_number_n_faces_of_dimension
     procedure :: get_first_n_face_id_of_dimension => reference_fe_get_first_n_face_id_of_dimension 
     procedure :: get_number_shape_functions => reference_fe_get_number_shape_functions
     procedure :: get_n_face_dimension  => reference_fe_get_n_face_dimension
     procedure :: get_vertices_n_face  =>   reference_fe_get_vertices_n_face
     procedure :: get_nodes_n_face   =>   reference_fe_get_nodes_n_face
     procedure :: get_n_faces_n_face   =>   reference_fe_get_n_faces_n_face
     procedure :: get_number_vertices_n_face => reference_fe_get_number_vertices_n_face

     procedure :: get_number_dofs_on_n_face => reference_fe_get_number_dofs_on_n_face
     procedure :: create_dofs_on_n_face_iterator => reference_fe_create_dofs_on_n_face_iterator

     procedure :: get_number_own_nodes_n_face => reference_fe_get_number_own_nodes_n_face
     procedure :: create_own_dofs_on_n_face_iterator => reference_fe_create_own_dofs_on_n_face_iterator
     procedure :: get_own_node_n_face => reference_fe_get_own_node_n_face

     procedure :: create_facet_integration_coupling_dofs_iterator => reference_fe_create_facet_integration_coupling_dofs_iterator
     procedure :: has_nodal_quadrature => reference_fe_has_nodal_quadrature
     procedure :: get_nodal_quadrature => reference_fe_get_nodal_quadrature
     procedure :: compute_relative_orientation => reference_fe_compute_relative_orientation
     procedure :: compute_relative_rotation => reference_fe_compute_relative_rotation
     procedure :: get_permuted_own_node_n_face  => reference_fe_get_permuted_own_node_n_face
	 procedure :: update_interpolation_signs => reference_fe_update_interpolation_signs

  end type reference_fe_t

  type p_reference_fe_t
     class(reference_fe_t), pointer :: p => NULL()
   contains
     procedure :: free => p_reference_fe_free
  end type p_reference_fe_t

  abstract interface
     subroutine create_interface ( this, topology, number_dimensions, order, field_type, &
          continuity, enable_face_integration )
       import :: reference_fe_t, ip, SPACE_DIM
       implicit none 
       class(reference_fe_t), intent(inout) :: this 
       character(*)         , intent(in)    :: topology
       integer(ip)          , intent(in)    :: number_dimensions
       integer(ip)          , intent(in)    :: order
       character(*)         , intent(in)    :: field_type
       logical              , intent(in)    :: continuity
       logical, optional    , intent(in)    :: enable_face_integration
     end subroutine create_interface

     subroutine create_quadrature_interface ( this, quadrature, max_order )
       import :: reference_fe_t, quadrature_t, ip
       implicit none 
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(inout) :: quadrature
       integer(ip), optional, intent(in)    :: max_order
     end subroutine create_quadrature_interface

     subroutine create_face_quadrature_interface ( this, quadrature, max_order  )
       import :: reference_fe_t, quadrature_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(inout) :: quadrature
       integer(ip), optional, intent(in)    :: max_order
     end subroutine create_face_quadrature_interface

     subroutine create_interpolation_interface ( this, quadrature, interpolation, compute_hessian )
       import :: reference_fe_t, quadrature_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this 
       type(quadrature_t)   , intent(in)    :: quadrature
       type(interpolation_t), intent(inout) :: interpolation
       logical    , optional, intent(in)    :: compute_hessian
     end subroutine create_interpolation_interface

     subroutine create_face_interpolation_interface ( this, local_face_id , local_quadrature,       &
          &                                           face_interpolation)
       import :: reference_fe_t, ip, quadrature_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this
       integer(ip)          , intent(in)    :: local_face_id
       type(quadrature_t)   , intent(in)    :: local_quadrature
       type(interpolation_t), intent(inout) :: face_interpolation
     end subroutine create_face_interpolation_interface

     function get_component_node_interface( this, node )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this 
       integer(ip)          , intent(in) :: node
       integer(ip) :: get_component_node_interface
     end function get_component_node_interface

     function get_scalar_from_vector_node_interface( this, node )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this 
       integer(ip)          , intent(in) :: node
       integer(ip) :: get_scalar_from_vector_node_interface
     end function get_scalar_from_vector_node_interface

     function get_number_nodes_scalar_interface(this) result(number_nodes_scalar)
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this
       integer(ip)                       :: number_nodes_scalar
     end function get_number_nodes_scalar_interface

     function get_max_order_interface( this )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       integer(ip) :: get_max_order_interface
     end function get_max_order_interface
     
     subroutine get_value_scalar_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 scalar_field )
       import :: reference_fe_t, interpolation_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       real(rp)             , intent(inout) :: scalar_field
     end subroutine get_value_scalar_interface

     subroutine get_value_vector_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_value_vector_interface
     
     subroutine get_values_scalar_interface( this, actual_cell_interpolation, values, qpoints_perm )
       import :: reference_fe_t, interpolation_t, rp, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp), allocatable, intent(inout) :: values(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_values_scalar_interface

     subroutine get_values_vector_interface( this, actual_cell_interpolation, values, qpoints_perm )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       type(vector_field_t), allocatable, intent(inout) :: values(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_values_vector_interface

     subroutine get_gradient_scalar_interface( this, actual_cell_interpolation, ishape, qpoint,     &
          &                                    vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_gradient_scalar_interface

     subroutine get_gradient_vector_interface( this, actual_cell_interpolation, ishape, qpoint,     &
          &                                    tensor_field )
       import :: reference_fe_t, interpolation_t, tensor_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(tensor_field_t) , intent(inout) :: tensor_field
     end subroutine get_gradient_vector_interface
     
     subroutine get_gradients_scalar_interface( this, actual_cell_interpolation, gradients, qpoints_perm )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation
       type(vector_field_t) , allocatable, intent(inout) :: gradients(:,:)
       integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
     end subroutine get_gradients_scalar_interface

     subroutine get_gradients_vector_interface( this, actual_cell_interpolation, gradients, qpoints_perm )
       import :: reference_fe_t, interpolation_t, tensor_field_t, ip
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation
       type(tensor_field_t) , allocatable, intent(inout) :: gradients(:,:)
       integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
     end subroutine get_gradients_vector_interface
     
     subroutine get_divergence_vector_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 scalar_field )
       import :: reference_fe_t, interpolation_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       real(rp)             , intent(inout) :: scalar_field
     end subroutine get_divergence_vector_interface
     
     subroutine get_divergences_vector_interface( this, actual_cell_interpolation, divergences, qpoints_perm  )
       import :: reference_fe_t, interpolation_t, rp, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp), allocatable, intent(inout) :: divergences(:,:)
       integer(ip), optional, intent(in)    :: qpoints_perm(:)
     end subroutine get_divergences_vector_interface
     
     subroutine get_curl_vector_interface( this, actual_cell_interpolation, ishape, qpoint, vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_curl_vector_interface
       
     subroutine get_curls_vector_interface( this, actual_cell_interpolation, curls, qpoints_perm )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
       type(vector_field_t) , allocatable, intent(inout) :: curls(:,:)
       integer(ip)          , optional   , intent(in)    :: qpoints_perm(:)
     end subroutine get_curls_vector_interface

     subroutine evaluate_fe_function_scalar_interface( this,                      &
                                                       actual_cell_interpolation, &
                                                       nodal_values,              &
                                                       quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       real(rp), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_scalar_interface

     subroutine evaluate_fe_function_vector_interface( this,                      &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, vector_field_t
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       real(rp)                         , intent(in)    :: nodal_values(:)
       type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_vector_interface

     subroutine evaluate_fe_function_tensor_interface( this,                      &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, tensor_field_t
       implicit none
       class(reference_fe_t)            , intent(in)    :: this 
       type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
       real(rp)                         , intent(in)    :: nodal_values(:)
       type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_tensor_interface

     subroutine evaluate_gradient_fe_function_scalar_interface( this,             &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, vector_field_t
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
       real(rp)                          , intent(in)    :: nodal_values(:)
       type(vector_field_t) , allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_gradient_fe_function_scalar_interface

     subroutine evaluate_gradient_fe_function_vector_interface( this,             &
          & actual_cell_interpolation, &
          & nodal_values,              &
          & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, tensor_field_t
       implicit none
       class(reference_fe_t)             , intent(in)    :: this 
       type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
       real(rp)                          , intent(in)    :: nodal_values(:)
       type(tensor_field_t) , allocatable, intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_gradient_fe_function_vector_interface
	 
     function check_compatibility_of_n_faces_interface(target_reference_fe, &
          &                       source_reference_fe, source_n_face_id,target_n_face_id)
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: target_reference_fe
       class(reference_fe_t), intent(in)    :: source_reference_fe
       integer(ip)          , intent(in)    :: source_n_face_id
       integer(ip)          , intent(in)    :: target_n_face_id 
       logical :: check_compatibility_of_n_faces_interface
     end function  check_compatibility_of_n_faces_interface

     function get_characteristic_length_interface( this)
       import :: reference_fe_t, rp
       implicit none 
       class(reference_fe_t), intent(in) :: this 
       real(rp)  :: get_characteristic_length_interface 
     end function get_characteristic_length_interface

     subroutine update_interpolation_interface ( this, fe_map, interpolation_reference_cell,        &
          &                            interpolation_real_cell )
       import :: reference_fe_t, fe_map_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this 
       type(fe_map_t)       , intent(in)    :: fe_map
       type(interpolation_t), intent(in)    :: interpolation_reference_cell
       type(interpolation_t), intent(inout) :: interpolation_real_cell
     end subroutine update_interpolation_interface

     subroutine create_nodal_quadrature_interface ( this )
       import :: reference_fe_t
       implicit none
       class(reference_fe_t), intent(inout) :: this 
     end subroutine create_nodal_quadrature_interface
  end interface

  public :: reference_fe_t, p_reference_fe_t
  public :: field_type_scalar, field_type_vector, field_type_tensor, field_type_symmetric_tensor
  public :: topology_hex, topology_tet, fe_type_lagrangian, fe_type_raviart_thomas, fe_type_nedelec, fe_type_new_tet

  type p_lagrangian_reference_fe_t
     class(lagrangian_reference_fe_t), pointer :: p => NULL()
   contains
     procedure :: free => p_lagrangian_reference_fe_free
  end type p_lagrangian_reference_fe_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, abstract, extends(reference_fe_t) :: lagrangian_reference_fe_t
  private
  integer(ip)              :: order_vector(SPACE_DIM)
  integer(ip), allocatable :: node_component_array(:,:)
  integer(ip), allocatable :: node_array_component(:,:)
  type(quadrature_t)       :: nodal_quadrature
contains
  ! Additional deferred methods
  !procedure (fill_scalar_interface)            , private, deferred :: fill_scalar
  procedure (create_data_out_quadrature_interface)           , deferred :: create_data_out_quadrature 
  procedure (get_number_subcells_interface      )            , deferred :: get_number_subcells
  procedure (get_subcells_connectivity_interface)            , deferred :: get_subcells_connectivity
  procedure (fill_quadrature_interface)             , private, deferred :: fill_quadrature
  procedure (fill_nodal_quadrature_interface)       , private, deferred :: fill_nodal_quadrature
  procedure (fill_interpolation_interface)          , private, deferred :: fill_interpolation
  procedure (fill_face_interpolation_interface)     , private, deferred :: fill_face_interpolation
  procedure (set_number_quadrature_points_interface), private, deferred :: set_number_quadrature_points
  ! Blending function to generate interpolations in the interior (given values on the boundary)
  procedure(blending_interface), deferred :: blending

  procedure :: create                    => lagrangian_reference_fe_create
  procedure :: fill_scalar               => lagrangian_reference_fe_fill_scalar
  procedure :: create_quadrature         => lagrangian_reference_fe_create_quadrature
  procedure :: create_face_quadrature    => lagrangian_reference_fe_create_face_quadrature
  procedure :: create_interpolation      => lagrangian_reference_fe_create_interpolation
  procedure :: create_face_interpolation => lagrangian_reference_fe_create_face_interpolation
  procedure :: create_face_local_interpolation  => lagrangian_reference_fe_create_face_local_interpolation
  procedure :: create_edge_local_interpolation  => lagrangian_reference_fe_create_edge_local_interpolation
  procedure :: update_interpolation      => lagrangian_reference_fe_update_interpolation
  procedure :: get_component_node        => lagrangian_reference_fe_get_component_node
  procedure :: get_scalar_from_vector_node  => lagrangian_reference_fe_get_scalar_from_vector_node
  procedure :: get_max_order             => lagrangian_reference_fe_get_max_order
  procedure :: get_value_scalar          => lagrangian_reference_fe_get_value_scalar
  procedure :: get_value_vector          => lagrangian_reference_fe_get_value_vector
  procedure :: get_values_scalar         => lagrangian_reference_fe_get_values_scalar
  procedure :: get_values_vector         => lagrangian_reference_fe_get_values_vector
  procedure :: get_gradient_scalar       => lagrangian_reference_fe_get_gradient_scalar
  procedure :: get_gradient_vector       => lagrangian_reference_fe_get_gradient_vector
  procedure :: get_gradients_scalar      => lagrangian_reference_fe_get_gradients_scalar
  procedure :: get_gradients_vector      => lagrangian_reference_fe_get_gradients_vector
  procedure :: get_divergence_vector     => lagrangian_reference_fe_get_divergence_vector
  procedure :: get_divergences_vector    => lagrangian_reference_fe_get_divergences_vector
  procedure :: get_curl_vector           => lagrangian_reference_fe_get_curl_vector
  procedure :: get_curls_vector          => lagrangian_reference_fe_get_curls_vector
  procedure :: create_nodal_quadrature   => lagrangian_reference_fe_create_nodal_quadrature
  procedure :: has_nodal_quadrature      => lagrangian_reference_fe_has_nodal_quadrature
  procedure :: get_nodal_quadrature      => lagrangian_reference_fe_get_nodal_quadrature
  procedure :: evaluate_fe_function_scalar          &
       & => lagrangian_reference_fe_evaluate_fe_function_scalar
  procedure :: evaluate_fe_function_vector          & 
       & => lagrangian_reference_fe_evaluate_fe_function_vector
  procedure :: evaluate_fe_function_tensor          & 
       & => lagrangian_reference_fe_evaluate_fe_function_tensor
  procedure :: evaluate_gradient_fe_function_scalar & 
       & => lagrangian_reference_fe_evaluate_gradient_fe_function_scalar
  procedure :: evaluate_gradient_fe_function_vector &
       & => lagrangian_reference_fe_evaluate_gradient_fe_function_vector
  procedure :: free                      => lagrangian_reference_fe_free
  ! Concrete TBPs of this derived data type
  procedure, private :: fill                         & 
       & => lagrangian_reference_fe_fill
  procedure, private, non_overridable :: fill_field_components        & 
       & => lagrangian_reference_fe_fill_field_components

  !     procedure, private, non_overridable :: get_node_coordinates_array   & 
  !      & => lagrangian_reference_fe_get_node_coordinates_array
  procedure, private, non_overridable :: extend_list_components       & 
       & => lagrangian_reference_fe_extend_list_components
  procedure, private :: apply_femap_to_interpolation & 
       & => lagrangian_reference_fe_apply_femap_to_interpolation
end type lagrangian_reference_fe_t

abstract interface

  subroutine fill_scalar_interface ( this )
    import :: lagrangian_reference_fe_t
    implicit none 
    class(lagrangian_reference_fe_t), intent(inout) :: this 
  end subroutine fill_scalar_interface
  
  subroutine create_data_out_quadrature_interface ( this, num_refinements, quadrature )
    import :: lagrangian_reference_fe_t, ip, quadrature_t
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip)                     , intent(in)    :: num_refinements
    type(quadrature_t)              , intent(inout) :: quadrature
  end subroutine create_data_out_quadrature_interface

  function get_number_subcells_interface(this, num_refinements) result(num_subcells)
    import :: lagrangian_reference_fe_t, ip
    implicit none
    class(lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip),                      intent(in)    :: num_refinements
    integer(ip)                                     :: num_subcells
  end function get_number_subcells_interface
  
  subroutine get_subcells_connectivity_interface(this, num_refinements, connectivity)
    import :: lagrangian_reference_fe_t, ip
    implicit none
    class(lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip),                      intent(in)    :: num_refinements
    integer(ip),                      intent(inout) :: connectivity(:,:)
  end subroutine get_subcells_connectivity_interface

  subroutine fill_quadrature_interface ( this, quadrature )
    import :: lagrangian_reference_fe_t, quadrature_t
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(inout) :: quadrature       
  end subroutine fill_quadrature_interface

  subroutine fill_nodal_quadrature_interface ( this, quadrature ) 
    import :: lagrangian_reference_fe_t, quadrature_t
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(inout) :: quadrature  
  end subroutine fill_nodal_quadrature_interface

  subroutine fill_interpolation_interface ( this, quadrature, interpolation, order_vector )
    import :: lagrangian_reference_fe_t, interpolation_t, ip, rp, quadrature_t, SPACE_DIM
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(in)    :: quadrature
    type(interpolation_t)           , intent(inout) :: interpolation
    integer(ip)           , optional, intent(in)    :: order_vector(SPACE_DIM)
  end subroutine fill_interpolation_interface

  subroutine fill_face_interpolation_interface ( this,               &
       local_quadrature, &
       local_face_id,   &
       face_interpolation )
    import :: lagrangian_reference_fe_t, interpolation_t, quadrature_t, ip
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    type(quadrature_t)              , intent(in)    :: local_quadrature
    integer(ip)                     , intent(in)    :: local_face_id
    type(interpolation_t)           , intent(inout) :: face_interpolation
  end subroutine fill_face_interpolation_interface

  function set_number_quadrature_points_interface ( this, order, dimension )
    import :: lagrangian_reference_fe_t, ip, SPACE_DIM
    implicit none 
    class(lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip)                     , intent(in)    :: order
    integer(ip)                     , intent(in)    :: dimension
    integer(ip) :: set_number_quadrature_points_interface
  end function set_number_quadrature_points_interface

  subroutine blending_interface( this,values)
    import :: lagrangian_reference_fe_t, point_t
    implicit none
    class(lagrangian_reference_fe_t), intent(in)    :: this 
    type(point_t)                   , intent(inout) :: values(:)     
  end subroutine blending_interface

end interface

public :: lagrangian_reference_fe_t, p_lagrangian_reference_fe_t 


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, abstract, extends(lagrangian_reference_fe_t) :: raviart_thomas_reference_fe_t
private
type(node_array_t)    :: node_array_vector(SPACE_DIM)
real(rp), allocatable :: change_basis_matrix(:,:)
logical               :: basis_changed
contains
procedure (change_basis_interface), private, deferred :: change_basis
procedure :: create                           => raviart_thomas_create
procedure :: free                             => raviart_thomas_free
procedure :: create_face_local_interpolation  => raviart_thomas_create_face_local_interpolation
procedure :: blending                         => raviart_thomas_blending
procedure :: create_data_out_quadrature       => raviart_thomas_create_data_out_quadrature
procedure :: get_number_subcells              => raviart_thomas_get_number_subcells
procedure :: get_subcells_connectivity        => raviart_thomas_get_subcells_connectivity
procedure :: has_nodal_quadrature             => raviart_thomas_has_nodal_quadrature
procedure :: get_nodal_quadrature             => raviart_thomas_get_nodal_quadrature    
procedure :: get_value_scalar                 => raviart_thomas_get_value_scalar
procedure :: get_value_vector                 => raviart_thomas_get_value_vector
procedure :: get_values_scalar                => raviart_thomas_get_values_scalar
procedure :: get_values_vector                => raviart_thomas_get_values_vector
procedure :: get_gradient_scalar              => raviart_thomas_get_gradient_scalar
procedure :: get_gradient_vector              => raviart_thomas_get_gradient_vector
procedure :: get_gradients_scalar             => raviart_thomas_get_gradients_scalar
procedure :: get_gradients_vector             => raviart_thomas_get_gradients_vector
procedure :: get_divergence_vector            => raviart_thomas_get_divergence_vector
procedure :: get_divergences_vector           => raviart_thomas_get_divergences_vector
procedure :: get_curl_vector                  => raviart_thomas_get_curl_vector
procedure :: get_curls_vector                  => raviart_thomas_get_curls_vector
procedure :: create_interpolation             => raviart_thomas_create_interpolation
procedure :: create_face_interpolation        => raviart_thomas_create_face_interpolation
procedure :: evaluate_fe_function_scalar          &
    & => raviart_thomas_evaluate_fe_function_scalar
procedure :: evaluate_fe_function_vector          & 
    & => raviart_thomas_evaluate_fe_function_vector
procedure :: evaluate_fe_function_tensor          & 
    & => raviart_thomas_evaluate_fe_function_tensor
procedure, private :: apply_femap_to_interpolation & 
    & => raviart_thomas_apply_femap_to_interpolation
procedure, private :: fill                         & 
    & => raviart_thomas_fill
procedure, private :: fill_vector                         & 
    & => raviart_thomas_fill_vector    
procedure, private :: fill_nodal_quadrature &
    & => raviart_thomas_fill_nodal_quadrature
procedure, private :: invert_change_basis_matrix &
    & => raviart_thomas_invert_change_basis_matrix
procedure, private :: apply_change_basis_matrix_to_interpolation &
    & => rt_apply_change_basis_matrix_to_interpolation 
procedure          :: apply_change_basis_matrix_to_nodal_values &
    & => rt_apply_change_basis_matrix_to_nodal_values
end type raviart_thomas_reference_fe_t 

abstract interface
  subroutine change_basis_interface ( this )
    import :: raviart_thomas_reference_fe_t 
    implicit none 
    class(raviart_thomas_reference_fe_t), intent(inout) :: this 
  end subroutine change_basis_interface
end interface  


public :: raviart_thomas_reference_fe_t  


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, abstract, extends(lagrangian_reference_fe_t) :: nedelec_reference_fe_t
private
type(node_array_t)    :: node_array_vector(SPACE_DIM)
real(rp), allocatable :: change_basis_matrix(:,:)
logical               :: basis_changed
contains

procedure (nedelec_change_basis_interface) , private, deferred :: change_basis
procedure (nedelec_fill_edge_interpolation), private, deferred :: fill_edge_interpolation

procedure :: create                          => nedelec_create
procedure :: free                            => nedelec_free
procedure :: create_face_local_interpolation => nedelec_create_face_local_interpolation
procedure :: blending                        => nedelec_blending
procedure :: create_data_out_quadrature      => nedelec_create_data_out_quadrature
procedure :: get_number_subcells             => nedelec_get_number_subcells
procedure :: get_subcells_connectivity       => nedelec_get_subcells_connectivity
procedure :: has_nodal_quadrature            => nedelec_has_nodal_quadrature
procedure :: get_nodal_quadrature            => nedelec_get_nodal_quadrature 
procedure :: get_value_scalar                => nedelec_get_value_scalar
procedure :: get_value_vector                => nedelec_get_value_vector
procedure :: get_values_scalar               => nedelec_get_values_scalar
procedure :: get_values_vector               => nedelec_get_values_vector
procedure :: get_gradient_scalar             => nedelec_get_gradient_scalar
procedure :: get_gradient_vector             => nedelec_get_gradient_vector
procedure :: get_gradients_scalar            => nedelec_get_gradients_scalar
procedure :: get_gradients_vector            => nedelec_get_gradients_vector
procedure :: get_divergence_vector           => nedelec_get_divergence_vector
procedure :: get_divergences_vector          => nedelec_get_divergences_vector
procedure :: get_curl_vector                 => nedelec_get_curl_vector
procedure :: get_curls_vector                => nedelec_get_curls_vector
procedure :: create_interpolation            => nedelec_create_interpolation
procedure :: create_face_interpolation       => nedelec_create_face_interpolation
procedure :: create_edge_interpolation       => nedelec_create_edge_interpolation
procedure :: create_edge_quadrature          => nedelec_create_edge_quadrature
procedure :: evaluate_fe_function_scalar          &
    & => nedelec_evaluate_fe_function_scalar
procedure :: evaluate_fe_function_vector          & 
    & => nedelec_evaluate_fe_function_vector
procedure :: evaluate_fe_function_tensor          & 
    & => nedelec_evaluate_fe_function_tensor
procedure, private :: apply_femap_to_interpolation & 
    & => nedelec_apply_femap_to_interpolation
procedure, private :: fill                         & 
    & => nedelec_fill
procedure, private :: fill_vector                         & 
    & => nedelec_fill_vector    
procedure, private :: fill_nodal_quadrature &
    & => nedelec_fill_nodal_quadrature
procedure, private :: invert_change_basis_matrix &
    & => nedelec_invert_change_basis_matrix
procedure, private :: apply_change_basis_matrix_to_interpolation &
    & => nedelec_apply_change_basis_matrix_to_interpolation 
procedure          :: apply_change_basis_matrix_to_nodal_values &
    & => nedelec_apply_change_basis_matrix_to_nodal_values
end type nedelec_reference_fe_t 

abstract interface
  subroutine nedelec_change_basis_interface ( this )
    import :: nedelec_reference_fe_t 
    implicit none 
    class(nedelec_reference_fe_t), intent(inout) :: this 
  end subroutine nedelec_change_basis_interface
  
  subroutine nedelec_fill_edge_interpolation ( this, & 
                                               local_edge_id, & 
                                               local_quadrature, & 
                                               edge_interpolation )
    import :: nedelec_reference_fe_t, ip, quadrature_t, interpolation_t
    implicit none 
    class(nedelec_reference_fe_t), intent(in)    :: this 
    integer(ip)                  , intent(in)    :: local_edge_id
    type(quadrature_t)           , intent(in)    :: local_quadrature
    type(interpolation_t)        , intent(inout) :: edge_interpolation
  end subroutine nedelec_fill_edge_interpolation
end interface 

public :: nedelec_reference_fe_t


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(lagrangian_reference_fe_t) :: tet_lagrangian_reference_fe_t
private
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                                 &
 &   => tet_lagrangian_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
 &   => tet_lagrangian_reference_fe_get_characteristic_length
procedure :: get_number_subcells                                         &
&    => tet_lagrangian_reference_fe_get_number_subcells
procedure :: get_subcells_connectivity                                   &
 &   => tet_lagrangian_reference_fe_get_subcells_connectivity
procedure :: blending                                                    &
 &   => tet_lagrangian_reference_fe_blending 
! Deferred TBP implementors from lagrangian_reference_fe_t
!procedure, private :: fill_scalar                                        &
!      & => tet_lagrangian_reference_fe_fill_scalar
procedure :: create_data_out_quadrature                                  & 
    => tet_lagrangian_create_data_out_quadrature
procedure, private :: fill_quadrature                                    &
 & => tet_lagrangian_reference_fe_fill_quadrature
procedure, private :: fill_nodal_quadrature                              &
 & => tet_lagrangian_reference_fe_fill_nodal_quadrature
procedure, private :: fill_interpolation                                 &
 & => tet_lagrangian_reference_fe_fill_interpolation
procedure, private :: fill_face_interpolation                            &
 & => tet_lagrangian_reference_fe_fill_face_interpolation
procedure, private :: get_node_local_id                                  &
 & => tet_lagrangian_reference_fe_get_node_local_id
procedure, private :: set_permutation_2D                                 &
 & => tet_lagrangian_reference_fe_set_permutation_2D     
procedure, private :: compute_number_nodes_scalar                        &
 & => tet_lagrangian_reference_fe_compute_number_nodes_scalar
procedure, private :: set_number_quadrature_points                       &
 & => tet_lagrangian_reference_fe_set_number_quadrature_points
! Concrete TBPs of this derived data type
procedure, private, non_overridable :: fill_nodes_n_face                    &
 & => tet_lagrangian_reference_fe_fill_nodes_n_face
procedure, private, non_overridable :: fill_n_face_dimension_and_vertices   &
 & => tet_lagrangian_reference_fe_fill_n_face_dimension_and_vertices
procedure, private, non_overridable :: compute_number_interior_nodes     &
 & => tet_lagrangian_reference_fe_compute_number_interior_nodes
procedure, private, non_overridable :: compute_sum_of_nodes_in_simplices &
 & => tet_lagrangian_reference_fe_compute_sum_of_nodes_in_simplices
procedure, private, non_overridable :: evaluate_interpolation            &
 & => tet_lagrangian_reference_fe_evaluate_interpolation
procedure, private, non_overridable :: get_n_face_orientation               &
 & => tet_lagrangian_reference_fe_get_n_face_orientation
end type tet_lagrangian_reference_fe_t

type, extends(tet_lagrangian_reference_fe_t) :: new_tet_lagrangian_reference_fe_t
  private
  logical               :: basis_changed
  real(rp), allocatable :: change_basis_matrix(:,:)
 contains
   procedure :: create  => new_tet_lagrangian_reference_fe_create
   procedure :: free    => new_tet_lagrangian_reference_fe_free
   procedure, private :: fill_quadrature                                                &
                      & => new_tet_lagrangian_reference_fe_fill_quadrature
   procedure, private :: fill_interpolation                                             &
                      & => new_tet_lagrangian_reference_fe_fill_interpolation
   procedure, private :: fill_interpolation_pre_basis                                   &
                      & => new_tet_lagrangian_reference_fe_fill_interpolation_pre_basis
   procedure, private :: change_basis                                                   &
                      & => new_tet_lagrangian_reference_fe_change_basis
   procedure, private :: invert_change_basis_matrix                                     &
                      & => new_tet_lagrangian_reference_fe_invert_change_basis_matrix
   procedure, private :: apply_change_basis_matrix_to_interpolation                     &
                      & => new_tet_lagrangian_ref_fe_apply_change_basis_to_interpolation 
   procedure, private :: set_number_quadrature_points                                   &
                      & => new_tet_lagrangian_reference_fe_set_number_quadrature_points
end type new_tet_lagrangian_reference_fe_t

public :: tet_lagrangian_reference_fe_t, new_tet_lagrangian_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(raviart_thomas_reference_fe_t) :: tet_raviart_thomas_reference_fe_t
private
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                                 &
&   => tet_raviart_thomas_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => tet_raviart_thomas_get_characteristic_length
! Deferred TBP implementors from lagrangian_reference_fe_t
!procedure, private :: fill_scalar                                        &
!      & => tet_raviart_thomas_fill_scalar
procedure, private :: fill_quadrature                                    &
& => tet_raviart_thomas_fill_quadrature
procedure, private :: fill_interpolation                                 &
& => tet_raviart_thomas_fill_interpolation
procedure, private :: fill_face_interpolation                            &
& => tet_raviart_thomas_fill_face_interpolation
procedure, private :: set_permutation_2D                                 &
& => tet_raviart_thomas_set_permutation_2D
procedure, private :: set_number_quadrature_points                       &
& => tet_raviart_thomas_set_number_quadrature_points
procedure, private :: get_node_local_id                   &
& => tet_raviart_thomas_get_node_local_id
! Concrete TBPs of this derived data type
procedure, private, non_overridable :: raviart_thomas_fill_nodes_n_face                    &
& => tet_raviart_thomas_fill_nodes_n_face
procedure, private, non_overridable :: raviart_thomas_fill_n_face_dimension_and_vertices   &
& => tet_raviart_thomas_fill_n_face_dimension_and_vertices
procedure, private, non_overridable :: compute_number_interior_nodes     &
& => tet_raviart_thomas_compute_number_interior_nodes
procedure, private, non_overridable :: raviart_thomas_compute_sum_of_nodes_in_simplices &
& => tet_raviart_thomas_compute_sum_of_nodes_in_simplices
procedure, private, non_overridable :: raviart_thomas_evaluate_interpolation            &
& => tet_raviart_thomas_evaluate_interpolation
procedure, private, non_overridable :: raviart_thomas_get_n_face_orientation               &
& => tet_raviart_thomas_get_n_face_orientation
procedure, private :: change_basis &
& => tet_raviart_thomas_reference_fe_change_basis
end type tet_raviart_thomas_reference_fe_t

public :: tet_raviart_thomas_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(lagrangian_reference_fe_t) :: hex_lagrangian_reference_fe_t
private
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                                 &
&   => hex_lagrangian_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => hex_lagrangian_reference_fe_get_characteristic_length
procedure :: get_number_subcells                                         &
&   => hex_lagrangian_reference_fe_get_number_subcells
procedure :: get_subcells_connectivity                                   &
&   => hex_lagrangian_reference_fe_get_subcells_connectivity
procedure :: blending                                                    &
&   => hex_lagrangian_reference_fe_blending           
! Deferred TBP implementors from lagrangian_reference_fe_t
procedure          :: create_data_out_quadrature                         & 
    => hex_lagrangian_create_data_out_quadrature
procedure, private :: fill_quadrature                                    &
& => hex_lagrangian_reference_fe_fill_quadrature
procedure, private :: fill_nodal_quadrature                              &
& => hex_lagrangian_reference_fe_fill_nodal_quadrature
procedure, private :: fill_interpolation                                 &
& => hex_lagrangian_reference_fe_fill_interpolation
procedure, private :: fill_face_interpolation                            &
& => hex_lagrangian_reference_fe_fill_face_interpolation
procedure, private :: set_number_quadrature_points                       &
& => hex_lagrangian_reference_fe_set_number_quadrature_points
end type hex_lagrangian_reference_fe_t

public :: hex_lagrangian_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(raviart_thomas_reference_fe_t) :: hex_raviart_thomas_reference_fe_t
private
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                                 &
&   => hex_raviart_thomas_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => hex_raviart_thomas_reference_fe_get_characteristic_length

! Deferred TBP implementors from raviart_thomas_reference_fe_t
procedure, private :: fill_quadrature                                    &
& => hex_raviart_thomas_reference_fe_fill_quadrature
procedure, private :: fill_interpolation                                 &
& => hex_raviart_thomas_reference_fe_fill_interpolation
procedure, private :: fill_interpolation_pre_basis                       &
& => hex_raviart_thomas_reference_fe_fill_interpolation_pre_basis
procedure, private :: fill_face_interpolation                            &
& => hex_raviart_thomas_reference_fe_fill_face_interpolation
procedure, private :: set_number_quadrature_points                       &
& => hex_raviart_thomas_reference_fe_set_number_quadrature_points
procedure, private :: change_basis &
& => hex_raviart_thomas_reference_fe_change_basis

end type hex_raviart_thomas_reference_fe_t

public :: hex_raviart_thomas_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(nedelec_reference_fe_t) :: hex_nedelec_reference_fe_t
private
contains 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                              &
&   => hex_nedelec_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => hex_nedelec_reference_fe_get_characteristic_length

! Deferred TBP implementors from nedelec_reference_fe_t
procedure, private :: fill_quadrature                                    &
& => hex_nedelec_reference_fe_fill_quadrature
procedure, private :: fill_interpolation                                 &
& => hex_nedelec_reference_fe_fill_interpolation
procedure, private :: fill_interpolation_pre_basis                       &
& => hex_nedelec_reference_fe_fill_interpolation_pre_basis
procedure, private :: fill_face_interpolation                            &
& => hex_nedelec_reference_fe_fill_face_interpolation
procedure, private :: fill_edge_interpolation                            &
& => hex_nedelec_reference_fe_fill_edge_interpolation
procedure, private :: set_number_quadrature_points                       &
& => hex_nedelec_reference_fe_set_number_quadrature_points
procedure, private :: change_basis &
& => hex_nedelec_reference_fe_change_basis

end type hex_nedelec_reference_fe_t

public :: hex_nedelec_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type, extends(nedelec_reference_fe_t) :: tet_nedelec_reference_fe_t
private
real(rp), allocatable :: basis_Sk(:,:)
contains 
procedure :: free => tet_nedelec_reference_fe_free 
  ! Deferred TBP implementors from reference_fe_t
procedure :: check_compatibility_of_n_faces                              &
&   => tet_nedelec_reference_fe_check_compatibility_of_n_faces
procedure :: get_characteristic_length                                   &
&   => tet_nedelec_reference_fe_get_characteristic_length
procedure, private :: fill                                               & 
&   => tet_nedelec_reference_fe_fill 
procedure, private :: fill_vector                                        & 
&   => tet_nedelec_reference_fe_fill_vector
procedure, private :: fill_quadrature                                    &
& => tet_nedelec_reference_fe_fill_quadrature
procedure, private :: fill_interpolation                                 &
& => tet_nedelec_reference_fe_fill_interpolation
procedure, private :: fill_interpolation_pre_basis                       &
& => tet_nedelec_reference_fe_fill_interpolation_pre_basis
procedure, private :: conform_k_order_polynomial_basis                
procedure, private :: fill_face_interpolation                            &
& => tet_nedelec_reference_fe_fill_face_interpolation
procedure, private :: fill_edge_interpolation                            &
& => tet_nedelec_reference_fe_fill_edge_interpolation
procedure, private :: set_permutation_2D                                 &
& => tet_nedelec_reference_fe_set_permutation_2D
procedure, private :: set_number_quadrature_points                       &
& => tet_nedelec_reference_fe_set_number_quadrature_points
procedure, private :: compute_number_nodes_scalar                        &
 & => tet_nedelec_reference_fe_compute_number_nodes_scalar
procedure, private :: get_node_local_id                                  &
& => tet_nedelec_reference_fe_get_node_local_id
! Concrete TBPs of this derived data type
procedure, private, non_overridable :: fill_nodes_n_face                            &
& => tet_nedelec_reference_fe_fill_nodes_n_face
procedure, private, non_overridable :: fill_n_face_dimension_and_vertices           &
& => tet_nedelec_reference_fe_fill_n_face_dimension_and_vertices
procedure, private, non_overridable :: compute_number_interior_nodes                &
& => tet_nedelec_reference_fe_compute_number_interior_nodes
procedure, private, non_overridable :: compute_sum_of_nodes_in_simplices            &
& => tet_nedelec_reference_fe_compute_sum_of_nodes_in_simplices
procedure, private, non_overridable :: nedelec_get_n_face_orientation               &
& => tet_nedelec_reference_fe_get_n_face_orientation
procedure, private :: change_basis                                                  &
& => tet_nedelec_reference_fe_change_basis
procedure, private :: create_and_fill_basis_Sk_indices                              & 
& => tet_nedelec_reference_fe_create_and_fill_basis_Sk_indices 
procedure :: update_interpolation_signs                                             &
& => tet_nedelec_reference_fe_update_interpolation_signs 
end type tet_nedelec_reference_fe_t

public :: tet_nedelec_reference_fe_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type volume_integrator_t 
private
integer(ip)                    :: number_shape_functions
integer(ip)                    :: number_quadrature_points
class(reference_fe_t), pointer :: reference_fe
type(interpolation_t)          :: interpolation      ! Unknown interpolation_t in the reference element domain
type(interpolation_t)          :: interpolation_o_map! Unknown interpolation_t in the physical element domain
contains

procedure, non_overridable :: create             => volume_integrator_create
procedure, non_overridable :: create_on_face     => volume_integrator_create_on_face
procedure, non_overridable :: free               => volume_integrator_free
procedure, non_overridable :: update             => volume_integrator_update
procedure, non_overridable :: apply_sign_change  => volume_integrator_apply_sign_change
procedure, non_overridable :: print              => volume_integrator_print

procedure, non_overridable :: get_interpolation_reference_cell =>                               &
&                                   volume_integrator_get_interpolation_reference_cell
procedure, non_overridable :: get_interpolation_real_cell =>                                    &
&                                   volume_integrator_get_interpolation_real_cell


procedure, non_overridable, private :: get_value_scalar           => volume_integrator_get_value_scalar
procedure, non_overridable, private :: get_value_vector           => volume_integrator_get_value_vector
procedure, non_overridable, private :: get_value_tensor           => volume_integrator_get_value_tensor
procedure, non_overridable, private :: get_value_symmetric_tensor => volume_integrator_get_value_symmetric_tensor
generic            :: get_value => get_value_scalar, &
                                   get_value_vector, &
                                   get_value_tensor, &
                                   get_value_symmetric_tensor
                                   
procedure, non_overridable, private :: get_values_scalar           => volume_integrator_get_values_scalar
procedure, non_overridable, private :: get_values_vector           => volume_integrator_get_values_vector
!procedure, non_overridable, private :: get_value_tensor           => volume_integrator_get_value_tensor
!procedure, non_overridable, private :: get_value_symmetric_tensor => volume_integrator_get_value_symmetric_tensor
generic            :: get_values => get_values_scalar, &
                                    get_values_vector !, &
                                   !get_value_tensor, &
                                   !get_value_symmetric_tensor
procedure, non_overridable, private :: get_gradient_scalar => volume_integrator_get_gradient_scalar
procedure, non_overridable, private :: get_gradient_vector => volume_integrator_get_gradient_vector
generic                             :: get_gradient => get_gradient_scalar, &
                                                       get_gradient_vector 

procedure, non_overridable, private :: get_gradients_scalar => volume_integrator_get_gradients_scalar
procedure, non_overridable, private :: get_gradients_vector => volume_integrator_get_gradients_vector
generic                             :: get_gradients => get_gradients_scalar, &
                                                        get_gradients_vector 

procedure, non_overridable, private :: get_symmetric_gradient_vector => volume_integrator_get_symmetric_gradient_vector
generic                             :: get_symmetric_gradient => get_symmetric_gradient_vector

procedure, non_overridable, private :: get_divergence_vector => volume_integrator_get_divergence_vector
procedure, non_overridable, private :: get_divergence_tensor => volume_integrator_get_divergence_tensor
generic                             :: get_divergence => get_divergence_vector, &
                                                         get_divergence_tensor
procedure, non_overridable, private :: get_divergences_vector => volume_integrator_get_divergences_vector
!procedure, non_overridable, private :: get_divergences_tensor => volume_integrator_get_divergences_tensor
generic                             :: get_divergences => get_divergences_vector!, &
                                                         !get_divergence_tensor

procedure, non_overridable, private :: get_curl_vector => volume_integrator_get_curl_vector
generic                             :: get_curl => get_curl_vector

procedure, non_overridable, private :: get_curls_vector => volume_integrator_get_curls_vector
generic                             :: get_curls => get_curls_vector

! We might want to have the following in the future:
!  (x) get_hessian (scalar,vector)
!  (x) get_third_derivative (scalar,vector)
! But note that in such a case we would require higher-to-2 rank tensors
! (i.e., type(tensor_field_t) is a rank-2 tensor)

procedure, non_overridable, private :: volume_integrator_evaluate_fe_function_scalar
procedure, non_overridable, private :: volume_integrator_evaluate_fe_function_vector
procedure, non_overridable, private :: volume_integrator_evaluate_fe_function_tensor
generic :: evaluate_fe_function => volume_integrator_evaluate_fe_function_scalar, &
& volume_integrator_evaluate_fe_function_vector, &
& volume_integrator_evaluate_fe_function_tensor

procedure, non_overridable, private :: volume_integrator_evaluate_gradient_fe_function_scalar
procedure, non_overridable, private :: volume_integrator_evaluate_gradient_fe_function_vector
generic :: evaluate_gradient_fe_function => volume_integrator_evaluate_gradient_fe_function_scalar, &
& volume_integrator_evaluate_gradient_fe_function_vector

end type volume_integrator_t

type p_volume_integrator_t
type(volume_integrator_t), pointer :: p => NULL() 
contains
procedure :: allocate => p_volume_integrator_allocate 
procedure :: free     => p_volume_integrator_free
end type p_volume_integrator_t

public :: volume_integrator_t, p_volume_integrator_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type volume_integrator_face_restriction_t
     private
     integer(ip)                            :: number_faces
     integer(ip)                            :: active_face_lid
     type(volume_integrator_t), allocatable :: volume_integrator(:) 
   contains
     procedure, non_overridable :: create  => volume_integrator_face_restriction_create
     procedure, non_overridable :: update  => volume_integrator_face_restriction_update
     procedure, non_overridable :: free    => volume_integrator_face_restriction_free
     procedure, non_overridable :: get_active_volume_integrator => volume_integrator_face_restriction_get_active_volume_integrator
  end type volume_integrator_face_restriction_t

  public :: volume_integrator_face_restriction_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type face_map_t
  private
  logical                         :: is_boundary
  type(fe_map_t)                  :: face_map
  type(fe_map_face_restriction_t) :: fe_maps(2)
  integer(ip)                     :: number_dimensions
contains
  procedure, non_overridable :: create               => face_map_create
  procedure, non_overridable :: free                 => face_map_free
  procedure, non_overridable :: update               => face_map_update
  procedure, non_overridable :: compute_characteristic_length                                      &
  &                                             => face_map_compute_characteristic_length
  procedure, non_overridable :: get_quadrature_coordinates                                         &
  &                                             => face_map_get_quadrature_coordinates
  procedure, non_overridable :: get_face_coordinates => face_map_get_face_coordinates
  procedure, non_overridable :: get_coordinates_neighbour                                          &
  &                                             => face_map_get_coordinates_neighbour
  procedure, non_overridable :: get_neighbour_fe_map => face_map_get_neighbour_fe_map
  procedure, non_overridable :: get_normals          => face_map_get_normals
  procedure, non_overridable :: get_det_jacobian     => face_map_get_det_jacobian
  procedure, non_overridable :: get_face_map         => face_map_get_face_map
end type face_map_t

public :: face_map_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type face_integrator_t
  private
  logical                                    :: is_boundary
  type(volume_integrator_face_restriction_t) :: volume_integrator_face_restriction(2)
  type(p_reference_fe_t)                     :: reference_fe(2)
  integer(ip)                                :: current_qpoints_perm_cols(2)
  type(allocatable_array_ip2_t)              :: qpoints_perm
contains
  procedure, non_overridable :: create            => face_integrator_create
  procedure, non_overridable :: update            => face_integrator_update
  procedure, non_overridable :: free              => face_integrator_free
  procedure, non_overridable :: get_value_scalar  => face_integrator_get_value_scalar
  procedure, non_overridable :: get_value_vector  => face_integrator_get_value_vector
  generic                    :: get_value         => get_value_scalar, get_value_vector
  procedure, non_overridable :: get_values_scalar => face_integrator_get_values_scalar
  procedure, non_overridable :: get_values_vector => face_integrator_get_values_vector
  generic                    :: get_values        => get_values_scalar, get_values_vector
  procedure, non_overridable :: get_gradient_scalar  => face_integrator_get_gradient_scalar
  generic                    :: get_gradient => get_gradient_scalar
  procedure, non_overridable :: get_gradients_scalar  => face_integrator_get_gradients_scalar
  generic                    :: get_gradients => get_gradients_scalar
  procedure, non_overridable :: get_curl          => face_integrator_get_curl_vector 
  procedure, non_overridable :: get_curls         => face_integrator_get_curls_vector 
  procedure, non_overridable :: get_current_qpoints_perm => face_integrator_get_current_qpoints_perm

  procedure, non_overridable, private :: face_integrator_evaluate_fe_function_scalar
  procedure, non_overridable, private :: face_integrator_evaluate_fe_function_vector
  procedure, non_overridable, private :: face_integrator_evaluate_fe_function_tensor
  generic :: evaluate_fe_function => face_integrator_evaluate_fe_function_scalar, &
  & face_integrator_evaluate_fe_function_vector, &
  & face_integrator_evaluate_fe_function_tensor

  procedure, non_overridable, private :: face_integrator_evaluate_gradient_fe_function_scalar
  procedure, non_overridable, private :: face_integrator_evaluate_gradient_fe_function_vector
  generic :: evaluate_gradient_fe_function => face_integrator_evaluate_gradient_fe_function_scalar, &
  & face_integrator_evaluate_gradient_fe_function_vector
end type face_integrator_t

type p_face_integrator_t
type(face_integrator_t)          , pointer :: p => NULL()
end type p_face_integrator_t

public :: face_integrator_t, p_face_integrator_t

public :: make_reference_fe

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

contains

  ! Includes with all the TBP and supporting subroutines for the types above.
  ! In a future, we would like to use the submodule features of FORTRAN 2008.

#include "sbm_quadrature.i90"

#include "sbm_interpolation.i90"

#include "sbm_reference_fe.i90"

#include "sbm_lagrangian_reference_fe.i90"

#include "sbm_raviart_thomas_reference_fe.i90"

#include "sbm_nedelec_reference_fe.i90"

#include "sbm_hex_lagrangian_reference_fe.i90"

#include "sbm_tet_lagrangian_reference_fe.i90"

#include "sbm_new_tet_lagrangian_reference_fe.i90"

#include "sbm_hex_raviart_thomas_reference_fe.i90"

#include "sbm_tet_raviart_thomas_reference_fe.i90"

#include "sbm_hex_nedelec_reference_fe.i90"

#include "sbm_tet_nedelec_reference_fe.i90"

#include "sbm_polytope_topology.i90"

#include "sbm_volume_integrator.i90"

#include "sbm_face_integrator.i90"

#include "sbm_reference_fe_factory.i90"

end module reference_fe_names
