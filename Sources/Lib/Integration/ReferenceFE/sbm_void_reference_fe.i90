! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================
subroutine void_reference_fe_create ( this, topology, number_dimensions, order, field_type, & 
     &  conformity, continuity )
  implicit none 
  class(void_reference_fe_t), intent(inout) :: this
  character(*)                    , intent(in)    :: topology
  integer(ip)                     , intent(in)    :: number_dimensions
  integer(ip)                     , intent(in)    :: order
  character(*)                    , intent(in)    :: field_type
  logical                         , intent(in)    :: conformity
  logical              , optional , intent(in)    :: continuity

  call this%free()
  call this%set_common_data(number_dimensions, &
                            -1, & ! DIRTY :: order is equal to -1 for void FEs independently of the value passed by the user
                            field_type, &
                            conformity, &
                            continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_void )
  call this%fill()
end subroutine void_reference_fe_create

!==================================================================================================
subroutine void_reference_fe_create_quadrature ( this, quadrature, max_order )
  implicit none 
  class(void_reference_fe_t), intent(in)       :: this  
  type(quadrature_t)        , intent(inout)    :: quadrature
  integer(ip)           , optional, intent(in) :: max_order
  call quadrature%create( this%number_dimensions, 0 )
end subroutine void_reference_fe_create_quadrature

!==================================================================================================
subroutine void_reference_fe_create_face_quadrature ( this, quadrature, max_order )
  implicit none
  class(void_reference_fe_t)      , intent(in)    :: this
  type(quadrature_t)              , intent(inout) :: quadrature
  integer(ip)           , optional, intent(in)    :: max_order
  integer(ip) :: face_dimensions
  face_dimensions = this%number_dimensions - 1
  call quadrature%create( face_dimensions, 0 )
end subroutine void_reference_fe_create_face_quadrature

!==================================================================================================
subroutine void_reference_fe_create_interpolation ( this, quadrature, & 
     &                                              interpolation, compute_hessian )
  implicit none 
  class(void_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  logical               , optional, intent(in)    :: compute_hessian

  integer(ip) :: ntens, i

  ntens = 0
  do i = 1, this%number_dimensions
     ntens = ntens + i
  end do

  call interpolation%create( this%number_dimensions, &
                             this%number_shape_functions, &
                             quadrature%number_quadrature_points, &
                             ntens, &
                             compute_hessian )
  !call this%fill_interpolation( quadrature, interpolation )
end subroutine void_reference_fe_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'local_face_id' of the element or
! in all the faces of the element.
subroutine void_reference_fe_create_face_interpolation( this,local_face_id, &
     & local_quadrature,face_interpolation)
  implicit none 
  class(void_reference_fe_t), intent(in)    :: this 
  integer(ip)                     , intent(in)    :: local_face_id
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: face_interpolation

  ! Allocate the arrays of the interpolation
  call face_interpolation%create(this%number_dimensions,this%node_array%number_nodes, &
       & local_quadrature%number_quadrature_points, 0 )

  ! Fill the values of the shape functions
  !call this%fill_face_interpolation(local_quadrature,local_face_id,face_interpolation)
end subroutine void_reference_fe_create_face_interpolation

!==================================================================================================
! This subroutine constructs a interpolation of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine void_reference_fe_create_face_local_interpolation (this, quadrature, interpolation)
  implicit none
  class(void_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation

  type(p_reference_fe_t) :: aux_reference_fe

  aux_reference_fe = make_reference_fe ( this%topology, &
                                         this%fe_type, &
                                         this%number_dimensions-1, &
                                         this%order, &
                                         this%field_type, &
                                         this%conformity )
  
  call aux_reference_fe%p%create_interpolation ( quadrature, interpolation )
  call aux_reference_fe%free()
end subroutine void_reference_fe_create_face_local_interpolation

!==================================================================================================
! This subroutine constructs a interpolation of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine void_reference_fe_create_edge_local_interpolation (this, quadrature, interpolation)
  implicit none
  class(void_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  type(p_reference_fe_t) :: aux_reference_fe
  aux_reference_fe = make_reference_fe ( this%topology, &
                                         this%fe_type, &
                                         1, &
                                         this%order, &
                                         this%field_type, &
                                         this%conformity )
  call aux_reference_fe%p%create_interpolation ( quadrature, interpolation )
  call aux_reference_fe%free()
end subroutine void_reference_fe_create_edge_local_interpolation

!==================================================================================================
subroutine void_reference_fe_update_interpolation( this, fe_map,                 &
     & interpolation_reference_cell, &
     & interpolation_real_cell )
  implicit none 
  class(void_reference_fe_t), intent(in)    :: this 
  type(fe_map_t)                  , intent(in)    :: fe_map
  type(interpolation_t)           , intent(in)    :: interpolation_reference_cell
  type(interpolation_t)           , intent(inout) :: interpolation_real_cell
  !call this%apply_femap_to_interpolation(fe_map,interpolation_reference_cell,interpolation_real_cell)
end subroutine void_reference_fe_update_interpolation

!==================================================================================================
function void_reference_fe_get_component_node( this, node )
  implicit none
  class(void_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: void_reference_fe_get_component_node
  check(.false.)
  !void_reference_fe_get_component_node = this%node_component_array(node,2)
end function void_reference_fe_get_component_node

!==================================================================================================
function void_reference_fe_get_scalar_from_vector_node( this, node )
  implicit none
  class(void_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: void_reference_fe_get_scalar_from_vector_node
  check(.false.)
  !void_reference_fe_get_scalar_from_vector_node = this%node_component_array(node,1)
end function void_reference_fe_get_scalar_from_vector_node

function void_reference_fe_get_max_order( this )
  implicit none
  class(void_reference_fe_t), intent(in)    :: this 
  integer(ip) :: void_reference_fe_get_max_order
  void_reference_fe_get_max_order = this%order
end function void_reference_fe_get_max_order

!==================================================================================================
subroutine void_reference_fe_get_value_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(void_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  check(.false.)
end subroutine void_reference_fe_get_value_scalar

!==================================================================================================
subroutine void_reference_fe_get_value_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(void_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  check(.false.)
end subroutine void_reference_fe_get_value_vector

!==================================================================================================
subroutine void_reference_fe_get_values_scalar( this, actual_cell_interpolation, values, qpoints_perm )
  implicit none
  class(void_reference_fe_t)     , intent(in)    :: this 
  type(interpolation_t)          , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable          , intent(inout) :: values(:,:)
  integer(ip)          , optional, intent(in)    :: qpoints_perm(:)
  integer(ip) :: ishape, qpoint, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_scalar )
  
  reallocate = .false.
  if (allocated(values)) reallocate = (size(values,1) < this%number_shape_functions) .or. &
                                      (size(values,2) < actual_cell_interpolation%number_quadrature_points)                                          
  if ((.not. allocated(values)) .or. reallocate) then
     if (allocated(values)) then 
        call memfree(values, __FILE__,__LINE__); 
     end if
     call memalloc(this%number_shape_functions, &
                   actual_cell_interpolation%number_quadrature_points, &
                   values, __FILE__,__LINE__);
  end if
end subroutine void_reference_fe_get_values_scalar

!==================================================================================================
subroutine void_reference_fe_get_values_vector( this, actual_cell_interpolation, values, qpoints_perm )
  implicit none
  class(void_reference_fe_t) , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  type(vector_field_t), allocatable, intent(inout) :: values(:,:)
  integer(ip)          , optional   , intent(in)   :: qpoints_perm(:)
  integer(ip) :: istat
  logical     :: reallocate
  
  assert( this%field_type == field_type_vector )

  reallocate = .false.
  if (allocated(values)) reallocate = (size(values,1) < this%number_shape_functions) .or. &
                                      (size(values,2) < actual_cell_interpolation%number_quadrature_points)                                  
  if ((.not. allocated(values)) .or. reallocate) then
     if (allocated(values)) then 
        deallocate(values, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(values(this%number_shape_functions, &
              actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);     
  end if   
end subroutine void_reference_fe_get_values_vector

!==================================================================================================
subroutine void_reference_fe_get_gradient_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(void_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  check(.false.)
end subroutine void_reference_fe_get_gradient_scalar

!==================================================================================================
subroutine void_reference_fe_get_gradient_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, tensor_field )
  implicit none
  class(void_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(tensor_field_t)            , intent(inout) :: tensor_field
  check(.false.)
end subroutine void_reference_fe_get_gradient_vector

!==================================================================================================
subroutine void_reference_fe_get_gradients_scalar( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(void_reference_fe_t)             , intent(in)    :: this 
  type(interpolation_t)                        , intent(in)    :: actual_cell_interpolation
  type(vector_field_t)            , allocatable, intent(inout) :: gradients(:,:)
  integer(ip)          , optional              , intent(in)    :: qpoints_perm(:)
  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_scalar )
  
  reallocate = .false.
  if (allocated(gradients)) reallocate = (size(gradients,1) < this%number_shape_functions) .or. &
                                         (size(gradients,2) < actual_cell_interpolation%number_quadrature_points)                                  
  if ((.not. allocated(gradients)) .or. reallocate) then
     if (allocated(gradients)) then 
        deallocate(gradients, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(gradients(this%number_shape_functions, &
                        actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
  end if
end subroutine void_reference_fe_get_gradients_scalar

!==================================================================================================
subroutine void_reference_fe_get_gradients_vector( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(void_reference_fe_t)                   , intent(in)    :: this 
  type(interpolation_t)                        , intent(in)    :: actual_cell_interpolation 
  type(tensor_field_t)            , allocatable, intent(inout) :: gradients(:,:)
  integer(ip)          , optional              , intent(in)    :: qpoints_perm(:)
  
  logical     :: reallocate
  integer(ip) :: istat
  assert( this%field_type == field_type_vector )
  
  reallocate = .false.
  if (allocated(gradients)) reallocate = (size(gradients,1) < this%number_shape_functions) .or. &
                                          (size(gradients,2) < actual_cell_interpolation%number_quadrature_points)                                  
  if ((.not. allocated(gradients)) .or. reallocate) then
     if (allocated(gradients)) then 
        deallocate(gradients, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(gradients(this%number_shape_functions, &
                        actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
  end if
  
end subroutine void_reference_fe_get_gradients_vector

!==================================================================================================
subroutine void_reference_fe_get_divergence_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(void_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  check(.false.)
end subroutine void_reference_fe_get_divergence_vector

!==================================================================================================
subroutine void_reference_fe_get_divergences_vector( this, actual_cell_interpolation, divergences, qpoints_perm )
  implicit none
  class(void_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable           , intent(inout) :: divergences(:,:)
  integer(ip)        , optional   , intent(in)    :: qpoints_perm(:)
  check(.false.)
end subroutine void_reference_fe_get_divergences_vector

! =================================================================================================
subroutine void_reference_fe_get_curl_vector( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(void_reference_fe_t)   , intent(in)     :: this 
  type(interpolation_t)              , intent(in)     :: actual_cell_interpolation 
  integer(ip)                        , intent(in)     :: ishape
  integer(ip)                        , intent(in)     :: qpoint
  type(vector_field_t)               , intent(inout)  :: vector_field
  check(.false.)
end subroutine void_reference_fe_get_curl_vector

subroutine void_reference_fe_get_curls_vector(this, actual_cell_interpolation, curls, qpoints_perm)
  implicit none
  class(void_reference_fe_t)   , intent(in)     :: this 
  type(interpolation_t)              , intent(in)     :: actual_cell_interpolation 
  type(vector_field_t), allocatable  , intent(inout)  :: curls(:,:)
  integer(ip)           , optional   , intent(in)     :: qpoints_perm(:)
  check(.false.)
end subroutine void_reference_fe_get_curls_vector

!==================================================================================================
subroutine void_reference_fe_evaluate_fe_function_scalar( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(void_reference_fe_t)      , intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  real(rp), allocatable           , intent(inout) :: quadrature_points_values(:)
  
  if ( allocated(quadrature_points_values) ) then
      if ( size(quadrature_points_values) < actual_cell_interpolation%number_quadrature_points ) then
         call memrealloc (actual_cell_interpolation%number_quadrature_points, & 
                          quadrature_points_values, __FILE__, __LINE__)
      end if
  else
    call memalloc (actual_cell_interpolation%number_quadrature_points, & 
                   quadrature_points_values, __FILE__, __LINE__)
  end if
  ! Required by output_handler_t (visualization purposes)
  quadrature_points_values = 0.0_rp
end subroutine void_reference_fe_evaluate_fe_function_scalar

!==================================================================================================
subroutine void_reference_fe_evaluate_fe_function_vector( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(void_reference_fe_t)       , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip) :: i, istat
  if ( allocated(quadrature_points_values) ) then
    if ( size(quadrature_points_values) < actual_cell_interpolation%number_quadrature_points ) then
      deallocate(quadrature_points_values, stat=istat); check(istat==0);
      allocate(quadrature_points_values(actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
    end if
  else
    allocate(quadrature_points_values(actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
  end if
  ! Required by output_handler_t (visualization purposes)
  do i=1, size(quadrature_points_values)
    call quadrature_points_values(i)%init(0.0_rp)
  end do
end subroutine void_reference_fe_evaluate_fe_function_vector

!==================================================================================================
subroutine void_reference_fe_evaluate_fe_function_tensor( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(void_reference_fe_t)       , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  check(.false.)
end subroutine void_reference_fe_evaluate_fe_function_tensor

!==================================================================================================
subroutine void_reference_fe_evaluate_gradient_fe_function_scalar( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(void_reference_fe_t)       , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip) :: i, istat
  if ( allocated(quadrature_points_values) ) then
    if ( size(quadrature_points_values) < actual_cell_interpolation%number_quadrature_points ) then
      deallocate(quadrature_points_values, stat=istat); check(istat==0);
      allocate(quadrature_points_values(actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
    end if
  else
    allocate(quadrature_points_values(actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
  end if
  ! Required by output_handler_t (visualization purposes)
  do i=1, size(quadrature_points_values)
    call quadrature_points_values(i)%init(0.0_rp)
  end do
end subroutine void_reference_fe_evaluate_gradient_fe_function_scalar

!==================================================================================================
subroutine void_reference_fe_evaluate_gradient_fe_function_vector( this,                  &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(void_reference_fe_t) , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip) :: i, istat
  if ( allocated(quadrature_points_values) ) then
     if ( size(quadrature_points_values) < actual_cell_interpolation%number_quadrature_points ) then
        deallocate(quadrature_points_values, stat=istat); check(istat==0);
        allocate(quadrature_points_values(actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
     end if
  else
     allocate(quadrature_points_values(actual_cell_interpolation%number_quadrature_points), stat=istat); check(istat==0);
  end if
  ! Required by output_handler_t (visualization purposes)
  do i=1, size(quadrature_points_values)
    call quadrature_points_values(i)%init(0.0_rp)
  end do
end subroutine void_reference_fe_evaluate_gradient_fe_function_vector

!==================================================================================================
function void_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(void_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: void_reference_fe_check_compatibility_of_n_faces
  ! If we end up here means that the target element is void.
  ! Return always true since the void element will never recover data from the source.
  ! Thus, no compatibility issues will arise.
  void_reference_fe_check_compatibility_of_n_faces = .true.
end function void_reference_fe_check_compatibility_of_n_faces

!=================================================================================================
function void_reference_fe_get_characteristic_length  ( this )
  implicit none 
  class(void_reference_fe_t), intent(in) :: this 
  real(rp)  :: void_reference_fe_get_characteristic_length 
  check(.false.)
end function void_reference_fe_get_characteristic_length 


!=================================================================================================
subroutine void_reference_fe_fill_own_dof_permutations  ( this )
  implicit none 
  class(void_reference_fe_t), intent(inout) :: this 
  real(rp)  :: void_reference_fe_get_characteristic_length 
  check(.false.)
end subroutine void_reference_fe_fill_own_dof_permutations 


!=================================================================================================
subroutine void_reference_fe_fill_qpoints_permutations  ( this, ndime, qpoints_perm, max_order )
  implicit none 
  class(void_reference_fe_t)   , intent(in)    :: this 
  integer(ip)                  , intent(in)    :: ndime
  type(allocatable_array_ip2_t), intent(inout) :: qpoints_perm
  integer(ip)       , optional , intent(in)    :: max_order
  check(.false.)
end subroutine void_reference_fe_fill_qpoints_permutations 


!==================================================================================================
subroutine void_reference_fe_free ( this )
  implicit none 
  class(void_reference_fe_t), intent(inout) :: this 
  call reference_fe_free ( this )
end subroutine void_reference_fe_free

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
subroutine void_reference_fe_fill (this)
  implicit none
  class(void_reference_fe_t), intent(inout) :: this
  integer(ip) :: c, i, j, dimension
  integer(ip) :: column, inode, idime, inode_scalar, num_columns
  type(node_iterator_t) :: node_iterator
  type(facet_iterator_t) :: facet_iterator
  type(list_iterator_t) :: list_iterator
  integer(ip) :: topology, n_face_dim, node, children,num_n_faces, ones_dim(SPACE_DIM)
  
  ! Change topology definition to these numbers from the very beginning (not parameter, dim independent)
  if ( this%topology == topology_hex) then
     topology = 2**this%number_dimensions-1
  elseif ( this%topology == topology_tet ) then
     topology = 0
  end if
  call this%polytope%create( this%number_dimensions, topology )  
  
  !call this%node_array%create( this%polytope, this%order_vector ) 
  num_n_faces = this%polytope%get_number_n_faces()
  ! Number nodes
  this%number_shape_functions = 0 !this%node_array%get_number_nodes()
  ! Number n-faces ( I don't like it, not volume included...)
  this%number_n_faces = num_n_faces-1
  ! number_n-faces_dimension
  this%number_n_faces_per_dimension = 0
  this%number_n_faces_per_dimension(1) = 1
  do i = 1,num_n_faces
     n_face_dim = this%polytope%get_n_face_dimension(i)
     this%number_n_faces_per_dimension( n_face_dim+2 ) = this%number_n_faces_per_dimension( n_face_dim+2 ) + 1
  end do
  do i = 1,this%number_dimensions+1
     this%number_n_faces_per_dimension(i+1) = this%number_n_faces_per_dimension(i+1) + this%number_n_faces_per_dimension(i)
  end do
  
  ! own_dofs_n-face
  call this%own_dofs_n_face%create(num_n_faces)
  call this%own_dofs_n_face%calculate_header()
  call this%own_dofs_n_face%allocate_list_from_pointer()

  ! dofs_n-face
  call this%dofs_n_face%create(num_n_faces)
  call this%dofs_n_face%calculate_header()
  call this%dofs_n_face%allocate_list_from_pointer()  
 
  ! vertices_n-face
  call this%vertices_n_face%create(num_n_faces)
  ones_dim = 1
  call this%vertex_array%create( this%polytope, order = ones_dim )
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%vertices_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  
  call this%vertices_n_face%calculate_header()
  call this%vertices_n_face%allocate_list_from_pointer()
  list_iterator = this%vertices_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! n-faces_n-face (NEW DEFINITION; now only n_faces of inferior dimension
  call this%n_faces_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        call this%n_faces_n_face%sum_to_pointer_index(i,1)
        call facet_iterator%next()
     end do
  end do
  call this%n_faces_n_face%calculate_header()
  call this%n_faces_n_face%allocate_list_from_pointer()
  list_iterator = this%n_faces_n_face%create_iterator()
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        children = facet_iterator%current()
        call list_iterator%set_current(children)
        call facet_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! orientation
  call this%orientation%create(num_n_faces)
  do i = 1,num_n_faces
     if ( n_face_dimension( this%polytope%get_n_face(i), this%number_dimensions ) == this%number_dimensions-1 ) then
        this%orientation%a(i) = facet_orientation( this%polytope%get_n_face(i), this%number_dimensions )
     end if
  end do
  ! own_nodes_n-face and face_integration_coupling_nodes_n-face
  if ( this%conformity .and. this%continuity) then
  else ! conformity and not continuity .and. non conformity and continuity
     call this%own_dofs_n_face%create(n=num_n_faces )
     call this%own_dofs_n_face%sum_to_pointer_index( this%own_dofs_n_face%get_num_pointers(), this%number_shape_functions)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()
     list_iterator = this%own_dofs_n_face%create_iterator()
     i=1
     do while(.not. list_iterator%is_upper_bound())
        call list_iterator%set_current(i)
        call list_iterator%next()
        i = i + 1 
     enddo
  end if

  ! I (almost arbitrarily) decided NOT to allocate neither:
  !  * number_rotations_per_dimension(:)
  !  * number_orientations_per_dimension(:)
  !  * own_node_permutations(:)
  ! Up to my knowledge, they should never be queried on in case of void_reference_fe 
  ! call memalloc (0, this%number_rotations_per_dimension,__FILE__,__LINE__)
  ! call memalloc (0, this%number_orientations_per_dimension,__FILE__,__LINE__)
  ! allocate(this%own_node_permutations(0))
end subroutine void_reference_fe_fill
