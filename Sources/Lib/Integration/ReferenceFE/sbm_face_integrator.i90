! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!fe_map_face_restriction_t type procedures
subroutine fe_map_face_restriction_create( this, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this
  type(quadrature_t)           , intent(in)    :: quadrature
  class(lagrangian_reference_fe_t)           , intent(in)    :: reference_fe_geometry

  integer(ip)           :: face_lid, istat

  call this%free()
  this%number_faces = reference_fe_geometry%get_number_faces()
  allocate(this%fe_map(this%number_faces),stat = istat)
  check(istat == 0)
  do face_lid = 1,  this%number_faces
     call this%fe_map(face_lid)%create_on_face(face_lid,quadrature,reference_fe_geometry)
  end do
end subroutine fe_map_face_restriction_create

!==================================================================================================
subroutine fe_map_face_restriction_update( this, face_lid, quadrature)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this
  integer(ip)                     , intent(in)    :: face_lid
  type(quadrature_t)           , intent(in)    :: quadrature

  this%active_face_lid = face_lid
  call this%fe_map(face_lid)%update(quadrature)

end subroutine fe_map_face_restriction_update

!==================================================================================================
subroutine fe_map_face_restriction_free( this)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this
  integer(ip) :: face_lid , istat
  do face_lid = 1, this%number_faces
     call this%fe_map(face_lid)%free()
  end do
  if (allocated(this%fe_map)) then
     deallocate(this%fe_map, stat = istat)
     check(istat == 0)
  end if
  this%number_faces = 0
  this%active_face_lid = 0
end subroutine fe_map_face_restriction_free

!==================================================================================================
function fe_map_face_restriction_get_coordinates(this,face_lid)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(in) :: this
  integer(ip)                     , intent(in) :: face_lid
  type(point_t), pointer :: fe_map_face_restriction_get_coordinates(:)
  fe_map_face_restriction_get_coordinates => this%fe_map(face_lid)%get_coordinates()
end function fe_map_face_restriction_get_coordinates

!==================================================================================================
function fe_map_face_restriction_get_active_fe_map(this)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), target, intent(in) :: this
  type(fe_map_t), pointer :: fe_map_face_restriction_get_active_fe_map
  assert ( this%active_face_lid >= 1 .and. this%active_face_lid <= this%number_faces )
  fe_map_face_restriction_get_active_fe_map => this%fe_map(this%active_face_lid)
end function fe_map_face_restriction_get_active_fe_map

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! face_map_t procedures
subroutine face_map_create(this, quadrature, left_geo_reference_fe, right_geo_reference_fe )
  implicit none
  ! Parameters
  class(face_map_t)             , intent(inout) :: this
  class(lagrangian_reference_fe_t), pointer, intent(in)    :: left_geo_reference_fe, right_geo_reference_fe
  type(quadrature_t)         , intent(in)    :: quadrature

  call this%free()

  this%is_boundary = (.not. associated(right_geo_reference_fe))

  this%number_dimensions = left_geo_reference_fe%get_number_dimensions()
  call this%face_map%create_face_map(quadrature,left_geo_reference_fe)
  call this%fe_maps(1)%create(quadrature,left_geo_reference_fe)
  if (associated(right_geo_reference_fe)) then
     call this%fe_maps(2)%create(quadrature,right_geo_reference_fe)
  end if
end subroutine face_map_create

!==================================================================================================
subroutine face_map_free(this)
  implicit none
  ! Parameters
  class(face_map_t), intent(inout) :: this
  integer(ip) :: i
  call this%face_map%free()
  do i=1,2
     call this%fe_maps(i)%free()
  end do
end subroutine face_map_free

!==================================================================================================
subroutine face_map_update(this,face_lid,face_quadrature,left_reference_fe_geo)
  implicit none
  ! Parameters
  class(face_map_t)    , intent(inout) :: this
  integer(ip)          , intent(in)    :: face_lid(2)
  type(quadrature_t), intent(in)    :: face_quadrature
  class(lagrangian_reference_fe_t), intent(in)    :: left_reference_fe_geo

  call this%face_map%update_face_map(face_lid(1),left_reference_fe_geo,face_quadrature)
  call this%fe_maps(1)%update(face_lid(1),face_quadrature)
  if (.not. this%is_boundary) then
     assert ( face_lid(2) >= 1 )
     call this%fe_maps(2)%update(face_lid(2),face_quadrature)
  end if
end subroutine face_map_update

!==================================================================================================
function face_map_compute_characteristic_length(this,qpoin)
  implicit none
  class(face_map_t), target, intent(in) :: this
  integer(ip)              , intent(in) :: qpoin
  real(rp) :: face_map_compute_characteristic_length

  real(rp)    :: h
  integer(ip) :: i
  type(fe_map_t), pointer :: fe_map
  
  fe_map => this%fe_maps(1)%fe_map(this%fe_maps(1)%active_face_lid)
  face_map_compute_characteristic_length = fe_map%compute_h(qpoin)

  if (.not. this%is_boundary) then
     i = 2
     fe_map => this%fe_maps(i)%fe_map(this%fe_maps(i)%active_face_lid)
     h = fe_map%compute_h(qpoin) 
     face_map_compute_characteristic_length = min(face_map_compute_characteristic_length, h)
  end if

end function face_map_compute_characteristic_length

!==================================================================================================
function face_map_get_face_coordinates(this)
  implicit none
  ! Parameters
  class(face_map_t), target, intent(in) :: this
  type(point_t), pointer :: face_map_get_face_coordinates(:)
  
  face_map_get_face_coordinates => this%face_map%get_coordinates()
end function face_map_get_face_coordinates

!==================================================================================================
function face_map_get_quadrature_coordinates(this)
  implicit none
  ! Parameters
  class(face_map_t), target, intent(in) :: this
  type(point_t), pointer :: face_map_get_quadrature_coordinates(:)
  
  face_map_get_quadrature_coordinates => this%face_map%get_quadrature_coordinates()
end function face_map_get_quadrature_coordinates

!==================================================================================================
function face_map_get_coordinates_neighbour(this,neighbour_id,face_lid)
  implicit none
  ! Parameters
  class(face_map_t), target, intent(in) :: this
  integer(ip)              , intent(in)    :: neighbour_id
  integer(ip)              , intent(in)    :: face_lid
  type(point_t), pointer :: face_map_get_coordinates_neighbour(:)
  assert( (neighbour_id == 1) .or. ((neighbour_id == 2) .and. (.not. this%is_boundary)))
  face_map_get_coordinates_neighbour => this%fe_maps(neighbour_id)%get_coordinates(face_lid)
end function face_map_get_coordinates_neighbour

!==================================================================================================
function face_map_get_neighbour_fe_map(this,neighbour_id)
  implicit none
  ! Parameters
  class(face_map_t), target, intent(in) :: this
  integer(ip)                           :: neighbour_id
  type(fe_map_face_restriction_t), pointer :: face_map_get_neighbour_fe_map

  assert( (neighbour_id == 1) .or. ((neighbour_id == 2) .and. (.not. this%is_boundary)))
  face_map_get_neighbour_fe_map => this%fe_maps(neighbour_id)
end function face_map_get_neighbour_fe_map

!=================================================================================================
subroutine face_map_get_normals (this, qpoint, normal)
  implicit none
  class(face_map_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: qpoint
  type(vector_field_t)    , intent(out)   :: normal(2)

  integer(ip) :: idime
  call normal(1)%init(0.0_rp)
  call normal(2)%init(0.0_rp)
  do idime = 1, this%number_dimensions
     call normal(1)%set(idime,this%face_map%normals(idime,qpoint))
     call normal(2)%set(idime,- this%face_map%normals(idime,qpoint))
  end do
end subroutine face_map_get_normals

!=================================================================================================
function face_map_get_det_jacobian ( this, i )
  implicit none
  class(face_map_t), intent(in) :: this
  integer(ip)    , intent(in) :: i
  real(rp) :: face_map_get_det_jacobian
  face_map_get_det_jacobian = this%face_map%get_det_jacobian(i)
end function face_map_get_det_jacobian

function face_map_get_face_map ( this )
  implicit none
  class(face_map_t), target, intent(in) :: this
  type(fe_map_t), pointer :: face_map_get_face_map
  face_map_get_face_map => this%face_map
end function face_map_get_face_map

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!volume_integrator_face_restriction_t type bound procedures
subroutine volume_integrator_face_restriction_create(this, quadrature, reference_fe)
  implicit none
  ! Parameters
  class(volume_integrator_face_restriction_t), intent(inout) :: this
  type(quadrature_t)                         , intent(in)    :: quadrature
  class(reference_fe_t)                      , intent(in)    :: reference_fe
  integer(ip) :: face_lid, istat
  call this%free()
  this%active_face_lid = -1
  this%number_faces = reference_fe%get_number_faces()
  allocate(this%volume_integrator(this%number_faces), stat = istat); check(istat==0);
  do face_lid =1, this%number_faces
     call this%volume_integrator(face_lid)%create_on_face(quadrature, reference_fe, face_lid)
  end do
end subroutine volume_integrator_face_restriction_create

!==================================================================================================
subroutine volume_integrator_face_restriction_update(this, fe_map, face_lid)
  implicit none
  class(volume_integrator_face_restriction_t), intent(inout) :: this
  type(fe_map_t)                             , intent(in)    :: fe_map
  integer(ip)                                , intent(in)    :: face_lid
  this%active_face_lid = face_lid
  call this%volume_integrator(face_lid)%update(fe_map)
end subroutine volume_integrator_face_restriction_update

!==================================================================================================
subroutine volume_integrator_face_restriction_apply_change_sign(this, iface, ishape)
  implicit none
  class(volume_integrator_face_restriction_t), intent(inout) :: this
  integer(ip)                                , intent(in)    :: iface 
  integer(ip)                                , intent(in)    :: ishape
  call this%volume_integrator(iface)%apply_sign_change(ishape)
end subroutine volume_integrator_face_restriction_apply_change_sign 

!==================================================================================================
subroutine volume_integrator_face_restriction_free(this)
  implicit none
  ! Parameters
  class(volume_integrator_face_restriction_t), intent(inout) :: this
  integer(ip) :: i, istat
  if (allocated(this%volume_integrator)) then
     do i = 1, this%number_faces
       call this%volume_integrator(i)%free()
     end do
     deallocate(this%volume_integrator, stat = istat); check(istat==0);
  end if
  this%number_faces   = 0
  this%active_face_lid = 0
end subroutine volume_integrator_face_restriction_free

function volume_integrator_face_restriction_get_active_volume_integrator(this)
  implicit none
  ! Parameters
  class(volume_integrator_face_restriction_t), target, intent(in) :: this
  type(volume_integrator_t), pointer :: volume_integrator_face_restriction_get_active_volume_integrator
  assert ( this%active_face_lid >= 1 .and. this%active_face_lid <= this%number_faces )
  volume_integrator_face_restriction_get_active_volume_integrator => this%volume_integrator(this%active_face_lid)
end function volume_integrator_face_restriction_get_active_volume_integrator

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_integrator_t type procedures
subroutine face_integrator_create(this,quadrature,left_reference_fe,right_reference_fe)
  implicit none
  ! Parameters
  class(face_integrator_t)      , intent(inout) :: this
  type(quadrature_t)            , intent(in)    :: quadrature
  class(reference_fe_t), pointer, intent(in)    :: left_reference_fe, right_reference_fe

  call this%free()

  this%is_boundary = (.not. associated(right_reference_fe))
  this%reference_fe(1)%p => left_reference_fe
  call this%volume_integrator_face_restriction(1)%create(quadrature,this%reference_fe(1)%p)

  if (.not. this%is_boundary) then
     this%reference_fe(2)%p => right_reference_fe
     call this%volume_integrator_face_restriction(2)%create(quadrature,this%reference_fe(2)%p)
  end if

  this%current_qpoints_perm_cols = 1
  ! @sbadia: order+2 only works for topology_hex. When the work for high order TETS with face 
  ! integration will be performed, it has to be corrected. @jbonilla: this workaround still works
  ! if quadratures for topology_hex plus Duffy transformation is used. Whenever, symmetric 
  ! quadrature points for TETs are used it has to be corrected.
  ! (For hex topology + lagrangian FE) the number of quadrature points within a face corresponds 
  ! to the number of interior nodes in a face for a reference FE with order+2 (instead of order+1)
  
  ! assert ( left_reference_fe%topology == topology_hex )
  
  ! For tet topology and 3D, the quadrature used is order+2, thus the number of quadrature points
  ! within a face corresponds  to the number of interior nodes in a face for a reference FE with 
  ! order+3 (instead of order+2)
  
   if ( ( left_reference_fe%number_dimensions .eq. 3) .and. (left_reference_fe%topology.eq.topology_tet) ) then 
     call left_reference_fe%node_array%fill_permutations( left_reference_fe%get_max_order()+4, &
                                                          quadrature%number_dimensions,        &
                                                          left_reference_fe%polytope,          &
                                                          this%qpoints_perm )
  else
     call left_reference_fe%node_array%fill_permutations( left_reference_fe%get_max_order()+3, &
                                                          quadrature%number_dimensions,        &
                                                          left_reference_fe%polytope,          &
                                                          this%qpoints_perm )
  end if
end subroutine face_integrator_create

!==================================================================================================
subroutine face_integrator_free(this)
  implicit none
  ! Parameters
  class(face_integrator_t)     , intent(inout) :: this
  integer(ip) :: i
  do i=1,2
     this%reference_fe(i)%p => NULL()
     call this%volume_integrator_face_restriction(i)%free()
  end do
  call this%qpoints_perm%free()
end subroutine face_integrator_free

!==================================================================================================
subroutine face_integrator_update(this,face_lid,face_map,relative_orientation,relative_rotation)
  implicit none
  ! Parameters
  class(face_integrator_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: face_lid(2)
  integer(ip)             , intent(in)    :: relative_orientation,relative_rotation
  type(face_map_t)        , intent(in)    :: face_map
  call this%volume_integrator_face_restriction(1)%update(face_map%fe_maps(1)%get_active_fe_map(),face_lid(1))
  if (.not. this%is_boundary) then
     this%current_qpoints_perm_cols(2) = relative_rotation +                                        &
         & this%reference_fe(2)%p%number_rotations_per_dimension(this%reference_fe(2)%p%number_dimensions-1)  &
         & * relative_orientation
     call this%volume_integrator_face_restriction(2)%update(face_map%fe_maps(2)%get_active_fe_map(),face_lid(2))
  end if
end subroutine face_integrator_update

!==================================================================================================
subroutine face_integrator_apply_change_sign(this, icell_around, face_lid, ishape)
  implicit none
  ! Parameters
  class(face_integrator_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: icell_around 
  integer(ip)             , intent(in)    :: face_lid
  integer(ip)             , intent(in)    :: ishape 
  
  assert(icell_around ==1) 
  if ( this%is_boundary ) then 
  call this%volume_integrator_face_restriction(1)%apply_change_sign(face_lid, ishape)
  else
  write(*,*) 'Subroutine still implemented for boundary faces integrates'
  assert(.false.) 
  end if
end subroutine face_integrator_apply_change_sign 

!==================================================================================================
subroutine face_integrator_get_value_scalar (this, ishape, qpoint, ineigh, scalar_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  real(rp)                , intent(out)   :: scalar_field
  integer(ip) :: actual_qpoint
  type(volume_integrator_t), pointer :: volume_integrator
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  assert( (ineigh == 1) .or. ((ineigh == 2) .and. (.not. this%is_boundary)))
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  actual_qpoint = this%qpoints_perm%a(qpoint,this%current_qpoints_perm_cols(ineigh))
  call volume_integrator%get_value(ishape,actual_qpoint,scalar_field)
end subroutine face_integrator_get_value_scalar

!==================================================================================================
subroutine face_integrator_get_value_vector (this, ishape, qpoint, ineigh, vector_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  type(vector_field_t)    , intent(out)   :: vector_field

  integer(ip) :: actual_qpoint
  type(volume_integrator_t), pointer :: volume_integrator
  assert( this%reference_fe(ineigh)%p%field_type == field_type_vector )
  assert( (ineigh == 1) .or. ((ineigh == 2) .and. (.not. this%is_boundary)))
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  actual_qpoint = this%qpoints_perm%a(qpoint,this%current_qpoints_perm_cols(ineigh))
  call volume_integrator%get_value(ishape,actual_qpoint,vector_field)
end subroutine face_integrator_get_value_vector

!==================================================================================================
subroutine face_integrator_get_values_scalar (this, ineigh, values)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ineigh
  real(rp), allocatable   , intent(inout) :: values(:,:)
  type(volume_integrator_t), pointer :: volume_integrator
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  call volume_integrator%get_values(values,this%qpoints_perm%a(:,this%current_qpoints_perm_cols(ineigh)))
end subroutine face_integrator_get_values_scalar

!==================================================================================================
subroutine face_integrator_get_values_vector (this, ineigh, values)
  implicit none
  class(face_integrator_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: ineigh
  type(vector_field_t), allocatable, intent(inout) :: values(:,:)
  type(volume_integrator_t), pointer :: volume_integrator
  assert( this%reference_fe(ineigh)%p%field_type == field_type_vector )
  assert( (ineigh == 1) .or. ((ineigh == 2) .and. (.not. this%is_boundary)))
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  call volume_integrator%get_values(values,this%qpoints_perm%a(:,this%current_qpoints_perm_cols(ineigh)))
end subroutine face_integrator_get_values_vector

!=================================================================================================
subroutine face_integrator_get_gradient_scalar (this, ishape, qpoint, ineigh, vector_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  type(vector_field_t)    , intent(out)   :: vector_field
  
  integer(ip) :: actual_qpoint
  type(volume_integrator_t), pointer :: volume_integrator
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  assert( (ineigh == 1) .or. ((ineigh == 2) .and. (.not. this%is_boundary)))
  actual_qpoint = this%qpoints_perm%a(qpoint,this%current_qpoints_perm_cols(ineigh))
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  call volume_integrator%get_gradient(ishape,actual_qpoint,vector_field)
end subroutine face_integrator_get_gradient_scalar

!=================================================================================================
subroutine face_integrator_get_gradients_scalar (this, ineigh, gradients)
  implicit none
  class(face_integrator_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: ineigh
  type(vector_field_t), allocatable, intent(inout) :: gradients(:,:)
  type(volume_integrator_t), pointer :: volume_integrator
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  assert( (ineigh == 1) .or. ((ineigh == 2) .and. (.not. this%is_boundary)))
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  call volume_integrator%get_gradients(gradients,this%qpoints_perm%a(:,this%current_qpoints_perm_cols(ineigh)))
end subroutine face_integrator_get_gradients_scalar

!=================================================================================================
subroutine face_integrator_get_curl_vector (this, ishape, qpoint, ineigh, vector_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  type(vector_field_t)    , intent(out)   :: vector_field
  
  integer(ip) :: actual_qpoint
  type(volume_integrator_t), pointer :: volume_integrator

  assert( this%reference_fe(ineigh)%p%field_type == field_type_vector )
  assert( (ineigh == 1) .or. ((ineigh == 2) .and. (.not. this%is_boundary)))
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  actual_qpoint = this%qpoints_perm%a(qpoint,this%current_qpoints_perm_cols(ineigh))
  call volume_integrator%get_curl(ishape,actual_qpoint,vector_field)
end subroutine face_integrator_get_curl_vector

!=================================================================================================
subroutine face_integrator_get_curls_vector (this, ineigh, curls)
  implicit none
  class(face_integrator_t)             , intent(in)    :: this
  integer(ip)                          , intent(in)    :: ineigh
  type(vector_field_t)    , allocatable, intent(inout) :: curls(:,:)
  type(volume_integrator_t), pointer :: volume_integrator
  assert( this%reference_fe(ineigh)%p%field_type == field_type_vector )
  assert( (ineigh == 1) .or. ((ineigh == 2) .and. (.not. this%is_boundary)))
  volume_integrator => this%volume_integrator_face_restriction(ineigh)%get_active_volume_integrator()
  call volume_integrator%get_curls(curls,this%qpoints_perm%a(:,this%current_qpoints_perm_cols(ineigh)))
end subroutine face_integrator_get_curls_vector

!=================================================================================================
function face_integrator_get_current_qpoints_perm ( this, neighbour_id )
  implicit none
  class(face_integrator_t), target, intent(in)    :: this
  integer(ip)                     , intent(in)    :: neighbour_id
  integer(ip), pointer :: face_integrator_get_current_qpoints_perm(:)
  face_integrator_get_current_qpoints_perm => this%qpoints_perm%a(:,this%current_qpoints_perm_cols(neighbour_id))
end function face_integrator_get_current_qpoints_perm

!=================================================================================================
subroutine face_integrator_evaluate_fe_function_scalar ( this,                     &
                                                         neighbour_id,             &
                                                         nodal_values,             &
                                                         quadrature_points_values )
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: neighbour_id
  real(rp)                , intent(in)    :: nodal_values(:)
  real(rp), allocatable   , intent(inout) :: quadrature_points_values(:)
  type(volume_integrator_t), pointer :: volume_integrator
  volume_integrator => this%volume_integrator_face_restriction(neighbour_id)%get_active_volume_integrator()
  call volume_integrator%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine face_integrator_evaluate_fe_function_scalar

!=================================================================================================
subroutine face_integrator_evaluate_fe_function_vector ( this,                     &
                                                         neighbour_id,             &
                                                         nodal_values,             &
                                                         quadrature_points_values )
  implicit none
  class(face_integrator_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: neighbour_id
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  type(volume_integrator_t), pointer :: volume_integrator
  volume_integrator => this%volume_integrator_face_restriction(neighbour_id)%get_active_volume_integrator()
  call volume_integrator%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine face_integrator_evaluate_fe_function_vector

!=================================================================================================
subroutine face_integrator_evaluate_fe_function_tensor ( this,                     &
                                                         neighbour_id,             &
                                                         nodal_values,             &
                                                         quadrature_points_values )
  implicit none
  class(face_integrator_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: neighbour_id
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  type(volume_integrator_t), pointer :: volume_integrator
  volume_integrator => this%volume_integrator_face_restriction(neighbour_id)%get_active_volume_integrator()
  call volume_integrator%evaluate_fe_function(nodal_values,quadrature_points_values)
end subroutine face_integrator_evaluate_fe_function_tensor

!=================================================================================================
subroutine face_integrator_evaluate_gradient_fe_function_scalar ( this,                     &
                                                                  neighbour_id,             &
                                                                  nodal_values,             &
                                                                  quadrature_points_values )
  implicit none
  class(face_integrator_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: neighbour_id
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  type(volume_integrator_t), pointer :: volume_integrator
  volume_integrator => this%volume_integrator_face_restriction(neighbour_id)%get_active_volume_integrator()
  call volume_integrator%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine face_integrator_evaluate_gradient_fe_function_scalar

!=================================================================================================
subroutine face_integrator_evaluate_gradient_fe_function_vector ( this,                     &
                                                                  neighbour_id,             &
                                                                  nodal_values,             &
                                                                  quadrature_points_values )
  implicit none
  class(face_integrator_t)         , intent(in)    :: this
  integer(ip)                      , intent(in)    :: neighbour_id
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  type(volume_integrator_t), pointer :: volume_integrator
  volume_integrator => this%volume_integrator_face_restriction(neighbour_id)%get_active_volume_integrator()
  call volume_integrator%evaluate_gradient_fe_function(nodal_values,quadrature_points_values)
end subroutine face_integrator_evaluate_gradient_fe_function_vector
