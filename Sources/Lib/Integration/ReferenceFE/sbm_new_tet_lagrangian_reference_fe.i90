! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_free(this) 
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(inout) ::  this
  integer(ip) :: i
  
  ! Free member variables of raviart_thomas_reference_fe_t
  if ( allocated(this%change_basis_matrix) ) &
     call memfree ( this%change_basis_matrix, __FILE__, __LINE__ )     
     
  this%basis_changed = .false. 
  
  ! Free member variables of lagrangian_reference_fe_t
  ! (and those of its ancestors)
  call lagrangian_reference_fe_free ( this )  
end subroutine new_tet_lagrangian_reference_fe_free

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_create( this, topology, number_dimensions, order, field_type, & 
     &  continuity, enable_face_integration )
  implicit none 
  class(new_tet_lagrangian_reference_fe_t), intent(inout) :: this
  character(*)                            , intent(in)    :: topology
  integer(ip)                             , intent(in)    :: number_dimensions
  integer(ip)                             , intent(in)    :: order
  character(*)                            , intent(in)    :: field_type
  logical                                 , intent(in)    :: continuity
  logical                      , optional , intent(in)    :: enable_face_integration
  
  assert ( order >= 0 )

  call this%free()
  call this%set_common_data(number_dimensions,order,field_type,continuity,enable_face_integration)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_new_tet )
  call this%fill()
  call this%create_nodal_quadrature()
  !if ( this%continuity ) then
    call this%change_basis()
  !end if
  
end subroutine new_tet_lagrangian_reference_fe_create

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)                      , intent(in)         :: quadrature
  type(interpolation_t)                   , intent(inout)      :: interpolation    
  integer(ip)                  , optional , intent(in)         :: order_vector(SPACE_DIM)
  
  type(interpolation_t) :: interpolation_pre_basis
  
  if ( .not. this%basis_changed ) then
    call this%fill_interpolation_pre_basis ( quadrature, interpolation, order_vector )
  else
    call interpolation_pre_basis%clone(interpolation)
    call this%fill_interpolation_pre_basis ( quadrature, interpolation_pre_basis, order_vector ) 
    call this%apply_change_basis_matrix_to_interpolation ( interpolation_pre_basis, interpolation )
    call interpolation_pre_basis%free()
  end if
end subroutine new_tet_lagrangian_reference_fe_fill_interpolation

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_fill_interpolation_pre_basis ( this, quadrature, interpolation, order_vector ) 
  implicit none 
  class(new_tet_lagrangian_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)

  type(tet_polynomial_prebase_t)        :: tet_polynomial_prebase
  type(polynomial_allocatable_array_t)  :: monomial_1D_basis(SPACE_DIM)
  type(monomial_t)                      :: monomial_1D
  
  real(rp), allocatable :: values(:)
  real(rp), allocatable :: gradients(:,:)
  integer(ip) :: idime, q_point
  
  do idime=1,interpolation%number_dimensions
     call monomial_1D%generate_basis(this%order_vector(idime), monomial_1D_basis(idime) )
  end do
  
  call tet_polynomial_prebase%create(interpolation%number_dimensions,monomial_1D_basis)
  call tet_polynomial_prebase%fill( quadrature%get_coordinates() )
    
  call memalloc(tet_polynomial_prebase%get_number_polynomials(),values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,tet_polynomial_prebase%get_number_polynomials(),gradients,__FILE__,__LINE__)
  
  do q_point=1, quadrature%get_number_quadrature_points()
     call tet_polynomial_prebase%evaluate(q_point, values, gradients)
     interpolation%shape_functions(1,:,q_point) = values(:)
     interpolation%shape_derivatives(1,:,:,q_point) = gradients(:,:)
  end do
  
  ! Free auxiliary memory
  if(allocated(values))    call memfree(values,__FILE__,__LINE__)
  if(allocated(gradients)) call memfree(gradients,__FILE__,__LINE__)
  
  do idime=1,interpolation%number_dimensions
     call monomial_1D_basis(idime)%free()
  end do
  call monomial_1D%free()
  call tet_polynomial_prebase%free()
end subroutine new_tet_lagrangian_reference_fe_fill_interpolation_pre_basis

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_change_basis(this) 
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(inout) ::  this
  
  type(interpolation_t)   :: interpolation
  integer(ip)             :: i, j
  
  call memalloc(this%number_shape_functions,this%number_shape_functions,this%change_basis_matrix,__FILE__,__LINE__)
  call this%create_interpolation(this%nodal_quadrature,interpolation)
  do i=1,this%number_shape_functions
     do j=1,this%number_shape_functions
        !write(*,*) 'Shape',j,'point',i
        !write(*,*) interpolation%shape_functions(1,j,i)
        this%change_basis_matrix(i,j) = interpolation%shape_functions(1,j,i)
     end do
  end do
  call interpolation%free()
  call this%invert_change_basis_matrix()
  this%basis_changed = .true.
end subroutine new_tet_lagrangian_reference_fe_change_basis

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_invert_change_basis_matrix(this)
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(inout) :: this 
  
  integer(ip) :: error
  integer(ip), allocatable :: ipiv(:)
  real(rp), allocatable :: inverse_change_basis_matrix(:,:)  
  integer(ip) :: i
  
  assert ( allocated(this%change_basis_matrix) )
  assert ( size(this%change_basis_matrix,1) == this%number_shape_functions )
  assert ( size(this%change_basis_matrix,2) == this%number_shape_functions )
  
  ! Solve linear system with several RHS
  ! Compute LU factorization of this%change_basis_matrix
#ifdef ENABLE_LAPACK
  call memalloc ( this%number_shape_functions, ipiv, __FILE__,__LINE__ )
   
  call memalloc ( this%number_shape_functions, & 
                  this%number_shape_functions, &
                  inverse_change_basis_matrix, &
                   __FILE__,__LINE__ )

  call DGETRF( this%number_shape_functions, & 
               this%number_shape_functions, &
               this%change_basis_matrix, &
               this%number_shape_functions, &
               ipiv, &
               error )
  check ( error == 0 )
  
  inverse_change_basis_matrix = 0.0_rp
  do i=1, this%number_shape_functions
    inverse_change_basis_matrix(i,i) = 1.0_rp
  end do  
 
  call DGETRS( 'N', & 
               this%number_shape_functions, &
               this%number_shape_functions, &
               this%change_basis_matrix, &
               this%number_shape_functions, &
               ipiv, &
               inverse_change_basis_matrix, &
               this%number_shape_functions, &
               error )
  check ( error == 0 )
  
  !do i=1, this%number_shape_functions
  !   this%change_basis_matrix(i,:) = 0.0_rp!inverse_change_basis_matrix(:,i)
  !end do
  
  !call memfree (  inverse_change_basis_matrix, __FILE__, __LINE__  )
  
  if ( allocated(this%change_basis_matrix) ) call memfree (  this%change_basis_matrix, __FILE__, __LINE__  )
   
  call memmovealloc(inverse_change_basis_matrix, &
                    this%change_basis_matrix, __FILE__, __LINE__ )
  !write(*,*) this%change_basis_matrix(1,:)
  !write(*,*) this%change_basis_matrix(2,:)
  !write(*,*) this%change_basis_matrix(3,:)
  call memfree ( ipiv, __FILE__,__LINE__ )
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_LAPACK.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the LAPACK'
  check(.false.)
#endif 
   
end subroutine new_tet_lagrangian_reference_fe_invert_change_basis_matrix

!==================================================================================================
subroutine new_tet_lagrangian_ref_fe_apply_change_basis_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)                   , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)                   , intent(inout) :: interpolation
  
  integer(ip)           :: i, j, idime, jdime, qpoint

  ! Initialize both shape functions and derivatives to zero.
  interpolation%shape_functions   = 0.0_rp
  interpolation%shape_derivatives = 0.0_rp
  
  ! Compute shape functions
  do qpoint = 1, interpolation%number_quadrature_points
     do i=1, this%number_shape_functions
        do j=1, this%number_shape_functions
           do idime=1, this%number_dimensions
              interpolation%shape_functions(idime, i, qpoint) = interpolation%shape_functions(idime, i, qpoint) + &
                   this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(idime, j, qpoint)
           end do
        end do
     end do
  end do
  
  ! Compute shape derivatives
  do qpoint = 1, interpolation%number_quadrature_points
     do i=1, this%number_shape_functions
        do j=1, this%number_shape_functions
           do idime=1, this%number_dimensions
              do jdime=1, this%number_dimensions
                 interpolation%shape_derivatives(idime, jdime, i, qpoint) = interpolation%shape_derivatives(idime, jdime, i, qpoint) + &
                      this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(idime, jdime, j, qpoint)
              end do
           end do
        end do
     end do
  end do
end subroutine new_tet_lagrangian_ref_fe_apply_change_basis_to_interpolation


!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  ! 
  !     This routine sets up the integration constants of open rules for
  !     triangles and tetrahedra mapping hexahedra quadratures
  !
  !-----------------------------------------------------------------------
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  type(hex_lagrangian_reference_fe_t)                :: hex_lagrangian_rfe

  if (get_quadratures_from_hex(quadrature)) then
     call hex_lagrangian_rfe%fill_quadrature ( quadrature ) 
     if (quadrature%number_dimensions.eq.1) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp        
        ! w' = w/2
        quadrature%weight = quadrature%weight / 2.0_rp
     elseif (quadrature%number_dimensions.eq.2) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp
        ! y' = (1-x')(y+1)/2
        quadrature%coordinates(2,:) = (1.0_rp - quadrature%coordinates(1,:)) * &
                                     ((1.0_rp + quadrature%coordinates(2,:)) / 2.0_rp)
        ! w' = (1-x')/4
        quadrature%weight = (1.0_rp - quadrature%coordinates(1,:)) /4.0_rp * &
                            quadrature%weight
        
     elseif (quadrature%number_dimensions.eq.3) then
        ! x' = (x+1)/2
        quadrature%coordinates(1,:) = (quadrature%coordinates(1,:)+1.0_rp) / 2.0_rp
        ! y' = (1-x')(y+1)/2
        quadrature%coordinates(2,:) = (1.0_rp - quadrature%coordinates(1,:)) * &
                                     ((1.0_rp + quadrature%coordinates(2,:)) / 2.0_rp)
        ! z' = (1-x'-y')(z+1)/2
        quadrature%coordinates(3,:) = (1.0_rp - quadrature%coordinates(1,:)    &
                                              - quadrature%coordinates(2,:)) * &
                                     ((1.0_rp + quadrature%coordinates(3,:)) / 2.0_rp)
        ! w' = ((1-x')^2+y'(x'-1))/8
        quadrature%weight = ((1.0_rp - quadrature%coordinates(1,:))**2.0_rp + &
                        quadrature%coordinates(2,:)*(quadrature%coordinates(1,:) - 1.0_rp)) / 8.0_rp * &
                        quadrature%weight
     end if
  else 
     call tet_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  end if
end subroutine new_tet_lagrangian_reference_fe_fill_quadrature

!=================================================================================================
function new_tet_lagrangian_reference_fe_set_number_quadrature_points( this, order, dimension )
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                             , intent(in)    :: order
  integer(ip)                             , intent(in)    :: dimension
  integer(ip) :: new_tet_lagrangian_reference_fe_set_number_quadrature_points
  
  if( dimension .eq. 1 ) then
     new_tet_lagrangian_reference_fe_set_number_quadrature_points = order + 1
  elseif( dimension .eq. 2 ) then
     !*************************************************************************
     ! Uncomment the following lines for using efficent symmetrical gaussian 
     ! quadrature rules. Uncomment function get_quadratures_from_hex too.
     ! Take into account that these quadratures DO NOT work for face integration.
     !
     ! Symmetric trianglular quadratures
     !if( order .eq. 1 ) then
     !   new_tet_lagrangian_reference_fe_set_number_quadrature_points = 3
     !elseif( order .eq. 2 ) then
     !   new_tet_lagrangian_reference_fe_set_number_quadrature_points = 6
     !elseif( order .eq. 3 ) then
     !   new_tet_lagrangian_reference_fe_set_number_quadrature_points = 13
     !elseif( order .eq. 4 ) then
     !   new_tet_lagrangian_reference_fe_set_number_quadrature_points = 19
     !elseif( order .eq. 5 ) then
     !   new_tet_lagrangian_reference_fe_set_number_quadrature_points = 28
     !else ! Quadratures based on brick quadratures transformation
     !_________________________________________________________________________
        new_tet_lagrangian_reference_fe_set_number_quadrature_points = (order+1)**2
     !end if
  elseif( dimension .eq. 3 ) then
     !*************************************************************************
     ! Uncomment the following lines for using efficent symmetrical gaussian 
     ! quadrature rules. Uncomment function get_quadratures_from_hex too.
     ! Take into account that these quadratures DO NOT work for face integration.
     !
     !if( order .eq. 1 ) then
     !   new_tet_lagrangian_reference_fe_set_number_quadrature_points = 4
     !elseif( order .eq. 2) then
     !   new_tet_lagrangian_reference_fe_set_number_quadrature_points = 11
     !else ! Quadratures based on brick quadratures transformation
     !_________________________________________________________________________
        new_tet_lagrangian_reference_fe_set_number_quadrature_points = (order+2)**3
     !end if
  end if
  
end function new_tet_lagrangian_reference_fe_set_number_quadrature_points

!=================================================================================================
function get_quadratures_from_hex(quadrature)
  implicit none
  type(quadrature_t), intent(in) :: quadrature
  logical :: get_quadratures_from_hex
  
  get_quadratures_from_hex = .true.
  !if ((quadrature%number_dimensions.eq.2).and.(quadrature%number_quadrature_points.lt.29)) then
  !   get_quadratures_from_hex = .false.
  !elseif ((quadrature%number_dimensions.eq.3).and.(quadrature%number_quadrature_points.lt.12)) then
  !   get_quadratures_from_hex = .false.
  !end if
end function

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_fill_face_interpolation (this, local_quadrature, local_face_id, face_interpolation)
  implicit none
  class(new_tet_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  integer(ip)                             , intent(in)    :: local_face_id
  type(interpolation_t)                   , intent(inout) :: face_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c,idime,iface,n_face_index
  ! Add offset to have same numbering as in polytope
  n_face_index = local_face_id+this%get_first_face_id()-1
  
  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%number_dimensions, local_quadrature%number_quadrature_points )
  c = 0
  do idime = 0,this%number_dimensions-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = 0.0_rp
     else 
        aux_quadrature%coordinates(idime+1,:) = 1 - sum(local_quadrature%coordinates(:,:),1)
     end if
  end do
  
  !if ( .not. this%basis_changed ) call this%fill_interpolation_pre_basis ( aux_quadrature, face_interpolation ) !( aux_quadrature, face_interpolation ) 
  call this%fill_interpolation( aux_quadrature, face_interpolation ) 
  call aux_quadrature%free()
  
end subroutine new_tet_lagrangian_reference_fe_fill_face_interpolation

!==================================================================================================
subroutine new_tet_lagrangian_reference_fe_create_rotated_quadrature(this, ref_quad, rotated_quad, num_rotations, num_orientations )
  implicit none
  class (new_tet_lagrangian_reference_fe_t), intent(in)    :: this
  type (quadrature_t)   , intent(in)    :: ref_quad
  type (quadrature_t)   , intent(inout) :: rotated_quad
  integer(ip)           , intent(in)    :: num_rotations
  integer(ip)           , intent(in)    :: num_orientations
  type(hex_lagrangian_reference_fe_t)                :: hex_lagrangian_rfe

  call rotated_quad%free()
  call rotated_quad%create(ref_quad%get_number_dimensions(), ref_quad%get_number_quadrature_points())
  
  
  if (ref_quad%number_dimensions.eq.1) then
     rotated_quad%coordinates = ref_quad%coordinates
     rotated_quad%weight = ref_quad%weight
  
  elseif (ref_quad%number_dimensions.eq.2) then
     if ((num_rotations + mod(num_orientations,2)).eq.2) then
        call hex_lagrangian_rfe%fill_quadrature ( rotated_quad ) 
        ! y' = (y+1)/2
        rotated_quad%coordinates(2,:) = (rotated_quad%coordinates(2,:)+1.0_rp) / 2.0_rp
        ! x' = (1-y')(x+1)/2
        rotated_quad%coordinates(1,:) = (1.0_rp - rotated_quad%coordinates(2,:)) * &
                                     ((1.0_rp + rotated_quad%coordinates(1,:)) / 2.0_rp)
        ! w' = (1-y')/4
        rotated_quad%weight = (1.0_rp - rotated_quad%coordinates(2,:)) /4.0_rp * &
                            rotated_quad%weight
        
     elseif ((num_rotations + mod(num_orientations,2)).eq.3) then
        call hex_lagrangian_rfe%fill_quadrature ( rotated_quad ) 
        ! w' = (x+1)/2
        rotated_quad%weight = (rotated_quad%coordinates(1,:) + 1.0_rp) /4.0_rp * &
                               rotated_quad%weight
        ! y' = (x+1)/2 * (y+1)/2
        rotated_quad%coordinates(2,:) = (rotated_quad%coordinates(1,:) + 1.0_rp)/ 2.0_rp * &
                                        (rotated_quad%coordinates(2,:) + 1.0_rp)/ 2.0_rp
        ! x' = (x+1)/2 - y'
        rotated_quad%coordinates(1,:) = (rotated_quad%coordinates(1,:) + 1.0_rp)/ 2.0_rp - &
                                         rotated_quad%coordinates(2,:)
     else
        rotated_quad%coordinates = ref_quad%coordinates
        rotated_quad%weight = ref_quad%weight
     end if
   end if
        
end subroutine new_tet_lagrangian_reference_fe_create_rotated_quadrature
