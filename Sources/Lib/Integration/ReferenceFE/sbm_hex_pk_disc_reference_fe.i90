! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published byfill_inter
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================

subroutine hpdrf_create(this, &
                                              topology, &
                                              num_dims, &
                                              order, &
                                              field_type, & 
                                              conformity, &
                                              continuity )
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(inout)  :: this
  character(*)                        , intent(in)    :: topology
  integer(ip)                         , intent(in)    :: num_dims
  integer(ip)                         , intent(in)    :: order
  character(*)                        , intent(in)    :: field_type
  logical                             , intent(in)    :: conformity
  logical              , optional     , intent(in)    :: continuity
  call this%free()
  call this%set_common_data(num_dims,order,field_type,conformity,continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_hex_pk_disc )
  call this%fill()
  call this%create_nodal_quadrature()
  call this%change_basis()
  !!call this%fill_h_refinement_interpolation()
  !!call this%fill_h_refinement_permutations()
end subroutine hpdrf_create

subroutine hpdrf_free ( this )
  implicit none 
  class(hex_pk_disc_reference_fe_t), intent(inout) :: this 
  call hex_lagrangian_reference_fe_free ( this )
  if ( allocated(this%change_basis_matrix) ) &
       call memfree ( this%change_basis_matrix, __FILE__, __LINE__ )     
  this%basis_changed = .false. 
  this%num_dofs_scalar = -1
end subroutine hpdrf_free

!function hpdrf_has_nodal_quadrature(this)
!  implicit none
!  class(hex_pk_disc_reference_fe_t), intent(in) :: this
!  logical :: hpdrf_has_nodal_quadrature
!  hpdrf_has_nodal_quadrature = .false.
!end function hpdrf_has_nodal_quadrature

subroutine hpdrf_fill_scalar (this)
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(inout)    :: this 
  type(list_iterator_t) :: dofs_list_iter
  type(list_iterator_t) :: own_dofs_list_iter
  integer(ip) :: num_n_faces
  integer(ip) :: current_dof_lid
  integer(ip) :: n_face_id

  if ( this%continuity ) then
    mcheck(.false., 'Continuity cannot be imposed for '//fe_type_hex_pk_disc//' fe type.')
  end if

  call this%fill_topology()
  
  num_n_faces = this%num_n_faces+1

  this%num_dofs_scalar = num_dofs_P_k(k=this%get_order(),dims=this%get_num_dims())
  this%num_shape_functions = this%num_dofs_scalar
  
  call this%own_dofs_n_face%create( num_n_faces )
  call this%dofs_n_face%create( num_n_faces )

  do n_face_id = 1,num_n_faces
    if ( this%get_n_face_dim(n_face_id) == this%get_num_dims() ) then
      call this%own_dofs_n_face%sum_to_pointer_index(n_face_id,this%num_dofs_scalar)
      call this%dofs_n_face%sum_to_pointer_index(n_face_id,this%num_dofs_scalar)
    else
      call this%own_dofs_n_face%sum_to_pointer_index(n_face_id,0)
      call this%dofs_n_face%sum_to_pointer_index(n_face_id,0)
    end if
  end do

  call this%own_dofs_n_face%calculate_header()
  call this%own_dofs_n_face%allocate_list_from_pointer()

  call this%dofs_n_face%calculate_header()
  call this%dofs_n_face%allocate_list_from_pointer()

  own_dofs_list_iter = this%own_dofs_n_face%create_iterator()
  dofs_list_iter     = this%dofs_n_face%create_iterator()

  current_dof_lid = 0
  do while (.not. own_dofs_list_iter%is_upper_bound())
    current_dof_lid = current_dof_lid + 1
    call own_dofs_list_iter%set_current(current_dof_lid)
    call dofs_list_iter%set_current(current_dof_lid)
    call own_dofs_list_iter%next()
    call dofs_list_iter%next()
  end do

  contains

    pure function num_dofs_P_k(k,dims)
      implicit none
      integer(ip), intent(in) :: k
      integer(ip), intent(in) :: dims
      integer(ip) :: num_dofs_P_k
      integer(ip) :: N, D, i
      D = 1
      N = 1
      do i = 1, dims
        N = N * (k+i)
        D = D * i
      end do
      num_dofs_P_k = N/D
    end function num_dofs_P_k

end subroutine hpdrf_fill_scalar

subroutine hpdrf_create_nodal_quadrature (this)
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(inout) :: this

  type(tet_lagrangian_reference_fe_t) :: reference_fe
  type(quadrature_t), pointer :: nodal_quadrature

  call reference_fe%create(&
    topology = topology_tet,&
    num_dims = this%get_num_dims(), &
    order = this%get_order(),&
    field_type = field_type_scalar,&
    conformity = .true.,&
    continuity = .false. )

  call reference_fe%create_nodal_quadrature()

  nodal_quadrature => reference_fe%get_nodal_quadrature()

  call this%nodal_quadrature%create( this%num_dims, this%num_dofs_scalar )

  this%nodal_quadrature%coordinates(:,:) =&
    2.0*nodal_quadrature%coordinates(:,:)-1.0

  this%nodal_quadrature%weight(:) = 1.0_rp

  call reference_fe%free()
  
  !! Create nodal quadrature
  !call this%nodal_quadrature%create( this%num_dims, this%num_nodes )
  !! Fill nodal quadrature
  !call this%fill_nodal_quadrature ( this%nodal_quadrature )  

end subroutine hpdrf_create_nodal_quadrature

!subroutine hpdrf_fill_nodal_quadrature( this, quadrature )
!  implicit none
!  class(hex_pk_disc_reference_fe_t), intent(in)    :: this 
!  type(quadrature_t)                  , intent(inout) :: quadrature
!
!end subroutine hpdrf_fill_nodal_quadrature

subroutine hpdrf_allocate_and_fill_node_component_array(this)

  implicit none
  class(hex_pk_disc_reference_fe_t), intent(inout) :: this

  integer(ip) :: i, j , c

  call memalloc( this%num_shape_functions, 2, this%node_component_array, __FILE__, __LINE__ )
  call memalloc( this%num_dofs_scalar,     & 
       & this%num_field_components, & 
       & this%node_array_component,    & 
       & __FILE__, __LINE__ )

  c = 1
  do i = 1, this%num_field_components
     do j = 1, this%num_dofs_scalar
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do

end subroutine hpdrf_allocate_and_fill_node_component_array

subroutine hpdrf_fill_field_components (this)
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(inout) :: this
  call this%extend_list_components( this%dofs_n_face )
  call this%extend_list_components( this%own_dofs_n_face )
  this%num_shape_functions = this%num_dofs_scalar * this%num_field_components
end subroutine hpdrf_fill_field_components

subroutine hpdrf_create_interpolation ( this, quadrature, interpolation, & 
     &                                                    interpolation_duties)
  implicit none 
  class(hex_pk_disc_reference_fe_t), intent(in)       :: this 
  type(quadrature_t)              , intent(in)       :: quadrature
  type(interpolation_t)           , intent(inout)    :: interpolation
  type(interpolation_duties_t), optional, intent(in) :: interpolation_duties

  call interpolation%create( this%num_dims, this%num_dofs_scalar, &
       &                     quadrature%num_quadrature_points, interpolation_duties )

  call this%fill_interpolation( quadrature, interpolation )

end subroutine hpdrf_create_interpolation

subroutine hpdrf_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation    
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)

  type(interpolation_t) :: interpolation_pre_basis

  if ( .not. this%basis_changed ) then
     call this%fill_interpolation_pre_basis ( quadrature, interpolation, order_vector )
  else
     call interpolation_pre_basis%clone(interpolation)
     call this%fill_interpolation_pre_basis ( quadrature, interpolation_pre_basis, order_vector ) 
     call this%apply_change_basis_matrix_to_interpolation ( interpolation_pre_basis, interpolation )
     call interpolation_pre_basis%free()
  end if
end subroutine hpdrf_fill_interpolation

subroutine hpdrf_fill_interpolation_pre_basis ( this, quadrature, interpolation, order_vector ) 
  implicit none 
  class(hex_pk_disc_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)

  type(truncated_tensor_product_polynomial_space_t)        :: tet_polynomial_prebase
  type(polynomial_basis_t)  :: monomial_1D_basis(SPACE_DIM)
  type(monomial_t)                      :: monomial_1D

  real(rp), allocatable :: values(:)
  real(rp), allocatable :: gradients(:,:)
  integer(ip) :: idime, q_point

  do idime=1,interpolation%num_dims
     call monomial_1D%generate_basis(this%order_vector(idime), monomial_1D_basis(idime) )
  end do

  call tet_polynomial_prebase%create(interpolation%num_dims,monomial_1D_basis)
  call tet_polynomial_prebase%fill( quadrature%get_coordinates() )

  call memalloc(tet_polynomial_prebase%get_num_polynomials(),values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,tet_polynomial_prebase%get_num_polynomials(),gradients,__FILE__,__LINE__)

  do q_point=1, quadrature%get_num_quadrature_points()
     call tet_polynomial_prebase%evaluate_values(q_point, values)
     interpolation%shape_functions(1,:,q_point) = values(:)
     if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
       call tet_polynomial_prebase%evaluate_gradients(q_point, gradients)
       interpolation%shape_derivatives(1,:,:,q_point) = gradients(:,:)
     end if
  end do

  ! Free auxiliary memory
  if(allocated(values))    call memfree(values,__FILE__,__LINE__)
  if(allocated(gradients)) call memfree(gradients,__FILE__,__LINE__)

  do idime=1,interpolation%num_dims
     call monomial_1D_basis(idime)%free()
  end do
  call monomial_1D%free()
  call tet_polynomial_prebase%free()
end subroutine hpdrf_fill_interpolation_pre_basis

subroutine hpdrf_create_interpolation_restricted_to_facet( this,facet_lid, &
     & subfacet_lid, local_quadrature,facet_interpolation)
  implicit none 
  class(hex_pk_disc_reference_fe_t), intent(in)    :: this 
  integer(ip)                     , intent(in)    :: facet_lid
  integer(ip)                     , intent(in)    :: subfacet_lid
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: facet_interpolation

  ! Allocate the arrays of the interpolation
  call facet_interpolation%create(this%num_dims,this%num_dofs_scalar, &
       & local_quadrature%num_quadrature_points )

  ! Fill the values of the shape functions
  call this%fill_interp_restricted_to_facet(local_quadrature,facet_lid,subfacet_lid,facet_interpolation)

end subroutine hpdrf_create_interpolation_restricted_to_facet

subroutine hpdrf_change_basis(this) 
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(inout) ::  this

  type(interpolation_t)   :: interpolation
  integer(ip)             :: i, j, num_shape_functions_x_component

  num_shape_functions_x_component = this%num_shape_functions/this%num_field_components
  call memalloc(num_shape_functions_x_component,num_shape_functions_x_component,this%change_basis_matrix,__FILE__,__LINE__)
  call this%create_interpolation(this%nodal_quadrature,interpolation)
  do i=1,num_shape_functions_x_component
     do j=1,num_shape_functions_x_component
        !write(*,*) 'Shape',j,'point',i
        !write(*,*) interpolation%shape_functions(1,j,i)
        this%change_basis_matrix(i,j) = interpolation%shape_functions(1,j,i)
     end do
  end do
  call interpolation%free()
  call this%invert_change_basis_matrix()
  this%basis_changed = .true.
end subroutine hpdrf_change_basis

subroutine hpdrf_invert_change_basis_matrix(this)
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(inout) :: this 

  integer(ip) :: error
  integer(ip), allocatable :: ipiv(:)
  real(rp), allocatable :: inverse_change_basis_matrix(:,:)  
  integer(ip) :: i, num_shape_functions_x_component

  num_shape_functions_x_component = this%num_shape_functions/this%num_field_components
  assert ( allocated(this%change_basis_matrix) )
  assert ( size(this%change_basis_matrix,1) == num_shape_functions_x_component )
  assert ( size(this%change_basis_matrix,2) == num_shape_functions_x_component )

  ! Solve linear system with several RHS
  ! Compute LU factorization of this%change_basis_matrix
#ifdef ENABLE_LAPACK
  call memalloc ( num_shape_functions_x_component, ipiv, __FILE__,__LINE__ )

  call memalloc ( num_shape_functions_x_component, & 
       num_shape_functions_x_component, &
       inverse_change_basis_matrix, &
       __FILE__,__LINE__ )

  call DGETRF( num_shape_functions_x_component, & 
       num_shape_functions_x_component, &
       this%change_basis_matrix, &
       num_shape_functions_x_component, &
       ipiv, &
       error )
  check ( error == 0 )

  inverse_change_basis_matrix = 0.0_rp
  do i=1, num_shape_functions_x_component
     inverse_change_basis_matrix(i,i) = 1.0_rp
  end do

  call DGETRS( 'N', & 
       num_shape_functions_x_component, &
       num_shape_functions_x_component, &
       this%change_basis_matrix, &
       num_shape_functions_x_component, &
       ipiv, &
       inverse_change_basis_matrix, &
       num_shape_functions_x_component, &
       error )
  check ( error == 0 )

  !do i=1, this%num_shape_functions
  !   this%change_basis_matrix(i,:) = 0.0_rp!inverse_change_basis_matrix(:,i)
  !end do

  !call memfree (  inverse_change_basis_matrix, __FILE__, __LINE__  )

  if ( allocated(this%change_basis_matrix) ) call memfree (  this%change_basis_matrix, __FILE__, __LINE__  )

  call memmovealloc(inverse_change_basis_matrix, &
       this%change_basis_matrix, __FILE__, __LINE__ )
  !write(*,*) this%change_basis_matrix(1,:)
  !write(*,*) this%change_basis_matrix(2,:)
  !write(*,*) this%change_basis_matrix(3,:)
  call memfree ( ipiv, __FILE__,__LINE__ )
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_LAPACK.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the LAPACK'
  check(.false.)
#endif 

end subroutine hpdrf_invert_change_basis_matrix

subroutine hpdrf_apply_change_basis_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(hex_pk_disc_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)                   , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)                   , intent(inout) :: interpolation

  integer(ip)           :: i, j, jdime, qpoint, num_shape_functions_x_component

  ! Initialize both shape functions and derivatives to zero.
  interpolation%shape_functions   = 0.0_rp
  num_shape_functions_x_component = this%num_shape_functions/this%num_field_components

  ! Compute shape functions
  do qpoint = 1, interpolation%num_quadrature_points
     do i=1, num_shape_functions_x_component
        do j=1, num_shape_functions_x_component
           interpolation%shape_functions(1, i, qpoint) = interpolation%shape_functions(1, i, qpoint) + &
                this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(1, j, qpoint)
        end do
     end do
  end do

  if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
     ! Compute shape derivatives
     interpolation%shape_derivatives = 0.0_rp
     do qpoint = 1, interpolation%num_quadrature_points
        do i=1, num_shape_functions_x_component
           do j=1, num_shape_functions_x_component
              do jdime=1, this%num_dims
                 interpolation%shape_derivatives(1, jdime, i, qpoint) = interpolation%shape_derivatives(1, jdime, i, qpoint) + &
                      this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(1, jdime, j, qpoint)
              end do
           end do
        end do
     end do
  end if

end subroutine hpdrf_apply_change_basis_to_interpolation
