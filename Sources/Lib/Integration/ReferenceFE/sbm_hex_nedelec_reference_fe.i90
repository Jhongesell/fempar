! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published byfill_inter
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================
function hex_nedelec_reference_fe_check_compatibility_of_n_faces                   &
     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
  implicit none
  class(hex_nedelec_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
  logical :: hex_nedelec_reference_fe_check_compatibility_of_n_faces 
  integer(ip) :: idime

  select type(source_reference_fe)
     class is(hex_nedelec_reference_fe_t)
        ! Get number nodes per dimension
     assert (target_reference_fe%number_dimensions == source_reference_fe%number_dimensions)
     do idime = 1, target_reference_fe%number_dimensions
        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
     end do
     assert (target_reference_fe%get_n_face_dimension(target_n_face_id) == source_reference_fe%get_n_face_dimension(source_n_face_id))
     assert (target_reference_fe%get_n_face_dimension(target_n_face_id) < 3)
     assert (target_reference_fe%number_field_components == source_reference_fe%number_field_components)
     assert (target_reference_fe%get_number_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_number_own_dofs_n_face(source_n_face_id))
     hex_nedelec_reference_fe_check_compatibility_of_n_faces = .true.
     class default
     hex_nedelec_reference_fe_check_compatibility_of_n_faces = .false.
  end select

end function hex_nedelec_reference_fe_check_compatibility_of_n_faces

!==================================================================================================
function hex_nedelec_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(hex_nedelec_reference_fe_t), intent(in) :: this 
  real(rp)  :: hex_nedelec_reference_fe_get_characteristic_length 
  hex_nedelec_reference_fe_get_characteristic_length =  2.0_rp
end function hex_nedelec_reference_fe_get_characteristic_length

!**************************************************************************************************
! Deferred TBP implementors from nedelec_reference_fe_t
!**************************************************************************************************

! @sbadia: Think about an automatic generation of gauss points for an arbitrary order
!==================================================================================================
subroutine hex_nedelec_reference_fe_fill_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  !
  !     This routine sets up the integration constants of open
  !     integration rules for brick elements:
  ! 
  !          NDIME = 1             NDIME = 2             NDIME = 3
  ! 
  !      NGAUS  EXACT POL.     NGAUS  EXACT POL.     NGAUS  EXACT POL. 
  !      -----  ----------     -----  ----------     -----  ----------
  !        1      q1           1 x 1     q1          1x1x1     q1	
  !        2      q3           2 x 2     q3          2x2x2     q3   
  !        3      q5           3 x 3     q5          3x3x3     q5
  !        4      q7           4 x 4     q7          4x4x4     q7
  !        5      q9           5 x 5     q9          5x5x5     q9
  !        6      q11          6 x 6     q11         6x6x6     q11
  !        7      q13          7 x 7     q13         7x7x7     q13
  !        8      q15          8 x 8     q15         8x8x8     q15
  !       16      q31         16 x 16    q31        16x16x16   q31
  ! 
  !-----------------------------------------------------------------------
  implicit none
  class(hex_nedelec_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(inout) :: quadrature
  real(rp)    :: posgl(20),weigl(20)
  integer(ip) :: nlocs,qpoin,ilocs,jlocs,klocs,ndime,ngaus

  ndime = quadrature%number_dimensions
  ngaus = quadrature%number_quadrature_points

  if(ndime==1) then
     nlocs=ngaus
  else if(ndime==2) then
     nlocs=nint(sqrt(real(ngaus,rp)))
  else
     nlocs=nint(real(ngaus,rp)**(1.0_rp/3.0_rp))
  end if

  if(nlocs==1) then
     posgl(1)=0.0_rp
     weigl(1)=2.0_rp
  else if(nlocs==2) then
     posgl(1)=-0.577350269189626_rp
     posgl(2)= 0.577350269189626_rp
     weigl(1)= 1.0_rp
     weigl(2)= 1.0_rp
  else if(nlocs==3) then
     posgl(1)=-0.774596669241483_rp
     posgl(2)= 0.0_rp
     posgl(3)= 0.774596669241483_rp
     weigl(1)= 0.555555555555556_rp
     weigl(2)= 0.888888888888889_rp
     weigl(3)= 0.555555555555556_rp
  else if(nlocs==4)  then
     posgl(1)=-0.861136311594053_rp
     posgl(2)=-0.339981043584856_rp
     posgl(3)= 0.339981043584856_rp
     posgl(4)= 0.861136311594053_rp
     weigl(1)= 0.347854845137454_rp
     weigl(2)= 0.652145154862546_rp
     weigl(3)= 0.652145154862546_rp
     weigl(4)= 0.347854845137454_rp
  else if(nlocs==5)  then
     posgl(1) = -0.906179845938664_rp
     posgl(2) = -0.538469310105683_rp
     posgl(3) =  0.0_rp
     posgl(4) =  0.538469310105683_rp
     posgl(5) =  0.906179845938664_rp
     weigl(1) =  0.236926885056189_rp
     weigl(2) =  0.478628670499366_rp
     weigl(3) =  0.568888888888889_rp
     weigl(4) =  0.478628670499366_rp
     weigl(5) =  0.236926885056189_rp
  else if(nlocs==6)  then
     posgl(1) = -0.932469514203152_rp
     posgl(2) = -0.661209386466265_rp
     posgl(3) = -0.238619186083197_rp
     posgl(4) =  0.238619186083197_rp
     posgl(5) =  0.661209386466265_rp
     posgl(6) =  0.932469514203152_rp
     weigl(1) =  0.171324492379170_rp
     weigl(2) =  0.360761573048139_rp
     weigl(3) =  0.467913934572691_rp
     weigl(4) =  0.467913934572691_rp
     weigl(5) =  0.360761573048139_rp
     weigl(6) =  0.171324492379170_rp
  else if(nlocs==7)  then
     posgl(1) = -0.949107912342759_rp
     posgl(2) = -0.741531185599394_rp
     posgl(3) = -0.405845151377397_rp
     posgl(4) =  0.0_rp
     posgl(5) =  0.405845151377397_rp
     posgl(6) =  0.741531185599394_rp
     posgl(7) =  0.949107912342759_rp
     weigl(1) =  0.129484966168870_rp
     weigl(2) =  0.279705391489277_rp
     weigl(3) =  0.381830050505119_rp
     weigl(4) =  0.417959183673469_rp
     weigl(5) =  0.381830050505119_rp
     weigl(6) =  0.279705391489277_rp
     weigl(7) =  0.129484966168870_rp
  else if(nlocs==8)  then
     posgl(1) = -0.960289856497536_rp
     posgl(2) = -0.796666477413627_rp
     posgl(3) = -0.525532409916329_rp
     posgl(4) = -0.183434642495650_rp
     posgl(5) =  0.183434642495650_rp
     posgl(6) =  0.525532409916329_rp
     posgl(7) =  0.796666477413627_rp
     posgl(8) =  0.960289856497536_rp

     weigl(1) =  0.101228536290376_rp
     weigl(2) =  0.222381034453374_rp
     weigl(3) =  0.313706645877887_rp
     weigl(4) =  0.362683783378362_rp
     weigl(5) =  0.362683783378362_rp
     weigl(6) =  0.313706645877887_rp
     weigl(7) =  0.222381034453374_rp
     weigl(8) =  0.101228536290376_rp
  else if(nlocs== 9 )  then 
     posgl( 1 ) = 0.968160239507626_rp 
     posgl( 2 ) = 0.836031107326636_rp 
     posgl( 3 ) = 0.613371432700590_rp 
     posgl( 4 ) = 0.324253423403809_rp 
     posgl( 5 ) = 0.000000000000000_rp 
     posgl( 6 ) = -0.324253423403809_rp 
     posgl( 7 ) = -0.613371432700590_rp 
     posgl( 8 ) = -0.836031107326636_rp 
     posgl( 9 ) = -0.968160239507626_rp 

     weigl( 1 ) = 0.081274388361575_rp 
     weigl( 2 ) = 0.180648160694857_rp 
     weigl( 3 ) = 0.260610696402936_rp 
     weigl( 4 ) = 0.312347077040003_rp 
     weigl( 5 ) = 0.330239355001260_rp 
     weigl( 6 ) = 0.312347077040003_rp 
     weigl( 7 ) = 0.260610696402936_rp 
     weigl( 8 ) = 0.180648160694857_rp 
     weigl( 9 ) = 0.081274388361575_rp 
  else if(nlocs== 10 )  then 
     posgl( 1 ) = 0.973906528517172_rp 
     posgl( 2 ) = 0.865063366688985_rp 
     posgl( 3 ) = 0.679409568299024_rp 
     posgl( 4 ) = 0.433395394129247_rp 
     posgl( 5 ) = 0.148874338981631_rp 
     posgl( 6 ) = -0.148874338981631_rp 
     posgl( 7 ) = -0.433395394129247_rp 
     posgl( 8 ) = -0.679409568299024_rp 
     posgl( 9 ) = -0.865063366688985_rp 
     posgl( 10 ) = -0.973906528517172_rp 

     weigl( 1 ) = 0.066671344308688_rp 
     weigl( 2 ) = 0.149451349150581_rp 
     weigl( 3 ) = 0.219086362515982_rp 
     weigl( 4 ) = 0.269266719309996_rp 
     weigl( 5 ) = 0.295524224714753_rp 
     weigl( 6 ) = 0.295524224714753_rp 
     weigl( 7 ) = 0.269266719309996_rp 
     weigl( 8 ) = 0.219086362515982_rp 
     weigl( 9 ) = 0.149451349150581_rp 
     weigl( 10 ) = 0.066671344308688_rp 
  else if(nlocs== 11 )  then 
     posgl( 1 ) = 0.978228658146057_rp 
     posgl( 2 ) = 0.887062599768095_rp 
     posgl( 3 ) = 0.730152005574049_rp 
     posgl( 4 ) = 0.519096129206812_rp 
     posgl( 5 ) = 0.269543155952345_rp 
     posgl( 6 ) = 0.000000000000000_rp 
     posgl( 7 ) = -0.269543155952345_rp 
     posgl( 8 ) = -0.519096129206812_rp 
     posgl( 9 ) = -0.730152005574049_rp 
     posgl( 10 ) = -0.887062599768095_rp 
     posgl( 11 ) = -0.978228658146057_rp 

     weigl( 1 ) = 0.055668567116174_rp 
     weigl( 2 ) = 0.125580369464904_rp 
     weigl( 3 ) = 0.186290210927734_rp 
     weigl( 4 ) = 0.233193764591990_rp 
     weigl( 5 ) = 0.262804544510247_rp 
     weigl( 6 ) = 0.272925086777901_rp 
     weigl( 7 ) = 0.262804544510247_rp 
     weigl( 8 ) = 0.233193764591990_rp 
     weigl( 9 ) = 0.186290210927734_rp 
     weigl( 10 ) = 0.125580369464904_rp 
     weigl( 11 ) = 0.055668567116174_rp 
  else if(nlocs== 12 )  then 
     posgl( 1 ) = 0.981560634246719_rp 
     posgl( 2 ) = 0.904117256370475_rp 
     posgl( 3 ) = 0.769902674194305_rp 
     posgl( 4 ) = 0.587317954286617_rp 
     posgl( 5 ) = 0.367831498998180_rp 
     posgl( 6 ) = 0.125233408511469_rp 
     posgl( 7 ) = -0.125233408511469_rp 
     posgl( 8 ) = -0.367831498998180_rp 
     posgl( 9 ) = -0.587317954286617_rp 
     posgl( 10 ) = -0.769902674194305_rp 
     posgl( 11 ) = -0.904117256370475_rp 
     posgl( 12 ) = -0.981560634246719_rp 

     weigl( 1 ) = 0.047175336386512_rp 
     weigl( 2 ) = 0.106939325995318_rp 
     weigl( 3 ) = 0.160078328543346_rp 
     weigl( 4 ) = 0.203167426723066_rp 
     weigl( 5 ) = 0.233492536538355_rp 
     weigl( 6 ) = 0.249147045813403_rp 
     weigl( 7 ) = 0.249147045813403_rp 
     weigl( 8 ) = 0.233492536538355_rp 
     weigl( 9 ) = 0.203167426723066_rp 
     weigl( 10 ) = 0.160078328543346_rp 
     weigl( 11 ) = 0.106939325995318_rp 
     weigl( 12 ) = 0.047175336386512_rp 
  else if(nlocs== 13 )  then 
     posgl( 1 ) = 0.984183054718588_rp 
     posgl( 2 ) = 0.917598399222978_rp 
     posgl( 3 ) = 0.801578090733310_rp 
     posgl( 4 ) = 0.642349339440340_rp 
     posgl( 5 ) = 0.448492751036447_rp 
     posgl( 6 ) = 0.230458315955135_rp 
     posgl( 7 ) = 0.000000000000000_rp 
     posgl( 8 ) = -0.230458315955135_rp 
     posgl( 9 ) = -0.448492751036447_rp 
     posgl( 10 ) = -0.642349339440340_rp 
     posgl( 11 ) = -0.801578090733310_rp 
     posgl( 12 ) = -0.917598399222978_rp 
     posgl( 13 ) = -0.984183054718588_rp 

     weigl( 1 ) = 0.040484004765316_rp 
     weigl( 2 ) = 0.092121499837728_rp 
     weigl( 3 ) = 0.138873510219787_rp 
     weigl( 4 ) = 0.178145980761946_rp 
     weigl( 5 ) = 0.207816047536888_rp 
     weigl( 6 ) = 0.226283180262897_rp 
     weigl( 7 ) = 0.232551553230874_rp 
     weigl( 8 ) = 0.226283180262897_rp 
     weigl( 9 ) = 0.207816047536888_rp 
     weigl( 10 ) = 0.178145980761946_rp 
     weigl( 11 ) = 0.138873510219787_rp 
     weigl( 12 ) = 0.092121499837728_rp 
     weigl( 13 ) = 0.040484004765316_rp 
  else if(nlocs== 14 )  then 
     posgl( 1 ) = 0.986283808696812_rp 
     posgl( 2 ) = 0.928434883663574_rp 
     posgl( 3 ) = 0.827201315069765_rp 
     posgl( 4 ) = 0.687292904811685_rp 
     posgl( 5 ) = 0.515248636358154_rp 
     posgl( 6 ) = 0.319112368927890_rp 
     posgl( 7 ) = 0.108054948707344_rp 
     posgl( 8 ) = -0.108054948707344_rp 
     posgl( 9 ) = -0.319112368927890_rp 
     posgl( 10 ) = -0.515248636358154_rp 
     posgl( 11 ) = -0.687292904811685_rp 
     posgl( 12 ) = -0.827201315069765_rp 
     posgl( 13 ) = -0.928434883663574_rp 
     posgl( 14 ) = -0.986283808696812_rp 

     weigl( 1 ) = 0.035119460331752_rp 
     weigl( 2 ) = 0.080158087159760_rp 
     weigl( 3 ) = 0.121518570687903_rp 
     weigl( 4 ) = 0.157203167158194_rp 
     weigl( 5 ) = 0.185538397477938_rp 
     weigl( 6 ) = 0.205198463721296_rp 
     weigl( 7 ) = 0.215263853463158_rp 
     weigl( 8 ) = 0.215263853463158_rp 
     weigl( 9 ) = 0.205198463721296_rp 
     weigl( 10 ) = 0.185538397477938_rp 
     weigl( 11 ) = 0.157203167158194_rp 
     weigl( 12 ) = 0.121518570687903_rp 
     weigl( 13 ) = 0.080158087159760_rp 
     weigl( 14 ) = 0.035119460331752_rp 
  else if(nlocs== 15 )  then 
     posgl( 1 ) = 0.987992518020485_rp 
     posgl( 2 ) = 0.937273392400706_rp 
     posgl( 3 ) = 0.848206583410427_rp 
     posgl( 4 ) = 0.724417731360170_rp 
     posgl( 5 ) = 0.570972172608539_rp 
     posgl( 6 ) = 0.394151347077563_rp 
     posgl( 7 ) = 0.201194093997435_rp 
     posgl( 8 ) = 0.000000000000000_rp 
     posgl( 9 ) = -0.201194093997435_rp 
     posgl( 10 ) = -0.394151347077563_rp 
     posgl( 11 ) = -0.570972172608539_rp 
     posgl( 12 ) = -0.724417731360170_rp 
     posgl( 13 ) = -0.848206583410427_rp 
     posgl( 14 ) = -0.937273392400706_rp 
     posgl( 15 ) = -0.987992518020485_rp 

     weigl( 1 ) = 0.030753241996117_rp 
     weigl( 2 ) = 0.070366047488108_rp 
     weigl( 3 ) = 0.107159220467172_rp 
     weigl( 4 ) = 0.139570677926154_rp 
     weigl( 5 ) = 0.166269205816994_rp 
     weigl( 6 ) = 0.186161000015562_rp 
     weigl( 7 ) = 0.198431485327112_rp 
     weigl( 8 ) = 0.202578241925561_rp 
     weigl( 9 ) = 0.198431485327112_rp 
     weigl( 10 ) = 0.186161000015562_rp 
     weigl( 11 ) = 0.166269205816994_rp 
     weigl( 12 ) = 0.139570677926154_rp 
     weigl( 13 ) = 0.107159220467172_rp 
     weigl( 14 ) = 0.070366047488108_rp 
     weigl( 15 ) = 0.030753241996117_rp 
  else if(nlocs==16)  then
     posgl( 1) =-0.98940093499165_rp
     posgl( 2) =-0.94457502307323_rp
     posgl( 3) =-0.86563120238783_rp
     posgl( 4) =-0.75540440835500_rp
     posgl( 5) =-0.61787624440264_rp
     posgl( 6) =-0.45801677765723_rp
     posgl( 7) =-0.28160355077926_rp
     posgl( 8) =-0.09501250983764_rp
     posgl( 9) = 0.09501250983764_rp
     posgl(10) = 0.28160355077926_rp
     posgl(11) = 0.45801677765723_rp
     posgl(12) = 0.61787624440264_rp
     posgl(13) = 0.75540440835500_rp
     posgl(14) = 0.86563120238783_rp
     posgl(15) = 0.94457502307323_rp
     posgl(16) = 0.98940093499165_rp

     weigl( 1) =  0.02715245941175_rp
     weigl( 2) =  0.06225352393865_rp
     weigl( 3) =  0.09515851168249_rp
     weigl( 4) =  0.12462897125553_rp
     weigl( 5) =  0.14959598881658_rp
     weigl( 6) =  0.16915651939500_rp
     weigl( 7) =  0.18260341504492_rp
     weigl( 8) =  0.18945061045507_rp
     weigl( 9) =  0.18945061045507_rp
     weigl(10) =  0.18260341504492_rp
     weigl(11) =  0.16915651939500_rp
     weigl(12) =  0.14959598881658_rp
     weigl(13) =  0.12462897125553_rp
     weigl(14) =  0.09515851168249_rp
     weigl(15) =  0.06225352393865_rp
     weigl(16) =  0.02715245941175_rp
  else if(nlocs== 17 )  then 
     posgl( 1 ) = 0.990575475314417_rp 
     posgl( 2 ) = 0.950675521768768_rp 
     posgl( 3 ) = 0.880239153726986_rp 
     posgl( 4 ) = 0.781514003896801_rp 
     posgl( 5 ) = 0.657671159216691_rp 
     posgl( 6 ) = 0.512690537086477_rp 
     posgl( 7 ) = 0.351231763453876_rp 
     posgl( 8 ) = 0.178484181495848_rp 
     posgl( 9 ) = 0.000000000000000_rp 
     posgl( 10 ) = -0.178484181495848_rp 
     posgl( 11 ) = -0.351231763453876_rp 
     posgl( 12 ) = -0.512690537086477_rp 
     posgl( 13 ) = -0.657671159216691_rp 
     posgl( 14 ) = -0.781514003896801_rp 
     posgl( 15 ) = -0.880239153726986_rp 
     posgl( 16 ) = -0.950675521768768_rp 
     posgl( 17 ) = -0.990575475314417_rp 

     weigl( 1 ) = 0.024148302868548_rp 
     weigl( 2 ) = 0.055459529373987_rp 
     weigl( 3 ) = 0.085036148317179_rp 
     weigl( 4 ) = 0.111883847193404_rp 
     weigl( 5 ) = 0.135136368468525_rp 
     weigl( 6 ) = 0.154045761076810_rp 
     weigl( 7 ) = 0.168004102156450_rp 
     weigl( 8 ) = 0.176562705366993_rp 
     weigl( 9 ) = 0.179446470356207_rp 
     weigl( 10 ) = 0.176562705366993_rp 
     weigl( 11 ) = 0.168004102156450_rp 
     weigl( 12 ) = 0.154045761076810_rp 
     weigl( 13 ) = 0.135136368468525_rp 
     weigl( 14 ) = 0.111883847193404_rp 
     weigl( 15 ) = 0.085036148317179_rp 
     weigl( 16 ) = 0.055459529373987_rp 
     weigl( 17 ) = 0.024148302868548_rp 
  else if(nlocs== 18 )  then 
     posgl( 1 ) = 0.991565168420931_rp 
     posgl( 2 ) = 0.955823949571398_rp 
     posgl( 3 ) = 0.892602466497556_rp 
     posgl( 4 ) = 0.803704958972523_rp 
     posgl( 5 ) = 0.691687043060353_rp 
     posgl( 6 ) = 0.559770831073948_rp 
     posgl( 7 ) = 0.411751161462843_rp 
     posgl( 8 ) = 0.251886225691506_rp 
     posgl( 9 ) = 0.084775013041735_rp 
     posgl( 10 ) = -0.084775013041735_rp 
     posgl( 11 ) = -0.251886225691506_rp 
     posgl( 12 ) = -0.411751161462843_rp 
     posgl( 13 ) = -0.559770831073948_rp 
     posgl( 14 ) = -0.691687043060353_rp 
     posgl( 15 ) = -0.803704958972523_rp 
     posgl( 16 ) = -0.892602466497556_rp 
     posgl( 17 ) = -0.955823949571398_rp 
     posgl( 18 ) = -0.991565168420931_rp 

     weigl( 1 ) = 0.021616013526483_rp 
     weigl( 2 ) = 0.049714548894969_rp 
     weigl( 3 ) = 0.076425730254889_rp 
     weigl( 4 ) = 0.100942044106287_rp 
     weigl( 5 ) = 0.122555206711478_rp 
     weigl( 6 ) = 0.140642914670651_rp 
     weigl( 7 ) = 0.154684675126265_rp 
     weigl( 8 ) = 0.164276483745833_rp 
     weigl( 9 ) = 0.169142382963144_rp 
     weigl( 10 ) = 0.169142382963144_rp 
     weigl( 11 ) = 0.164276483745833_rp 
     weigl( 12 ) = 0.154684675126265_rp 
     weigl( 13 ) = 0.140642914670651_rp 
     weigl( 14 ) = 0.122555206711478_rp 
     weigl( 15 ) = 0.100942044106287_rp 
     weigl( 16 ) = 0.076425730254889_rp 
     weigl( 17 ) = 0.049714548894969_rp 
     weigl( 18 ) = 0.021616013526483_rp 
  else if(nlocs== 19 )  then 
     posgl( 1 ) = 0.992406843843584_rp 
     posgl( 2 ) = 0.960208152134830_rp 
     posgl( 3 ) = 0.903155903614818_rp 
     posgl( 4 ) = 0.822714656537143_rp 
     posgl( 5 ) = 0.720966177335229_rp 
     posgl( 6 ) = 0.600545304661681_rp 
     posgl( 7 ) = 0.464570741375961_rp 
     posgl( 8 ) = 0.316564099963630_rp 
     posgl( 9 ) = 0.160358645640225_rp 
     posgl( 10 ) = 0.000000000000000_rp 
     posgl( 11 ) = -0.160358645640225_rp 
     posgl( 12 ) = -0.316564099963630_rp 
     posgl( 13 ) = -0.464570741375961_rp 
     posgl( 14 ) = -0.600545304661681_rp 
     posgl( 15 ) = -0.720966177335229_rp 
     posgl( 16 ) = -0.822714656537143_rp 
     posgl( 17 ) = -0.903155903614818_rp 
     posgl( 18 ) = -0.960208152134830_rp 
     posgl( 19 ) = -0.992406843843584_rp 

     weigl( 1 ) = 0.019461788229726_rp 
     weigl( 2 ) = 0.044814226765699_rp 
     weigl( 3 ) = 0.069044542737641_rp 
     weigl( 4 ) = 0.091490021622450_rp 
     weigl( 5 ) = 0.111566645547334_rp 
     weigl( 6 ) = 0.128753962539336_rp 
     weigl( 7 ) = 0.142606702173607_rp 
     weigl( 8 ) = 0.152766042065860_rp 
     weigl( 9 ) = 0.158968843393954_rp 
     weigl( 10 ) = 0.161054449848784_rp 
     weigl( 11 ) = 0.158968843393954_rp 
     weigl( 12 ) = 0.152766042065860_rp 
     weigl( 13 ) = 0.142606702173607_rp 
     weigl( 14 ) = 0.128753962539336_rp 
     weigl( 15 ) = 0.111566645547334_rp 
     weigl( 16 ) = 0.091490021622450_rp 
     weigl( 17 ) = 0.069044542737641_rp 
     weigl( 18 ) = 0.044814226765699_rp 
     weigl( 19 ) = 0.019461788229726_rp 
  else if(nlocs== 20 )  then 
     posgl( 1 ) = 0.993128599185095_rp 
     posgl( 2 ) = 0.963971927277914_rp 
     posgl( 3 ) = 0.912234428251326_rp 
     posgl( 4 ) = 0.839116971822219_rp 
     posgl( 5 ) = 0.746331906460151_rp 
     posgl( 6 ) = 0.636053680726515_rp 
     posgl( 7 ) = 0.510867001950827_rp 
     posgl( 8 ) = 0.373706088715420_rp 
     posgl( 9 ) = 0.227785851141645_rp 
     posgl( 10 ) = 0.076526521133497_rp 
     posgl( 11 ) = -0.076526521133497_rp 
     posgl( 12 ) = -0.227785851141645_rp 
     posgl( 13 ) = -0.373706088715420_rp 
     posgl( 14 ) = -0.510867001950827_rp 
     posgl( 15 ) = -0.636053680726515_rp 
     posgl( 16 ) = -0.746331906460151_rp 
     posgl( 17 ) = -0.839116971822219_rp 
     posgl( 18 ) = -0.912234428251326_rp 
     posgl( 19 ) = -0.963971927277914_rp 
     posgl( 20 ) = -0.993128599185095_rp 

     weigl( 1 ) = 0.017614007139152_rp 
     weigl( 2 ) = 0.040601429800387_rp 
     weigl( 3 ) = 0.062672048334109_rp 
     weigl( 4 ) = 0.083276741576705_rp 
     weigl( 5 ) = 0.101930119817240_rp 
     weigl( 6 ) = 0.118194531961518_rp 
     weigl( 7 ) = 0.131688638449177_rp 
     weigl( 8 ) = 0.142096109318382_rp 
     weigl( 9 ) = 0.149172986472604_rp 
     weigl( 10 ) = 0.152753387130726_rp 
     weigl( 11 ) = 0.152753387130726_rp 
     weigl( 12 ) = 0.149172986472604_rp 
     weigl( 13 ) = 0.142096109318382_rp 
     weigl( 14 ) = 0.131688638449177_rp 
     weigl( 15 ) = 0.118194531961518_rp 
     weigl( 16 ) = 0.101930119817240_rp 
     weigl( 17 ) = 0.083276741576705_rp 
     weigl( 18 ) = 0.062672048334109_rp 
     weigl( 19 ) = 0.040601429800387_rp 
     weigl( 20 ) = 0.017614007139152_rp 
  else
     write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',nlocs
     check(.false.)
  end if

  if(ndime==1) then
     qpoin=0
     do ilocs=1,nlocs
        qpoin=qpoin+1
        quadrature%weight(  qpoin)=weigl(ilocs)
        quadrature%coordinates(1,qpoin)=posgl(ilocs)
     end do
  else if(ndime==2) then
     qpoin=0
     do jlocs=1,nlocs
        do ilocs=1,nlocs
           qpoin=qpoin+1
           quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)
           quadrature%coordinates(1,qpoin)=posgl(ilocs)
           quadrature%coordinates(2,qpoin)=posgl(jlocs)
        end do
     end do
  else if(ndime==3) then
     qpoin=0
     do klocs=1,nlocs
        do jlocs=1,nlocs
           do ilocs=1,nlocs
              qpoin=qpoin+1
              quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)*weigl(klocs)
              quadrature%coordinates(1,qpoin)=posgl(ilocs)
              quadrature%coordinates(2,qpoin)=posgl(jlocs)
              quadrature%coordinates(3,qpoin)=posgl(klocs)
           end do
        end do
     end do
  end if

end subroutine hex_nedelec_reference_fe_fill_quadrature


!==================================================================================================
subroutine hex_nedelec_reference_fe_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(hex_nedelec_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)         :: quadrature
  type(interpolation_t)           , intent(inout)      :: interpolation    
  integer(ip)        , optional   , intent(in)         :: order_vector(SPACE_DIM)
  
  integer(ip)           :: i, j, idime, jdime, qpoint
  type(interpolation_t) :: interpolation_pre_basis
  
  if ( .not. this%basis_changed ) then
    call this%fill_interpolation_pre_basis ( quadrature, interpolation, order_vector )
  else
    call interpolation_pre_basis%clone(interpolation)
    call this%fill_interpolation_pre_basis ( quadrature, interpolation_pre_basis, order_vector ) 
    call this%apply_change_basis_matrix_to_interpolation ( interpolation_pre_basis, interpolation )
    call interpolation_pre_basis%free()
  end if
  
end subroutine hex_nedelec_reference_fe_fill_interpolation

! This subroutine fills the interpolation using the polynomial_names machinery
!==================================================================================================
subroutine hex_nedelec_reference_fe_fill_interpolation_pre_basis( this, quadrature, interpolation, order_vector )
  implicit none
  class(hex_nedelec_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)         :: quadrature
  type(interpolation_t)           , intent(inout)      :: interpolation    
  integer(ip)        , optional   , intent(in)         :: order_vector(SPACE_DIM)
  
  type(tensor_product_polynomial_space_t) :: tensor_product_polynomial_space
  type(polynomial_allocatable_array_t)    :: polynomial_1D_basis(SPACE_DIM)
  type(lagrange_polynomial_t)             :: polynomial_1D

  real(rp), allocatable :: tensor_product_values(:)
  real(rp), allocatable :: tensor_product_gradients(:,:)
  integer(ip) :: order_vector_(SPACE_DIM)
  integer(ip) :: perm_order_vector_(SPACE_DIM)
  integer(ip) :: idime, jdime, q_point, i, c, aux

  ! Initialize both shape functions and derivatives to zero.
  ! This initialization step CANNOT be avoided. Shape-functions
  ! in the RT pre-basis have only one non-zero component. Clients
  ! of type(interpolation_t) may consume all components of each shape 
  ! function (even if they have a single non-zero component), therefore 
  ! they must be initialized provided the code below just computes the
  ! single non-zero component of each shape function
  interpolation%shape_functions   = 0.0_rp
  interpolation%shape_derivatives = 0.0_rp

  if ( present(order_vector) ) then
    order_vector_ = order_vector
  else
    order_vector_  = this%order_vector
  end if

  do idime=1, interpolation%number_dimensions
     perm_order_vector_   = order_vector_ 

     ! Swap positions 1 and idime of perm_order_vector_
     aux                       = perm_order_vector_(1)
     perm_order_vector_(1)     = perm_order_vector_(idime)
     perm_order_vector_(idime) = aux 

     ! Generate a basis of 1D polynomials per coordinate direction 
     ! (X,Y,(Z)) with order given by order_vector_(SPACE_DIM)
     do jdime=1,interpolation%number_dimensions
       call polynomial_1D%generate_basis( perm_order_vector_(jdime), & 
                                          polynomial_1D_basis(jdime) )
     end do

     ! Create an scalar-valued space of  2/3D polynomials from the 
     ! tensor product of the basis of 1D polynomials
     call tensor_product_polynomial_space%create(interpolation%number_dimensions,&
                                                 polynomial_1D_basis)
     call tensor_product_polynomial_space%fill( quadrature%get_coordinates() )

     call memalloc(tensor_product_polynomial_space%get_number_polynomials(),&
                   tensor_product_values,__FILE__,__LINE__)
     call memalloc(SPACE_DIM,&
                   tensor_product_polynomial_space%get_number_polynomials(),&
                   tensor_product_gradients,__FILE__,__LINE__)

     do q_point=1, quadrature%get_number_quadrature_points()
        c=(idime-1)*tensor_product_polynomial_space%get_number_polynomials()
        call tensor_product_polynomial_space%evaluate(q_point, &
                                                      tensor_product_values, &
                                                      tensor_product_gradients)
        do i=1, tensor_product_polynomial_space%get_number_polynomials()
           c = c+1
           interpolation%shape_functions(idime,c,q_point) = tensor_product_values(i)
           do jdime = 1,interpolation%number_dimensions
              interpolation%shape_derivatives(idime,jdime,c,q_point) = tensor_product_gradients(jdime,i)
           end do
        end do
     end do
  
   
     ! Free auxiliary memory
     do jdime=1,interpolation%number_dimensions
        call polynomial_1D_basis(jdime)%free()
     end do
     call tensor_product_polynomial_space%free()
     call polynomial_1D%free()
  
     call memfree(tensor_product_values,__FILE__,__LINE__)
     call memfree(tensor_product_gradients,__FILE__,__LINE__)
  end do

end subroutine hex_nedelec_reference_fe_fill_interpolation_pre_basis

!==================================================================================================
subroutine hex_nedelec_reference_fe_fill_face_interpolation( this, local_quadrature, local_face_id, face_interpolation )
  implicit none
  class(hex_nedelec_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  integer(ip)                             , intent(in)    :: local_face_id
  type(interpolation_t)                   , intent(inout) :: face_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c,idime,iface,n_face_index
  
  ! Add offset to have same numbering as in polytope
  n_face_index = local_face_id+this%get_first_face_id()-1
  
  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%number_dimensions, local_quadrature%number_quadrature_points )
  c = 0
  do idime = 0,this%number_dimensions-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = -1.0_rp
     else
        aux_quadrature%coordinates(idime+1,:) = 1.0_rp
     end if
  end do
  call this%fill_interpolation( aux_quadrature, face_interpolation ) 
  call aux_quadrature%free()
end subroutine hex_nedelec_reference_fe_fill_face_interpolation

!==================================================================================================
subroutine hex_nedelec_reference_fe_fill_edge_interpolation( this, local_edge_id, local_quadrature, edge_interpolation )
  implicit none
  class(hex_nedelec_reference_fe_t)       , intent(in)    :: this
  integer(ip)                             , intent(in)    :: local_edge_id
  type(quadrature_t)                      , intent(in)    :: local_quadrature
  type(interpolation_t)                   , intent(inout) :: edge_interpolation
  type(quadrature_t) :: aux_quadrature
  integer(ip) :: c, idime, n_face_index
  
  ! Add offset to have same numbering as in polytope
  n_face_index = local_edge_id+this%get_first_n_face_id_of_dimension(1)-1
  
  ! Create a d-dimensional quadrature as follows
  call aux_quadrature%create( this%number_dimensions, local_quadrature%number_quadrature_points )
  c = 0
  do idime = 0,this%number_dimensions-1
     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
        c = c+1
        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
        aux_quadrature%coordinates(idime+1,:) = -1.0_rp
     else
        aux_quadrature%coordinates(idime+1,:) = 1.0_rp
     end if
  end do
  call this%fill_interpolation( aux_quadrature, edge_interpolation ) 
  call aux_quadrature%free()
end subroutine hex_nedelec_reference_fe_fill_edge_interpolation

subroutine hex_nedelec_reference_fe_change_basis(this) 
  implicit none
  class(hex_nedelec_reference_fe_t), intent(inout) ::  this
  
  ! Local variables required by edge boundary moments integration
  type(hex_lagrangian_reference_fe_t) :: fe_1D
  type(quadrature_t)                  :: edge_quadrature
  type(interpolation_t)               :: interpolation_1D, edge_interpolation
  type(fe_map_t)                      :: edge_map
  type(point_t), pointer              :: edge_map_coordinates(:)
  real(rp)                            :: shape_test
  type(vector_field_t)                :: tangent
  
  ! Local variables required by face boundary moments integration
  type(hex_nedelec_reference_fe_t)    :: fe_2D
  type(quadrature_t)                  :: face_quadrature
  type(interpolation_t)               :: interpolation_2D, face_interpolation
  type(fe_map_t)                      :: face_map
  type(point_t), pointer              :: face_map_coordinates(:)
  type(vector_field_t)                :: normal
  type(vector_field_t)                :: cross_product_v_shape_trial_normal
  type(vector_field_t)                :: cross_product_v_shape_trial_normal_proj
  type(vector_field_t)                :: col_jacobian
  
  ! Local variables required by interior moments integration
  type(quadrature_t)                  :: cell_quadrature
  type(interpolation_t)               :: reduced_order_cell_interpolation, cell_interpolation
  type(point_t), pointer              :: cell_map_coordinates(:)
  type(fe_map_t)                      :: cell_map
  integer(ip)                         :: reduced_order_vector(SPACE_DIM)
  integer(ip)                         :: num_interior_moments
  type(vector_field_t)                :: v_shape_test
  
  ! Local variables requires for both boundary/interior moments integration
  type(hex_lagrangian_reference_fe_t) :: d_fe_geo
  type(vector_field_t)                :: v_shape_trial
  integer(ip)                         :: ishape, jshape, qpoint
  real(rp)                            :: factor
  integer(ip)                         :: idime
  
  ! Local variable required for normals reorientation calcs (required to update_face_map)
  integer(ip)                         :: local_face_id
  
  ! Rest of local variables
  integer(ip)                         :: c, d, i, j, istat
  integer(ip)                         :: num_rows_own_node_permutations
  integer(ip)                         :: num_cols_own_node_permutations
  type(list_iterator_t)               :: own_dofs_iterator
  
  ! Facets and vertices within reference cell traversal-related data structures
  type(list_iterator_t)               :: vertex_iterator
  integer(ip)                         :: vertex_within_cell_id
  integer(ip)                         :: vertex_within_edge_id
  integer(ip)                         :: vertex_within_face_id
  integer(ip)                         :: edge_id, facet_id, n_face_id
  
  assert ( .not. this%basis_changed )
  assert ( this%conformity .and. this%continuity )
 
  ! Allocate change_basis_matrix
  if ( allocated(this%change_basis_matrix) ) & 
       call memfree(this%change_basis_matrix, __FILE__, __LINE__)    
      
  call memalloc(this%number_shape_functions, &
                this%number_shape_functions, &
                this%change_basis_matrix, &
                __FILE__, &
                __LINE__)
  
 ! Create a 1D scalar lagrangian reference FE of order k-1
 call fe_1D%create(topology          = this%get_topology(), &
                   number_dimensions = 1, &
                   order             = this%order-1, &
                   field_type        = field_type_scalar, &
                   conformity        = .true. )


 ! Create a d-dim scalar lagrangian reference FE of order 1 (geometry)
 call d_fe_geo%create(topology          = this%get_topology(), &
                      number_dimensions = this%number_dimensions, &
                      order             = 1, &
                      field_type        = field_type_scalar, &
                      conformity        = .true. )

 call this%create_edge_quadrature( edge_quadrature )
 call fe_1D%create_interpolation( edge_quadrature, interpolation_1D )
 
 call edge_map%create_edge_map( edge_quadrature, d_fe_geo )

 ! Initialize change of basis matrix
 this%change_basis_matrix = 0.0_rp
  
 d = 0
 do edge_id = this%get_first_n_face_id_of_dimension(1), & 
               this%get_first_n_face_id_of_dimension(1) + this%get_number_n_faces_of_dimension(1)-1
  
     ! Get face map coordinates
     edge_map_coordinates => edge_map%get_coordinates()
   
     ! Extract coordinates of the vertices within the face
     vertex_within_edge_id = 1
     vertex_iterator = this%vertices_n_face%create_iterator(edge_id)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
        call edge_map_coordinates(vertex_within_edge_id)%init(d_fe_geo%nodal_quadrature%coordinates(:, vertex_within_cell_id))
        call vertex_iterator%next()
        vertex_within_edge_id = vertex_within_edge_id + 1
     end do

     ! Update edge_map on current edge
     call edge_map%update_edge_map(local_edge_id = edge_id - d_fe_geo%get_first_n_face_id_of_dimension(1)+1, &
                                   reference_fe  = d_fe_geo, &
                                   quadrature    = edge_quadrature ) 
     
     call this%create_edge_interpolation (edge_id - d_fe_geo%get_first_n_face_id_of_dimension(1)+1, &
                                          edge_quadrature, &
                                          edge_interpolation )
     
     ! Integrate edge boundary moments int_edge(u.t q), q \in P_k-1
     do qpoint = 1, edge_quadrature%number_quadrature_points
        factor = edge_map%get_det_jacobian(qpoint) * edge_quadrature%get_weight(qpoint)
        call edge_map%get_tangent(qpoint, tangent)

        do ishape=1, interpolation_1D%number_shape_functions
           call fe_1D%get_value(interpolation_1D, ishape, qpoint, shape_test)
           do jshape=1, edge_interpolation%number_shape_functions
              call this%get_value(edge_interpolation, jshape, qpoint, v_shape_trial)
              this%change_basis_matrix(d+ishape,jshape) = this%change_basis_matrix(d+ishape,jshape) &
                                                          + shape_test * v_shape_trial * tangent * factor
           end do
        end do
     end do
     d = d + interpolation_1D%number_shape_functions
 end do

 if ( this%number_dimensions == 3 .and. this%order > 1 ) then
    ! Create a 2D nedelec reference FE of order k-1.
    ! Not that conformity = .false. as we are interested into 
    ! pre_basis_interpolation. Also because of computational reasons,
    ! with conformity = .false. we avoid evaluating the change of
    ! basis matrix (i.e., evaluation of functionals)
    call fe_2D%create(topology          = this%get_topology(), &
                      number_dimensions = 2, &
                      order             = this%order-1, &
                      field_type        = field_type_vector, &
                      conformity        = .false. )
    
    call this%create_face_quadrature( face_quadrature )
    call fe_2D%create_interpolation( face_quadrature, interpolation_2D )
    call face_map%create_face_map( face_quadrature, d_fe_geo )
 
    do facet_id = this%get_first_face_id(), this%get_first_face_id() + this%get_number_faces()-1
  
     ! Get face map coordinates
     face_map_coordinates => face_map%get_coordinates()
   
     ! Extract coordinates of the vertices within the face
     vertex_within_face_id = 1
     vertex_iterator = this%vertices_n_face%create_iterator(facet_id)
     do while ( .not. vertex_iterator%is_upper_bound () )
        vertex_within_cell_id = vertex_iterator%get_current()
        call face_map_coordinates(vertex_within_face_id)%init(d_fe_geo%nodal_quadrature%coordinates(:, vertex_within_cell_id))
        call vertex_iterator%next()
        vertex_within_face_id = vertex_within_face_id + 1
     end do

     ! Update face_map on current face
     local_face_id = facet_id - d_fe_geo%get_first_face_id()+1
     call face_map%update_face_map(reorientation_factor   = d_fe_geo%get_normal_orientation_factor(local_face_id), &
                                   quadrature             = face_quadrature ) 
     
     call this%create_face_interpolation (facet_id - d_fe_geo%get_first_face_id()+1, &
                                          face_quadrature, &
                                          face_interpolation )
     
     call cross_product_v_shape_trial_normal_proj%init(0.0_rp)
     
     ! Integrate face boundary moments int_Face(u x n q), q \in Q_k-2,k-1 x Q_k-1,k-2
     do qpoint = 1, face_quadrature%number_quadrature_points
        factor = face_map%get_det_jacobian(qpoint) * face_quadrature%get_weight(qpoint)
        call face_map%get_normal(qpoint, normal)
        
        !!!!!!!!!!!
        !! IMPORTANT NOTE: trick to have normals associated to each pair of faces pointing
        !!                 to the same direction. This only works provided we have an "oriented"
        !!                 triangulation.
        !!!!!!!!!!!
        normal = (-1.0_rp)**(this%orientation%a(facet_id)) * normal
        do i=1, SPACE_DIM
          call normal%set(i, abs(normal%get(i)))
        end do
        
        do ishape=1, interpolation_2D%number_shape_functions
           call fe_2D%get_value(interpolation_2D, ishape, qpoint, v_shape_test)
           do jshape=1, face_interpolation%number_shape_functions
              call this%get_value(face_interpolation, jshape, qpoint, v_shape_trial)
              
              ! Compute u x n
              cross_product_v_shape_trial_normal = cross_product(v_shape_trial,normal)
              
              ! Multiply the transpose of the jacobian with normalized columns by u x n
              ! This is required to transform u x n in a vector contained within the face
              do i=1,this%number_dimensions-1
                call face_map%get_jacobian_normalized_column(i,qpoint,col_jacobian)
                call cross_product_v_shape_trial_normal_proj%set(i, col_jacobian*cross_product_v_shape_trial_normal)
              end do
              
              this%change_basis_matrix(d+ishape,jshape) = this%change_basis_matrix(d+ishape,jshape) &
                                                         + cross_product_v_shape_trial_normal_proj * v_shape_test * factor
           end do
        end do
     end do
     d = d + interpolation_2D%number_shape_functions
  end do
 end if
 
 
 if ( this%number_dimensions == 2 ) then
   ! Q_{k-1,k-2} x Q_{k-2,k-1}
   reduced_order_vector(1)   = this%order_vector(1)
   reduced_order_vector(2)   = this%order_vector(2)-2
 else if ( this%number_dimensions == 3 ) then
   ! Q_{k-1,k-2,k-2} x Q_{k-2,k-1,k-2} x Q_{k-2,k-2,k-1}
   reduced_order_vector(1)   = this%order_vector(1)
   reduced_order_vector(2:3) = this%order_vector(2:3)-2
 end if
  
  
 ! compute number shape functions for reduced order element
 num_interior_moments = 1
 do idime = 1, this%number_dimensions
     num_interior_moments = num_interior_moments*(reduced_order_vector(idime)+1)
 end do
 num_interior_moments = num_interior_moments*this%number_dimensions
  
 ! create cell quadrature
 call this%create_quadrature(cell_quadrature)
  
 ! create reduced order interpolation
 call reduced_order_cell_interpolation%create( this%number_dimensions, &
                                               num_interior_moments, &
                                               cell_quadrature%number_quadrature_points, &
                                               number_entries_symmetric_tensor=0, &
                                               compute_hessian = .false. )
  
 call this%fill_interpolation_pre_basis( cell_quadrature, reduced_order_cell_interpolation, reduced_order_vector)
  
 ! Create PRE-BASIS cell-interpolation from this RT REF FE 
 call this%create_interpolation( cell_quadrature, cell_interpolation )
  
 ! Create + Update cell map 
 call cell_map%create(cell_quadrature, d_fe_geo )
 cell_map_coordinates => cell_map%get_coordinates()
 do vertex_within_cell_id=1,d_fe_geo%get_number_vertices()
    call cell_map_coordinates(vertex_within_cell_id)%init(d_fe_geo%nodal_quadrature%coordinates(:, vertex_within_cell_id))
 end do
 call cell_map%update(cell_quadrature)

 ! ! Integration of interior moments int_K (u.q), q \in Q_{k-1,k-2,k-2} x Q_{k-2,k-1,k-2} x Q_{k-2,k-2,k-1}     
 do qpoint = 1, cell_quadrature%number_quadrature_points
    factor = cell_map%get_det_jacobian(qpoint) * cell_quadrature%get_weight(qpoint)
    do ishape=1, reduced_order_cell_interpolation%number_shape_functions
       call this%get_value(reduced_order_cell_interpolation, ishape, qpoint, v_shape_test)
       do jshape=1, cell_interpolation%number_shape_functions
        call this%get_value(cell_interpolation, jshape, qpoint, v_shape_trial)
         this%change_basis_matrix(d+ishape,jshape) = this%change_basis_matrix(d+ishape,jshape) + &
                                                     v_shape_test * v_shape_trial * factor
        end do
     end do
   end do
   
  ! Invert change_basis_matrix
  call this%invert_change_basis_matrix()
  
 ! Transform type(list_t) member variables of this to reflect change of basis
  call this%own_dofs_n_face%create( this%number_n_faces + 1 )

  if ( this%conformity .and. this%continuity ) then
     do edge_id = this%get_first_n_face_id_of_dimension(1), & 
          this%get_first_n_face_id_of_dimension(1) + this%get_number_n_faces_of_dimension(1)-1
        call this%own_dofs_n_face%sum_to_pointer_index(edge_id, interpolation_1D%number_shape_functions )           
     end do

     if (this%number_dimensions == 3 .and. this%order > 1) then
        do facet_id = this%get_first_face_id(), this%get_first_face_id() + this%get_number_faces()-1
           call this%own_dofs_n_face%sum_to_pointer_index(facet_id, interpolation_2D%number_shape_functions )
        end do
     end if

     call this%own_dofs_n_face%sum_to_pointer_index(this%number_n_faces + 1, num_interior_moments)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()

     c=1
     do idime=1, this%number_dimensions
        do n_face_id = this%get_first_n_face_id_of_dimension(idime), & 
             this%get_first_n_face_id_of_dimension(idime) + this%get_number_n_faces_of_dimension(idime)-1
           own_dofs_iterator = this%own_dofs_n_face%create_iterator(n_face_id)
           do while ( .not. own_dofs_iterator%is_upper_bound() )
              call own_dofs_iterator%set_current(c)
              c = c + 1
              call own_dofs_iterator%next()
           end do
           call own_dofs_iterator%next()
        end do
     end do

  else 

     call this%own_dofs_n_face%sum_to_pointer_index( this%own_dofs_n_face%get_num_pointers(), this%number_shape_functions)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()
     own_dofs_iterator = this%own_dofs_n_face%create_iterator()
     i=1
     do while(.not. own_dofs_iterator%is_upper_bound())
        call own_dofs_iterator%set_current(i)
        call own_dofs_iterator%next()
        i = i + 1 
     enddo

  end if
  this%dofs_n_face      = this%own_dofs_n_face
 
  
  ! Re-define own_node_permutations-related stuff
  if ( allocated(this%number_rotations_per_dimension) )  call memfree (this%number_rotations_per_dimension,__FILE__,__LINE__)
  if ( allocated(this%number_orientations_per_dimension) ) call memfree (this%number_orientations_per_dimension,__FILE__,__LINE__)
  if (allocated(this%own_dof_permutations)) then
     do i = 1, this%number_dimensions-1
        call this%own_dof_permutations(i)%free()
     end do
     deallocate(this%own_dof_permutations, stat=istat)
     check(istat==0)
  end if
  
  call memalloc (this%number_dimensions-1,this%number_rotations_per_dimension,__FILE__,__LINE__)
  call memalloc (this%number_dimensions-1,this%number_orientations_per_dimension,__FILE__,__LINE__)
  
  do idime = 1, this%number_dimensions-1
     call this%node_array_vector(1)%compute_num_rot_and_perm( idime, &
                                                              this%polytope, &
                                                              this%number_rotations_per_dimension(idime), &
                                                              this%number_orientations_per_dimension(idime))
  end do
  
  allocate(this%own_dof_permutations(this%number_dimensions-1)) 
  do idime = 1, this%number_dimensions-1
    num_cols_own_node_permutations = this%number_rotations_per_dimension(idime)*this%number_orientations_per_dimension(idime)
    if ( idime == 1 ) then
      num_rows_own_node_permutations = interpolation_1D%number_shape_functions
    else if ( idime == 2 ) then
	  if ( this%order == 1 ) then 
	  num_rows_own_node_permutations = 0
	  else 
      num_rows_own_node_permutations = interpolation_2D%number_shape_functions
	  end if 
    end if   
  
   call this%own_dof_permutations(idime)%create(num_rows_own_node_permutations, &
                                                 num_cols_own_node_permutations)

   
   ! Warning: temporarily initializing this%own_node_permutations(number_dimensions-1)%a(:)
   !          to the identity. This only will work provided that for all faces F within the 
   !          triangulation, F is oriented the same way in both cells around it
   if (num_rows_own_node_permutations > 0) then
     do j=1, num_cols_own_node_permutations
       do i=1, num_rows_own_node_permutations
         this%own_dof_permutations(idime)%a(i,j) = i
       end do
     end do
   end if
 end do  
  

 ! Flag change of basis
 this%basis_changed = .true.

  
 ! Free all local data structures required for edge moments integration
 call d_fe_geo%free()
 call fe_1D%free()
 call edge_quadrature%free()
 call interpolation_1D%free()
 call edge_interpolation%free()
 call edge_map%free()
 
 ! Free all local data structures required for face moments integration
 call fe_2D%free()
 call face_quadrature%free()
 call interpolation_2D%free()
 call face_interpolation%free()
 call face_map%free()
 
 ! Free all  
 call cell_quadrature%free()
 call reduced_order_cell_interpolation%free()
 call cell_interpolation%free()
 call cell_map%free()
  
end subroutine hex_nedelec_reference_fe_change_basis 

! @sbadia: It could be replaced by an anisotropic quadrature
!==================================================================================================
function hex_nedelec_reference_fe_compute_number_quadrature_points( this, degree, dimension )
  implicit none
  class(hex_nedelec_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: degree
  integer(ip)                         , intent(in)    :: dimension
  integer(ip) :: hex_nedelec_reference_fe_compute_number_quadrature_points
  hex_nedelec_reference_fe_compute_number_quadrature_points = int(ceiling(real(degree + 1,rp)/2.0_rp)**real(dimension,rp),ip)
 end function hex_nedelec_reference_fe_compute_number_quadrature_points
 
 !==================================================================================================
subroutine hex_nedelec_reference_fe_fill_qpoints_permutations(this, quadrature, qpoints_perm)
  implicit none
  class(hex_nedelec_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
  integer(ip)    :: ndime, n_q_points, order
  
  ndime      = quadrature%get_number_dimensions()
  n_q_points = quadrature%get_number_quadrature_points()
  order      = int(real(n_q_points,rp)**(1.0_rp/real(ndime,rp)),ip)+1
  
  call this%node_array%fill_permutations( order, &
                                          ndime, &
                                          this%polytope, &
                                          qpoints_perm )
  
end subroutine hex_nedelec_reference_fe_fill_qpoints_permutations
