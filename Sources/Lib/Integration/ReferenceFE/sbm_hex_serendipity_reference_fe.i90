! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published byfill_inter
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================

subroutine hsrf_create(this, &
                                              topology, &
                                              num_dims, &
                                              order, &
                                              field_type, & 
                                              conformity, &
                                              continuity )
  implicit none
  class(hex_serendipity_reference_fe_t), intent(inout)  :: this
  character(*)                        , intent(in)    :: topology
  integer(ip)                         , intent(in)    :: num_dims
  integer(ip)                         , intent(in)    :: order
  character(*)                        , intent(in)    :: field_type
  logical                             , intent(in)    :: conformity
  logical              , optional     , intent(in)    :: continuity
  call this%free()
  call this%set_common_data(num_dims,order,field_type,conformity,continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_serendipity )
  call this%fill()
  call this%create_nodal_quadrature()
  call this%change_basis()
  !!call this%fill_h_refinement_interpolation()
  !!call this%fill_h_refinement_permutations()
end subroutine hsrf_create

subroutine hsrf_free ( this )
  implicit none 
  class(hex_serendipity_reference_fe_t), intent(inout) :: this 
  call hex_lagrangian_reference_fe_free ( this )
  if ( allocated(this%change_basis_matrix) ) &
       call memfree ( this%change_basis_matrix, __FILE__, __LINE__ )     
  this%basis_changed = .false. 
  call this%node_array_dim_2%free()
  call this%node_array_dim_3%free()
  this%num_nodes = -1
end subroutine hsrf_free

subroutine hsrf_fill_scalar (this)
  implicit none
  class(hex_serendipity_reference_fe_t), intent(inout)    :: this 
  type(node_iterator_t) :: node_iterator
  type(facet_iterator_t) :: facet_iterator
  type(list_iterator_t) :: list_iterator
  integer(ip) :: topology, i, n_face_dim, node, children,num_n_faces, ones_dim(SPACE_DIM)
  logical, allocatable :: visited(:) 
  integer(ip) :: current_dof_lid
  type(list_iterator_t) :: dofs_n_face_iterator 

  call this%fill_topology()
  
  num_n_faces = this%num_n_faces+1
  
  call this%node_array%create( this%polytope, this%order_vector ) 
  call this%node_array_dim_2%create( this%polytope, [serendipity_to_lagr(2,this%order_vector(1)),&
                                                serendipity_to_lagr(2,this%order_vector(2)),&
                                                serendipity_to_lagr(2,this%order_vector(3)) ] )
  call this%node_array_dim_3%create( this%polytope, [serendipity_to_lagr(3,this%order_vector(1)),&
                                                serendipity_to_lagr(3,this%order_vector(2)),&
                                                serendipity_to_lagr(3,this%order_vector(3)) ] )

  call this%own_dofs_n_face%create( num_n_faces )
  do i = 1,num_n_faces
    if (this%get_n_face_dim(i) <= 1) then
      call count_own_dofs_n_face(this%node_array , i)
    else if (this%get_n_face_dim(i) == 2) then
      call count_own_dofs_n_face(this%node_array_dim_2, i)
    else
      call count_own_dofs_n_face(this%node_array_dim_3, i)
    end if
  end do

  call this%own_dofs_n_face%calculate_header()
  call this%own_dofs_n_face%allocate_list_from_pointer()
  list_iterator = this%own_dofs_n_face%create_iterator()

  current_dof_lid = 0
  do while (.not. list_iterator%is_upper_bound())
    current_dof_lid = current_dof_lid + 1
    call list_iterator%set_current(current_dof_lid)
    call list_iterator%next()
  end do

  ! Number nodes
  this%num_shape_functions = current_dof_lid
  this%num_nodes = current_dof_lid

  call this%dofs_n_face%create( num_n_faces )

  call memalloc ( num_n_faces, visited, __FILE__, __LINE__ ) 
  ! Count dofs in nface
  do i=1,num_n_faces
    visited(:) = .false.
    call this%dofs_n_face%sum_to_pointer_index(i,count_dofs_in_n_face(i,visited))
  end do

  call this%dofs_n_face%calculate_header()
  call this%dofs_n_face%allocate_list_from_pointer()
  ! List dofs in nface
  do i=1,num_n_faces
    visited(:) = .false.
    dofs_n_face_iterator = this%dofs_n_face%create_iterator(i)
    call list_dof_in_n_face(i,dofs_n_face_iterator,visited)
  end do
  call memfree ( visited, __FILE__, __LINE__ ) 

  if ( this%conformity .and. this%continuity ) then
  else
     call this%own_dofs_n_face%create(n=num_n_faces )
     call this%own_dofs_n_face%sum_to_pointer_index( this%own_dofs_n_face%get_num_pointers(), this%num_shape_functions)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()
     list_iterator = this%own_dofs_n_face%create_iterator()
     i=1
     do while(.not. list_iterator%is_upper_bound())
        call list_iterator%set_current(i)
        call list_iterator%next()
        i = i + 1 
     enddo
  end if

  contains

    subroutine count_own_dofs_n_face(node_array, n_face_id)
      implicit none
      type(node_array_t), intent(in) :: node_array
      integer(ip)       , intent(in) :: n_face_id
        node_iterator = node_array%create_node_iterator( this%polytope%get_n_face(n_face_id), own_boundary = .false. )
        do while (.not. node_iterator%has_finished() )
           call this%own_dofs_n_face%sum_to_pointer_index(n_face_id,1)
           call node_iterator%next()
        end do
    end subroutine count_own_dofs_n_face

    recursive function count_dofs_in_n_face(i, visited) result (num_dofs)

       implicit none
       integer(ip), intent(in)    :: i
       logical    , intent(inout) :: visited(:) 

       integer(ip) :: num_dofs

       type(list_iterator_t) :: facets_n_face_iter  
       
       if ( visited(i) ) then
         num_dofs = 0 
         return
       end if

       visited(i) = .true. 

       num_dofs =  this%own_dofs_n_face%get_sublist_size(i)
       facets_n_face_iter = this%facets_n_face%create_iterator(i)
       do while ( .not. facets_n_face_iter%is_upper_bound() ) 
         if (facets_n_face_iter%get_current() /= i) then
            num_dofs =  num_dofs + count_dofs_in_n_face(facets_n_face_iter%get_current(),visited)
         end if   
         call facets_n_face_iter%next()
       end do

    end function count_dofs_in_n_face

    recursive subroutine list_dof_in_n_face(i,dofs_n_face_iterator,visited)

       implicit none
       integer(ip)          , intent(in) :: i
       type(list_iterator_t), intent(inout) :: dofs_n_face_iterator
       logical              , intent(inout) :: visited(:) 
       type(list_iterator_t) :: facets_n_face_iter
       type(list_iterator_t) :: own_dofs_n_face_iterator

       if ( visited(i) ) return  

       visited(i) = .true. 
         
       own_dofs_n_face_iterator = this%own_dofs_n_face%create_iterator(i)
       do while ( .not. own_dofs_n_face_iterator%is_upper_bound() ) 
         call dofs_n_face_iterator%set_current(own_dofs_n_face_iterator%get_current())
         call own_dofs_n_face_iterator%next()
         call dofs_n_face_iterator%next()
       end do 

       facets_n_face_iter = this%facets_n_face%create_iterator(i)
       do while ( .not. facets_n_face_iter%is_upper_bound() ) 
         if (facets_n_face_iter%get_current() /= i) then
             call list_dof_in_n_face(facets_n_face_iter%get_current(),dofs_n_face_iterator,visited)
         end if   
         call facets_n_face_iter%next()
       end do
    end subroutine list_dof_in_n_face

end subroutine hsrf_fill_scalar

subroutine hsrf_create_nodal_quadrature (this)
  implicit none
  class(hex_serendipity_reference_fe_t), intent(inout) :: this
  
  ! Create nodal quadrature
  call this%nodal_quadrature%create( this%num_dims, this%num_nodes )
  ! Fill nodal quadrature
  call this%fill_nodal_quadrature ( this%nodal_quadrature )  

end subroutine hsrf_create_nodal_quadrature

subroutine hsrf_fill_nodal_quadrature( this, quadrature )
  implicit none
  class(hex_serendipity_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip) :: idime, current_node, n_face_id


  do idime=1,this%num_dims
    current_node = 1
    do n_face_id = 1,this%num_n_faces + 1
      if (this%get_n_face_dim(n_face_id) <= 1) then
        call generate_coordinates(this%node_array,idime,n_face_id,current_node)
      else if (this%get_n_face_dim(n_face_id) == 2) then
        call generate_coordinates(this%node_array_dim_2,idime,n_face_id,current_node)
      else
        call generate_coordinates(this%node_array_dim_3,idime,n_face_id,current_node)
      end if
    end do
  end do

  quadrature%weight = 1.0_rp

  contains

    subroutine generate_coordinates(node_array,idime, n_face_id,current_node)
      implicit none
      type(node_array_t), intent(in) :: node_array
      integer(ip)       , intent(in) :: n_face_id
      integer(ip)       , intent(in) :: idime
      integer(ip)       , intent(inout) :: current_node

      type(node_iterator_t) :: node_iterator

        node_iterator = node_array%create_node_iterator( this%polytope%get_n_face(n_face_id), own_boundary = .false. )
        do while (.not. node_iterator%has_finished() )
           if (this%order_vector(idime) > 0 ) then 
             quadrature%coordinates(idime,current_node) = this%node_array%coordinates(idime,node_iterator%current())*(2.0_rp/this%order_vector(idime))-1.0_rp
           else 
             quadrature%coordinates(idime,current_node) = this%node_array%coordinates(idime,node_iterator%current())
           end if 
           current_node = current_node + 1
           call node_iterator%next()
        end do
    end subroutine generate_coordinates

end subroutine hsrf_fill_nodal_quadrature

subroutine hsrf_allocate_and_fill_node_component_array(this)

  implicit none
  class(hex_serendipity_reference_fe_t), intent(inout) :: this

  integer(ip) :: i, j , c

  call memalloc( this%num_shape_functions, 2, this%node_component_array, __FILE__, __LINE__ )
  call memalloc( this%num_nodes,     & 
       & this%num_field_components, & 
       & this%node_array_component,    & 
       & __FILE__, __LINE__ )

  c = 1
  do i = 1, this%num_field_components
     do j = 1, this%num_nodes
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do

end subroutine hsrf_allocate_and_fill_node_component_array

subroutine hsrf_fill_field_components (this)
  implicit none
  class(hex_serendipity_reference_fe_t), intent(inout) :: this
  call this%extend_list_components( this%dofs_n_face )
  call this%extend_list_components( this%own_dofs_n_face )
  this%num_shape_functions = this%num_nodes * this%num_field_components
end subroutine hsrf_fill_field_components

subroutine hsrf_create_interpolation ( this, quadrature, interpolation, & 
     &                                                    interpolation_duties)
  implicit none 
  class(hex_serendipity_reference_fe_t), intent(in)       :: this 
  type(quadrature_t)              , intent(in)       :: quadrature
  type(interpolation_t)           , intent(inout)    :: interpolation
  type(interpolation_duties_t), optional, intent(in) :: interpolation_duties

  call interpolation%create( this%num_dims, this%num_nodes, &
       &                     quadrature%num_quadrature_points, interpolation_duties )

  call this%fill_interpolation( quadrature, interpolation )

end subroutine hsrf_create_interpolation

subroutine hsrf_fill_interpolation( this, quadrature, interpolation, order_vector )
  implicit none
  class(hex_serendipity_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation    
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)

  type(interpolation_t) :: interpolation_pre_basis

  if ( .not. this%basis_changed ) then
     call this%fill_interpolation_pre_basis ( quadrature, interpolation, order_vector )
  else
     call interpolation_pre_basis%clone(interpolation)
     call this%fill_interpolation_pre_basis ( quadrature, interpolation_pre_basis, order_vector ) 
     call this%apply_change_basis_matrix_to_interpolation ( interpolation_pre_basis, interpolation )
     call interpolation_pre_basis%free()
  end if

end subroutine hsrf_fill_interpolation

subroutine hsrf_fill_interpolation_pre_basis ( this, quadrature, interpolation, order_vector ) 
  implicit none 
  class(hex_serendipity_reference_fe_t), intent(in) :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  integer(ip) , optional          , intent(in)    :: order_vector(SPACE_DIM)

  type(serendipity_polynomial_space_t)        :: serendipity_polynomial_prebasis
  type(polynomial_basis_t)  :: monomial_1D_basis(SPACE_DIM)
  type(monomial_t)                      :: monomial_1D

  real(rp), allocatable :: values(:)
  real(rp), allocatable :: gradients(:,:)
  integer(ip) :: idime, q_point

  do idime=1,interpolation%num_dims
     call monomial_1D%generate_basis(this%order_vector(idime), monomial_1D_basis(idime) )
  end do

  call serendipity_polynomial_prebasis%create(interpolation%num_dims,monomial_1D_basis)
  call serendipity_polynomial_prebasis%fill( quadrature%get_coordinates() )

  call memalloc(serendipity_polynomial_prebasis%get_num_polynomials(),values,__FILE__,__LINE__)
  call memalloc(SPACE_DIM,serendipity_polynomial_prebasis%get_num_polynomials(),gradients,__FILE__,__LINE__)

  do q_point=1, quadrature%get_num_quadrature_points()
     call serendipity_polynomial_prebasis%evaluate(q_point, values, gradients)
     interpolation%shape_functions(1,:,q_point) = values(:)
     if(interpolation%my_duties%compute_first_derivatives_is_assigned()) &
          &  interpolation%shape_derivatives(1,:,:,q_point) = gradients(:,:)
  end do

  ! Free auxiliary memory
  if(allocated(values))    call memfree(values,__FILE__,__LINE__)
  if(allocated(gradients)) call memfree(gradients,__FILE__,__LINE__)

  do idime=1,interpolation%num_dims
     call monomial_1D_basis(idime)%free()
  end do
  call monomial_1D%free()
  call serendipity_polynomial_prebasis%free()
end subroutine hsrf_fill_interpolation_pre_basis

subroutine hsrf_change_basis(this) 
  implicit none
  class(hex_serendipity_reference_fe_t), intent(inout) ::  this

  type(interpolation_t)   :: interpolation
  integer(ip)             :: i, j, num_shape_functions_x_component

  num_shape_functions_x_component = this%num_shape_functions/this%num_field_components
  call memalloc(num_shape_functions_x_component,num_shape_functions_x_component,this%change_basis_matrix,__FILE__,__LINE__)
  call this%create_interpolation(this%nodal_quadrature,interpolation)
  do i=1,num_shape_functions_x_component
     do j=1,num_shape_functions_x_component
        !write(*,*) 'Shape',j,'point',i
        !write(*,*) interpolation%shape_functions(1,j,i)
        this%change_basis_matrix(i,j) = interpolation%shape_functions(1,j,i)
     end do
  end do
  call interpolation%free()
  call this%invert_change_basis_matrix()
  this%basis_changed = .true.
end subroutine hsrf_change_basis

subroutine hsrf_invert_change_basis_matrix(this)
  implicit none
  class(hex_serendipity_reference_fe_t), intent(inout) :: this 

  integer(ip) :: error
  integer(ip), allocatable :: ipiv(:)
  real(rp), allocatable :: inverse_change_basis_matrix(:,:)  
  integer(ip) :: i, num_shape_functions_x_component

  num_shape_functions_x_component = this%num_shape_functions/this%num_field_components
  assert ( allocated(this%change_basis_matrix) )
  assert ( size(this%change_basis_matrix,1) == num_shape_functions_x_component )
  assert ( size(this%change_basis_matrix,2) == num_shape_functions_x_component )

  ! Solve linear system with several RHS
  ! Compute LU factorization of this%change_basis_matrix
#ifdef ENABLE_LAPACK
  call memalloc ( num_shape_functions_x_component, ipiv, __FILE__,__LINE__ )

  call memalloc ( num_shape_functions_x_component, & 
       num_shape_functions_x_component, &
       inverse_change_basis_matrix, &
       __FILE__,__LINE__ )

  call DGETRF( num_shape_functions_x_component, & 
       num_shape_functions_x_component, &
       this%change_basis_matrix, &
       num_shape_functions_x_component, &
       ipiv, &
       error )
  check ( error == 0 )

  inverse_change_basis_matrix = 0.0_rp
  do i=1, num_shape_functions_x_component
     inverse_change_basis_matrix(i,i) = 1.0_rp
  end do

  call DGETRS( 'N', & 
       num_shape_functions_x_component, &
       num_shape_functions_x_component, &
       this%change_basis_matrix, &
       num_shape_functions_x_component, &
       ipiv, &
       inverse_change_basis_matrix, &
       num_shape_functions_x_component, &
       error )
  check ( error == 0 )

  !do i=1, this%num_shape_functions
  !   this%change_basis_matrix(i,:) = 0.0_rp!inverse_change_basis_matrix(:,i)
  !end do

  !call memfree (  inverse_change_basis_matrix, __FILE__, __LINE__  )

  if ( allocated(this%change_basis_matrix) ) call memfree (  this%change_basis_matrix, __FILE__, __LINE__  )

  call memmovealloc(inverse_change_basis_matrix, &
       this%change_basis_matrix, __FILE__, __LINE__ )
  !write(*,*) this%change_basis_matrix(1,:)
  !write(*,*) this%change_basis_matrix(2,:)
  !write(*,*) this%change_basis_matrix(3,:)
  call memfree ( ipiv, __FILE__,__LINE__ )
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_LAPACK.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the LAPACK'
  check(.false.)
#endif 

end subroutine hsrf_invert_change_basis_matrix

subroutine hsrf_apply_change_basis_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(hex_serendipity_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)                   , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)                   , intent(inout) :: interpolation

  integer(ip)           :: i, j, jdime, qpoint, num_shape_functions_x_component

  ! Initialize both shape functions and derivatives to zero.
  interpolation%shape_functions   = 0.0_rp
  num_shape_functions_x_component = this%num_shape_functions/this%num_field_components

  ! Compute shape functions
  do qpoint = 1, interpolation%num_quadrature_points
     do i=1, num_shape_functions_x_component
        do j=1, num_shape_functions_x_component
           interpolation%shape_functions(1, i, qpoint) = interpolation%shape_functions(1, i, qpoint) + &
                this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(1, j, qpoint)
        end do
     end do
  end do

  if(interpolation%my_duties%compute_first_derivatives_is_assigned()) then
     ! Compute shape derivatives
     interpolation%shape_derivatives = 0.0_rp
     do qpoint = 1, interpolation%num_quadrature_points
        do i=1, num_shape_functions_x_component
           do j=1, num_shape_functions_x_component
              do jdime=1, this%num_dims
                 interpolation%shape_derivatives(1, jdime, i, qpoint) = interpolation%shape_derivatives(1, jdime, i, qpoint) + &
                      this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(1, jdime, j, qpoint)
              end do
           end do
        end do
     end do
  end if

end subroutine hsrf_apply_change_basis_to_interpolation












!function hsrf_check_compatibility_of_n_faces                   &
!     &                      (target_reference_fe,source_reference_fe, source_n_face_id,target_n_face_id)
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)  :: target_reference_fe
!  class(reference_fe_t)               , intent(in)  :: source_reference_fe
!  integer(ip)                         , intent(in)  :: source_n_face_id ! Local n-face ID
!  integer(ip)                         , intent(in)  :: target_n_face_id ! Local n-face ID
!  logical :: hsrf_check_compatibility_of_n_faces 
!  integer(ip) :: idime
!
!  select type(source_reference_fe)
!     class is(hex_lagrangian_reference_fe_t)
!        ! Get number nodes per dimension
!     assert (target_reference_fe%num_dims == source_reference_fe%num_dims)
!     do idime = 1, target_reference_fe%num_dims
!        assert (target_reference_fe%order_vector(idime) == source_reference_fe%order_vector(idime))
!     end do
!     assert (target_reference_fe%get_n_face_dim(target_n_face_id) == source_reference_fe%get_n_face_dim(source_n_face_id))
!     assert (target_reference_fe%get_n_face_dim(target_n_face_id) < 3)
!     assert (target_reference_fe%num_field_components == source_reference_fe%num_field_components)
!     assert (target_reference_fe%get_num_own_dofs_n_face(target_n_face_id) == source_reference_fe%get_num_own_dofs_n_face(source_n_face_id))
!     hsrf_check_compatibility_of_n_faces = .true.
!     class default
!     hsrf_check_compatibility_of_n_faces = .false.
!  end select
!
!end function hsrf_check_compatibility_of_n_faces
!
!!==================================================================================================
!function hsrf_get_characteristic_length ( this )
!  implicit none 
!  class(hex_serendipity_reference_fe_t), intent(in) :: this 
!  real(rp)  :: hsrf_get_characteristic_length 
!  hsrf_get_characteristic_length =  2.0_rp
!end function hsrf_get_characteristic_length
!
!!**************************************************************************************************
!! Deferred TBP implementors from lagrangian_reference_fe_t
!!**************************************************************************************************
!
!!==================================================================================================
!function hsrf_get_num_subcells(this, num_refinements) result(num_subcells)
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  integer(ip)                         , intent(in)    :: num_refinements
!  integer(ip)                                         :: num_subcells
!  num_subcells = (num_refinements+1)**this%num_dims
!end function hsrf_get_num_subcells
!
!!==================================================================================================
!subroutine hsrf_get_subcells_connectivity(this, num_refinements, connectivity)
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  integer(ip)                         , intent(in)    :: num_refinements
!  integer(ip)                         , intent(inout) :: connectivity(:,:)
!  integer(ip) :: order_vector(this%num_dims)
!  integer(ip) :: num_subelems
!  integer(ip) :: subelem
!  integer(ip) :: geo_nnodes
!  integer(ip) :: local_node
!  integer(ip) :: first_coord(this%num_dims)
!  integer(ip) :: local_coord(this%num_dims)
!  integer(ip) :: global_coord(this%num_dims)
!  integer(ip) :: ones_dim(this%num_dims)
!  ones_dim = 1
!  num_subelems = this%get_num_subcells(num_refinements=num_refinements)
!  geo_nnodes = this%get_num_vertices()
!  assert(size(connectivity,1) == geo_nnodes)
!  assert(size(connectivity,2) == num_subelems)
!  order_vector = num_refinements+1
!
!  do subelem = 1, num_subelems
!     !call this%get_node_local_coordinates(first_coord,subelem, & 
!     !                                      & this%num_dims,this%order(1)-1)
!     call index_to_ijk( subelem, this%num_dims, order_vector, first_coord )
!
!     do local_node = 1, geo_nnodes
!        !call this%get_node_local_coordinates(local_coord,local_node,this%num_dims,1)
!        call index_to_ijk( local_node, this%num_dims, 2*ones_dim, local_coord )
!
!        global_coord = first_coord + local_coord 
!        !connectivity(local_node, subelem) = this%get_node_local_id(global_coord, &
!        !                                                   & this%num_dims,this%order(1)) ! 
!        connectivity(local_node, subelem) = ijk_to_index(global_coord, order_vector,this%num_dims)+1
!     end do
!  end do
!end subroutine hsrf_get_subcells_connectivity
!
!!==================================================================================================
!subroutine hex_serendipity_create_data_out_quadrature ( this, num_refinements, quadrature )
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  integer(ip)                         , intent(in)    :: num_refinements
!  type(quadrature_t)                  , intent(inout) :: quadrature
!
!  integer(ip)        :: i
!  type(node_array_t) :: node_array 
!  integer(ip)        :: order_vector(SPACE_DIM)
!  
!  assert ( num_refinements >= 0 )
!
!  call quadrature%free()
!  
!  order_vector = num_refinements+1
!  call node_array%create( this%polytope, order_vector ) 
!
!  call quadrature%create( this%num_dims, node_array%num_nodes )
!  do i=1,this%num_dims
!     quadrature%coordinates(i,:) = node_array%coordinates(i,:)*(2.0_rp/order_vector(i))-1.0_rp
!  end do
!  quadrature%weight = 1.0_rp
!  
!  call node_array%free()
!end subroutine hex_serendipity_create_data_out_quadrature
!
!!==================================================================================================
!subroutine hsrf_fill_quadrature ( this, quadrature ) 
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  type(quadrature_t)                  , intent(inout) :: quadrature
!  call quadrature%fill_hex_gauss_legendre()
!end subroutine hsrf_fill_quadrature
!
!
!! This subroutine fills the interpolation using the polynomial_names machinery
!
!! Here we define the dim-1 quadrature and next translate the nodes
!! using the facet type to dim. Next, use the same machinary as for the volume with this new quadrature.
!!!==================================================================================================
!subroutine hsrf_fill_interp_restricted_to_facet( this, local_quadrature, & 
!     & facet_lid, subfacet_lid, facet_interpolation )
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  type(quadrature_t)                  , intent(in)    :: local_quadrature
!  integer(ip)                         , intent(in)    :: facet_lid
!  integer(ip)                         , intent(in)    :: subfacet_lid
!  type(interpolation_t)               , intent(inout) :: facet_interpolation
!  type(quadrature_t) :: aux_quadrature
!  integer(ip) :: c,idime,iface,n_face_index
!  ! Add offset to have same numbering as in polytope
!  n_face_index = facet_lid+this%get_first_facet_id()-1
!  ! Create a d-dimensional quadrature as follows
!  call aux_quadrature%create( this%num_dims, local_quadrature%num_quadrature_points )
!  c = 0
!  do idime = 0,this%num_dims-1
!     if ( this%polytope%n_face_dir_is_fixed( n_face_index, idime ) == 1 ) then
!        c = c+1
!        aux_quadrature%coordinates(idime+1,:) = local_quadrature%coordinates(c,:)
!        if ( subfacet_lid >= 0 ) then
!          aux_quadrature%coordinates(idime+1,:) =                         &
!            ( aux_quadrature%coordinates(idime+1,:) - 1.0_rp ) / 2.0_rp + &
!            real( IBITS( subfacet_lid, c-1 , 1 ), rp )
!        end if
!     else if ( this%polytope%n_face_dir_coordinate( n_face_index, idime ) == 0 ) then
!        aux_quadrature%coordinates(idime+1,:) = -1.0_rp
!     else
!        aux_quadrature%coordinates(idime+1,:) = 1.0_rp
!     end if
!  end do
!  call this%fill_interpolation( aux_quadrature, facet_interpolation ) 
!  call aux_quadrature%free()
!end subroutine hsrf_fill_interp_restricted_to_facet
!
!! @sbadia: It could be replaced by an anisotropic quadrature
!!==================================================================================================
!function hsrf_compute_num_quadrature_points( this, degree, dimension )
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  integer(ip)                         , intent(in)    :: degree
!  integer(ip)                         , intent(in)    :: dimension
!  integer(ip) :: hsrf_compute_num_quadrature_points
!  hsrf_compute_num_quadrature_points = int(ceiling(real(degree + 1,rp)/2.0_rp)**real(dimension,rp),ip)
!end function hsrf_compute_num_quadrature_points
!
!!==================================================================================================
!subroutine hsrf_fill_qpoints_permutations(this, quadrature, qpoints_perm)
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  type(quadrature_t)                  , intent(in)    :: quadrature
!  type(allocatable_array_ip2_t)       , intent(inout) :: qpoints_perm
!  integer(ip)    :: ndime, n_q_points, order
!  
!  ndime      = quadrature%get_num_dims()
!  n_q_points = quadrature%get_num_quadrature_points()
!  order      = int(real(n_q_points,rp)**(1.0_rp/real(ndime,rp)),ip)+1
!  
!  call this%node_array%fill_permutations( order, &
!                                          ndime, &
!                                          this%polytope, &
!                                          qpoints_perm )
!  
!end subroutine hsrf_fill_qpoints_permutations
!
!
!! Subroutine to deal with high order parametrizations of the boundary
!!==================================================================================================
!subroutine hsrf_blending(this,values)
!  implicit none
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this
!  type(point_t)                       , intent(inout) :: values(:)
!
!  integer(ip) :: i,j, ipoin, nlocs, ndime,nnode
!
!  assert(size(values) == this%node_array%num_nodes)
!
!  ndime = this%num_dims
!  nnode = this%node_array%num_nodes
!
!  if(ndime==1) then
!     nlocs=nnode
!  else if(ndime==2) then
!     nlocs=nint(sqrt(real(nnode,rp)))
!  else
!     nlocs=nint(real(nnode,rp)**(1.0_rp/3.0_rp))
!  end if
!
!  if(ndime==2) then
!     !ipoin=0
!     do j = 2, nlocs - 1
!        do i = 2, nlocs - 1
!           ipoin = nlocs*(j-1)+i
!           !ipoin = ipoin + 1
!           call blend_2D(this%nodal_quadrature%coordinates(1,ipoin), & ! reference coordinates
!                &        this%nodal_quadrature%coordinates(2,ipoin), &
!                &        values(1), &                 ! value at vertex 1
!                &        values(nlocs), &             ! value at vertex 2
!                &        values(nlocs*(nlocs-1)+1), & ! value at vertex 3
!                &        values(nlocs*nlocs), &       ! value at vertex 4
!                &        values(i), &                 ! value at edge 5
!                &        values(nlocs*(nlocs-1)+i), & ! value at edge 6
!                &        values(nlocs*(j-1)+1), &     ! value at edge 7
!                &        values(nlocs*j), &           ! value at edge 8
!                &        values(ipoin))               ! interpolated value
!
!        end do
!     end do
!  end if
!
!end subroutine hsrf_blending
!
!!**************************************************************************************************
!! Concrete TBPs of this derived data type
!!**************************************************************************************************
!
!!==================================================================================================
!subroutine hsrf_fill_h_refinement_interpolation ( this )
!  implicit none 
!  class(hex_serendipity_reference_fe_t), intent(inout) :: this
!  type(quadrature_t) :: h_refined_quadrature
!  integer(ip)        :: num_refinements
!  num_refinements = 1
!  call this%create_data_out_quadrature( max((num_refinements+1)*this%order-1,0), h_refined_quadrature )
!  call this%create_interpolation( h_refined_quadrature, this%h_refinement_interpolation )
!  call h_refined_quadrature%free()
!end subroutine hsrf_fill_h_refinement_interpolation
!
!!==================================================================================================
!subroutine hsrf_fill_h_refinement_permutations ( this )
!  implicit none 
!  class(hex_serendipity_reference_fe_t), intent(inout) :: this
!  call this%fill_n_subfacet_permutation(this%num_dims-1, &
!                                       this%h_refinement_subfacet_permutation)
!  if ( this%num_dims == 3 ) then
!     call this%fill_n_subfacet_permutation(this%num_dims-2, &
!                                          this%h_refinement_subedge_permutation)
!  end if
!end subroutine hsrf_fill_h_refinement_permutations
!
!!==================================================================================================
!subroutine hsrf_fill_n_subfacet_permutation ( this, n_face_dime, permutation_array )
!  implicit none 
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this              
!  integer(ip)                         , intent(in)    :: n_face_dime
!  integer(ip)           , allocatable , intent(inout) :: permutation_array(:,:,:)
!  integer(ip)           :: num_refinements, num_n_faces, num_n_subfaces, num_dofs_on_n_face
!  integer(ip)           :: first_n_face_id, n_face_id, n_subface_id, dof_on_n_subface_id, icomp
!  type(node_array_t)    :: h_refinement_node_array   
!  type(node_iterator_t) :: node_iterator_on_n_subface
!  
!  num_refinements    = 1
!  num_n_faces        = this%get_num_n_faces_of_dim(n_face_dime)
!  num_n_subfaces     = ( num_refinements + 1 ) ** n_face_dime     ! Topology-dependent
!  first_n_face_id    = this%get_first_n_face_id_of_dim(n_face_dime)
!  num_dofs_on_n_face = this%get_num_dofs_on_n_face(first_n_face_id) ! Only cubes and simplices
!
!  call memalloc(num_n_faces,num_n_subfaces,num_dofs_on_n_face,permutation_array,__FILE__,__LINE__)
!
!  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
!  
!  do n_face_id = first_n_face_id, first_n_face_id+num_n_faces-1
!     do n_subface_id = 0, num_n_subfaces-1
!        dof_on_n_subface_id = 0
!        node_iterator_on_n_subface = h_refinement_node_array%create_node_iterator ( this%polytope%get_n_face(n_face_id), & 
!                                                                                    n_subface_id, own_boundary = .true. )
!        do icomp = 1, this%num_field_components
!           call node_iterator_on_n_subface%init()
!           do while (.not. node_iterator_on_n_subface%has_finished() )
!              dof_on_n_subface_id = dof_on_n_subface_id + 1
!              permutation_array(n_face_id-first_n_face_id+1,n_subface_id+1,dof_on_n_subface_id) = node_iterator_on_n_subface%current()
!              call node_iterator_on_n_subface%next()
!           end do
!        end do
!        assert( dof_on_n_subface_id == num_dofs_on_n_face )
!     end do
!  end do
!
!  call h_refinement_node_array%free()
!  
!end subroutine hsrf_fill_n_subfacet_permutation
!
!!==================================================================================================
!subroutine hsrf_interpolate_nodal_values_on_subcell ( this,                   &
!                                                                             subcell_id,             &
!                                                                             nodal_values_on_parent, & 
!                                                                             nodal_values_on_child )
!  implicit none 
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this              
!  integer(ip)                         , intent(in)    :: subcell_id
!  real(rp)                            , intent(in)    :: nodal_values_on_parent(:)
!  real(rp)                            , intent(inout) :: nodal_values_on_child(:)
!  integer(ip)           :: num_refinements
!  integer(ip)           :: icomp, ishape_fe, ishape_coarser_fe, qpoint
!  real(rp)              :: coefficient
!  type(node_array_t)    :: h_refinement_node_array
!  type(node_iterator_t) :: node_iterator_on_subcell
!  
!  num_refinements = 1
!  call h_refinement_node_array%create( this%polytope, ( num_refinements + 1 ) * this%order_vector )
!  
!  node_iterator_on_subcell = h_refinement_node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
!                                                                subcell_id, own_boundary = .true. )
!  
!  nodal_values_on_child = 0.0_rp
!  ishape_fe = 0
!  do icomp = 0, this%num_field_components-1
!     call node_iterator_on_subcell%init()
!     do while (.not. node_iterator_on_subcell%has_finished() )
!        qpoint = node_iterator_on_subcell%current()
!        ishape_fe = ishape_fe + 1
!        do ishape_coarser_fe = 1, this%get_num_shape_functions()
!           call this%get_h_refinement_coefficient(ishape_fe,ishape_coarser_fe,qpoint,coefficient)
!           nodal_values_on_child(ishape_fe) = nodal_values_on_child(ishape_fe) + &
!                                      coefficient * nodal_values_on_parent(ishape_coarser_fe)
!        end do
!        call node_iterator_on_subcell%next()
!     end do
!  end do
!  assert( ishape_fe == this%get_num_shape_functions() )
!  
!  call h_refinement_node_array%free()
!  
!end subroutine hsrf_interpolate_nodal_values_on_subcell
!
!!==================================================================================================
!subroutine hsrf_project_nodal_values_on_cell ( this,                     &
!                                                                      nodal_values_on_children, &
!                                                                      nodal_values_on_parent )
!  implicit none 
!  class(hex_serendipity_reference_fe_t), intent(in)    :: this  
!  real(rp)                            , intent(in)    :: nodal_values_on_children(:,:)
!  real(rp)                            , intent(inout) :: nodal_values_on_parent(:)
!  type(node_iterator_t) :: node_iterator
!  integer(ip)           :: parent_index, parent_ijk, parent_coordinate(0:SPACE_DIM-1)
!  integer(ip)           :: child_coordinate(0:SPACE_DIM-1), child_index, subcell_id
!  integer(ip)           :: i, icomp
!  
!  node_iterator = this%node_array%create_node_iterator( this%polytope%get_n_face(this%polytope%num_n_faces), &
!                                                        own_boundary = .true. )
!  
!  do icomp = 0, this%num_field_components-1
!     call node_iterator%init()
!     do while (.not. node_iterator%has_finished() )
!        subcell_id        = 0
!        parent_index      = node_iterator%current()
!        parent_ijk        = node_iterator%current_ijk()
!        parent_coordinate = node_iterator%coordinate
!        child_coordinate  = 2 * parent_coordinate
!        do i = 0,this%node_array%polytope%num_dims-1
!           if ( child_coordinate(i) .ge. this%order_vector(i+1) ) then
!              child_coordinate(i) = child_coordinate(i) - this%order_vector(i+1)
!              subcell_id = IBSET(subcell_id,i)
!           end if
!        end do
!        child_index = ijk_to_index( child_coordinate,      &
!                                    this%node_array%order, &
!                                    this%node_array%polytope%num_dims )
!        child_index = this%node_array%ijk_to_index( child_index ) + &
!                      icomp * this%node_array%num_nodes
!        parent_index = parent_index + icomp * this%node_array%num_nodes
!        nodal_values_on_parent( parent_index ) = nodal_values_on_children( subcell_id+1, &
!                                                                           child_index )
!        call node_iterator%next()
!     end do
!  end do
!  
!end subroutine hsrf_project_nodal_values_on_cell
!
!!==================================================================================================
!subroutine hsrf_get_h_refinement_coefficient ( this, ishape_fe,   & 
!                                                                      ishape_coarser_fe, & 
!                                                                      qpoint, coefficient )
!  implicit none 
!  class(hex_serendipity_reference_fe_t), target, intent(in)    :: this
!  integer(ip)                                 , intent(in)    :: ishape_fe
!  integer(ip)                                 , intent(in)    :: ishape_coarser_fe
!  integer(ip)                                 , intent(in)    :: qpoint
!  real(rp)                                    , intent(inout) :: coefficient
!  assert( ishape_fe >= 1 .and. ishape_fe <= this%num_shape_functions )
!  assert( ishape_coarser_fe >= 1 .and. ishape_coarser_fe <= this%num_shape_functions )
!  assert( qpoint >= 1 )
!  if ( this%node_component_array(ishape_fe,2) == & 
!       this%node_component_array(ishape_coarser_fe,2) ) then
!     coefficient = this%h_refinement_interpolation%shape_functions(1, & 
!                               this%node_component_array(ishape_coarser_fe,1),qpoint)
!  else
!     coefficient = 0.0_rp
!  end if
!end subroutine hsrf_get_h_refinement_coefficient
!
