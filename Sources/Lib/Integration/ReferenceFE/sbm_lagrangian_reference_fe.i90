! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================
subroutine lagrangian_reference_fe_create ( this, topology, num_dims, order, field_type, & 
     &  conformity, continuity )
  implicit none 
  class(lagrangian_reference_fe_t), intent(inout) :: this
  character(*)                    , intent(in)    :: topology
  integer(ip)                     , intent(in)    :: num_dims
  integer(ip)                     , intent(in)    :: order
  character(*)                    , intent(in)    :: field_type
  logical                         , intent(in)    :: conformity
  logical              , optional , intent(in)    :: continuity

  call this%free()
  call this%set_common_data(num_dims,order,field_type,conformity,continuity)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_lagrangian )
  call this%fill()
  call this%create_nodal_quadrature()

end subroutine lagrangian_reference_fe_create

!==================================================================================================
subroutine lagrangian_reference_fe_create_quadrature ( this, quadrature, degree )
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this  
  type(quadrature_t)              , intent(inout) :: quadrature
  integer(ip)           , optional, intent(in)    :: degree

  integer(ip) :: ngaus, degree_, idime
  ! @sbadia: to be improved to anisotropic quadratures
  if ( present(degree) ) then
     degree_ = degree
  else
     degree_ = this%get_default_quadrature_degree()
  end if
  ngaus = this%compute_num_quadrature_points( degree_,this%num_dims)
  call quadrature%create( this%num_dims, ngaus )
  call this%fill_quadrature( quadrature )
end subroutine lagrangian_reference_fe_create_quadrature

!==================================================================================================
subroutine lagrangian_reference_fe_create_facet_quadrature ( this, quadrature, degree )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(inout) :: quadrature
  integer(ip)           , optional, intent(in)    :: degree

  integer(ip) :: ngaus, degree_, facet_dims, idime
  ! @sbadia: to be improved to anisotropic quadratures
  if ( present(degree) ) then
     degree_ = degree
  else
     degree_ = this%get_default_quadrature_degree()
  end if
  facet_dims = this%num_dims - 1
  ngaus = this%compute_num_quadrature_points(degree_,facet_dims)
  call quadrature%create( facet_dims, ngaus )
  call this%fill_quadrature( quadrature )

end subroutine lagrangian_reference_fe_create_facet_quadrature

!==================================================================================================
subroutine lagrangian_reference_fe_create_interpolation ( this, quadrature, interpolation, & 
     &                                                    interpolation_duties)
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)       :: this 
  type(quadrature_t)              , intent(in)       :: quadrature
  type(interpolation_t)           , intent(inout)    :: interpolation
  type(interpolation_duties_t), optional, intent(in) :: interpolation_duties

  call interpolation%create( this%num_dims, this%node_array%num_nodes, &
       &                     quadrature%num_quadrature_points, interpolation_duties )

  call this%fill_interpolation( quadrature, interpolation )

end subroutine lagrangian_reference_fe_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'facet_lid' of the element or
! in all the faces of the element.
subroutine lrfe_create_interpolation_restricted_to_facet( this,facet_lid, &
     & subfacet_lid, local_quadrature,facet_interpolation)
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip)                     , intent(in)    :: facet_lid
  integer(ip)                     , intent(in)    :: subfacet_lid
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: facet_interpolation

  ! Allocate the arrays of the interpolation
  call facet_interpolation%create(this%num_dims,this%node_array%num_nodes, &
       & local_quadrature%num_quadrature_points )

  ! Fill the values of the shape functions
  call this%fill_interp_restricted_to_facet(local_quadrature,facet_lid,subfacet_lid,facet_interpolation)

end subroutine lrfe_create_interpolation_restricted_to_facet

!==================================================================================================
! This subroutine constructs a interpolation of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine lagrangian_reference_fe_create_facet_interpolation (this, quadrature, facet_interpolation)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: facet_interpolation

  type(p_reference_fe_t) :: aux_reference_fe
  
  aux_reference_fe = make_reference_fe ( this%topology, &
       this%fe_type, &
       this%num_dims-1, &
       this%order_vector(1), &
       this%field_type, &
       this%conformity )

  call aux_reference_fe%p%create_interpolation ( quadrature, facet_interpolation)
  call aux_reference_fe%free()
end subroutine lagrangian_reference_fe_create_facet_interpolation

!==================================================================================================
! This subroutine constructs a interpolation of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine lagrangian_reference_fe_create_edget_interpolation (this, quadrature, edget_interpolation)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: edget_interpolation
  type(p_reference_fe_t) :: aux_reference_fe
  !assert( this%num_dims > 2 )
  aux_reference_fe = make_reference_fe ( this%topology, &
                                         this%fe_type, &
  !                                       this%num_dims-2, 
                                         1, &
                                         this%order_vector(1), &
                                         this%field_type, &
                                         this%conformity )
  call aux_reference_fe%p%create_interpolation ( quadrature, edget_interpolation )
  call aux_reference_fe%free()
end subroutine lagrangian_reference_fe_create_edget_interpolation
!==================================================================================================
subroutine lagrangian_reference_fe_apply_cell_map( this, cell_map,                 &
     & interpolation_reference_cell, &
     & interpolation_real_cell )
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(cell_map_t)                  , intent(in)    :: cell_map
  type(interpolation_t)           , intent(in)    :: interpolation_reference_cell
  type(interpolation_t)           , intent(inout) :: interpolation_real_cell
  call this%apply_cell_map_to_interpolation(cell_map,interpolation_reference_cell,interpolation_real_cell)
end subroutine lagrangian_reference_fe_apply_cell_map

!==================================================================================================
function lagrangian_reference_fe_get_component_node( this, node )
  implicit none
  class(lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: lagrangian_reference_fe_get_component_node
  lagrangian_reference_fe_get_component_node = this%node_component_array(node,2)
end function lagrangian_reference_fe_get_component_node

!==================================================================================================
function lagrangian_reference_fe_get_scalar_from_vector_node( this, node )
  implicit none
  class(lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: lagrangian_reference_fe_get_scalar_from_vector_node
  lagrangian_reference_fe_get_scalar_from_vector_node = this%node_component_array(node,1)
end function lagrangian_reference_fe_get_scalar_from_vector_node

function lagrangian_reference_fe_get_max_order( this )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip) :: lagrangian_reference_fe_get_max_order
  lagrangian_reference_fe_get_max_order = maxval(this%order_vector(1:this%num_dims))
end function lagrangian_reference_fe_get_max_order

!==================================================================================================
subroutine lagrangian_reference_fe_get_value_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  scalar_field = actual_cell_interpolation%shape_functions(1,ishape,qpoint)
end subroutine lagrangian_reference_fe_get_value_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_get_value_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  call vector_field%init(0.0_rp)
  call vector_field%set(this%node_component_array(ishape,2), &
       & actual_cell_interpolation%shape_functions(1,this%node_component_array(ishape,1),qpoint))
end subroutine lagrangian_reference_fe_get_value_vector

!==================================================================================================
subroutine lagrangian_reference_fe_get_values_scalar( this, actual_cell_interpolation, values, qpoints_perm )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable           , intent(inout) :: values(:,:)
  integer(ip)          , optional   , intent(in)  :: qpoints_perm(:)
  integer(ip) :: ishape, qpoint, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_scalar )
  
  reallocate = .false.
  if (allocated(values)) reallocate = (size(values,1) < this%num_shape_functions) .or. &
                                      (size(values,2) < actual_cell_interpolation%num_quadrature_points)                                          
  if ((.not. allocated(values)) .or. reallocate) then
     if (allocated(values)) then 
        call memfree(values, __FILE__,__LINE__); 
     end if
     call memalloc(this%num_shape_functions, &
                   actual_cell_interpolation%num_quadrature_points, &
                   values, __FILE__,__LINE__);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        values(ishape,qpoint) = actual_cell_interpolation%shape_functions(1,ishape,actual_qpoint)
     end do
  end do
end subroutine lagrangian_reference_fe_get_values_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_get_values_vector( this, actual_cell_interpolation, values, qpoints_perm )
  implicit none
  class(lagrangian_reference_fe_t) , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  type(vector_field_t), allocatable, intent(inout) :: values(:,:)
  integer(ip)          , optional   , intent(in)   :: qpoints_perm(:)
  
  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_vector )
  
  reallocate = .false.
  if (allocated(values)) reallocate = (size(values,1) < this%num_shape_functions) .or. &
                                      (size(values,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(values)) .or. reallocate) then
     if (allocated(values)) then 
        deallocate(values, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(values(this%num_shape_functions, &
              actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);      
  else
     do qpoint=1, actual_cell_interpolation%num_quadrature_points
        do ishape=1, this%num_shape_functions
           call values(ishape,qpoint)%init(0.0_rp)
        end do
     end do
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        call values(ishape,qpoint)%set(this%node_component_array(ishape,2), &
                                        actual_cell_interpolation%shape_functions(1,this%node_component_array(ishape,1),actual_qpoint))
     end do
  end do
end subroutine lagrangian_reference_fe_get_values_vector

!==================================================================================================
subroutine lagrangian_reference_fe_get_gradient_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  integer(ip) :: idime
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get gradient scalar requires cell interpolation to compute derivaties ')
  call vector_field%init(0.0_rp)
  do idime=1,this%num_dims
     call vector_field%set(idime,actual_cell_interpolation%shape_derivatives(1,idime,ishape,qpoint))
  end do
end subroutine lagrangian_reference_fe_get_gradient_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_get_gradient_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, tensor_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(tensor_field_t)            , intent(inout) :: tensor_field
  integer(ip) :: idime
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get gradient vector requires cell interpolation to compute derivaties ')
  call tensor_field%init(0.0_rp)
  do idime=1,this%num_dims
     call tensor_field%set(idime,this%node_component_array(ishape,2), &
          & actual_cell_interpolation%shape_derivatives(1,idime,this%node_component_array(ishape,1),qpoint))
  end do
end subroutine lagrangian_reference_fe_get_gradient_vector

!==================================================================================================
subroutine lagrangian_reference_fe_get_gradients_scalar( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(lagrangian_reference_fe_t)             , intent(in)    :: this 
  type(interpolation_t)                        , intent(in)    :: actual_cell_interpolation
  type(vector_field_t)            , allocatable, intent(inout) :: gradients(:,:)
  integer(ip)          , optional              , intent(in)    :: qpoints_perm(:)

  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_scalar )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get gradients scalar requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(gradients)) reallocate = (size(gradients,1) < this%num_shape_functions) .or. &
                                         (size(gradients,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(gradients)) .or. reallocate) then
     if (allocated(gradients)) then 
        deallocate(gradients, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(gradients(this%num_shape_functions, &
                        actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);      
  else
     do qpoint=1, actual_cell_interpolation%num_quadrature_points
        do ishape=1, this%num_shape_functions
           call gradients(ishape,qpoint)%init(0.0_rp)
        end do
     end do
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        do idime=1,this%num_dims
           call gradients(ishape,qpoint)%set(idime,actual_cell_interpolation%shape_derivatives(1,idime,ishape,actual_qpoint))
        end do
     end do
  end do
end subroutine lagrangian_reference_fe_get_gradients_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_get_gradients_vector( this, actual_cell_interpolation, gradients, qpoints_perm )
  implicit none
  class(lagrangian_reference_fe_t)             , intent(in)    :: this 
  type(interpolation_t)                        , intent(in)    :: actual_cell_interpolation 
  type(tensor_field_t)            , allocatable, intent(inout) :: gradients(:,:)
  integer(ip)          , optional              , intent(in)    :: qpoints_perm(:)
  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get gradients vector requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(gradients)) reallocate = (size(gradients,1) < this%num_shape_functions) .or. &
                                          (size(gradients,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(gradients)) .or. reallocate) then
     if (allocated(gradients)) then 
        deallocate(gradients, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(gradients(this%num_shape_functions, &
                        actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);      
  else
     do qpoint=1, actual_cell_interpolation%num_quadrature_points
        do ishape=1, this%num_shape_functions
           call gradients(ishape,qpoint)%init(0.0_rp)
        end do
     end do
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        do idime=1,this%num_dims
           call gradients(ishape,qpoint)%set(idime, &
                                             this%node_component_array(ishape,2), &
                                             actual_cell_interpolation%shape_derivatives(1,idime,this%node_component_array(ishape,1),actual_qpoint))
        end do
     end do
  end do
end subroutine lagrangian_reference_fe_get_gradients_vector

!==================================================================================================
subroutine lagrangian_reference_fe_get_divergence_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get divergence vector requires cell interpolation to compute derivaties ')

  scalar_field = actual_cell_interpolation%shape_derivatives(1,this%node_component_array(ishape,2), &
       & this%node_component_array(ishape,1), &
       & qpoint)  
end subroutine lagrangian_reference_fe_get_divergence_vector

!==================================================================================================
subroutine lagrangian_reference_fe_get_divergences_vector( this, actual_cell_interpolation, divergences, qpoints_perm )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp), allocatable           , intent(inout) :: divergences(:,:)
  integer(ip)        , optional   , intent(in)    :: qpoints_perm(:)

  integer(ip) :: ishape, qpoint, actual_qpoint
  logical     :: reallocate
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get divergences vector requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(divergences)) reallocate = (size(divergences,1) < this%num_shape_functions) .or. &
                                           (size(divergences,2) < actual_cell_interpolation%num_quadrature_points)
                                          
  if ((.not. allocated(divergences)) .or. reallocate) then
     if (allocated(divergences)) then 
        call memfree(divergences, __FILE__,__LINE__); 
     end if
     call memalloc(this%num_shape_functions, &
                   actual_cell_interpolation%num_quadrature_points, &
                   divergences, __FILE__,__LINE__);
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        divergences(ishape,qpoint) = actual_cell_interpolation%shape_derivatives(1,this%node_component_array(ishape,2), &
                                                                                 this%node_component_array(ishape,1), &
                                                                                 actual_qpoint)  
     end do
  end do
end subroutine lagrangian_reference_fe_get_divergences_vector

! =================================================================================================
subroutine lagrangian_reference_fe_get_curl_vector( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(lagrangian_reference_fe_t)   , intent(in)     :: this 
  type(interpolation_t)              , intent(in)     :: actual_cell_interpolation 
  integer(ip)                        , intent(in)     :: ishape
  integer(ip)                        , intent(in)     :: qpoint
  type(vector_field_t)               , intent(inout)  :: vector_field
  integer(ip)   :: icomp, ishape_scalar 
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%num_shape_functions )
  assert( qpoint >= 1 )  
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get curl vector requires cell interpolation to compute derivaties ')

 ishape_scalar = this%node_component_array(ishape,1) 
 icomp         = this%node_component_array(ishape,2)
 call vector_field%init(0.0_rp)
 if (this%num_dims == 2) then 
    if  (icomp == 1) then  ! [0,0,- d_y u_x]
       call vector_field%set(3, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,2,ishape_scalar,qpoint))
    elseif (icomp == 2) then  ! [0,0,d_x u_y] 
       call vector_field%set(3, actual_cell_interpolation%shape_derivatives(1,1,ishape_scalar,qpoint))
    end if
 elseif (this%num_dims == 3) then
    if   (icomp == 1) then ! [0, d_z u_x, - d_y u_x]
       call vector_field%set(2, actual_cell_interpolation%shape_derivatives(1,3,ishape_scalar,qpoint))
       call vector_field%set(3, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,2,ishape_scalar,qpoint))

    elseif (icomp == 2) then ! [-d_z u_y, 0, d_x u_y]
       call vector_field%set(1, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,3,ishape_scalar,qpoint))
       call vector_field%set(3, actual_cell_interpolation%shape_derivatives(1,1,ishape_scalar,qpoint))

    elseif (icomp == 3) then ! [d_y u_z, -d_x u_z, 0]
       call vector_field%set(1, actual_cell_interpolation%shape_derivatives(1,2,ishape_scalar,qpoint))
       call vector_field%set(2, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,1,ishape_scalar,qpoint))
    end if
 end if 
end subroutine lagrangian_reference_fe_get_curl_vector

subroutine lagrangian_reference_fe_get_curls_vector(this, actual_cell_interpolation, curls, qpoints_perm)
  implicit none
  class(lagrangian_reference_fe_t)   , intent(in)     :: this 
  type(interpolation_t)              , intent(in)     :: actual_cell_interpolation 
  type(vector_field_t), allocatable  , intent(inout)  :: curls(:,:)
  integer(ip)           , optional   , intent(in)     :: qpoints_perm(:)

  integer(ip) :: idime, ishape, qpoint, istat, actual_qpoint
  logical     :: reallocate
  integer(ip)   :: icomp, ishape_scalar 
  assert( this%field_type == field_type_vector )
  mcheck(actual_cell_interpolation%my_duties%compute_first_derivatives_is_assigned(),'Lagrangian reference FE get curls vector requires cell interpolation to compute derivaties ')

  reallocate = .false.
  if (allocated(curls)) reallocate = (size(curls,1) < this%num_shape_functions) .or. &
                                      (size(curls,2) < actual_cell_interpolation%num_quadrature_points)                                  
  if ((.not. allocated(curls)) .or. reallocate) then
     if (allocated(curls)) then 
        deallocate(curls, stat=istat); 
        check(istat==0);
     end if
     ! This allocate inherently invokes default initialization of member variables of type(vector_field_t)
     ! (i.e., no need to explicitly initialize)
     allocate(curls(this%num_shape_functions, &
                    actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);      
  else
     do qpoint=1, actual_cell_interpolation%num_quadrature_points
        do ishape=1, this%num_shape_functions
           call curls(ishape,qpoint)%init(0.0_rp)
        end do
     end do
  end if
  do qpoint=1, actual_cell_interpolation%num_quadrature_points
     if (present(qpoints_perm)) then
       actual_qpoint = qpoints_perm(qpoint)
     else
       actual_qpoint = qpoint
     end if
     do ishape=1, this%num_shape_functions
        ishape_scalar = this%node_component_array(ishape,1) 
        icomp         = this%node_component_array(ishape,2)
        if (this%num_dims == 2) then 
           if  (icomp == 1) then  ! [0,0,- d_y u_x]
              call curls(ishape,qpoint)%set(3, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,2,ishape_scalar,actual_qpoint))
           elseif (icomp == 2) then  ! [0,0,d_x u_y] 
              call curls(ishape,qpoint)%set(3, actual_cell_interpolation%shape_derivatives(1,1,ishape_scalar,actual_qpoint))
           end if
        elseif (this%num_dims == 3) then
           if   (icomp == 1) then ! [0, d_z u_x, - d_y u_x]
              call curls(ishape,qpoint)%set(2, actual_cell_interpolation%shape_derivatives(1,3,ishape_scalar,actual_qpoint))
              call curls(ishape,qpoint)%set(3, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,2,ishape_scalar,actual_qpoint))
           elseif (icomp == 2) then ! [-d_z u_y, 0, d_x u_y]
              call curls(ishape,qpoint)%set(1, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,3,ishape_scalar,actual_qpoint))
              call curls(ishape,qpoint)%set(3, actual_cell_interpolation%shape_derivatives(1,1,ishape_scalar,actual_qpoint))
           elseif (icomp == 3) then ! [d_y u_z, -d_x u_z, 0]
              call curls(ishape,qpoint)%set(1, actual_cell_interpolation%shape_derivatives(1,2,ishape_scalar,actual_qpoint))
              call curls(ishape,qpoint)%set(2, -1.0_rp*actual_cell_interpolation%shape_derivatives(1,1,ishape_scalar,actual_qpoint))
           end if
        end if
     end do
  end do
end subroutine lagrangian_reference_fe_get_curls_vector

!==================================================================================================
subroutine lagrangian_reference_fe_create_nodal_quadrature (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  ! Create nodal quadrature
  call this%nodal_quadrature%create( this%num_dims, this%node_array%num_nodes )
  ! Fill nodal quadrature
  call this%fill_nodal_quadrature ( this%nodal_quadrature )  
end subroutine lagrangian_reference_fe_create_nodal_quadrature

function lagrangian_reference_fe_has_nodal_quadrature(this)
  implicit none
  class(lagrangian_reference_fe_t), intent(in) :: this
  logical :: lagrangian_reference_fe_has_nodal_quadrature
  lagrangian_reference_fe_has_nodal_quadrature = .true.
end function lagrangian_reference_fe_has_nodal_quadrature

function lagrangian_reference_fe_get_nodal_quadrature(this)
  implicit none
  class(lagrangian_reference_fe_t), target, intent(in) :: this
  type(quadrature_t), pointer :: lagrangian_reference_fe_get_nodal_quadrature
  lagrangian_reference_fe_get_nodal_quadrature => this%nodal_quadrature
end function lagrangian_reference_fe_get_nodal_quadrature

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_fe_function_scalar( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  real(rp), allocatable           , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, ishape

  if ( allocated(quadrature_points_values) ) then
      if ( size(quadrature_points_values) < actual_cell_interpolation%num_quadrature_points ) then
         call memrealloc (actual_cell_interpolation%num_quadrature_points, & 
                          quadrature_points_values, __FILE__, __LINE__)
      end if
  else
    call memalloc (actual_cell_interpolation%num_quadrature_points, & 
                   quadrature_points_values, __FILE__, __LINE__)
  end if
  
  do qpoint = 1, actual_cell_interpolation%num_quadrature_points
     quadrature_points_values(qpoint) = 0.0_rp
     do ishape = 1, actual_cell_interpolation%num_shape_functions
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
             & actual_cell_interpolation%shape_functions(1,ishape,qpoint)*nodal_values(ishape)
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_fe_function_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_fe_function_vector( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t) , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, inode, icomp, inode_scalar, istat

  if ( allocated(quadrature_points_values) ) then
    if ( size(quadrature_points_values) < actual_cell_interpolation%num_quadrature_points ) then
      deallocate(quadrature_points_values, stat=istat); check(istat==0);
      allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
    end if
  else
    allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  
  do qpoint = 1, actual_cell_interpolation%num_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%num_shape_functions
        inode_scalar = this%node_component_array(inode,1)
        icomp        = this%node_component_array(inode,2)
        call quadrature_points_values(qpoint)%add(icomp, &
             & actual_cell_interpolation%shape_functions(1,inode_scalar,qpoint)*nodal_values(inode))
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_fe_function_vector

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_fe_function_tensor( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t) , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, inode, icomp, inode_scalar, istat, idime, jdime

  if ( allocated(quadrature_points_values) ) then
    if ( size(quadrature_points_values) < actual_cell_interpolation%num_quadrature_points ) then
      deallocate(quadrature_points_values, stat=istat); check(istat==0);
      allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
    end if
  else
    allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  
  do qpoint = 1, actual_cell_interpolation%num_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%num_shape_functions
        inode_scalar = this%node_component_array(inode,1)
        icomp        = this%node_component_array(inode,2)
        idime = mod((icomp-1),this%num_dims) + 1
        jdime = (icomp -1)/this%num_dims + 1
        call quadrature_points_values(qpoint)%add(idime,jdime, &
             & actual_cell_interpolation%shape_functions(1,inode_scalar,qpoint)*nodal_values(inode))
     end do
  end do
  

end subroutine lagrangian_reference_fe_evaluate_fe_function_tensor

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_scalar( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t) , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(vector_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip)                                      :: qpoint,inode
  type(vector_field_t)                             :: gradient_shape
  integer(ip)                                      :: istat

  if ( allocated(quadrature_points_values) ) then
    if ( size(quadrature_points_values) < actual_cell_interpolation%num_quadrature_points ) then
      deallocate(quadrature_points_values, stat=istat); check(istat==0);
      allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
    end if
  else
    allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if
  
  do qpoint = 1, actual_cell_interpolation%num_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, actual_cell_interpolation%num_shape_functions
        call this%get_gradient(actual_cell_interpolation,inode,qpoint,gradient_shape)
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
             &                             gradient_shape * nodal_values(inode)
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_vector( this,                  &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t) , intent(in)    :: this 
  type(interpolation_t)            , intent(in)    :: actual_cell_interpolation 
  real(rp)                         , intent(in)    :: nodal_values(:)
  type(tensor_field_t), allocatable, intent(inout) :: quadrature_points_values(:)
  integer(ip)                                      :: qpoint, inode
  type(tensor_field_t)                             :: gradient_shape
  integer(ip)                                      :: istat

  if ( allocated(quadrature_points_values) ) then
     if ( size(quadrature_points_values) < actual_cell_interpolation%num_quadrature_points ) then
        deallocate(quadrature_points_values, stat=istat); check(istat==0);
        allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
     end if
  else
     allocate(quadrature_points_values(actual_cell_interpolation%num_quadrature_points), stat=istat); check(istat==0);
  end if

  do qpoint = 1, actual_cell_interpolation%num_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%num_shape_functions
        call this%get_gradient(actual_cell_interpolation,inode,qpoint,gradient_shape)
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
             &                             gradient_shape * nodal_values(inode)
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_vector

!==================================================================================================
subroutine lagrangian_reference_fe_free ( this )
  implicit none 
  class(lagrangian_reference_fe_t), intent(inout) :: this 
  ! lagrangian_reference_fe_t variables
  if(allocated(this%node_component_array)) & 
       call memfree(this%node_component_array,__FILE__,__LINE__)
  if(allocated(this%node_array_component)) & 
       call memfree(this%node_array_component,__FILE__,__LINE__)
   call this%nodal_quadrature%free()    
  call reference_fe_free ( this )
end subroutine lagrangian_reference_fe_free

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
subroutine lagrangian_reference_fe_fill (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip) :: j, dimension, num_interior_dofs, num_interior_dofs_scalar
  integer(ip) :: column, inode, idime, inode_scalar, num_columns

  this%order_vector = this%order

  call this%fill_scalar( )

  call memalloc (this%num_dims-1,this%num_rotations_x_dim,__FILE__,__LINE__)
  call memalloc (this%num_dims-1,this%num_orientations_x_dim,__FILE__,__LINE__)

  do idime = 1, this%num_dims-1
     call this%node_array%compute_num_rot_and_perm( idime, &
          this%polytope, &
          this%num_rotations_x_dim(idime), &
          this%num_orientations_x_dim(idime))
  end do

  if ( this%conformity .and. this%continuity ) then
     allocate(this%own_dof_permutations(this%num_dims-1))
     call this%generate_own_dofs_cell_permutations()
  end if

  if ( this%num_field_components /= 1 ) then
     call this%fill_field_components( )
     if ( this%conformity .and. this%continuity ) then
        do dimension = 1, this%num_dims-1
           if ( this%own_dof_permutations(dimension)%nd1 > 0 .and. this%own_dof_permutations(dimension)%nd2 > 0 ) then
              ! Compute the number of interior nodes x edge or face
              j = this%get_first_n_face_id_of_dim(dimension)
              num_interior_dofs        = this%get_num_own_dofs_n_face(j)
              num_interior_dofs_scalar = num_interior_dofs/this%num_field_components
              num_columns = this%num_rotations_x_dim(dimension) * &
                   this%num_orientations_x_dim(dimension) 
              call memrealloc ( num_interior_dofs,                   &
                   num_columns,                             &
                   this%own_dof_permutations(dimension)%a, &
                   __FILE__, __LINE__ )
              this%own_dof_permutations(dimension)%nd1 = size(this%own_dof_permutations(dimension)%a,1)
              this%own_dof_permutations(dimension)%nd2 = size(this%own_dof_permutations(dimension)%a,2)
              do column = 1, num_columns
                 ! Fill the rest of components
                 inode = num_interior_dofs_scalar
                 do idime = 2, this%num_field_components
                    ! This is taking advantage of the face that we know how the DoF are ordered
                    ! in case this ordering change, this will not work anymore.
                    do inode_scalar = 1, num_interior_dofs_scalar
                       inode = inode + 1
                       this%own_dof_permutations(dimension)%a(inode,column) = & 
                            & num_interior_dofs_scalar * (idime-1) + & 
                            & this%own_dof_permutations(dimension)%a(inode_scalar,column)
                    end do
                 end do
              end do
           end if
        end do
     end if
  else
     !this%num_nodes_scalar = this%num_shape_functions
  end if

  call this%allocate_and_fill_node_component_array()

end subroutine lagrangian_reference_fe_fill

!==================================================================================================
subroutine lrf_allocate_and_fill_node_component_array(this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this

  integer(ip) :: i, j , c

  call memalloc( this%num_shape_functions, 2, this%node_component_array, __FILE__, __LINE__ )
  call memalloc( this%node_array%num_nodes,     & 
       & this%num_field_components, & 
       & this%node_array_component,    & 
       & __FILE__, __LINE__ )

  c = 1
  do i = 1, this%num_field_components
     do j = 1, this%node_array%num_nodes
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do

end subroutine lrf_allocate_and_fill_node_component_array

!==================================================================================================
subroutine lagrangian_reference_fe_generate_own_dofs_cell_permutations (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip) :: idime
  
  do idime = 1, this%num_dims-1
     call this%node_array%fill_permutations( this%order, &
                                             idime, &
                                             this%polytope, &
                                             this%own_dof_permutations(idime) )
  end do
end subroutine lagrangian_reference_fe_generate_own_dofs_cell_permutations

subroutine lagrangian_reference_fe_fill_qpoints_permutations (this, quadrature, qpoints_perm)
  implicit none
  class(lagrangian_reference_fe_t)        , intent(in)    :: this 
  type(quadrature_t)           , intent(in)    :: quadrature
  type(allocatable_array_ip2_t), intent(inout) :: qpoints_perm
  check(.false.)
end subroutine lagrangian_reference_fe_fill_qpoints_permutations

!==================================================================================================
subroutine lagrangian_reference_fe_fill_field_components (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  call this%extend_list_components( this%dofs_n_face )
  call this%extend_list_components( this%own_dofs_n_face )
  !this%num_nodes_scalar = this%num_shape_functions
  this%num_shape_functions = this%node_array%num_nodes * this%num_field_components
end subroutine lagrangian_reference_fe_fill_field_components

!==================================================================================================
subroutine lagrangian_reference_fe_extend_list_components(this, list_1d)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  type(list_t)                    , intent(inout) :: list_1d
  type(list_t) :: list
  integer(ip)  :: ngaus, order, i, j, k, c, node_1d, aux_1, aux_2
  type(list_iterator_t) :: list_1d_iterator
  type(list_iterator_t) :: list_iterator

  call list%create(n=this%num_n_faces+1)

  do i = 1,this%num_n_faces+1
     call list%sum_to_pointer_index(i, list_1d%get_sublist_size(i) * this%num_field_components)
  end do

  call list%calculate_header()
  call list%allocate_list_from_pointer()

  aux_1 = this%num_shape_functions
  do i = 1,this%num_n_faces+1
     list_iterator = list%create_iterator(i)
     do k = 1,this%num_field_components
        aux_2 = aux_1*(k-1)
        list_1d_iterator = list_1d%create_iterator(i)
        do while(.not. list_1d_iterator%is_upper_bound())
           node_1d = list_1d_iterator%get_current()
           call list_iterator%set_current(node_1d + aux_2)
           call list_1d_iterator%next()
           call list_iterator%next()
        end do
     end do
  end do

  list_1d = list
  call list%free() 
end subroutine lagrangian_reference_fe_extend_list_components

!==================================================================================================
subroutine lagrangian_reference_fe_assign_cell_map_duties (this, interpolation_duties,cell_map_duties)
  class(lagrangian_reference_fe_t)       , intent(in)  :: this 
  type(interpolation_duties_t), intent(in)  :: interpolation_duties
  type(cell_map_duties_t)     , intent(out) :: cell_map_duties

  call cell_map_duties%assign_compute_jacobian_inverse(.false.)
  call cell_map_duties%assign_compute_jacobian_derivative(.false.)
  if(interpolation_duties%compute_second_derivatives_is_assigned()) then
     call cell_map_duties%assign_compute_jacobian_inverse(.true.)
     call cell_map_duties%assign_compute_jacobian_derivative(.true.)
     return
  end if
  if(interpolation_duties%compute_first_derivatives_is_assigned()) then
     call cell_map_duties%assign_compute_jacobian_inverse(.true.)
  end if

end subroutine lagrangian_reference_fe_assign_cell_map_duties
!==================================================================================================
subroutine lagrangian_reference_fe_apply_cell_map_to_interpolation(this,map,ref,phy)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(cell_map_t)                , intent(in)    :: map
  type(interpolation_t)           , intent(in)    :: ref
  type(interpolation_t)           , intent(inout) :: phy
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  integer(ip) :: ndime,nnode,nlocs,ntens
  integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens

  ndime = ref%num_dims
  ntens = ref%num_entries_symmetric_tensor
  nlocs = ref%num_quadrature_points
  !nnode = ref%num_shape_functions
  nnode = size(ref%shape_functions,2)

  ! Shape functions do not change
  !phy%shape_functions = ref%shape_functions 

  ! First derivatives do
  !if(phy%kder==1) then
  if(phy%my_duties%compute_first_derivatives_is_assigned()) then
     phy%shape_derivatives=0.0_rp
     do ilocs=1,phy%num_quadrature_points
        do inode=1,size(phy%shape_functions,2)!phy%num_shape_functions
           do idime=1,ndime
              do jdime=1,ndime
                 phy%shape_derivatives(1,idime,inode,ilocs) = phy%shape_derivatives(1,idime,inode,ilocs) &
                      + map%inv_jacobian(jdime,idime,ilocs)*ref%shape_derivatives(1,jdime,inode,ilocs)
              end do
           end do
        end do
     end do
  end if

  ! Second derivatives are
  !
  !    d^2 N / d x_i d x_j
  !       = (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j)
  !       + (d N / d s_k) (d^2 s_k / d x_i d x_j) 
  !
  if(phy%my_duties%compute_second_derivatives_is_assigned()) then
    call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
     call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
     do ilocs=1,nlocs
        ! Transforms the array HESSI to a symmetric matrix WMAT1
        do inode=1,nnode
           do itens = 1, ntens
              wvec1(itens) = ref%hessian(1,itens,inode,ilocs)
           end do
           call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
        end do
        ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for each node
        do inode=1,nnode
           call btdbma(wmat2(1,1,inode),wmat1(1,1,inode),map%inv_jacobian(:,:,ilocs), &
                &        ndime,ndime)
        end do
        ! Add second cartesian derivatives of the map times 
        ! first derivatives of shape functions
        do inode=1,nnode
           do idime=1,ndime
              do jdime=1,ndime
                 do kdime=1,ndime
                    wmat2(idime,jdime,inode)=wmat2(idime,jdime,inode) &
                         & + ref%shape_derivatives(1,kdime,inode,ilocs) &
                         &   * map%d2sdx(kdime,idime,jdime,ilocs)
                 end do
              end do
           end do
        end do
        ! Writes the Hessian matrix as an array
        do inode=1,nnode
           ! do itens = 1, ntens
           !    wvec1(itens) = phy%hessian(1,itens,inode,ilocs)
           ! end do
           ! call store_symmetric_matrix_as_vector(wmat2(1,1,inode),wvec1,ndime,ntens)
           call store_symmetric_matrix_as_vector(wmat2(1,1,inode),wvec1,ndime,ntens)
           do itens = 1, ntens
              phy%hessian(1,itens,inode,ilocs) = wvec1(itens)
           end do
        end do
     end do
     call memfree(wmat1,__FILE__,__LINE__)
     call memfree(wmat2,__FILE__,__LINE__)
  end if
end subroutine lagrangian_reference_fe_apply_cell_map_to_interpolation

!==================================================================================================
function lagrangian_reference_fe_get_default_quadrature_degree(this)
  implicit none
  class(lagrangian_reference_fe_t), intent(in) :: this
  integer(ip) :: lagrangian_reference_fe_get_default_quadrature_degree
  integer(ip) :: idime
  lagrangian_reference_fe_get_default_quadrature_degree = 0
  do idime = 1,this%num_dims
     lagrangian_reference_fe_get_default_quadrature_degree = max(lagrangian_reference_fe_get_default_quadrature_degree,2*this%order_vector(idime))
  end do
end function lagrangian_reference_fe_get_default_quadrature_degree

!==================================================================================================
subroutine lagrangian_reference_fe_get_h_refinement_coefficient ( this, ishape_fe,   & 
                                                                  ishape_coarser_fe, & 
                                                                  qpoint, coefficient )
  implicit none 
  class(lagrangian_reference_fe_t), target, intent(in)    :: this
  integer(ip)                             , intent(in)    :: ishape_fe
  integer(ip)                             , intent(in)    :: ishape_coarser_fe
  integer(ip)                             , intent(in)    :: qpoint
  real(rp)                                , intent(inout) :: coefficient
  massert(.false.,'Note: you are calling get_h_refinement_coefficient on a type extension of reference_fe_t where it is not implemented.')
end subroutine lagrangian_reference_fe_get_h_refinement_coefficient

!==================================================================================================
subroutine lagrangian_reference_fe_interpolate_nodal_values_on_subcell ( this,                   &
                                                                         subcell_id,             &
                                                                         nodal_values_on_parent, & 
                                                                         nodal_values_on_child )
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this              
  integer(ip)                     , intent(in)    :: subcell_id
  real(rp)                        , intent(in)    :: nodal_values_on_parent(:)
  real(rp)                        , intent(inout) :: nodal_values_on_child(:)
  massert(.false.,'Note: you are calling interpolate_nodal_values_on_subcell on a type extension of reference_fe_t where it is not implemented.')
end subroutine lagrangian_reference_fe_interpolate_nodal_values_on_subcell

!==================================================================================================
subroutine lagrangian_reference_fe_project_nodal_values_on_cell ( this,                     &
                                                                  nodal_values_on_children, &
                                                                  nodal_values_on_parent )
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this  
  real(rp)                        , intent(in)    :: nodal_values_on_children(:,:)
  real(rp)                        , intent(inout) :: nodal_values_on_parent(:)
  massert(.false.,'Note: you are calling project_nodal_values_on_subcell on a type extension of reference_fe_t where it is not implemented.')
end subroutine lagrangian_reference_fe_project_nodal_values_on_cell
!**************************************************************************************************
! Auxiliary procedures called by the child-classes that are not bound to the attributes
!**************************************************************************************************

!=================================================================================================
! BNM(A,B)=A!/((A-B)!B!) computes the binomial coefficient of (A,B), A>B
integer (ip) function get_binomial_coefficient(a,b)
  implicit none
  integer(ip), intent(in)    :: a,b
  if (a >= b) then
     get_binomial_coefficient = int(get_factorial(a)/(get_factorial(b)*get_factorial(a-b)))
  else
     write(*,*) 'ERROR: no binomial coef for b > a'
     check(.false.)
  end if
end function get_binomial_coefficient

!==================================================================================================
! FC(i)=i! computes the factorial of i
integer(ip) function get_factorial(i)
  implicit none
  integer(ip), intent(in)    :: i
  integer(ip) :: k
  get_factorial = 1
  do k=2,i
     get_factorial = get_factorial*k
  end do
end function get_factorial

!==================================================================================================
subroutine store_symmetric_matrix_as_vector(xmatr,vecto,ndime,ntens)
  !-----------------------------------------------------------------------
  !                                      
  ! This routine stores a symmetric matrix XMATR into a vector VECTO
  !
  !-----------------------------------------------------------------------
  implicit none
  real(rp)   , intent(in)    :: xmatr(ndime,ndime)
  real(rp)   , intent(inout) :: vecto(ntens)
  integer(ip), intent(in)    :: ndime,ntens

  if(ndime.eq.2) then
     vecto(1)=xmatr(1,1)
     vecto(3)=xmatr(1,2)
     vecto(2)=xmatr(2,2)
  else
     vecto(1)=xmatr(1,1)
     vecto(4)=xmatr(1,2)
     vecto(2)=xmatr(2,2)
     vecto(5)=xmatr(1,3)
     vecto(6)=xmatr(2,3)
     vecto(3)=xmatr(3,3)
  end if

end subroutine store_symmetric_matrix_as_vector

subroutine lagrangian_reference_fe_fill_scalar (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout)    :: this 
  type(node_iterator_t) :: node_iterator
  type(facet_iterator_t) :: facet_iterator
  type(list_iterator_t) :: list_iterator
  integer(ip) :: topology, i, n_face_dim, node, children,num_n_faces, ones_dim(SPACE_DIM)

  call this%fill_topology()
  
  num_n_faces = this%num_n_faces+1
  
  call this%node_array%create( this%polytope, this%order_vector ) 
  ! Number nodes
  this%num_shape_functions = this%node_array%get_num_nodes()
  ! own_dofs_nodes_n-face  
  call this%own_dofs_n_face%create( num_n_faces )
  do i = 1,num_n_faces
     node_iterator = this%node_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .false. )
     do while (.not. node_iterator%has_finished() )
        call this%own_dofs_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%own_dofs_n_face%calculate_header()
  call this%own_dofs_n_face%allocate_list_from_pointer()
  list_iterator = this%own_dofs_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = this%node_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .false. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! nodes_n-face
  call this%dofs_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     node_iterator = this%node_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%dofs_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%dofs_n_face%calculate_header()
  call this%dofs_n_face%allocate_list_from_pointer()  
  list_iterator = this%dofs_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = this%node_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do

  if ( this%conformity .and. this%continuity ) then
  else
     call this%own_dofs_n_face%create(n=num_n_faces )
     call this%own_dofs_n_face%sum_to_pointer_index( this%own_dofs_n_face%get_num_pointers(), this%num_shape_functions)
     call this%own_dofs_n_face%calculate_header()
     call this%own_dofs_n_face%allocate_list_from_pointer()
     list_iterator = this%own_dofs_n_face%create_iterator()
     i=1
     do while(.not. list_iterator%is_upper_bound())
        call list_iterator%set_current(i)
        call list_iterator%next()
        i = i + 1 
     enddo
  end if
end subroutine lagrangian_reference_fe_fill_scalar

subroutine lagrangian_reference_fe_fill_topology (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout)    :: this 
  type(node_iterator_t) :: node_iterator
  type(facet_iterator_t) :: facet_iterator
  type(list_iterator_t) :: list_iterator
  integer(ip) :: topology, i, n_face_dim, node, children,num_n_faces, ones_dim(SPACE_DIM)

  ! Change topology definition to these numbers from the very beginning (not parameter, dim independent)
  if ( this%topology == topology_hex) then
     topology = 2**this%num_dims-1
  elseif ( this%topology == topology_tet ) then
     topology = 0
  end if
  call this%polytope%create( this%num_dims, topology )  
  num_n_faces = this%polytope%get_num_n_faces()
  ! Number n-faces ( I don't like it, not volume included...)
  this%num_n_faces = num_n_faces-1

  ! num_n-faces_dim
  this%ptr_n_faces_x_dim = 0
  this%ptr_n_faces_x_dim(1) = 1
  do i = 1,num_n_faces
     n_face_dim = this%polytope%get_n_face_dim(i)
     this%ptr_n_faces_x_dim( n_face_dim+2 ) = this%ptr_n_faces_x_dim( n_face_dim+2 ) + 1
  end do
  do i = 1,this%num_dims+1
     this%ptr_n_faces_x_dim(i+1) = this%ptr_n_faces_x_dim(i+1) + this%ptr_n_faces_x_dim(i)
  end do
 
  ! vertices_n-face
  call this%vertices_n_face%create(num_n_faces)
  ones_dim = 1
  call this%vertex_array%create( this%polytope, order = ones_dim )
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%vertices_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  
  call this%vertices_n_face%calculate_header()
  call this%vertices_n_face%allocate_list_from_pointer()
  list_iterator = this%vertices_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  call this%facets_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        call this%facets_n_face%sum_to_pointer_index(i,1)
        call facet_iterator%next()
     end do
  end do
  call this%facets_n_face%calculate_header()
  call this%facets_n_face%allocate_list_from_pointer()
  list_iterator = this%facets_n_face%create_iterator()
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        children = facet_iterator%current()
        call list_iterator%set_current(children)
        call facet_iterator%next()
        call list_iterator%next()
     end do
  end do

  ! orientation
  call this%orientation%create(num_n_faces)
  do i = 1,num_n_faces
     if ( compute_n_face_dim( this%polytope%get_n_face(i), this%num_dims ) == this%num_dims-1 ) then
        this%orientation%a(i) = facet_orientation( this%polytope%get_n_face(i), this%num_dims )
     end if
  end do
end subroutine lagrangian_reference_fe_fill_topology

!=================================================================================================
function get_quadratures_from_hex(quadrature)
  implicit none
  type(quadrature_t), intent(in) :: quadrature
  logical :: get_quadratures_from_hex
  
  get_quadratures_from_hex = .true.
  if ((quadrature%num_dims.eq.2).and.(quadrature%num_quadrature_points.lt.29)) then
     get_quadratures_from_hex = .false.
  elseif ((quadrature%num_dims.eq.3).and.(quadrature%num_quadrature_points.lt.12)) then
     get_quadratures_from_hex = .false.
  end if
end function

!==================================================================================================
subroutine p_lagrangian_reference_fe_free( this )
  implicit none
  class(p_lagrangian_reference_fe_t), intent(inout) :: this
  if (associated ( this%p )) then
     call this%p%free()
     deallocate ( this%p )
  end if
end subroutine p_lagrangian_reference_fe_free
