! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************
!==================================================================================================
subroutine raviart_thomas_create_interpolation ( this, quadrature, & 
     &                                           interpolation, compute_hessian )
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  logical               , optional, intent(in)    :: compute_hessian

  integer(ip) :: ntens, i

  ntens = 0
  do i = 1, this%number_dimensions
     ntens = ntens + i
  end do

  call interpolation%create( this%number_dimensions, this%number_shape_functions, &
       quadrature%number_quadrature_points, ntens, compute_hessian )

  call this%fill_interpolation( quadrature, interpolation )

end subroutine raviart_thomas_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'local_face_id' of the element or
! in all the faces of the element.
subroutine raviart_thomas_create_face_interpolation( this, local_face_id, local_quadrature, face_interpolation)
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  integer(ip)                     , intent(in)    :: local_face_id
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: face_interpolation

  ! Allocate the arrays of the interpolation
  call face_interpolation%create(this%number_dimensions, &
                                 this%number_shape_functions, &
                                 local_quadrature%number_quadrature_points, &
                                 0 )

  ! Fill the values of the shape functions
  call this%fill_face_interpolation(local_quadrature, &
                                    local_face_id, &
                                    face_interpolation)

end subroutine raviart_thomas_create_face_interpolation

!==================================================================================================
subroutine raviart_thomas_create_nodal_quadrature (this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(inout) :: this
  ! Create nodal quadrature
  call this%nodal_quadrature%create( this%number_dimensions, this%number_shape_functions )
  ! Fill nodal quadrature
  call this%fill_nodal_quadrature ( this%nodal_quadrature )  
end subroutine raviart_thomas_create_nodal_quadrature

!==================================================================================================
subroutine raviart_thomas_fill_nodal_quadrature ( this, quadrature ) 
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(inout) :: quadrature
  type(node_iterator_t) :: node_iterator
  integer(ip) :: i,j,init,finish

  do i=1,this%number_dimensions
     init = 1
     finish = 0
     do j=1,this%number_dimensions
        finish = finish + this%node_array_vector(j)%number_nodes        
        quadrature%coordinates(i,init:finish) = (this%node_array_vector(j)%coordinates(i,:)*(2.0_rp/this%node_array_vector(j)%order(i))-1.0_rp)
        init = init + this%node_array_vector(j)%number_nodes
     end do
  end do
  quadrature%weight = 1.0_rp

end subroutine raviart_thomas_fill_nodal_quadrature

!==================================================================================================
subroutine raviart_thomas_create ( this, topology, number_dimensions, order, field_type, & 
     &  continuity, enable_face_integration )
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(inout) :: this
  character(*)                    , intent(in)    :: topology
  integer(ip)                     , intent(in)    :: number_dimensions
  integer(ip)                     , intent(in)    :: order
  character(*)                    , intent(in)    :: field_type
  logical                         , intent(in)    :: continuity
  logical              , optional , intent(in)    :: enable_face_integration

  assert ( order >= 0 )

  call this%free()
  call this%set_common_data(number_dimensions,order,field_type,continuity,enable_face_integration)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_raviart_thomas )
  call this%fill()
  call this%create_nodal_quadrature()
  if ( this%continuity ) then
    call this%change_basis()
  end if  

end subroutine raviart_thomas_create

!==================================================================================================
subroutine raviart_thomas_free ( this )
  implicit none 
  class(raviart_thomas_reference_fe_t), intent(inout) :: this
  integer(ip) :: i
  
  ! Free member variables of raviart_thomas_reference_fe_t
  if ( allocated(this%change_basis_matrix) ) &
     call memfree ( this%change_basis_matrix, __FILE__, __LINE__ )     
     
  this%basis_changed = .false. 
  do i=1, size(this%node_array_vector)
    call this%node_array_vector(i)%free()
  end do
  
  ! Free member variables of lagrangian_reference_fe_t
  ! (and those of its ancestors)
  call lagrangian_reference_fe_free ( this )  
end subroutine raviart_thomas_free

!==================================================================================================
subroutine raviart_thomas_fill (this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(inout) :: this
  integer(ip) :: c, i, j, dimension, number_interior_nodes, number_interior_nodes_scalar
  integer(ip) :: column, inode, idime, inode_scalar, num_columns
  ! Here we put a k+1,k,k order_vector, which is the one for the x-component.
  ! In fill_vector, we use order_vector (and other arrays) using a permutation 
  this%order_vector = this%order
  this%order_vector(1) = this%order+1
  call this%fill_vector()
  
  call memalloc( this%number_shape_functions, 2, this%node_component_array, __FILE__, __LINE__ )
  
  call memalloc( this%node_array_vector(1)%number_nodes,     & 
       &         this%number_field_components, & 
       &         this%node_array_component,    & 
       &         __FILE__, __LINE__ )

  c = 1
  do i = 1, this%number_field_components
    assert(this%node_array_vector(i)%number_nodes == this%node_array_vector(1)%number_nodes)
    do j = 1, this%node_array_vector(i)%number_nodes
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do
  
end subroutine raviart_thomas_fill


subroutine raviart_thomas_fill_vector (this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(inout)    :: this 
  type(node_iterator_t) :: node_iterator
  type(n_face_iterator_t) :: facet_iterator
  type(list_iterator_t) :: list_iterator
  integer(ip) :: topology, i, n_face_dim, node, children,num_n_faces, ones_dim(SPACE_DIM), idime, perm(SPACE_DIM), offset(SPACE_DIM+1)

  ! Change topology definition to these numbers from the very beginning (not parameter, dim independent)
  if ( this%topology == topology_hex) then
     topology = 2**this%number_dimensions-1
  elseif ( this%topology == topology_tet ) then
     topology = 0
  end if

  call this%polytope%create( this%number_dimensions, topology )  

  this%number_shape_functions = 0
  offset(1) = 0
  do idime = 1,this%number_dimensions
     perm = [ (i, i=1,SPACE_DIM) ]
     perm(idime) = 1
     perm(1) = idime
     call this%node_array_vector(idime)%create( this%polytope, this%order_vector(perm) ) 
     ! Number nodes
     this%number_shape_functions = this%number_shape_functions + this%node_array_vector(idime)%get_number_nodes()
     offset(idime+1) = offset(idime) + this%node_array_vector(idime)%get_number_nodes()
  end do

  num_n_faces = this%polytope%get_number_n_faces()
  ! Number n-faces ( I don't like it, not volume included...)
  this%number_n_faces = num_n_faces-1
  ! number_n-faces_dimension
  this%number_n_faces_per_dimension = 0
  this%number_n_faces_per_dimension(1) = 1
  do i = 1,num_n_faces
     n_face_dim = this%polytope%get_n_face_dimension(i)
     this%number_n_faces_per_dimension( n_face_dim+2 ) = this%number_n_faces_per_dimension( n_face_dim+2 ) + 1
  end do
  do i = 1,this%number_dimensions+1
     this%number_n_faces_per_dimension(i+1) = this%number_n_faces_per_dimension(i+1) + this%number_n_faces_per_dimension(i)
  end do

  ! interior_nodes_n-face  
  call this%interior_nodes_n_face%create( num_n_faces )
  do i = 1,num_n_faces
     do idime = 1, this%number_dimensions
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .false. )
        do while (.not. node_iterator%has_finished() )
           call this%interior_nodes_n_face%sum_to_pointer_index(i,1)
           call node_iterator%next()
        end do
     end do
  end do
  call this%interior_nodes_n_face%calculate_header()
  call this%interior_nodes_n_face%allocate_list_from_pointer()
  list_iterator = this%interior_nodes_n_face%create_iterator()
  do i = 1,num_n_faces
     do idime = 1, this%number_dimensions
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .false. )
        do while (.not. node_iterator%has_finished() )
           node = node_iterator%current() + offset(idime)
           call list_iterator%set_current(node)
           call node_iterator%next()
           call list_iterator%next()
        end do
     end do
  end do
  ! nodes_n-face
  call this%nodes_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     do idime = 1,this%number_dimensions
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
        do while (.not. node_iterator%has_finished() )
           call this%nodes_n_face%sum_to_pointer_index(i,1)
           call node_iterator%next()
        end do
     end do
  end do
  call this%nodes_n_face%calculate_header()
  call this%nodes_n_face%allocate_list_from_pointer()  
  list_iterator = this%nodes_n_face%create_iterator()
  do i = 1,num_n_faces
     do idime = 1,this%number_dimensions
        node_iterator = this%node_array_vector(idime)%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
        do while (.not. node_iterator%has_finished() )
           node = node_iterator%current() + offset(idime)
           call list_iterator%set_current(node)
           call node_iterator%next()
           call list_iterator%next()
        end do
     end do
  end do
  ! vertices_n-face
  call this%vertices_n_face%create(num_n_faces)
  ones_dim = 1
  call this%vertex_array%create( this%polytope, order = ones_dim )
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%vertices_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%vertices_n_face%calculate_header()
  call this%vertices_n_face%allocate_list_from_pointer()
  list_iterator = this%vertices_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = this%vertex_array%create_node_iterator( this%polytope%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! n-faces_n-face (NEW DEFINITION; now only n_faces of inferior dimension
  call this%n_faces_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        call this%n_faces_n_face%sum_to_pointer_index(i,1)
        call facet_iterator%next()
     end do
  end do
  call this%n_faces_n_face%calculate_header()
  call this%n_faces_n_face%allocate_list_from_pointer()
  list_iterator = this%n_faces_n_face%create_iterator()
  do i = 1,num_n_faces
     facet_iterator = this%polytope%create_facet_iterator( this%polytope%get_n_face(i) )
     do while (.not. facet_iterator%has_finished() )
        children = facet_iterator%current()
        call list_iterator%set_current(children)
        call facet_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! orientation
  call this%orientation%create(num_n_faces)
  do i = 1,num_n_faces
     if ( n_face_dimension( this%polytope%get_n_face(i), this%number_dimensions ) == this%number_dimensions-1 ) then
        this%orientation%a(i) = facet_orientation( this%polytope%get_n_face(i), this%number_dimensions )
     end if
  end do
  ! own_nodes_n-face and face_integration_coupling_nodes_n-face
  if ( this%continuity ) then
     this%own_nodes_n_faces = this%interior_nodes_n_face
     ! Create a void face_integration_coupling_nodes_face type(list_t)
     call this%face_integration_coupling_nodes_facet%create(n=num_n_faces )
     call this%face_integration_coupling_nodes_facet%calculate_header()
     call this%face_integration_coupling_nodes_facet%allocate_list_from_pointer()
  else
     call this%own_nodes_n_faces%create(n=num_n_faces )
     call this%own_nodes_n_faces%sum_to_pointer_index( this%own_nodes_n_faces%get_num_pointers(), this%number_shape_functions)
     call this%own_nodes_n_faces%calculate_header()
     call this%own_nodes_n_faces%allocate_list_from_pointer()
     list_iterator = this%own_nodes_n_faces%create_iterator()
     i=1
     do while(.not. list_iterator%is_upper_bound())
        call list_iterator%set_current(i)
        call list_iterator%next()
        i = i + 1 
     enddo
     if ( this%conformity ) then
        ! Create a void face_integration_coupling_nodes_face type(list_t)
        call this%face_integration_coupling_nodes_facet%create(n=num_n_faces)
        call this%face_integration_coupling_nodes_facet%calculate_header()
        call this%face_integration_coupling_nodes_facet%allocate_list_from_pointer()
     else
        this%face_integration_coupling_nodes_facet = this%nodes_n_face
     end if
  end if
end subroutine raviart_thomas_fill_vector

!==================================================================================================
! This subroutine constructs a interpolation of order 1 of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine raviart_thomas_create_face_local_interpolation ( this, quadrature, &
     & interpolation)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation

  write(*,*) 'Raviart-Thomas FEs cannot be used for geometry mapping'
  check(.false.)

end subroutine raviart_thomas_create_face_local_interpolation

!==================================================================================================
subroutine raviart_thomas_get_value_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine raviart_thomas_get_value_scalar

!==================================================================================================
subroutine raviart_thomas_get_value_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )
  call vector_field%init(actual_cell_interpolation%shape_functions(:,ishape,qpoint))
end subroutine raviart_thomas_get_value_vector

!!==================================================================================================
subroutine raviart_thomas_get_gradient_scalar( this, actual_cell_interpolation, & 
     & ishape, qpoint, vector_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  integer(ip) :: idime
  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector-based FE spaces'
  check( .false. )
end subroutine raviart_thomas_get_gradient_scalar

!==================================================================================================
subroutine raviart_thomas_get_gradient_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, tensor_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(tensor_field_t)            , intent(inout) :: tensor_field
  integer(ip) :: i,j 
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )
  do i=1, this%number_dimensions
    do j=1, this%number_dimensions
     call tensor_field%set(i,j,actual_cell_interpolation%shape_derivatives(j,i,ishape,qpoint))
    end do
  end do
  end subroutine raviart_thomas_get_gradient_vector

!==================================================================================================
subroutine raviart_thomas_get_divergence_vector( this, actual_cell_interpolation, & 
     & ishape, qpoint, scalar_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field

  ! Locals 
  integer(ip) :: idime

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )

  scalar_field = 0.0_rp
  do idime = 1, this%number_dimensions
     scalar_field = scalar_field + actual_cell_interpolation%shape_derivatives(idime,idime,ishape,qpoint)
  end do

end subroutine raviart_thomas_get_divergence_vector

!==================================================================================================
subroutine raviart_thomas_get_curl_vector( this, actual_cell_interpolation, &
     & ishape, qpoint, vector_field )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: actual_cell_interpolation 
  integer(ip)                         , intent(in)    :: ishape
  integer(ip)                         , intent(in)    :: qpoint
  type(vector_field_t)                , intent(inout) :: vector_field

  check(.false.)

end subroutine raviart_thomas_get_curl_vector

!==================================================================================================
subroutine raviart_thomas_evaluate_fe_function_scalar( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  real(rp)                        , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, ishape

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for vector field unknowns '
  check( .false. )

end subroutine raviart_thomas_evaluate_fe_function_scalar

!==================================================================================================
subroutine raviart_thomas_evaluate_fe_function_vector( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  type(vector_field_t)            , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, inode, icomp, inode_scalar

  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%number_shape_functions
        call quadrature_points_values(qpoint)%add( & 
             actual_cell_interpolation%shape_functions(:,inode,qpoint)*nodal_values(inode) )
     end do
  end do

end subroutine raviart_thomas_evaluate_fe_function_vector

!==================================================================================================
subroutine raviart_thomas_evaluate_fe_function_tensor( this,                      &
     &  actual_cell_interpolation, &
     &  nodal_values,              &
     &  quadrature_points_values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  type(tensor_field_t)            , intent(inout) :: quadrature_points_values(:)

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine raviart_thomas_evaluate_fe_function_tensor

subroutine raviart_thomas_blending(this,values)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  type(point_t)                       , intent(inout) :: values(:)

  write(*,*) 'Vector Laplacian cannot be used for geometry blending'
  check(.false.)

end subroutine raviart_thomas_blending

subroutine raviart_thomas_get_subelements_connectivity(this, connectivity)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(inout) :: connectivity(:,:)
  write(*,*) 'Vector Laplacian cannot be used for visualization purposes'
end subroutine raviart_thomas_get_subelements_connectivity


!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
subroutine raviart_thomas_apply_femap_to_interpolation(this,map,ref,phy)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(fe_map_t)                  , intent(in)    :: map
  type(interpolation_t)           , intent(in)    :: ref
  type(interpolation_t)           , intent(inout) :: phy
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  integer(ip) :: ndime,nnode,nlocs,ntens
  integer(ip) :: ilocs,inode,idime,jdime,kdime,ldime

  ndime = ref%number_dimensions
  ntens = ref%number_entries_symmetric_tensor
  nlocs = ref%number_quadrature_points
  !nnode = ref%number_shape_functions
  nnode = size(ref%shape_functions,2)
  
  ! Piola map for shape functions
  ! \phi(x_g) = \phi(F(X_g))= 1/det(J) * J \phi(X_g)
  phy%shape_functions=0.0_rp
  do ilocs=1,phy%number_quadrature_points
     do inode=1,this%number_shape_functions
        do idime=1,this%number_dimensions
           do jdime=1,this%number_dimensions
               phy%shape_functions(idime,inode,ilocs) = phy%shape_functions(idime,inode,ilocs) &
                    + map%jacobian(idime,jdime,ilocs)*ref%shape_functions(jdime,inode,ilocs)
           end do
           phy%shape_functions(idime,inode,ilocs) = phy%shape_functions(idime,inode,ilocs) / map%det_jacobian(ilocs)
        end do
     end do
  end do
  
  ! Piola map for shape derivatives
  ! \phi(x_g) = \phi(F(X_g))= 1/det(J) * J grad(phi(X_g)) J^{-1}
  phy%shape_derivatives=0.0_rp
  do ilocs=1,phy%number_quadrature_points
     do inode=1,this%number_shape_functions
        do idime=1,this%number_dimensions
           do jdime=1,this%number_dimensions
              do kdime=1,this%number_dimensions
                 do ldime=1,this%number_dimensions
                    phy%shape_derivatives(jdime,idime,inode,ilocs) = phy%shape_derivatives(jdime,idime,inode,ilocs) &
                       + map%jacobian(idime,kdime,ilocs)*ref%shape_derivatives(ldime,kdime,inode,ilocs)*map%inv_jacobian(jdime,ldime,ilocs)
                 end do
              end do
           phy%shape_derivatives(jdime,idime,inode,ilocs) = phy%shape_derivatives(jdime,idime,inode,ilocs) / map%det_jacobian(ilocs)
        end do
        end do
     end do
  end do
  
  !! @sbadia: put Piola here
  !phy%shape_derivatives=0.0_rp
  !do ilocs=1,phy%number_quadrature_points
  !   do inode=1,this%number_shape_functions
  !      do idime=1,this%number_dimensions
  !         do jdime=1,this%number_dimensions
  !           do kdime=1,this%number_dimensions
  !             phy%shape_derivatives(idime,jdime,inode,ilocs) = phy%shape_derivatives(idime,jdime,inode,ilocs) &
  !                  + map%inv_jacobian(kdime,jdime,ilocs)*ref%shape_derivatives(idime,kdime,inode,ilocs)
  !           end do
  !         end do
  !      end do
  !   end do
  !end do
end subroutine raviart_thomas_apply_femap_to_interpolation

subroutine raviart_thomas_invert_change_basis_matrix(this)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(inout) :: this 
  integer(ip) :: error
  integer(ip), allocatable :: ipiv(:)
  real(rp), allocatable :: inverse_change_basis_matrix(:,:)  
  integer(ip) :: i
  
  assert ( allocated(this%change_basis_matrix) )
  assert ( size(this%change_basis_matrix,1) == this%number_shape_functions )
  assert ( size(this%change_basis_matrix,2) == this%number_shape_functions )
  
  ! Solve linear system with several RHS
  ! Compute LU factorization of this%change_basis_matrix
#ifdef ENABLE_LAPACK
  call memalloc ( this%number_shape_functions, ipiv, __FILE__,__LINE__ )
   
  call memalloc ( this%number_shape_functions, & 
                  this%number_shape_functions, &
                  inverse_change_basis_matrix, &
                   __FILE__,__LINE__ )

  call DGETRF( this%number_shape_functions, & 
               this%number_shape_functions, &
               this%change_basis_matrix, &
               this%number_shape_functions, &
               ipiv, &
               error )
  check ( error == 0 )
  
  inverse_change_basis_matrix = 0.0_rp
  do i=1, this%number_shape_functions
    inverse_change_basis_matrix(i,i) = 1.0_rp
  end do  
 
  call DGETRS( 'N', & 
               this%number_shape_functions, &
               this%number_shape_functions, &
               this%change_basis_matrix, &
               this%number_shape_functions, &
               ipiv, &
               inverse_change_basis_matrix, &
               this%number_shape_functions, &
               error )
  check ( error == 0 )
  
  
 call memmovealloc(inverse_change_basis_matrix, &
                   this%change_basis_matrix, __FILE__, __LINE__ )

  
  call memfree ( ipiv, __FILE__,__LINE__ )
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_LAPACK.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the LAPACK'
  check(.false.)
#endif 
   
end subroutine raviart_thomas_invert_change_basis_matrix


subroutine rt_apply_change_basis_matrix_to_nodal_values ( this, nodal_values_rt, nodal_values_pre_basis )
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  real(rp)                            , intent(in)    :: nodal_values_rt(:)
  real(rp)                            , intent(out)   :: nodal_values_pre_basis(:)

  assert ( size(nodal_values_rt) == size(nodal_values_pre_basis) )
  assert ( size(nodal_values_rt) == this%number_shape_functions )
  
  nodal_values_pre_basis = 0.0_rp
  
#ifdef ENABLE_BLAS
  call DGEMV( 'N', & 
              this%number_shape_functions, &
              this%number_shape_functions, &
              1.0_rp, &
              this%change_basis_matrix, &
              this%number_shape_functions, &
              nodal_values_rt, &
              1, &
              0.0_rp, & 
              nodal_values_pre_basis, & 
              1)
#else
  write (0,*) 'Error: reference_fe.f90 was not compiled with -DENABLE_BLAS.'
  write (0,*) 'Error: You must activate this cpp macro in order to use the BLAS'
  check(.false.)
#endif 
  
end subroutine  rt_apply_change_basis_matrix_to_nodal_values 
  

subroutine rt_apply_change_basis_matrix_to_interpolation(this, interpolation_pre_basis, interpolation)
  implicit none
  class(raviart_thomas_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)               , intent(in)    :: interpolation_pre_basis
  type(interpolation_t)               , intent(inout) :: interpolation
  
  integer(ip)           :: i, j, idime, jdime, qpoint

  ! Initialize both shape functions and derivatives to zero.
  interpolation%shape_functions   = 0.0_rp
  interpolation%shape_derivatives = 0.0_rp
  
  ! Compute shape functions
  do qpoint = 1, interpolation%number_quadrature_points
     do i=1, this%number_shape_functions
        do j=1, this%number_shape_functions
           do idime=1, this%number_dimensions
              interpolation%shape_functions(idime, i, qpoint) = interpolation%shape_functions(idime, i, qpoint) + &
                   this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_functions(idime, j, qpoint)
           end do
        end do
     end do
  end do
  
  ! Compute shape derivatives
  do qpoint = 1, interpolation%number_quadrature_points
     do i=1, this%number_shape_functions
        do j=1, this%number_shape_functions
           do idime=1, this%number_dimensions
              do jdime=1, this%number_dimensions
                 interpolation%shape_derivatives(idime, jdime, i, qpoint) = interpolation%shape_derivatives(idime, jdime, i, qpoint) + &
                      this%change_basis_matrix(j,i) * interpolation_pre_basis%shape_derivatives(idime, jdime, j, qpoint)
              end do
           end do
        end do
     end do
  end do
end subroutine rt_apply_change_basis_matrix_to_interpolation
