! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine unfitted_cell_iterator_create ( this, base_static_triangulation )
  
  implicit none
  class(unfitted_cell_iterator_t)           , intent(inout) :: this
  class(base_static_triangulation_t), target, intent(in)    :: base_static_triangulation

  class(marching_cubes_t), pointer :: marching_cubes

  select type (base_static_triangulation)
  class is (serial_unfitted_triangulation_t)
    marching_cubes => base_static_triangulation%get_marching_cubes()
  class is (par_unfitted_triangulation_t)
    marching_cubes => base_static_triangulation%get_marching_cubes()
  class default
    check(.false.)
  end select

  assert(associated(marching_cubes%triangulation))
  call this%free()
  call this%cell_iterator_t%create(base_static_triangulation)
  this%marching_cubes => marching_cubes

end subroutine unfitted_cell_iterator_create

!========================================================================================
subroutine unfitted_cell_iterator_free ( this )
  implicit none
  class(unfitted_cell_iterator_t), intent(inout) :: this
  call this%cell_iterator_t%free()
  this%marching_cubes => null()
end subroutine unfitted_cell_iterator_free

!========================================================================================
subroutine unfitted_cell_iterator_update_sub_triangulation( this )

  implicit none
  class(unfitted_cell_iterator_t), intent(inout) :: this

  integer(ip) :: num_subnodes, num_nodes, num_intersections, i1, i2, mc_case, num_dim
  integer(ip) :: ipo, idi, subcell, subfacet
  type(point_t), pointer, dimension(:) ::  node_coords, intersec_coords, coordinates
  type(quadrature_t), pointer :: quadrature
  real(rp), pointer :: points_in_quadrature(:,:)
  type(point_t),  pointer :: phys_cell_coords(:)
  type(cell_map_t), pointer :: cell_map
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: subcell_nodes(4)
  integer(ip) :: subfacet_nodes(3)

  assert(this%is_local())

  if ( .not. this%is_cut() ) return

  assert(this%marching_cubes%mc_runtime_init)
  num_subnodes = this%get_num_subnodes()
  num_nodes = this%get_num_nodes()
  num_dim = this%marching_cubes%triangulation%get_num_dims()
  num_intersections = num_subnodes - num_nodes
  assert(num_subnodes > num_nodes)

  ! Recover the sub-points coordinates on the ref space
  coordinates => this%marching_cubes%subnodes_ref_coords
  assert( num_subnodes <= size(coordinates) )
  node_coords => coordinates(1:num_nodes)
  call this%get_coordinates_ref_space( node_coords )
  intersec_coords => coordinates(num_nodes+1:num_subnodes)
  i1 = this%marching_cubes%mc_ptr_to_intersections(this%get_gid())
  i2 = this%marching_cubes%mc_ptr_to_intersections(this%get_gid()+1)-1
  intersec_coords(:) = this%marching_cubes%mc_intersection_points(i1:i2)

  ! Recover connectivities of the sub-cells
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  this%marching_cubes%subcells_nodal_connectivities(:,:) = 0
  do subcell=1,this%get_num_subcells()
    this%marching_cubes%subcells_nodal_connectivities(:,subcell) = &
    this%marching_cubes%mc_table_subcell_node_ids_x_case(:,subcell,mc_case)
  end do

  ! Recover connectivities of the sub-faces
  this%marching_cubes%subfacets_nodal_connectivities(:,:) = 0
  do subfacet=1,this%get_num_subfacets()
    this%marching_cubes%subfacets_nodal_connectivities(:,subfacet) = &
    this%marching_cubes%mc_table_subfacet_node_ids_x_case(:,subfacet,mc_case)
  end do

  !Fix inverted sub-cells and sub-faces (only in 3D)
  if (this%marching_cubes%triangulation%get_num_dims()==3) then

    ! Search for inverted sub-cells and reorient them
    this%marching_cubes%subcell_has_been_reoriented(:)=.false.
    do subcell=1,this%get_num_subcells()
      if (this%subcell_has_been_reoriented(subcell)) then
        this%marching_cubes%subcell_has_been_reoriented(subcell)=.true.
        subcell_nodes(:) = this%marching_cubes%subcells_nodal_connectivities(:,subcell)
        this%marching_cubes%subcells_nodal_connectivities(:,subcell) = subcell_nodes([1,3,2,4])
      end if
    end do

    ! Find sub-faces belonging to inverted sub-cells and reorient them
    do subfacet=1,this%get_num_subfacets()
      if (this%subfacet_touches_interior_reoriented_subcell(subfacet)) then
        subfacet_nodes(:) = this%marching_cubes%subfacets_nodal_connectivities(:,subfacet)
        this%marching_cubes%subfacets_nodal_connectivities(:,subfacet) = subfacet_nodes([1,3,2])
      end if
    end do

  end if

  ! Update the quadrature
  quadrature => this%marching_cubes%subnodes_nodal_quadratures(mc_case)
  assert(num_dim == quadrature%get_num_dims())
  assert(num_subnodes == quadrature%get_num_quadrature_points())
  points_in_quadrature => quadrature%get_coordinates()
  do ipo = 1, num_subnodes
    do idi = 1, num_dim
      points_in_quadrature(idi,ipo) = coordinates(ipo)%get(idi)
    end do
  end do

  ! Prepare the fe map
  cell_map => this%marching_cubes%subnodes_cell_maps(mc_case)
  reference_fe_geo => this%get_reference_fe_geo()
  call cell_map%update_interpolation( quadrature, reference_fe_geo )
  phys_cell_coords => cell_map%get_coordinates()
  call this%get_coordinates(phys_cell_coords)
  call cell_map%compute_quadrature_points_coordinates()

  ! At this point we can extract the physical coordinates of the sub-nodes from the cell_maps

end subroutine unfitted_cell_iterator_update_sub_triangulation

!========================================================================================
function unfitted_cell_iterator_get_mc_case( this ) result ( mc_case )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip) :: mc_case
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
end function unfitted_cell_iterator_get_mc_case

!========================================================================================
function unfitted_cell_iterator_get_num_subcells( this ) result ( num_subcells )
  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip) :: num_subcells
  integer(ip) :: mc_case
  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  mc_case           = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_subcells      = this%marching_cubes%mc_table_num_subcells_x_case(mc_case)
end function unfitted_cell_iterator_get_num_subcells

!========================================================================================
function unfitted_cell_iterator_get_num_subcell_nodes( this ) result ( num_nodes_subcell )
  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip) :: num_nodes_subcell
  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  num_nodes_subcell = 0
  if (this%get_num_subcells() .ne. 0) num_nodes_subcell = this%marching_cubes%mc_table_num_nodes_subcell
end function unfitted_cell_iterator_get_num_subcell_nodes

!========================================================================================
subroutine unfitted_cell_iterator_get_phys_coords_of_subcell( this, subcell, points)

  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subcell
  type(point_t),                   intent(inout) :: points(:)

  integer(ip) :: num_nodes_subcell, mc_case
  type(point_t), pointer :: subnodes_phys_coords(:)
  type(cell_map_t), pointer :: cell_map
  integer(ip), pointer ::  subcell_node_ids(:)

  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  num_nodes_subcell = this%get_num_subcell_nodes()
  assert( size(points) == num_nodes_subcell)
  assert(this%is_cut())
  assert( (1_ip <= subcell) .and. (subcell <= this%get_num_subcells())  )

  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  cell_map => this%marching_cubes%subnodes_cell_maps(mc_case)
  subnodes_phys_coords => cell_map%get_quadrature_points_coordinates()
  subcell_node_ids =>  this%marching_cubes%subcells_nodal_connectivities(:,subcell)
  points(:) = subnodes_phys_coords(subcell_node_ids(:))

end subroutine unfitted_cell_iterator_get_phys_coords_of_subcell

!========================================================================================
subroutine unfitted_cell_iterator_get_ref_coords_of_subcell( this, subcell, points)

  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subcell
  type(point_t),                   intent(inout) :: points(:)

  integer(ip) :: num_nodes_subcell
  type(point_t), pointer :: subnodes_ref_coords(:)
  integer(ip), pointer ::  subcell_node_ids(:)

  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  num_nodes_subcell = this%get_num_subcell_nodes()
  assert( size(points) == num_nodes_subcell)
  assert(this%is_cut())
  assert( (1_ip <= subcell) .and. (subcell <= this%get_num_subcells())  )

  subnodes_ref_coords => this%marching_cubes%subnodes_ref_coords
  subcell_node_ids =>  this%marching_cubes%subcells_nodal_connectivities(:,subcell)
  points(:) = subnodes_ref_coords(subcell_node_ids(:))

end subroutine unfitted_cell_iterator_get_ref_coords_of_subcell

!========================================================================================
function unfitted_cell_iterator_get_num_subfacets( this ) result ( num_subfacets )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip) :: num_subfacets
  integer(ip) :: mc_case
  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  mc_case           = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_subfacets      = this%marching_cubes%mc_table_num_subfacets_x_case(mc_case)
end function unfitted_cell_iterator_get_num_subfacets

!========================================================================================
function unfitted_cell_iterator_get_num_subfacet_nodes( this ) result ( num_nodes_subfacet )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip) :: num_nodes_subfacet
  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  num_nodes_subfacet = 0
  if (this%get_num_subfacets() .ne. 0) num_nodes_subfacet = this%marching_cubes%mc_table_num_nodes_subfacet
end function unfitted_cell_iterator_get_num_subfacet_nodes

!========================================================================================
subroutine unfitted_cell_iterator_get_phys_coords_of_subfacet( this, subfacet, points )

  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subfacet
  type(point_t),                   intent(inout) :: points(:)

  integer(ip) :: num_nodes_subfacet, mc_case
  type(point_t), pointer :: subnodes_phys_coords(:)
  type(cell_map_t), pointer :: cell_map
  integer(ip), pointer ::  subfacet_node_ids(:)

  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  num_nodes_subfacet = this%get_num_subfacet_nodes()
  assert( size(points) == num_nodes_subfacet)
  assert(this%is_cut())
  assert( (1_ip <= subfacet) .and. (subfacet <= this%get_num_subfacets())  )

  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  cell_map => this%marching_cubes%subnodes_cell_maps(mc_case)
  subnodes_phys_coords => cell_map%get_quadrature_points_coordinates()
  subfacet_node_ids =>  this%marching_cubes%subfacets_nodal_connectivities(:,subfacet)
  points(:) = subnodes_phys_coords(subfacet_node_ids(:))

end subroutine unfitted_cell_iterator_get_phys_coords_of_subfacet

!========================================================================================
subroutine unfitted_cell_iterator_get_ref_coords_of_subfacet( this, subfacet, points )

  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subfacet
  type(point_t),                   intent(inout) :: points(:)

  integer(ip) :: num_nodes_subfacet, mc_case
  type(point_t), pointer :: subnodes_ref_coords(:)
  integer(ip), pointer ::  subfacet_node_ids(:)

  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  num_nodes_subfacet = this%get_num_subfacet_nodes()
  assert( size(points) == num_nodes_subfacet)
  assert(this%is_cut())
  assert( (1_ip <= subfacet) .and. (subfacet <= this%get_num_subfacets())  )

  subnodes_ref_coords => this%marching_cubes%subnodes_ref_coords
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  subfacet_node_ids =>  this%marching_cubes%subfacets_nodal_connectivities(:,subfacet)
  points(:) = subnodes_ref_coords(subfacet_node_ids(:))

end subroutine unfitted_cell_iterator_get_ref_coords_of_subfacet

!========================================================================================
function unfitted_cell_iterator_is_cut( this ) result ( is_cut )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  logical :: is_cut
  integer(ip) :: mc_case, num_mc_cases
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_mc_cases = this%marching_cubes%mc_table_num_cases
  is_cut = (1_ip < mc_case) .and. ( mc_case < num_mc_cases)
end function unfitted_cell_iterator_is_cut

!========================================================================================
function unfitted_cell_iterator_is_interior( this ) result ( is_interior )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  logical :: is_interior
  integer(ip) :: mc_case, num_mc_cases
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_mc_cases = this%marching_cubes%mc_table_num_cases
  is_interior = ( mc_case == num_mc_cases )
end function unfitted_cell_iterator_is_interior

!========================================================================================
function unfitted_cell_iterator_is_exterior( this ) result ( is_exterior )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  logical :: is_exterior
  integer(ip) :: mc_case
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  is_exterior = ( mc_case == 1_ip )
end function unfitted_cell_iterator_is_exterior

!========================================================================================
function unfitted_cell_iterator_is_interior_subcell( this, subcell ) result ( is_in )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  integer(ip), intent(in) :: subcell
  logical :: is_in
  integer(ip) :: mc_case, num_subcells, pos
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  assert(this%is_cut())
  num_subcells = this%get_num_subcells()
  assert( ( 1_ip <= subcell) .and. subcell <= num_subcells )
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  pos = this%marching_cubes%mc_table_inout_subcells_x_case(subcell, mc_case)
  is_in = ( pos == -1_ip )
end function unfitted_cell_iterator_is_interior_subcell

!========================================================================================
function unfitted_cell_iterator_is_exterior_subcell( this, subcell ) result ( is_out )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  integer(ip), intent(in) :: subcell
  logical :: is_out
  integer(ip) :: mc_case, num_subcells, pos
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  assert(this%is_cut())
  num_subcells = this%get_num_subcells()
  assert( ( 1_ip <= subcell) .and. subcell <= num_subcells )
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  pos = this%marching_cubes%mc_table_inout_subcells_x_case(subcell, mc_case)
  is_out = ( pos == 1_ip )
end function unfitted_cell_iterator_is_exterior_subcell

!========================================================================================
function unfitted_cell_iterator_get_num_subnodes( this ) result (num_subnodes)
  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip) :: num_subnodes
  integer(ip) :: mc_case
  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  mc_case      = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_subnodes = this%get_num_nodes() + this%marching_cubes%mc_table_num_cut_edges_x_case(mc_case)
end function unfitted_cell_iterator_get_num_subnodes

!========================================================================================
function unfitted_cell_iterator_subcell_has_been_reoriented(this,subcell) result (is_inverted)

  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip), intent(in) :: subcell
  logical :: is_inverted

  type(point_t) :: Xe(4)
  type(vector_field_t) :: u,v,w
  integer(ip), pointer :: Te(:)
  real(rp) :: vol

  ! This routine is only needed (and implemented) when the sub-cell is a tetrahedron
  ! Check it
  assert(1<=subcell .and. subcell <= this%get_num_subcells())
  assert(this%get_num_subcell_nodes()==4)
  assert(this%marching_cubes%triangulation%get_num_dims() == 3)

  ! Get connectivities and coordinates
  ! We assume that update_triangulation was called for this cell
  Te => this%marching_cubes%subcells_nodal_connectivities(:,subcell)
  Xe(:) = this%marching_cubes%subnodes_ref_coords(Te)

  ! Compute (signed) volume
  u = Xe(2) - Xe(1)
  v = Xe(3) - Xe(1)
  w = Xe(4) - Xe(1)
  vol = w*cross_product(u,v)

  ! Check if inverted
  is_inverted = vol < 0.0_rp

end function unfitted_cell_iterator_subcell_has_been_reoriented

!========================================================================================
function unfitted_cell_iterator_subfacet_touches_reoriented_subcell(this,subfacet) result (is_neighbour)

  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip), intent(in) :: subfacet
  logical :: is_neighbour

  integer(ip), pointer :: Tf(:), Te(:)
  integer(ip) :: subcell
  logical :: has_the_subfacet, has_been_reoriented, is_interior

  ! This routine is only needed (and implemented) when the sub-cell is a tetrahedron
  ! Check it
  assert(1<=subfacet .and. subfacet <= this%get_num_subfacets())
  assert(this%get_num_subcell_nodes()==4)
  assert(this%marching_cubes%triangulation%get_num_dims() == 3)

  ! Initialize result
  is_neighbour= .false.

  ! Get connectivities of the sub-face
  Tf => this%marching_cubes%subfacets_nodal_connectivities(:,subfacet)

  ! Do a loop in sub-cell
  do subcell=1,this%get_num_subcells()

    ! Find the sub-cells that have the three nodes of the face
    Te => this%marching_cubes%subcells_nodal_connectivities(:,subcell)
    has_the_subfacet = (any(Te == Tf(1)) .and. any(Te == Tf(2)) .and. any(Te == Tf(3)))

    ! Check if it has been reoriented
    has_been_reoriented = this%marching_cubes%subcell_has_been_reoriented(subcell)

    !Check if it is interior
    is_interior = this%is_interior_subcell(subcell)

    ! If the three conditions are met, return true, so that the sub-face will be reoriented
    is_neighbour = has_the_subfacet .and. has_been_reoriented .and. is_interior

  end do

end function unfitted_cell_iterator_subfacet_touches_reoriented_subcell




