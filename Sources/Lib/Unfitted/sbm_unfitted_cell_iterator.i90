! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine unfitted_cell_iterator_create ( this, triangulation )
  
  implicit none
  class(unfitted_cell_iterator_t)           , intent(inout) :: this
  class(triangulation_t)            , target, intent(in)    :: triangulation

  class(marching_cubes_t), pointer :: marching_cubes
  call this%free()
  select type (triangulation)
  class is (serial_unfitted_triangulation_t)
    marching_cubes => triangulation%get_marching_cubes()
    call this%bst_cell_iterator_t%create(triangulation)
  class is (unfitted_p4est_serial_triangulation_t)
    marching_cubes => triangulation%get_marching_cubes()
    call cell_iterator_create(this,triangulation)
  class is (par_unfitted_triangulation_t)
    marching_cubes => triangulation%get_marching_cubes()
    call this%bst_cell_iterator_t%create(triangulation)
  class default
    check(.false.)
  end select
  assert(associated(marching_cubes%triangulation))
  this%marching_cubes => marching_cubes
end subroutine unfitted_cell_iterator_create

!========================================================================================
subroutine unfitted_cell_iterator_free ( this )
  implicit none
  class(unfitted_cell_iterator_t), intent(inout) :: this
  call this%bst_cell_iterator_t%free()
  this%marching_cubes => null()
end subroutine unfitted_cell_iterator_free

!========================================================================================
subroutine unfitted_cell_iterator_update_sub_triangulation( this )
  implicit none
  class(unfitted_cell_iterator_t), intent(inout) :: this
  assert(this%is_local())
  call this%marching_cubes%update_sub_triangulation( this )
end subroutine unfitted_cell_iterator_update_sub_triangulation

!========================================================================================
function unfitted_cell_iterator_get_num_subcells( this ) result ( num_subcells )
  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip) :: num_subcells
  assert(this%is_local())
  num_subcells = this%marching_cubes%get_num_subcells( this )
end function unfitted_cell_iterator_get_num_subcells

!========================================================================================
function unfitted_cell_iterator_get_num_subcell_nodes( this ) result ( num_nodes_subcell )
  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip) :: num_nodes_subcell
  assert(this%is_local())
  num_nodes_subcell = this%marching_cubes%get_num_subcell_nodes( this )
end function unfitted_cell_iterator_get_num_subcell_nodes

!========================================================================================
subroutine unfitted_cell_iterator_get_phys_coords_of_subcell( this, subcell, points)
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subcell
  type(point_t),                   intent(inout) :: points(:)
  assert(this%is_local())
  call this%marching_cubes%get_phys_coords_of_subcell( this, subcell, points )
end subroutine unfitted_cell_iterator_get_phys_coords_of_subcell

!========================================================================================
subroutine unfitted_cell_iterator_get_ref_coords_of_subcell( this, subcell, points)
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subcell
  type(point_t),                   intent(inout) :: points(:)
  assert(this%is_local())
  call this%marching_cubes%get_ref_coords_of_subcell( this, subcell, points)
end subroutine unfitted_cell_iterator_get_ref_coords_of_subcell

!========================================================================================
function unfitted_cell_iterator_get_num_subfacets( this ) result ( num_subfacets )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip) :: num_subfacets
  integer(ip) :: mc_case

  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  assert(this%marching_cubes%mc_cell_info_init)

  if (this%is_cut()) then
    assert(this%marching_cubes%current_cell_gid == this%get_gid())
    num_subfacets = this%marching_cubes%num_subfacets
  else
    num_subfacets = 0
  end if

end function unfitted_cell_iterator_get_num_subfacets

!========================================================================================
function unfitted_cell_iterator_get_num_subfacet_nodes( this ) result ( num_nodes_subfacet )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip) :: num_nodes_subfacet

  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  assert(this%marching_cubes%mc_cell_info_init)

  if (this%is_cut()) then
    num_nodes_subfacet = this%marching_cubes%mc_table_num_nodes_in_sub_facet
  else
    num_nodes_subfacet = 0
  end if

end function unfitted_cell_iterator_get_num_subfacet_nodes

!========================================================================================
subroutine unfitted_cell_iterator_get_phys_coords_of_subfacet( this, subfacet, points )

  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subfacet
  type(point_t),                   intent(inout) :: points(:)

  integer(ip) :: num_nodes_subfacet, mc_case
  type(point_t), pointer :: subnodes_phys_coords(:)
  type(cell_map_t), pointer :: cell_map
  integer(ip), pointer ::  subfacet_node_ids(:)

  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  assert(this%marching_cubes%mc_cell_info_init)
  assert(this%marching_cubes%current_cell_gid == this%get_gid())

  num_nodes_subfacet = this%get_num_subfacet_nodes()
  assert( size(points) == num_nodes_subfacet)
  assert(this%is_cut())
  assert( (1_ip <= subfacet) .and. (subfacet <= this%get_num_subfacets())  )

  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  cell_map => this%marching_cubes%sub_nodes_cell_maps(mc_case)
  subnodes_phys_coords => cell_map%get_quadrature_points_coordinates()
  subfacet_node_ids =>  this%marching_cubes%unfitted_sub_facets_node_ids(:,subfacet)
  points(:) = subnodes_phys_coords(subfacet_node_ids(:))

end subroutine unfitted_cell_iterator_get_phys_coords_of_subfacet

!========================================================================================
subroutine unfitted_cell_iterator_get_ref_coords_of_subfacet( this, subfacet, points )

  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  integer(ip),                     intent(in)    :: subfacet
  type(point_t),                   intent(inout) :: points(:)

  integer(ip) :: num_nodes_subfacet, mc_case
  type(point_t), pointer :: subnodes_ref_coords(:)
  integer(ip), pointer ::  subfacet_node_ids(:)

  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  assert(this%marching_cubes%mc_cell_info_init)
  assert(this%marching_cubes%current_cell_gid == this%get_gid())

  num_nodes_subfacet = this%get_num_subfacet_nodes()
  assert( size(points) == num_nodes_subfacet)
  assert(this%is_cut())
  assert( (1_ip <= subfacet) .and. (subfacet <= this%get_num_subfacets())  )

  subnodes_ref_coords => this%marching_cubes%subnodes_ref_coords
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  subfacet_node_ids =>  this%marching_cubes%unfitted_sub_facets_node_ids(:,subfacet)
  points(:) = subnodes_ref_coords(subfacet_node_ids(:))

end subroutine unfitted_cell_iterator_get_ref_coords_of_subfacet

!========================================================================================
function unfitted_cell_iterator_is_cut( this ) result ( is_cut )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)    :: this
  logical :: is_cut
  integer(ip) :: mc_case, num_mc_cases
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_mc_cases = this%marching_cubes%mc_table_num_cases
  is_cut = (1_ip < mc_case) .and. ( mc_case < num_mc_cases)
end function unfitted_cell_iterator_is_cut

!========================================================================================
function unfitted_cell_iterator_is_interior( this ) result ( is_interior )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  logical :: is_interior
  integer(ip) :: mc_case, num_mc_cases
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_mc_cases = this%marching_cubes%mc_table_num_cases
  is_interior = ( mc_case == num_mc_cases )
end function unfitted_cell_iterator_is_interior

!========================================================================================
function unfitted_cell_iterator_is_exterior( this ) result ( is_exterior )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  logical :: is_exterior
  integer(ip) :: mc_case
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  mc_case = this%marching_cubes%mc_case_x_cell(this%get_gid())
  is_exterior = ( mc_case == 1_ip )
end function unfitted_cell_iterator_is_exterior

!========================================================================================
function unfitted_cell_iterator_is_interior_subcell( this, subcell ) result ( is_in )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  integer(ip), intent(in) :: subcell
  logical :: is_in
  integer(ip) :: num_subcells, pos
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  assert(this%is_cut())
  assert(this%marching_cubes%current_cell_gid == this%get_gid())
  num_subcells = this%marching_cubes%num_subcells
  assert( ( 1_ip <= subcell) .and. subcell <= num_subcells )
  pos = this%marching_cubes%subcells_status(subcell)
  is_in = ( pos == -1_ip )
end function unfitted_cell_iterator_is_interior_subcell

!========================================================================================
function unfitted_cell_iterator_is_exterior_subcell( this, subcell ) result ( is_out )
  implicit none
  class(unfitted_cell_iterator_t), intent(in)  :: this
  integer(ip), intent(in) :: subcell
  logical :: is_out
  integer(ip) :: num_subcells, pos
  assert(this%is_local())
  assert(this%marching_cubes%mc_runtime_init)
  assert(this%is_cut())
  assert(this%marching_cubes%current_cell_gid == this%get_gid())
  num_subcells = this%get_num_subcells()
  assert( ( 1_ip <= subcell) .and. subcell <= num_subcells )
  pos = this%marching_cubes%subcells_status(subcell)
  is_out = ( pos == 1_ip )
end function unfitted_cell_iterator_is_exterior_subcell

!========================================================================================
function unfitted_cell_iterator_get_num_subnodes( this ) result (num_subnodes)
  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip) :: num_subnodes
  integer(ip) :: mc_case
  assert(this%is_local())
  assert(this%marching_cubes%mc_tables_init)
  mc_case      = this%marching_cubes%mc_case_x_cell(this%get_gid())
  num_subnodes = this%get_num_nodes() + this%marching_cubes%mc_table_num_cut_edges_x_case(mc_case)
end function unfitted_cell_iterator_get_num_subnodes

!========================================================================================
function unfitted_cell_iterator_is_inverted_subcell(this,subcell) result (is_inverted)

  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  integer(ip), intent(in) :: subcell
  logical :: is_inverted

  type(point_t) :: Xe(4)
  type(vector_field_t) :: u,v,w
  integer(ip), pointer :: Te(:)
  real(rp) :: vol

  ! This routine is only needed (and implemented) when the sub-cell is a tetrahedron
  ! Check it
  assert(1<=subcell .and. subcell <= this%marching_cubes%num_subcells)
  assert(this%get_num_subcell_nodes()==4)
  assert(this%marching_cubes%triangulation%get_num_dims() == 3)

  ! Get connectivities and coordinates
  ! We assume that update_triangulation was called for this cell
  Te => this%marching_cubes%sub_cells_node_ids(:,subcell)
  Xe(:) = this%marching_cubes%subnodes_ref_coords(Te)

  ! Compute (signed) volume
  u = Xe(2) - Xe(1)
  v = Xe(3) - Xe(1)
  w = Xe(4) - Xe(1)
  vol = w*cross_product(u,v)

  ! Check if inverted
  is_inverted = vol < 0.0_rp

end function unfitted_cell_iterator_is_inverted_subcell

!========================================================================================
function unfitted_cell_iterator_is_valid_submesh(this)

  implicit none
  class(unfitted_cell_iterator_t), intent(in) :: this
  logical :: unfitted_cell_iterator_is_valid_submesh

  integer(ip) :: subcell
  type(point_t) :: Xe(4)
  type(vector_field_t) :: u,v,w
  integer(ip), pointer :: Te(:)
  real(rp) :: vol
  class(reference_fe_t), pointer :: reference_fe_geo
  real(rp), parameter :: volume_reference_fe_hex = 8.0_rp
  real(rp), parameter :: volume_reference_fe_tet = 1.0_rp/6.0_rp
  real(rp), parameter :: tol_volume =  1.0e-13_rp
  ! This routine is only needed (and implemented) when the sub-cell is a tetrahedron
  ! Check it
  assert(this%get_num_subcell_nodes()==4)
  assert(this%marching_cubes%triangulation%get_num_dims() == 3)

  vol = 0.0_rp
  do subcell=1,this%marching_cubes%num_subcells

    ! Get connectivities and coordinates
    ! We assume that update_triangulation was called for this cell
    Te => this%marching_cubes%sub_cells_node_ids(:,subcell)
    Xe(:) = this%marching_cubes%subnodes_ref_coords(Te)

    ! Compute volume
    u = Xe(1) - Xe(4)
    v = Xe(2) - Xe(4)
    w = Xe(3) - Xe(4)
    vol = vol + volume_reference_fe_tet*abs(u*cross_product(v,w))
  end do

  reference_fe_geo => this%get_reference_fe()
  if ( reference_fe_geo%get_topology() == topology_hex ) then
    unfitted_cell_iterator_is_valid_submesh = (abs(vol-volume_reference_fe_hex) < tol_volume )
  else if ( reference_fe_geo%get_topology() == topology_tet ) then
    unfitted_cell_iterator_is_valid_submesh = (abs(vol-volume_reference_fe_tet) < tol_volume )
  end if
end function unfitted_cell_iterator_is_valid_submesh

!========================================================================================
subroutine unfitted_cell_iterator_generate_subcells(this)

  implicit none
  class(unfitted_cell_iterator_t), intent(inout) :: this

#ifdef ENABLE_QHULL

  integer(ip) :: ierror
  real(qh_coordT), allocatable :: points(:,:)
  integer(qh_int), pointer  :: cells(:,:)
  integer(ip) , parameter :: num_dims = 3
  integer(ip) :: num_points
  integer(ip) :: num_cells
  integer(ip) :: ipoin
  integer(ip) :: idime

  assert(this%marching_cubes%triangulation%get_num_dims() == num_dims)
  assert(qh_int == ip)
  assert(qh_coordT == rp)

  ! Convert point coordinates to an intrinsic Fortran array
  num_points = this%get_num_subnodes()
  call memalloc(num_dims,num_points,points,__FILE__,__LINE__)
  do ipoin = 1,num_points
    do idime = 1, num_dims
      points(idime,ipoin) = this%marching_cubes%subnodes_ref_coords(ipoin)%get(idime)
    end do
  end do

  ! Compute number of cells in the Delaunay triangulation
  num_cells = 0
  ierror = delaunay_init_and_compute_f90(num_dims, num_points, points, num_cells)
  check(ierror == 0)
  this%marching_cubes%num_subcells = num_cells
  call this%marching_cubes%reallocate_nsubcells_arrays()
  

  ! Fill in the cells connectivities
  cells => this%marching_cubes%sub_cells_node_ids
  cells(:,:) = 0
  check(num_cells <= size(cells,2))
  ierror = delaunay_fill_cells_f90(num_dims, num_cells, cells)
  check(ierror == 0)

  ! Clean up
  ierror = delaunay_free_f90()
  check(ierror == 0)
  call memfree(points,__FILE__,__LINE__)

#else

  mcheck(.false.,'This subroutine needs ENABLE_QHULL')

#endif

end subroutine unfitted_cell_iterator_generate_subcells

!========================================================================================
subroutine unfitted_cell_iterator_generate_subcells_status(this)

  implicit none
  class(unfitted_cell_iterator_t), intent(inout) :: this

  integer(ip) :: isubcell, inode
  real(rp), pointer :: levelset_nodal_values(:)
  real(rp) :: phi
  integer(ip), parameter :: field_id = 1

  ! By default the sub-cells are outside
  this%marching_cubes%subcells_status(:) = 0_ip
  this%marching_cubes%subcells_status(1:this%marching_cubes%num_subcells) = 1_ip

  ! Recover the values of the levelset function on the subnodes
  this%marching_cubes%level_set_all_nodes(:) = 0.0_rp
  call this%marching_cubes%fe%set_gid(this%get_gid())
  call this%marching_cubes%fe_levelset%gather_nodal_values(this%marching_cubes%fe,field_id,this%marching_cubes%level_set_all_nodes)
  assert(this%marching_cubes%fe_space%get_num_fields()==field_id)

  ! Set as interior the sub-cells that touches an interior point
  do isubcell = 1, this%marching_cubes%num_subcells
    do inode = 1, this%get_num_subcell_nodes()
      phi = this%marching_cubes%level_set_all_nodes(this%marching_cubes%sub_cells_node_ids(inode,isubcell))
      if (phi<0) then
        this%marching_cubes%subcells_status(isubcell) = -1_ip
        exit
      end if
    end do
  end do
  

end subroutine unfitted_cell_iterator_generate_subcells_status

!========================================================================================
subroutine unfitted_cell_iterator_generate_boundary_subfacets(this)

  implicit none
  class(unfitted_cell_iterator_t), intent(inout) :: this

  integer(ip), parameter :: nbef = 4
  integer(ip), parameter :: nbfn = 3
  integer(ip), parameter :: FACETS(nbfn,nbef) = reshape([1,2,3, 1,4,2, 1,3,4, 2,4,3],[nbfn,nbef])
                                                        ![1,3,2, 1,2,4, 2,3,4, 1,4,3]
  integer(ip) :: iscell
  integer(ip) :: isfacet
  integer(ip) :: nsfacet
  integer(ip), pointer :: Te(:)
  integer(ip) :: ineig

  assert(this%marching_cubes%triangulation%get_num_dims() == 3)

  ! Reset the sub-facets nodes ids
  this%marching_cubes%unfitted_sub_facets_node_ids(:,:) = 0

  ! Find the neighbors in the sub-mesh
  this%marching_cubes%subcell_facet_neigs(:,:) = -1
  call find_facets_neighbors_in_mesh(&
    T      =  this%marching_cubes%sub_cells_node_ids,&
    nbel   =  this%marching_cubes%num_subcells,&
    facets =  FACETS,&
    nbef   =  nbef,&
    neigs  =  this%marching_cubes%subcell_facet_neigs)

  nsfacet = 0
  ! Loop in interior sub-cells
  do iscell = 1,this%marching_cubes%num_subcells
    if (this%marching_cubes%subcells_status(iscell)==-1) then
      Te => this%marching_cubes%sub_cells_node_ids(:,iscell)

      ! Loop in interior sub-cells
      do isfacet = 1, nbef
        ineig = this%marching_cubes%subcell_facet_neigs(isfacet,iscell)
        assert(ineig /= -1)

        ! If the neig along this facet is exterior, then take the facets node ids
        if (ineig>0) then
          if (this%marching_cubes%subcells_status(ineig)==1) then
            nsfacet = nsfacet + 1
            ! memrealloc is here since the number of subfacets is determined by delaunay and cannot be known beforehand
            call memrealloc_if_more_space_needed ( &
                 this%marching_cubes%get_max_num_nodes_in_subfacet(), &
                 nsfacet, &
                 this%marching_cubes%unfitted_sub_facets_node_ids, &
                __FILE__, __LINE__ )
            this%marching_cubes%unfitted_sub_facets_node_ids(:,nsfacet) = Te(FACETS(:,isfacet))
          end if
        end if

      end do

    end if
  end do
  this%marching_cubes%num_subfacets = nsfacet

end subroutine unfitted_cell_iterator_generate_boundary_subfacets
