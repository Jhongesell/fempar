! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine suhpafs_create_same_reference_fes_on_all_cells(&
  this, &
  triangulation, &
  reference_fes, &
  conditions )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  class(conditions_t), target       , optional, intent(in)    :: conditions
  mcheck(.false.,'You cannot create an unfitted fe space with the same reference fe on all cells (you need void and non void ref elems)')
end subroutine suhpafs_create_same_reference_fes_on_all_cells

!========================================================================================
subroutine suhpafs_space_create_different_ref_fes_between_cells(&
    this, &
    triangulation,            &
    reference_fes,            &
    set_ids_to_reference_fes, &
    conditions )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t), target       , optional, intent(in)    :: conditions
  class(marching_cubes_t), pointer :: marching_cubes
  call this%free()
  call this%serial_fe_space_t%create(&
    triangulation,reference_fes,set_ids_to_reference_fes,conditions)
  select type(triangulation)
  class is (unfitted_p4est_serial_triangulation_t)
    this%unfitted_triangulation => triangulation
    marching_cubes => triangulation%get_marching_cubes()
    call this%unfitted_integration%create(this,marching_cubes)
  class default
    check(.false.)
  end select
  call this%debug_info%init()
  call this%allocate_and_fill_aggregate_ids()
  call this%compute_aggregate_size()
  call this%check_for_full_neighbors()
end subroutine suhpafs_space_create_different_ref_fes_between_cells

!========================================================================================
subroutine suhpafs_free(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  call this%serial_fe_space_t%free()
  this%unfitted_triangulation => null()
  call this%unfitted_integration%free()
  if (allocated(this%aggregate_ids)) then
    call memfree(this%aggregate_ids,__FILE__,__LINE__)
  end if
  call this%debug_info%free()
end subroutine suhpafs_free

!========================================================================================
subroutine suhpafs_set_use_constraints(this,use_constraints)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  logical, intent(in) :: use_constraints
  this%use_constraints = use_constraints
end subroutine suhpafs_set_use_constraints

!========================================================================================
subroutine suhpafs_create_fe_cell_iterator(this, fe)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(in)    :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(unfitted_fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine suhpafs_create_fe_cell_iterator

!========================================================================================
subroutine suhpafs_count_dofs ( this ) 
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this   


  ! TODO: This code is almost replicated from the father. Surely, there are better ways to do that.

  logical, allocatable :: per_field_proper_vefs_visited(:,:)
  logical, allocatable :: per_field_improper_vefs_visited(:,:)
  integer(ip) :: field_id, vef_lid, ivef, num_own_dofs_on_vef, iblock
  class(fe_cell_iterator_t), allocatable :: fe, coarser_fe, source_fe
  type(fe_vef_iterator_t) :: vef
  integer(ip) :: ielem
  logical :: local_found

  integer(ip) :: num_fields
  integer(ip), allocatable :: num_dofs_x_field(:)
  integer(ip), pointer :: fe_space_type_x_field(:)
  class(triangulation_t), pointer :: triangulation
  type(block_layout_t), pointer :: block_layout

  logical, allocatable :: proper_vef_constrains_full_cell(:,:)
  logical, allocatable :: touched_cell_dofs(:)
  integer(ip) :: icell
  class(reference_fe_t), pointer :: coarser_reference_fe
  type(list_iterator_t) :: coarser_fe_dofs_on_vef_iterator
  integer(ip) :: coarser_fe_ivef
  type(fe_vef_iterator_t) :: coarser_vef


  ! We want to call this subroutine only for aggregation-based FE spaces
  if (.not. this%use_constraints) then
    call this%serial_fe_space_t%count_dofs()
    return
  end if

  ! This is needed since we cannot access to private variables of the father
  triangulation => this%get_triangulation()
  block_layout => this%get_block_layout()
  num_fields = this%get_num_fields()
  call memalloc(num_fields,num_dofs_x_field,__FILE__,__LINE__)
  fe_space_type_x_field => this%get_fe_space_type()

  ! Create iterators
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_vef_iterator(vef)
  call this%create_fe_vef_iterator(coarser_vef)
  call this%create_fe_cell_iterator(coarser_fe)

  ! Mark the vefs owning DOFs that constraint hanging DOFs in full cells
  ! TODO: This is only needed for adaptive runs
  ! TODO: We only need to do the loop for full cells that are rood
  ! TODO this code is replicated in another subroutine. Avoid code duplication and computing two times the same thing.
  call memalloc ( num_fields, triangulation%get_num_proper_vefs(), proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
  call memalloc ( this%get_max_num_shape_functions(), touched_cell_dofs,__FILE__,__LINE__ )
  proper_vef_constrains_full_cell(:,:) = .false.
  call fe%first()
  do while ( .not. fe%has_finished())
     if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
        do field_id=1, num_fields
          if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
            if ( .not. fe%is_void(field_id)) then
               do ivef = 1, fe%get_num_vefs()
                   call fe%get_vef(ivef,vef)
                   if ( .not. vef%has_free_dofs(field_id,coarser_fe) ) cycle
                   if ( .not. vef%is_proper() ) then
                     do icell = 1,vef%get_num_improper_cells_around()
                        call vef%get_improper_cell_around(icell,coarser_fe)
                        coarser_fe_ivef = vef%get_improper_cell_around_ivef(icell)
                        coarser_reference_fe => coarser_fe%get_reference_fe(field_id)
                        if (coarser_fe%is_cut()) then
                          touched_cell_dofs(:) = .false.
                          coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
                          do while ( .not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
                            touched_cell_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) = .true.
                            call coarser_fe_dofs_on_vef_iterator%next()
                          end do
                          do coarser_fe_ivef = 1, coarser_fe%get_num_vefs()
                            call coarser_fe%get_vef(coarser_fe_ivef,coarser_vef)
                            massert(coarser_vef%is_proper(),'This vef has to be proper by the 2:1 balance condition.')
                            coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_own_dofs_on_n_face_iterator(coarser_fe_ivef)
                            do while ( .not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
                              if ( touched_cell_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) then
                                proper_vef_constrains_full_cell(field_id,coarser_vef%get_gid()) = .true.
                                exit
                              end if
                              call coarser_fe_dofs_on_vef_iterator%next()
                            end do
                          end do
                        end if
                     end do
                   end if
               end do
            end if
          end if
        end do
     end if
     call fe%next()
  end do
  
  ! Count #DoFs per field
  num_dofs_x_field = 0
  
  call memalloc ( num_fields, triangulation%get_num_proper_vefs(), per_field_proper_vefs_visited,  __FILE__, __LINE__ )
  call memalloc ( num_fields, triangulation%get_num_improper_vefs(), per_field_improper_vefs_visited,  __FILE__, __LINE__ )
  per_field_proper_vefs_visited = .false.
  per_field_improper_vefs_visited = .false.

  ! Loop in full cells
  call fe%first()
  do while ( .not. fe%has_finished())
     if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
        do field_id=1, num_fields
          if ( .not. fe%is_void(field_id)) then
            num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + fe%count_own_dofs_cell(field_id)
            if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
               do ivef = 1, fe%get_num_vefs()
                 call fe%get_vef(ivef,vef)
                 if ( .not. vef%has_free_dofs(field_id,coarser_fe) ) cycle
                 vef_lid = abs(fe%get_vef_gid(ivef))
                 if ( vef%is_proper() ) then
                   if ( .not. per_field_proper_vefs_visited (field_id,vef_lid) ) then
                     num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                     if (num_own_dofs_on_vef>0) then
                       per_field_proper_vefs_visited (field_id,vef_lid) = .true.
                       num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + num_own_dofs_on_vef 
                     end if
                   end if
                 else if ( .not. per_field_improper_vefs_visited (field_id,vef_lid) ) then
                   num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                   if (num_own_dofs_on_vef>0) then
                     per_field_improper_vefs_visited (field_id,vef_lid) = .true.
                     num_dofs_x_field(field_id) = num_dofs_x_field(field_id) +  num_own_dofs_on_vef 
                   end if
                 end if
               end do
            end if
          end if
        end do
     end if
     call fe%next()
  end do

  ! Loop in cut cells
  call fe%first()
  do while ( .not. fe%has_finished())
     if ( fe%is_local() .and.  fe%is_cut() ) then
        do field_id=1, num_fields
          if ( .not. fe%is_void(field_id)) then
            if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
               do ivef = 1, fe%get_num_vefs()
                 call fe%get_vef(ivef,vef)
                 vef_lid = abs(fe%get_vef_gid(ivef))
                 if ( vef%is_proper() ) then
                   if ( .not. per_field_proper_vefs_visited (field_id,vef_lid) ) then
                     if (proper_vef_constrains_full_cell(field_id,vef_lid)) then
                       num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
                       if (num_own_dofs_on_vef>0) then
                         per_field_proper_vefs_visited (field_id,vef_lid) = .true.
                         num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + num_own_dofs_on_vef 
                       end if
                     end if
                   end if
                 end if
               end do
            end if
          end if
        end do
     end if
     call fe%next()
  end do
  
  call fe%first()
  do while(.not. fe%has_finished())
     mcheck(.not. fe%is_ghost(),'For the moment, this subroutine only works for serial runs')
     !if ( fe%is_ghost() .and. (.not. fe%is_cut()) ) then
     !    do field_id = 1, num_fields
     !      if ( .not. fe%is_void(field_id)) then
     !         if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
     !            do ivef = 1, fe%get_num_vefs()
     !              call fe%get_vef(ivef, vef)
     !              if ( vef%is_at_interface() ) then
     !                local_found = .false.
     !                ! Find local element around vef_lid in elem_id
     !                do ielem=1, vef%get_num_cells_around()
     !                  call vef%get_cell_around(ielem, source_fe)
     !                  if ( source_fe%is_local() .and. (.not. source_fe%is_void(field_id)) ) then
     !                    local_found = .true.
     !                    exit
     !                  end if
     !                end do
     !                if ( .not. local_found ) then
     !                   vef_lid = abs(fe%get_vef_gid(ivef))
     !                   if ( vef%is_proper() ) then
     !                     if ( .not. per_field_proper_vefs_visited (field_id,vef_lid) ) then
     !                      num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
     !                      if (num_own_dofs_on_vef>0) then
     !                        per_field_proper_vefs_visited (field_id,vef_lid) = .true.
     !                        num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + &
     !                                                          num_own_dofs_on_vef 
     !                      end if
     !                     end if
     !                   else if ( .not. per_field_improper_vefs_visited (field_id,vef_lid) ) then
     !                      num_own_dofs_on_vef = fe%count_own_dofs_vef(ivef,field_id)
     !                      if (num_own_dofs_on_vef>0) then
     !                        per_field_improper_vefs_visited (field_id,vef_lid) = .true.
     !                        num_dofs_x_field(field_id) = num_dofs_x_field(field_id) + &
     !                                                           num_own_dofs_on_vef 
     !                      end if                                     
     !                   end if
     !                end if
     !              end if
     !            end do
     !         else
     !            do ivef = 1, fe%get_num_vefs()
     !               call fe%get_vef(ivef, vef)
     !               if ( vef%is_facet() .and. vef%is_at_interface() ) then
     !                 call fe%generate_dofs_facet_integration_coupling ( ivef, &
     !                                                                    field_id, &
     !                                                                    num_dofs_x_field(field_id) )
     !               end if
     !            end do  
     !         end if
     !      end if
     !    end do
     !end if
     call fe%next()    
  end do
  
  ! Count #DoFs per block
  call block_layout%clear_num_dofs_x_block()
  do field_id=1, this%get_num_fields()
    iblock = block_layout%get_block_id(field_id) 
    call block_layout%add_to_block_num_dofs(iblock,num_dofs_x_field(field_id))     
  end do

  ! This is needed since we cannot access to private variables of the father
  do field_id=1, this%get_num_fields()
    call this%set_field_num_dofs(field_id,num_dofs_x_field(field_id))
  end do
  
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_vef_iterator(coarser_vef)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(source_fe)
  call memfree ( per_field_proper_vefs_visited,  __FILE__, __LINE__ )
  call memfree ( per_field_improper_vefs_visited,  __FILE__, __LINE__ )
  call memfree(num_dofs_x_field,__FILE__,__LINE__)
  call memfree ( proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
  call memfree ( touched_cell_dofs,__FILE__,__LINE__ )
end subroutine suhpafs_count_dofs 

!========================================================================================
subroutine suhpafs_list_dofs ( this ) 
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this   
  
  ! TODO: This code is almost replicated from the father. Surely, there are better ways to do that.

  integer(ip), allocatable :: owner_cell_gid_x_field_and_proper_vef(:,:)
  integer(ip), allocatable :: owner_cell_gid_x_field_and_improper_vef(:,:)
  integer(ip), allocatable :: per_field_proper_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: per_field_improper_vef_lid_in_owner_cell (:,:)
  integer(ip), allocatable :: blocks_current_num_dofs(:)
  integer(ip), allocatable :: fields_current_dof(:)
  class(fe_cell_iterator_t), allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t)  :: vef, coarser_vef
  integer(ip) :: block_id, field_id
  integer(ip) :: ivef, jvef, vef_lid
  integer(ip) :: previous_dof_block
  integer(ip) :: current_fixed_dof, previous_fixed_dof
  integer(ip) :: source_cell_id, source_vef_lid
  logical     :: is_owner, local_found, add_dofs
  integer(ip) :: ielem
  integer(ip) :: ivef_in_source_fe
  class(reference_fe_t), pointer :: reference_fe
  type(list_iterator_t) :: own_dofs_on_vef_iterator
  logical, allocatable :: per_field_visited_proper_vefs_at_interface(:,:) 

  integer(ip) :: num_fields
  integer(ip), allocatable :: num_dofs_x_field(:)
  class(triangulation_t), pointer :: triangulation
  type(block_layout_t), pointer :: block_layout

  logical, allocatable :: proper_vef_constrains_full_cell(:,:)
  logical, allocatable :: touched_cell_dofs(:)
  integer(ip) :: icell
  class(reference_fe_t), pointer :: coarser_reference_fe
  type(list_iterator_t) :: coarser_fe_dofs_on_vef_iterator
  integer(ip) :: coarser_fe_ivef

  ! We want to call this subroutine only for aggregation-based FE spaces
  if (.not. this%use_constraints) then
    call this%serial_fe_space_t%list_dofs()
    return
  end if
 
  ! This is needed since we cannot access to private variables of the father
  triangulation => this%get_triangulation()
  block_layout => this%get_block_layout()
  num_fields = this%get_num_fields()
  call memalloc(num_fields,num_dofs_x_field,__FILE__,__LINE__)
  do field_id=1, num_fields
    num_dofs_x_field(field_id) = this%get_field_num_dofs(field_id)
  end do

  call this%create_fe_cell_iterator(coarser_fe)
  call this%create_fe_cell_iterator(source_fe)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_vef_iterator(vef)
  call this%create_fe_vef_iterator(coarser_vef)

  ! Mark the vefs owning DOFs that constraint hanging DOFs in full cells
  ! TODO: This is only needed for adaptive runs
  ! TODO: We only need to do the loop for full cells that are rood
  ! TODO this code is replicated in another subroutine. Avoid code duplication and computing two times the same thing.
  call memalloc ( num_fields, triangulation%get_num_proper_vefs(), proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
  call memalloc ( this%get_max_num_shape_functions(), touched_cell_dofs,__FILE__,__LINE__ )
  proper_vef_constrains_full_cell(:,:) = .false.
  call fe%first()
  do while ( .not. fe%has_finished())
     if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
        do field_id=1, num_fields
          !if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
            if ( .not. fe%is_void(field_id)) then
               do ivef = 1, fe%get_num_vefs()
                   call fe%get_vef(ivef,vef)
                   if ( .not. vef%has_free_dofs(field_id,coarser_fe) ) cycle
                   if ( .not. vef%is_proper() ) then
                     do icell = 1,vef%get_num_improper_cells_around()
                        call vef%get_improper_cell_around(icell,coarser_fe)
                        coarser_fe_ivef = vef%get_improper_cell_around_ivef(icell)
                        coarser_reference_fe => coarser_fe%get_reference_fe(field_id)
                        if (coarser_fe%is_cut()) then
                          touched_cell_dofs(:) = .false.
                          coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_dofs_on_n_face_iterator(coarser_fe_ivef)
                          do while ( .not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
                            touched_cell_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) = .true.
                            call coarser_fe_dofs_on_vef_iterator%next()
                          end do
                          do coarser_fe_ivef = 1, coarser_fe%get_num_vefs()
                            call coarser_fe%get_vef(coarser_fe_ivef,coarser_vef)
                            massert(coarser_vef%is_proper(),'This vef has to be proper by the 2:1 balance condition.')
                            coarser_fe_dofs_on_vef_iterator = coarser_reference_fe%create_own_dofs_on_n_face_iterator(coarser_fe_ivef)
                            do while ( .not. coarser_fe_dofs_on_vef_iterator%is_upper_bound() )
                              if ( touched_cell_dofs(coarser_fe_dofs_on_vef_iterator%get_current()) ) then
                                proper_vef_constrains_full_cell(field_id,coarser_vef%get_gid()) = .true.
                                exit
                              end if
                              call coarser_fe_dofs_on_vef_iterator%next()
                            end do
                          end do
                        end if
                     end do
                   end if
               end do
            end if
          !end if
        end do
     end if
     call fe%next()
  end do
  
  current_fixed_dof = this%get_num_fixed_dofs()
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), owner_cell_gid_x_field_and_proper_vef,  __FILE__, __LINE__ )
  owner_cell_gid_x_field_and_proper_vef = -1
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), owner_cell_gid_x_field_and_improper_vef,  __FILE__, __LINE__ )
  owner_cell_gid_x_field_and_improper_vef = -1
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), per_field_proper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_proper_vef_lid_in_owner_cell = -1
  
  call memalloc ( this%get_num_fields(), triangulation%get_num_vefs(), per_field_improper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  per_field_improper_vef_lid_in_owner_cell = -1
  
  call memalloc( block_layout%get_num_blocks(), blocks_current_num_dofs, __FILE__, __LINE__ )
  blocks_current_num_dofs = 0
  
  call memalloc( num_fields, fields_current_dof, __FILE__, __LINE__ )
  fields_current_dof = 0

  call memalloc (num_fields, triangulation%get_num_vefs(), per_field_visited_proper_vefs_at_interface, __FILE__, __LINE__) 
  per_field_visited_proper_vefs_at_interface = .false.

  
  if (num_fields > 1) then
    do field_id=1, num_fields
       block_id = block_layout%get_block_id(field_id)
       fields_current_dof(field_id) = fields_current_dof(field_id) + blocks_current_num_dofs(block_id)
       blocks_current_num_dofs(block_id) = blocks_current_num_dofs(block_id) + num_dofs_x_field(field_id)
    end do
  end if
  

  ! First process not cut cells as always

  call fe%first()
  do while ( .not. fe%has_finished())
     if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
       do field_id=1, this%get_num_fields()
         if ( .not. fe%is_void(field_id)) then
           call fe%generate_own_dofs_cell ( field_id, fields_current_dof(field_id) )
           do ivef= 1, fe%get_num_vefs()
             call fe%get_vef(ivef,vef)
             if ( vef%has_free_dofs(field_id,coarser_fe) ) then
               vef_lid = abs(fe%get_vef_gid(ivef))
               
               is_owner = .false.
               if ( vef%is_proper() ) then
                 is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
               else 
                 is_owner = ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 )
               end if
               
               if ( is_owner ) then
                 previous_dof_block = fields_current_dof(field_id)
                 call fe%generate_own_dofs_vef ( ivef, &
                                                 field_id, &
                                                 fields_current_dof(field_id), &
                                                 free_dofs_loop=.true. )
                 if ( previous_dof_block < fields_current_dof(field_id) ) then
                   if ( vef%is_proper() ) then
                     owner_cell_gid_x_field_and_proper_vef ( field_id, vef_lid ) = fe%get_gid() 
                     per_field_proper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                   else
                     owner_cell_gid_x_field_and_improper_vef ( field_id, vef_lid ) = fe%get_gid() 
                     per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                   end if
                 end if
               else
                 if ( vef%is_proper() ) then
                   source_cell_id = owner_cell_gid_x_field_and_proper_vef(field_id, vef_lid)
                   source_vef_lid = per_field_proper_vef_lid_in_owner_cell(field_id,vef_lid)
                 else
                   source_cell_id = owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid)
                   source_vef_lid = per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid)
                 end if
                 call source_fe%set_gid( source_cell_id )
                 call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
               end if
             else 
               do ielem=1, vef%get_num_improper_cells_around()
                 call vef%get_improper_cell_around(ielem,coarser_fe)
                 if (.not. coarser_fe%is_void(field_id)) then
                    do jvef=1, coarser_fe%get_num_vefs()
                      call coarser_fe%get_vef(jvef, coarser_vef)
                      if (coarser_vef%is_at_interface() .and. coarser_vef%is_proper()) then
                        per_field_visited_proper_vefs_at_interface(field_id,coarser_vef%get_gid()) = .true. 
                      end if
                    end do
                 end if
               end do               
                
               assert ( fe%get_vef_gid(ivef) < 0 )
               vef_lid = abs(fe%get_vef_gid(ivef))
               if ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 ) then
                  previous_fixed_dof = current_fixed_dof
                  call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.)
                  if (previous_fixed_dof < current_fixed_dof) then
                    owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) = fe%get_gid()
                    per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                  end if
               else 
                 call source_fe%set_gid(owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid))
                 call fe%fetch_own_dofs_vef_from_source_fe ( ivef,      &
                                                             source_fe, &
                                                             per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid), &
                                                             field_id ) 
               end if
             end if
           end do
         end if
         call fe%determine_has_fixed_dofs(field_id)
         call fe%determine_has_hanging_dofs(field_id)
       end do
     end if
     call fe%next()
  end do  

  ! Process cut cells (first loop)
  call fe%first()
  do while ( .not. fe%has_finished())
     if ( fe%is_local() .and. fe%is_cut() ) then
       do field_id=1, this%get_num_fields()
         if ( .not. fe%is_void(field_id)) then
           do ivef= 1, fe%get_num_vefs()
             call fe%get_vef(ivef,vef)
             if ( vef%is_proper() ) then
               vef_lid = abs(fe%get_vef_gid(ivef))
               if ( proper_vef_constrains_full_cell(field_id,vef_lid) ) then
                 is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
                 if ( is_owner ) then
                   previous_dof_block = fields_current_dof(field_id)
                   call fe%generate_own_dofs_vef ( ivef, &
                                                   field_id, &
                                                   fields_current_dof(field_id), &
                                                   free_dofs_loop=.true. )
                   if ( previous_dof_block < fields_current_dof(field_id) ) then
                     owner_cell_gid_x_field_and_proper_vef ( field_id, vef_lid ) = fe%get_gid() 
                     per_field_proper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                   end if
                 end if
               end if
             end if
           end do
         end if
         call fe%determine_has_fixed_dofs(field_id)
         call fe%determine_has_hanging_dofs(field_id)
       end do
     end if
     call fe%next()
  end do  

  ! Process all cut FEs (second loop)

  call fe%first()
  do while ( .not. fe%has_finished())
     if ( fe%is_local() .and. ( fe%is_cut()) ) then
       do field_id=1, this%get_num_fields()
         if ( .not. fe%is_void(field_id)) then
           call fe%generate_own_dofs_cell ( field_id, current_fixed_dof, are_free_dofs=.false. )
           do ivef= 1, fe%get_num_vefs()
             call fe%get_vef(ivef,vef)
             if ( vef%has_free_dofs(field_id,coarser_fe) ) then
               vef_lid = abs(fe%get_vef_gid(ivef))
               
               is_owner = .false.
               if ( vef%is_proper() ) then
                 is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
               else 
                 is_owner = ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 )
               end if
               
               if ( is_owner ) then
                 previous_fixed_dof = current_fixed_dof
                 call fe%generate_own_dofs_vef ( ivef, &
                                                 field_id, &
                                                 current_fixed_dof, &
                                                 free_dofs_loop=.false. )
                  if (previous_fixed_dof < current_fixed_dof) then
                   if ( vef%is_proper() ) then
                     owner_cell_gid_x_field_and_proper_vef ( field_id, vef_lid ) = fe%get_gid() 
                     per_field_proper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                   else
                     owner_cell_gid_x_field_and_improper_vef ( field_id, vef_lid ) = fe%get_gid() 
                     per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                   end if
                 end if
               else
                 if ( vef%is_proper() ) then
                   source_cell_id = owner_cell_gid_x_field_and_proper_vef(field_id, vef_lid)
                   source_vef_lid = per_field_proper_vef_lid_in_owner_cell(field_id,vef_lid)
                 else
                   source_cell_id = owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid)
                   source_vef_lid = per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid)
                 end if
                 call source_fe%set_gid( source_cell_id )
                 call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
               end if
             else 
               do ielem=1, vef%get_num_improper_cells_around()
                 call vef%get_improper_cell_around(ielem,coarser_fe)
                 if (.not. coarser_fe%is_void(field_id)) then
                    do jvef=1, coarser_fe%get_num_vefs()
                      call coarser_fe%get_vef(jvef, coarser_vef)
                      if (coarser_vef%is_at_interface() .and. coarser_vef%is_proper()) then
                        per_field_visited_proper_vefs_at_interface(field_id,coarser_vef%get_gid()) = .true. 
                      end if
                    end do
                 end if
               end do               
                
               assert ( fe%get_vef_gid(ivef) < 0 )
               vef_lid = abs(fe%get_vef_gid(ivef))
               if ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 ) then
                  previous_fixed_dof = current_fixed_dof
                  call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.)
                  if (previous_fixed_dof < current_fixed_dof) then
                    owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) = fe%get_gid()
                    per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
                  end if
               else 
                 call source_fe%set_gid(owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid))
                 call fe%fetch_own_dofs_vef_from_source_fe ( ivef,      &
                                                             source_fe, &
                                                             per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid), &
                                                             field_id ) 
               end if
             end if
           end do
         end if
         call fe%determine_has_fixed_dofs(field_id)
         call fe%determine_has_hanging_dofs(field_id)
       end do
     end if
     call fe%next()
  end do  
  
  call fe%first()
  do while(.not. fe%has_finished())
     mcheck(.not. fe%is_ghost(),'For the moment, this subroutine only works for serial runs')
     !if ( fe%is_ghost() ) then
     !    do field_id = 1, num_fields
     !      if ( .not. fe%is_void(field_id)) then
     !         if ( this%fe_space_type_x_field(field_id) == fe_space_type_cg ) then
     !            do ivef = 1, fe%get_num_vefs()
     !              call fe%get_vef(ivef, vef)
     !              if ( .not. vef%is_ghost() ) then
     !               if ( vef%is_at_interface() ) then
     !                local_found = .false.
     !                ! Find local element around vef_lid in elem_id
     !                do ielem=1, vef%get_num_cells_around()
     !                  call vef%get_cell_around(ielem, source_fe)
     !                  if ( source_fe%is_local() .and. (.not. source_fe%is_void(field_id)) ) then
     !                    local_found = .true.
     !                    exit
     !                  end if
     !                end do
     !                
     !                if ( local_found ) then
     !                  ivef_in_source_fe = source_fe%get_vef_lid_from_gid(vef%get_gid())
     !                  ! Check that the source fe has at least one dof on this vef
     !                  reference_fe => source_fe%get_reference_fe(field_id)
     !                  own_dofs_on_vef_iterator = &
     !                     reference_fe%create_own_dofs_on_n_face_iterator(ivef_in_source_fe)
     !                  if (own_dofs_on_vef_iterator%get_size() > 0) then
     !                    call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
     !                                                                source_fe, & 
     !                                                                ivef_in_source_fe, &
     !                                                                field_id )
     !                  end if
     !                else 
     !                   vef_lid = abs(fe%get_vef_gid(ivef))
     !                   if ( vef%is_proper() ) then
     !                     is_owner = ( owner_cell_gid_x_field_and_proper_vef( field_id, vef_lid ) == -1 )
     !                     add_dofs = per_field_visited_proper_vefs_at_interface(field_id,vef%get_gid()) 
     !                   else 
     !                     is_owner = ( owner_cell_gid_x_field_and_improper_vef( field_id, vef_lid ) == -1 )
     !                     add_dofs = .not. vef%has_free_dofs(field_id,coarser_fe)
     !                   end if
     !                   
     !                   if ( add_dofs ) then       
     !                    if ( is_owner ) then
     !                      if ( vef%is_proper() ) then
     !                          previous_dof_block = fields_current_dof(field_id)  
     !                          call fe%generate_own_dofs_vef ( ivef, field_id, fields_current_dof(field_id), free_dofs_loop=.true. ) 
     !                          if ( previous_dof_block < fields_current_dof(field_id) ) then
     !                            owner_cell_gid_x_field_and_proper_vef ( field_id, vef_lid ) = fe%get_gid() 
     !                            per_field_proper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
     !                          end if  
     !                      else
     !                          previous_dof_block = current_fixed_dof  
     !                          call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.)
     !                          if ( previous_dof_block < current_fixed_dof ) then
     !                            owner_cell_gid_x_field_and_improper_vef ( field_id, vef_lid ) = fe%get_gid() 
     !                            per_field_improper_vef_lid_in_owner_cell ( field_id, vef_lid ) = ivef 
     !                          end if  
     !                      end if
     !                    else
     !                      if ( vef%is_proper() ) then
     !                         source_cell_id = owner_cell_gid_x_field_and_proper_vef(field_id, vef_lid)
     !                         source_vef_lid = per_field_proper_vef_lid_in_owner_cell(field_id,vef_lid)
     !                      else
     !                         source_cell_id = owner_cell_gid_x_field_and_improper_vef(field_id, vef_lid)
     !                         source_vef_lid = per_field_improper_vef_lid_in_owner_cell(field_id,vef_lid)
     !                      end if
     !                      call source_fe%set_gid( source_cell_id )
     !                      call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
     !                    end if
     !                   end if
     !                end if
     !               end if
     !              end if
     !            end do
     !         else
     !            do ivef = 1, fe%get_num_vefs()
     !               call fe%get_vef(ivef, vef)
     !               if ( vef%is_facet() .and. vef%is_at_interface() ) then
     !                 call fe%generate_dofs_facet_integration_coupling ( ivef, &
     !                                                                    field_id, &
     !                                                                    num_dofs_x_field(field_id) )
     !               end if
     !            end do  
     !         end if
     !      end if
     !    end do
     !end if
     call fe%next()    
  end do
  
  
  ! Set #DoFs per field and block in case of single-field, single-block problem
  ! (as we did not call fe_space%count_dofs() in this case)
  if ( num_fields == 1 ) then
    field_id = 1
    block_id = 1
    num_dofs_x_field(field_id) = fields_current_dof(field_id)
    call block_layout%set_block_num_dofs(block_id,num_dofs_x_field(field_id))
  end if

  ! This is needed since we cannot access to private variables of the father
  do field_id=1, this%get_num_fields()
    call this%set_field_num_dofs(field_id,num_dofs_x_field(field_id))
  end do
  
  call this%set_num_hanging_dofs( current_fixed_dof - this%get_num_fixed_dofs() )
  call this%set_num_fixed_dofs(current_fixed_dof)
  
  call this%free_fe_cell_iterator(coarser_fe)
  call this%free_fe_cell_iterator(source_fe)
  call this%free_fe_cell_iterator(fe)
  call this%free_fe_vef_iterator(vef)
  call this%free_fe_vef_iterator(coarser_vef)
  call memfree( blocks_current_num_dofs, __FILE__, __LINE__ )
  call memfree( fields_current_dof     , __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_x_field_and_proper_vef,  __FILE__, __LINE__ )
  call memfree ( owner_cell_gid_x_field_and_improper_vef,  __FILE__, __LINE__ )
  call memfree ( per_field_proper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  call memfree ( per_field_improper_vef_lid_in_owner_cell,  __FILE__, __LINE__ )
  call memfree ( per_field_visited_proper_vefs_at_interface, __FILE__, __LINE__)
  call memfree (num_dofs_x_field,__FILE__,__LINE__)
  call memfree ( proper_vef_constrains_full_cell,  __FILE__, __LINE__ )
  call memfree ( touched_cell_dofs,__FILE__,__LINE__ )
end subroutine suhpafs_list_dofs 

!========================================================================================
subroutine suhpafs_setup_hanging_node_constraints ( this )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this   

  integer(ip) :: improper_dof_lid
  integer(ip) :: hanging_dof_lid
  class(fe_cell_iterator_t), allocatable :: fe
  class(fe_cell_iterator_t), allocatable :: root_fe
  integer(ip) :: field_id
  integer(ip), pointer :: fe_dofs(:)
  integer(ip), pointer :: root_fe_dofs(:)
  integer(ip) :: idof, root_idof
  integer(ip) :: num_free_dofs_in_root
  integer(ip) :: num_diri_dofs_in_root
  integer(ip) :: current_pos_free
  integer(ip) :: current_pos_diri
  class(reference_fe_t), pointer :: reference_fe
  class(reference_fe_t), pointer :: root_reference_fe
  class(reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quad_ref_fe
  type(cell_map_t), allocatable :: cell_map(:)
  type(cell_map_t), pointer :: root_cell_map
  type(quadrature_t), pointer :: root_fe_quad
  integer(ip) :: iaux
  type(point_t), pointer :: coordinates_nodes_cut_cell(:)
  type(cell_integrator_t), allocatable :: cell_integrator(:)
  type(quadrature_t) :: nodal_quad_in_root_fe
  class(triangulation_t), pointer :: triangulation
  real(rp), allocatable  :: shape_values(:,:)
  type(point_t), pointer :: coordinates(:)
  integer(ip) :: istat
  logical, allocatable :: visited_hanging_dof_lids(:)

  type(std_vector_integer_ip_t) , pointer :: ptr_constraining_free_dofs
  type(std_vector_integer_ip_t) , pointer :: ptr_constraining_dirichlet_dofs
  type(std_vector_integer_ip_t) , pointer :: constraining_free_dofs
  type(std_vector_real_rp_t)    , pointer :: constraining_free_dofs_coefficients
  type(std_vector_integer_ip_t) , pointer :: constraining_dirichlet_dofs
  type(std_vector_real_rp_t)    , pointer :: constraining_dirichlet_dofs_coefficients
  type(std_vector_real_rp_t)    , pointer :: constraints_independent_term

  ! Setup the hanging nodes due to mesh adaptivity
  call this%serial_fe_space_t%setup_hanging_node_constraints()

  ! We want to follow in this subroutine only for aggregation-based FE spaces
  if (.not. this%use_constraints) then
    return
  end if

  ptr_constraining_free_dofs                 => this%get_ptr_constraining_free_dofs()
  ptr_constraining_dirichlet_dofs            => this%get_ptr_constraining_dirichlet_dofs()
  constraining_free_dofs                     => this%get_constraining_free_dofs()
  constraining_free_dofs_coefficients        => this%get_constraining_free_dofs_coefficients()
  constraining_dirichlet_dofs                => this%get_constraining_dirichlet_dofs()
  constraining_dirichlet_dofs_coefficients   => this%get_constraining_dirichlet_dofs_coefficients()
  constraints_independent_term               => this%get_constraints_independent_term()

  ! Auxiliary
  triangulation => this%get_triangulation()
  call nodal_quad_in_root_fe%create(triangulation%get_num_dims(),this%get_max_num_shape_functions())

  call memalloc(this%get_num_hanging_dofs(),visited_hanging_dof_lids,__FILE__,__LINE__)
  
  !Fill the sizes of each sub-list

  ! Init to 0
  ! Re-size to 0 to force re-initialization during second resize (to the actual/correct size)
  call ptr_constraining_free_dofs%resize(0)
  call ptr_constraining_dirichlet_dofs%resize(0)
  call ptr_constraining_free_dofs%resize(this%get_num_hanging_dofs()+1,0)
  call ptr_constraining_dirichlet_dofs%resize(this%get_num_hanging_dofs()+1,0)

  ! In our case, this is 0
  call constraints_independent_term%resize(this%get_num_hanging_dofs())
  do iaux = 1,this%get_num_hanging_dofs()
    call constraints_independent_term%set(iaux,0.0_rp)
  end do

  ! Nodes in cut cells might depend on several nodes of their root cell. Count them! and set cut FEs as having hanging nodes.
  ! (We skip Dirichlet Dofs since they are already taken into account in previous loop)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(root_fe)
  visited_hanging_dof_lids(:) = .false.
  do while (.not. fe%has_finished())
    if ( fe%is_local() .and. fe%is_cut() ) then

      call root_fe%set_gid(this%aggregate_ids(fe%get_gid()))
       
      do field_id=1, this%get_num_fields()

        call fe%get_field_fe_dofs(field_id, fe_dofs)
        call root_fe%get_field_fe_dofs(field_id, root_fe_dofs)

        num_free_dofs_in_root = count(root_fe_dofs>0,kind=ip)
        num_diri_dofs_in_root = count(root_fe_dofs<0,kind=ip)

        ! TODO
        ! num_hang_dofs_in_root = ...
        ! num_diri_dofs_in_root = count(root_fe_dofs<0,kind=ip) - num_hang_dofs_in_root
        ! Then, add how many free and diri nodes the root hanging nodes depend on

        do idof = 1, size(fe_dofs)
          if ( fe%is_fixed_dof(fe_dofs(idof)) .and. (.not. fe%is_strong_dirichlet_dof(fe_dofs(idof))) ) then
            improper_dof_lid = abs(fe_dofs(idof))
            hanging_dof_lid  = improper_dof_lid - this%get_num_dirichlet_dofs()
            if ( .not. visited_hanging_dof_lids(hanging_dof_lid) ) then
              call ptr_constraining_free_dofs%set(hanging_dof_lid+1, num_free_dofs_in_root )
              call ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, num_diri_dofs_in_root )
              visited_hanging_dof_lids(hanging_dof_lid) = .true.
            end if
          end if
        end do

        call fe%determine_has_hanging_dofs(field_id)

      end do

    end if
    call fe%next()
  end do

  ! Create the header from the sizes
  call ptr_constraining_free_dofs%transform_length_to_header()
  call ptr_constraining_dirichlet_dofs%transform_length_to_header()

  ! Allocate the vectors containing the raw data

  call constraining_free_dofs%resize&
    (ptr_constraining_free_dofs%get(ptr_constraining_free_dofs%size())-1)
  call constraining_free_dofs_coefficients%resize&
    (ptr_constraining_free_dofs%get(ptr_constraining_free_dofs%size())-1)

  call constraining_dirichlet_dofs%resize&
    (ptr_constraining_dirichlet_dofs%get(ptr_constraining_dirichlet_dofs%size())-1)
  call constraining_dirichlet_dofs_coefficients%resize&
    (ptr_constraining_dirichlet_dofs%get(ptr_constraining_dirichlet_dofs%size())-1)

  ! Compute dependencies and coefficients for the rest of constraints
  call fe%first()
  allocate(cell_integrator(this%get_num_fields()),stat=istat); check(istat==0)
  allocate(cell_map(this%get_num_fields()),stat=istat); check(istat==0)
  iaux = 1
  visited_hanging_dof_lids(:) = .false.
  do while (.not. fe%has_finished())
    if ( fe%is_local() .and. fe%is_cut() ) then

      call root_fe%set_gid(this%aggregate_ids(fe%get_gid()))
      do field_id = 1, this%get_num_fields()

        call fe%get_field_fe_dofs(field_id, fe_dofs)
        call root_fe%get_field_fe_dofs(field_id, root_fe_dofs)

        ! Get the coordinates in the reference space of the nodes associated to the cut cell shape functions
        reference_fe => fe%get_reference_fe(field_id)
        massert(reference_fe%has_nodal_quadrature(),'This routine only work for interpolatory FEs.')
        nodal_quad_ref_fe => reference_fe%get_nodal_quadrature()

        ! Transform them to the physical space
        reference_fe_geo => fe%get_reference_fe_geo()
        if (iaux == 1) then
          call cell_map(field_id)%create(nodal_quad_ref_fe,reference_fe_geo)
        else
          call cell_map(field_id)%update_interpolation(nodal_quad_ref_fe,reference_fe_geo)
        end if
        coordinates => cell_map(field_id)%get_coordinates()
        call fe%get_nodes_coordinates(coordinates)
        call cell_map(field_id)%compute_quadrature_points_coordinates()
        coordinates_nodes_cut_cell => cell_map(field_id)%get_quadrature_points_coordinates()

        ! Transform back to the reference space of the root_fe
        call root_fe%update_integration()
        root_fe_quad => root_fe%get_quadrature()
        root_cell_map  => root_fe%get_cell_map()
        call send_to_reference_space(coordinates_nodes_cut_cell,root_fe_quad,root_cell_map,nodal_quad_in_root_fe)

        ! Evaluate the root_fe shape functions at these points
        root_reference_fe => root_fe%get_reference_fe(field_id)
        if (iaux == 1) then
          call cell_integrator(field_id)%create(nodal_quad_in_root_fe,root_reference_fe)
        else
          call cell_integrator(field_id)%update_interpolation(nodal_quad_in_root_fe)
        end if
        call cell_integrator(field_id)%update(root_cell_map)
        call cell_integrator(field_id)%get_values(shape_values)

        do idof = 1, size(fe_dofs)
          if ( fe%is_fixed_dof(fe_dofs(idof)) .and. (.not. fe%is_strong_dirichlet_dof(fe_dofs(idof))) ) then
            improper_dof_lid = abs(fe_dofs(idof))
            hanging_dof_lid  = improper_dof_lid - this%get_num_dirichlet_dofs()
            if ( .not. visited_hanging_dof_lids(hanging_dof_lid) ) then
              current_pos_free = ptr_constraining_free_dofs%get(hanging_dof_lid)
              current_pos_diri = ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)
              do root_idof = 1,size(root_fe_dofs)
                if (root_fe_dofs(root_idof)>0) then
                  call constraining_free_dofs%set(current_pos_free,root_fe_dofs(root_idof))
                  call constraining_free_dofs_coefficients%set(current_pos_free,shape_values(root_idof,idof))
                  current_pos_free = current_pos_free + 1
                else if (root_fe_dofs(root_idof)<0) then
                  call constraining_dirichlet_dofs%set(current_pos_diri,root_fe_dofs(root_idof))
                  call constraining_dirichlet_dofs_coefficients%set(current_pos_diri,shape_values(root_idof,idof))
                  current_pos_diri = current_pos_diri + 1
                else
                  mcheck(.false.,'Dof cannot be zero')
                end if
              end do
              visited_hanging_dof_lids(hanging_dof_lid) = .true.
            end if
          end if
        end do

      end do
      iaux = iaux + 1
    end if
    call fe%next()
  end do

  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(root_fe)
  do field_id = 1, this%get_num_fields()
    call cell_map(field_id)%free()
  end do
  deallocate(cell_map,stat=istat); check(istat==0)
  do field_id = 1, this%get_num_fields()
    call cell_integrator(field_id)%free()
  end do
  deallocate(cell_integrator,stat=istat); check(istat==0)
  call nodal_quad_in_root_fe%free()
  call memfree(shape_values,__FILE__,__LINE__)
  call memfree(visited_hanging_dof_lids,__FILE__,__LINE__)
end subroutine suhpafs_setup_hanging_node_constraints

!========================================================================================
function suhpafs_get_aggregate_ids(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  integer(ip), pointer :: suhpafs_get_aggregate_ids(:)
  suhpafs_get_aggregate_ids => this%aggregate_ids
end function suhpafs_get_aggregate_ids

!========================================================================================
subroutine suhpafs_print_debug_info(this,iounit)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  integer(ip) :: iounit
  integer(ip) :: istat
  real(rp)    :: max_aggregate_size
  integer(ip) :: max_aggregate_size_id
  logical     :: has_full_neig_along_dim(3)
  integer(ip) :: max_separation_from_root_id
  real(ip)    :: max_separation_from_root
  integer(ip) :: has_full_neig_along_dim_int(3)
  integer(ip) :: i

  istat = this%debug_info%get(key='max_separation_from_root_id',  value=max_separation_from_root_id ); check(istat==0)
  istat = this%debug_info%get(key='max_separation_from_root',     value=max_separation_from_root    ); check(istat==0)
  istat = this%debug_info%get(key='max_aggregate_size',           value=max_aggregate_size          ); check(istat==0)
  istat = this%debug_info%get(key='max_aggregate_size_id',        value=max_aggregate_size_id       ); check(istat==0)
  istat = this%debug_info%get(key='has_full_neig_c',              value=has_full_neig_along_dim(1)  ); check(istat==0)
  istat = this%debug_info%get(key='has_full_neig_e',              value=has_full_neig_along_dim(2)  ); check(istat==0)
  istat = this%debug_info%get(key='has_full_neig_f',              value=has_full_neig_along_dim(3)  ); check(istat==0)

  has_full_neig_along_dim_int(:) = 0
  do i = 1,3
    if (has_full_neig_along_dim(i)) then
      has_full_neig_along_dim_int(i) = 1
    end if
  end do

  write(iounit,'(a,e32.25)') 'max_separation_from_root    ;',  max_separation_from_root      
  write(iounit,'(a,i32)'   ) 'max_separation_from_root_id ;',  max_separation_from_root_id
  write(iounit,'(a,e32.25)') 'max_aggregate_size          ;',  max_aggregate_size                  
  write(iounit,'(a,i32)'   ) 'max_aggregate_size_id       ;',  max_aggregate_size_id            
  write(iounit,'(a,i32)'   ) 'has_full_neig_c             ;',  has_full_neig_along_dim_int(1)             
  write(iounit,'(a,i32)'   ) 'has_full_neig_e             ;',  has_full_neig_along_dim_int(2)             
  write(iounit,'(a,i32)'   ) 'has_full_neig_f             ;',  has_full_neig_along_dim_int(3)             
end subroutine suhpafs_print_debug_info

!========================================================================================
subroutine suhpafs_allocate_and_fill_aggregate_ids(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout)    :: this

  class(cell_iterator_t), allocatable :: cell
  integer(ip) :: icell
  class(cell_iterator_t), allocatable :: cell_arround
  integer(ip), parameter :: max_num_sweeps = 5
  integer(ip) :: isweep
  logical ::  is_needed 
  logical :: has_been_aggregated
  integer(ip) :: icell_arround
  class(triangulation_t), pointer :: triangulation
  class(vef_iterator_t), allocatable :: vef
  integer(ip) :: ivef
  integer(ip) :: ifacet
  integer(ip), allocatable :: tent_distance(:)
  integer(ip), allocatable :: min_distance(:)
  integer(ip) :: min_distance_aggr_id
  logical(ip),allocatable :: touched(:)

  integer(ip), allocatable :: distance(:,:)
  integer(ip), target :: face2dir_2d(4,2) = reshape([0,0,1,-1,1,-1,0,0],[4,2])
  integer(ip), target :: face2dir_3d(6,3) = reshape([ 0, 0, 0, 0, 1,-1,&
                                                      0, 0, 1,-1, 0, 0,&
                                                      1,-1, 0, 0, 0, 0],[6,3])
  integer(ip), pointer :: face2dir(:,:)

  integer(ip) :: max_separation_from_root_id
  real(ip)    :: max_separation_from_root
  integer(ip) :: istat


  triangulation => this%get_triangulation()
  call memalloc(triangulation%get_num_local_cells(),this%aggregate_ids,__FILE__,__LINE__)

  if (.not. this%use_constraints) then
    this%aggregate_ids(:) = 0
    max_separation_from_root_id = -1
    max_separation_from_root    = -1.0_rp
    istat = this%debug_info%set(key='max_separation_from_root_id',value=max_separation_from_root_id); check(istat==0)
    istat = this%debug_info%set(key='max_separation_from_root',   value=max_separation_from_root   ); check(istat==0)
    return
  end if

  if (triangulation%get_num_dims() == 2) then
    face2dir => face2dir_2d
  else if (triangulation%get_num_dims() == 3) then
    face2dir => face2dir_3d
  else
    mcheck(.false.,'Only for 3D and 2D')
  end if

  max_separation_from_root = 0.0_rp

  call memalloc(triangulation%get_num_local_cells(),triangulation%get_num_dims(),distance,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_local_cells(),touched,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_dims(),tent_distance,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_dims(),min_distance,__FILE__,__LINE__)

  call triangulation%create_cell_iterator(cell)
  call triangulation%create_cell_iterator(cell_arround)
  call triangulation%create_vef_iterator(vef)

  ! Initialize by setting the roots of the aggregates
  touched(:) = .false.
  do while (.not. cell%has_finished())
    if (cell%is_local()) then
      if (cell%is_interior()) then
        this%aggregate_ids(cell%get_gid()) = cell%get_gid()
        distance(cell%get_gid(),:) = 0
        touched(cell%get_gid()) = .true.
      else
        this%aggregate_ids(cell%get_gid()) = 0
      end if
    end if
    call cell%next()
  end do

  is_needed = .true.
  isweep = 1
  do while (is_needed)

    ! Check that we not reach the max num of sweeps allowed
    wassert(isweep <= max_num_sweeps, 'Max number of sweeps reached in the cut cell agglometarion algorithm. Refine your mesh!')
    if (isweep > max_num_sweeps) exit

    ! Glue to the neighbors
    call cell%first()
    is_needed = .false.
    do while (.not. cell%has_finished())
      if (cell%is_local()) then
        if ( cell%is_cut() .and. (.not. touched(cell%get_gid())) )  then


          ! TODO: We try to glue only by true neighbors
          ! For adaptive meshes, shall we look for improper neighbors as well?

          ! Glue to the face-neighbor with the smallest distance to a full element
          min_distance(:) = 99999999
          min_distance_aggr_id = 0
          ifacet = 0
          do ivef = 1, cell%get_num_vefs()
            call cell%get_vef(ivef,vef)
            if ( .not. vef%is_facet() ) cycle
            ifacet = ifacet + 1
            do icell_arround = 1,vef%get_num_cells_around()
              call vef%get_cell_around(icell_arround,cell_arround)
              if ( touched(cell_arround%get_gid()) ) then

                ! Compute the movement to reach the root element
                tent_distance = distance(cell_arround%get_gid(),:) + face2dir(ifacet,:)

                ! Find which is the best neighbor to glue into
                if ( norm2(real(tent_distance,kind=rp)) < norm2(real(min_distance,kind=rp)) ) then
                  min_distance =  tent_distance
                  min_distance_aggr_id = this%aggregate_ids(cell_arround%get_gid())
                end if

              end if
            end do
          end do

          if (min_distance_aggr_id == 0) then
            is_needed = .true.
          else
            this%aggregate_ids(cell%get_gid()) = min_distance_aggr_id
            distance(cell%get_gid(),:) = min_distance
            if (max_separation_from_root < norm2(real(min_distance,kind=rp))) then
              max_separation_from_root = norm2(real(min_distance,kind=rp))
              max_separation_from_root_id = min_distance_aggr_id
            end if
          end if

        end if
      end if
      call cell%next()
    end do

    ! Mark as touched all the aggregated cells
    touched(:) = this%aggregate_ids(:) > 0

    isweep = isweep + 1
  end do

  call triangulation%free_cell_iterator(cell)
  call triangulation%free_cell_iterator(cell_arround)
  call triangulation%free_vef_iterator(vef)

  ! Store info
  istat = this%debug_info%set(key='max_separation_from_root_id',value=max_separation_from_root_id); check(istat==0)
  istat = this%debug_info%set(key='max_separation_from_root',value=max_separation_from_root); check(istat==0)

  call memfree(tent_distance,__FILE__,__LINE__)
  call memfree(min_distance,__FILE__,__LINE__)
  call memfree(distance,__FILE__,__LINE__)
  call memfree(touched,__FILE__,__LINE__)

end subroutine suhpafs_allocate_and_fill_aggregate_ids

!========================================================================================
subroutine suhpafs_compute_aggregate_size(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout)    :: this

  class(cell_iterator_t), allocatable :: cell
  real(rp), allocatable :: extreme_coords(:,:,:)
  integer(ip) :: max_full_cell_id
  type(point_t), allocatable :: coords(:)
  integer(ip) :: inode
  integer(ip) :: idime
  integer(ip) :: iaggr
  integer(ip), parameter :: XMAX=2, XMIN=1
  real(rp) :: max_aggregate_size
  integer(ip) :: max_aggregate_size_id
  integer(ip) :: istat
  class(triangulation_t), pointer :: triangulation

  if (.not. this%use_constraints) then
    max_aggregate_size    = -1.0_rp
    max_aggregate_size_id = -1
    istat = this%debug_info%set(key='max_aggregate_size',   value=max_aggregate_size   ); check(istat==0)
    istat = this%debug_info%set(key='max_aggregate_size_id',value=max_aggregate_size_id); check(istat==0)
    return
  end if

  triangulation => this%get_triangulation()

  call triangulation%create_cell_iterator(cell)

  ! Count number of full cells
  max_full_cell_id = 0
  do while (.not. cell%has_finished())
    if (cell%is_local() .and. cell%is_interior()) then
      max_full_cell_id = max(max_full_cell_id,cell%get_gid())
    end if
    call cell%next()
  end do

  ! Determine the extreme coordinates
  call memalloc(max_full_cell_id,triangulation%get_num_dims(),2,extreme_coords,__FILE__,__LINE__)
  call memalloc(this%get_max_num_shape_functions(),coords,__FILE__,__LINE__)
  extreme_coords(:,:,XMAX) = -999999999999_rp
  extreme_coords(:,:,XMIN) = +999999999999_rp
  call cell%first()
  do while (.not. cell%has_finished())
    if (cell%is_local() .and. ( cell%is_cut() .or. cell%is_interior() )) then
      call cell%get_nodes_coordinates(coords)
      do inode = 1,cell%get_num_nodes()
        do idime = 1,triangulation%get_num_dims()
        if (coords(inode)%get(idime)>extreme_coords(this%aggregate_ids(cell%get_gid()),idime,XMAX)) then
          extreme_coords(this%aggregate_ids(cell%get_gid()),idime,XMAX) = coords(inode)%get(idime)
        end if
        if (coords(inode)%get(idime)<extreme_coords(this%aggregate_ids(cell%get_gid()),idime,XMIN)) then
          extreme_coords(this%aggregate_ids(cell%get_gid()),idime,XMIN) = coords(inode)%get(idime)
        end if
        end do
      end do
    end if
    call cell%next()
  end do

  ! Compute the maximum aggregate size
  max_aggregate_size = 0
  call cell%first()
  do while (.not. cell%has_finished())
    if (cell%is_local() .and. ( cell%is_cut() .or. cell%is_interior() )) then
      iaggr = this%aggregate_ids(cell%get_gid())
      do idime = 1, triangulation%get_num_dims()
        if (max_aggregate_size<(extreme_coords(iaggr,idime,XMAX)-extreme_coords(iaggr,idime,XMIN))) then
          max_aggregate_size = extreme_coords(iaggr,idime,XMAX)-extreme_coords(iaggr,idime,XMIN)
          max_aggregate_size_id = iaggr
        end if
      end do
    end if
    call cell%next()
  end do

  ! Store the computed value
  istat = this%debug_info%set(key='max_aggregate_size',value=max_aggregate_size); check(istat==0)
  istat = this%debug_info%set(key='max_aggregate_size_id',value=max_aggregate_size_id); check(istat==0)

  call triangulation%free_cell_iterator(cell)
  call memfree(coords,__FILE__,__LINE__)
  call memfree(extreme_coords,__FILE__,__LINE__)

end subroutine suhpafs_compute_aggregate_size

!========================================================================================
subroutine suhpafs_check_for_full_neighbors(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout)    :: this

  logical :: has_full_neig_along_dim(3)
  logical :: cell_has_full_neig_along_dim(3)
  class(cell_iterator_t), allocatable :: cell
  class(cell_iterator_t), allocatable :: cell_arround
  class(vef_iterator_t), allocatable :: vef
  integer(ip) :: ivef
  integer(ip) :: icell_arround
  integer(ip) :: i
  class(triangulation_t), pointer :: triangulation
  integer(ip) :: istat

 triangulation => this%get_triangulation()

  call triangulation%create_cell_iterator(cell)
  call triangulation%create_cell_iterator(cell_arround)
  call triangulation%create_vef_iterator(vef)

  has_full_neig_along_dim(:) = .true.
  if (triangulation%get_num_dims() == 2) then
    has_full_neig_along_dim(3) = .false.
  end if
  do while (.not. cell%has_finished())
    if (cell%is_local() .and. cell%is_cut()) then
        cell_has_full_neig_along_dim(:) = .false.
        do ivef = 1, cell%get_num_vefs()
          call cell%get_vef(ivef,vef)
          do icell_arround = 1,vef%get_num_cells_around()
            call vef%get_cell_around(icell_arround,cell_arround)
            if (cell_arround%is_interior()) then
              cell_has_full_neig_along_dim(vef%get_dim()+1) = .true.
            end if
          end do
        end do
        do i=1,triangulation%get_num_dims()
         if (.not. cell_has_full_neig_along_dim(i)) has_full_neig_along_dim(i) = .false.
        end do
    end if
    call cell%next()
  end do

  call triangulation%free_cell_iterator(cell)
  call triangulation%free_cell_iterator(cell_arround)
  call triangulation%free_vef_iterator(vef)

  istat = this%debug_info%set(key='has_full_neig_c',value=has_full_neig_along_dim(1)); check(istat==0)
  istat = this%debug_info%set(key='has_full_neig_e',value=has_full_neig_along_dim(2)); check(istat==0)
  istat = this%debug_info%set(key='has_full_neig_f',value=has_full_neig_along_dim(3)); check(istat==0)

end subroutine suhpafs_check_for_full_neighbors

subroutine send_to_reference_space(phys_coords_as_point,fe_quad,cell_map,ref_coords_as_quadrature)
  implicit none
  type(point_t),      intent(in)    :: phys_coords_as_point(:)
  type(quadrature_t), intent(in)    :: fe_quad
  type(cell_map_t),     intent(in)    :: cell_map
  type(quadrature_t), intent(inout) :: ref_coords_as_quadrature

  real(rp), pointer :: det_jacobians(:)
  integer(ip) :: qpoint
  type(vector_field_t) :: b
  type(vector_field_t) :: eta
  type(vector_field_t) :: Aeta
  type(vector_field_t) :: x
  integer(ip)   :: idime
  real(rp), pointer :: ref_quad_coords(:,:)
  type(point_t), pointer :: phys_quad_coords(:)

  assert(size(phys_coords_as_point)<=ref_coords_as_quadrature%get_num_quadrature_points())
  assert(fe_quad%get_num_dims() == ref_coords_as_quadrature%get_num_dims())

  ! Check that we have an affine fe map
#ifdef DEBUG
  det_jacobians => cell_map%get_det_jacobians()
  do qpoint = 1, size(det_jacobians)
    massert( abs(det_jacobians(1) - det_jacobians(qpoint)) < 1.0e-13, 'We assume that the FE map is afine')
  end do
#endif

  ! Compute the rhs of the affine cell_map
  qpoint = 1
  ref_quad_coords  => fe_quad%get_coordinates()
  phys_quad_coords => cell_map%get_quadrature_points_coordinates()
  call eta%init(0.0)
  call x%init(0.0)
  do idime = 1, fe_quad%get_num_dims()
    call eta%set(idime,ref_quad_coords(idime,qpoint))
    call x%set(idime,phys_quad_coords(qpoint)%get(idime))
  end do
  Aeta = cell_map%apply_jacobian(qpoint,eta)
  b = x - Aeta

  ! Compute the inverse affine fe map
  ref_quad_coords  => ref_coords_as_quadrature%get_coordinates()
  do qpoint = 1,size(phys_coords_as_point) 
    call x%init(0.0)
    do idime = 1, fe_quad%get_num_dims()
      call x%set(idime,phys_coords_as_point(qpoint)%get(idime))
    end do
    x = x - b
    eta = cell_map%apply_inv_jacobian(1,x)
    do idime = 1, fe_quad%get_num_dims()
      ref_quad_coords(idime,qpoint) = eta%get(idime)
    end do
  end do

end subroutine send_to_reference_space

