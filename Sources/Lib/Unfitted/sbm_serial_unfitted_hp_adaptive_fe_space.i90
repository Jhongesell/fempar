! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine suhpafs_create_same_reference_fes_on_all_cells(&
  this, &
  triangulation, &
  reference_fes, &
  conditions )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  class(conditions_t), target       , optional, intent(in)    :: conditions
  mcheck(.false.,'You cannot create an unfitted fe space with the same reference fe on all cells (you need void and non void ref elems)')
end subroutine suhpafs_create_same_reference_fes_on_all_cells

!========================================================================================
subroutine suhpafs_space_create_different_ref_fes_between_cells(&
    this, &
    triangulation,            &
    reference_fes,            &
    set_ids_to_reference_fes, &
    conditions )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t)                    , intent(inout) :: this
  class(triangulation_t), target  , intent(in)    :: triangulation
  type(p_reference_fe_t)                      , intent(in)    :: reference_fes(:)
  integer(ip)                                 , intent(in)    :: set_ids_to_reference_fes(:,:)
  class(conditions_t), target       , optional, intent(in)    :: conditions
  class(marching_cubes_t), pointer :: marching_cubes
  call this%free()
  call this%serial_hp_adaptive_fe_space_t%create(&
    triangulation,reference_fes,set_ids_to_reference_fes,conditions)
  select type(triangulation)
  class is (unfitted_p4est_serial_triangulation_t)
    this%unfitted_triangulation => triangulation
    marching_cubes => triangulation%get_marching_cubes()
    call this%unfitted_integration%create(this,marching_cubes)
  class default
    check(.false.)
  end select
  call this%allocate_and_fill_aggregate_ids()
end subroutine suhpafs_space_create_different_ref_fes_between_cells

!========================================================================================
subroutine suhpafs_free(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  call this%serial_hp_adaptive_fe_space_t%free()
  this%unfitted_triangulation => null()
  call this%unfitted_integration%free()
  if (allocated(this%aggregate_ids)) then
    call memfree(this%aggregate_ids,__FILE__,__LINE__)
  end if
  this%max_separation_from_root = -1.0_rp
end subroutine suhpafs_free

!========================================================================================
subroutine suhpafs_set_use_constraints(this,use_constraints)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this
  logical, intent(in) :: use_constraints
  this%use_constraints = use_constraints
end subroutine suhpafs_set_use_constraints

!========================================================================================
subroutine suhpafs_create_fe_cell_iterator(this, fe)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(in)    :: this
  class(fe_cell_iterator_t), allocatable, intent(inout) :: fe
  integer(ip) :: istat
  call this%free_fe_cell_iterator(fe)
  allocate(unfitted_hp_adaptive_fe_cell_iterator_t :: fe, stat=istat); check(istat==0)
  call fe%create(this)
end subroutine suhpafs_create_fe_cell_iterator

!========================================================================================
subroutine suhpafs_generate_global_dof_numbering( this, block_layout )
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this 
  type(block_layout_t), target        , intent(inout) :: block_layout
  logical :: perform_numbering
  integer(ip) :: block_id, field_id
  type(block_layout_t), pointer :: p_block_layout

  if (.not. this%use_constraints) then
    ! Call the father
    call this%serial_hp_adaptive_fe_space_t%generate_global_dof_numbering(block_layout)
    return
  end if

  p_block_layout => this%get_block_layout()
  perform_numbering = .not. associated(p_block_layout) 
  if (.not. perform_numbering) perform_numbering = .not. (p_block_layout == block_layout)
  
  if ( perform_numbering ) then
    call this%set_block_layout(block_layout)
  
    !this%num_fixed_dofs = this%get_num_fixed_dofs()
  
    ! Initialize number DoFs per field
    call this%allocate_num_dofs_x_field()
    do field_id=1, this%get_num_fields()
      call this%set_field_num_dofs(field_id, 0)
    end do
  
    ! Initialize number DoFs per block
    do block_id=1, this%get_num_blocks()
      call this%set_block_num_dofs(block_id, 0)
    end do
  
    ! Generate field-wise/block-wise global DoF identifiers
    do field_id = 1, this%get_num_fields()
      call this%fill_fe_dofs_and_count_dofs( field_id )
    end do
  
    !call this%setup_hanging_node_constraints()
    call this%setup_cut_cells_constraints()
  end if  

end subroutine suhpafs_generate_global_dof_numbering

!========================================================================================
subroutine suhpafs_procedure_fill_fe_dofs_and_count_dofs( this, field_id ) 
  implicit none
  ! Parameters
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout) :: this 
  integer(ip)                         ,  intent(in)   :: field_id

  ! TODO: This code is almost replicated from the father. Surely, there are better ways to do that.
  
  ! Local variables
  integer(ip) :: ivef, vef_lid
  integer(ip) :: iblock, init_dof_block, current_dof_block, previous_dof_block
  integer(ip) :: init_fixed_dof, current_fixed_dof, previous_fixed_dof
  integer(ip), allocatable :: visited_proper_vef_to_cell_map(:,:)
  integer(ip), allocatable :: visited_improper_vef_to_cell_map(:,:)
  
  class(fe_cell_iterator_t) , allocatable :: fe, source_fe, coarser_fe
  type(fe_vef_iterator_t) :: vef
  integer(ip), pointer :: field_blocks(:)
  integer(ip), pointer :: fe_space_type_x_field(:)

  logical :: all_improper_cells_around_void, is_owner
  integer(ip) :: source_cell_id
  integer(ip) :: source_vef_lid  
  integer(ip) :: icell_improper_around

  if (.not. this%use_constraints) then
    ! Call the father
    call this%serial_hp_adaptive_fe_space_t%fill_fe_dofs_and_count_dofs(field_id)
    return
  end if

  field_blocks            => this%get_field_blocks()
  fe_space_type_x_field => this%get_fe_space_type()
  iblock            = field_blocks(field_id)
  init_dof_block    = this%get_block_num_dofs(iblock)
  current_dof_block = init_dof_block
  
  init_fixed_dof    = this%num_fixed_dofs
  current_fixed_dof = init_fixed_dof

  call this%create_fe_cell_iterator(fe)
  if ( fe_space_type_x_field(field_id) == fe_space_type_cg ) then
     call memalloc ( 2, this%p4est_triangulation%get_num_proper_vefs(), visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
     call memalloc ( 2, this%p4est_triangulation%get_num_proper_vefs(), visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
     visited_proper_vef_to_cell_map = -1
     visited_improper_vef_to_cell_map = -1
     
     call this%create_fe_vef_iterator(vef)
     call this%create_fe_cell_iterator(source_fe)
     call this%create_fe_cell_iterator(coarser_fe)


     ! First process the local, non-cut cells as always
     do while ( .not. fe%has_finished())
       if ( fe%is_local() .and. (.not. fe%is_cut()) ) then
         call fe%generate_own_dofs_cell ( field_id, current_dof_block )
         do ivef = 1, fe%get_num_vefs()
           call fe%get_vef(ivef,vef)

           all_improper_cells_around_void=.true.
           do icell_improper_around=1, vef%get_num_improper_cells_around()
             call vef%get_improper_cell_around(icell_improper_around,coarser_fe)
             if (.not. coarser_fe%is_void(field_id)) then 
               all_improper_cells_around_void=.false.
               exit
             end if
           end do

           if ( vef%is_proper() .or. all_improper_cells_around_void ) then

             vef_lid = abs(fe%get_vef_gid(ivef))
             is_owner = .false.
             if ( vef%is_proper()) then
               is_owner = ( visited_proper_vef_to_cell_map   ( 1, vef_lid ) == -1 )
             else
               is_owner = ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 )
             end if

             if ( is_owner ) then
               previous_dof_block = current_dof_block
               call fe%generate_own_dofs_vef ( ivef, field_id, current_dof_block, free_dofs_loop=.true.  )
               if (previous_dof_block < current_dof_block) then
                 if ( vef%is_proper()) then
                   visited_proper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                   visited_proper_vef_to_cell_map ( 2, vef_lid ) = ivef
                 else
                   visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                   visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
                 end if
               end if
             else 
               if ( vef%is_proper()) then
                 source_cell_id = visited_proper_vef_to_cell_map(1,vef_lid)
                 source_vef_lid = visited_proper_vef_to_cell_map(2,vef_lid)
               else
                 source_cell_id = visited_improper_vef_to_cell_map(1,vef_lid)
                 source_vef_lid = visited_improper_vef_to_cell_map(2,vef_lid)
               end if
               call source_fe%set_gid(source_cell_id)
               call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
             end if
           else 
             mcheck(.false.,'For the moment that the only interior constained nodes are the ones of cut cells. I.e., no hanging nodes in the interior allowed')
             assert ( fe%get_vef_gid(ivef) < 0 )
             vef_lid = abs(fe%get_vef_gid(ivef))
             if ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 ) then
               previous_fixed_dof = current_fixed_dof
               call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.  )
               if (previous_fixed_dof < current_fixed_dof) then
                 visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                 visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
               end if
             else 
               call source_fe%set_gid(visited_improper_vef_to_cell_map(1,vef_lid))
               call fe%fetch_own_dofs_vef_from_source_fe ( ivef, &
                 source_fe, &
                 visited_improper_vef_to_cell_map(2,vef_lid), &
                 field_id) 
             end if
           end if   
         end do
       end if 
       call fe%determine_has_fixed_dofs(field_id)
       call fe%next()
     end do

     ! Then, process all the cut cells
     call fe%first()
     do while ( .not. fe%has_finished())
       if ( fe%is_local() .and. fe%is_cut() )  then
         call fe%generate_own_dofs_cell ( field_id, current_fixed_dof, are_free_dofs = .false. )
         do ivef = 1, fe%get_num_vefs()
           call fe%get_vef(ivef,vef)

           vef_lid = abs(fe%get_vef_gid(ivef))
           is_owner = .false.
           if ( vef%is_proper()) then
             is_owner = ( visited_proper_vef_to_cell_map   ( 1, vef_lid ) == -1 )
           else
             is_owner = ( visited_improper_vef_to_cell_map ( 1, vef_lid ) == -1 )
           end if

           if ( is_owner ) then
             previous_fixed_dof = current_fixed_dof
             call fe%generate_own_dofs_vef ( ivef, field_id, current_fixed_dof, free_dofs_loop=.false.  )
             if (previous_fixed_dof < current_fixed_dof) then
               if ( vef%is_proper()) then
                 visited_proper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                 visited_proper_vef_to_cell_map ( 2, vef_lid ) = ivef
               else
                 visited_improper_vef_to_cell_map ( 1, vef_lid ) = fe%get_gid()
                 visited_improper_vef_to_cell_map ( 2, vef_lid ) = ivef
               end if
             end if
           else 
             if ( vef%is_proper()) then
               source_cell_id = visited_proper_vef_to_cell_map(1,vef_lid)
               source_vef_lid = visited_proper_vef_to_cell_map(2,vef_lid)
             else
               source_cell_id = visited_improper_vef_to_cell_map(1,vef_lid)
               source_vef_lid = visited_improper_vef_to_cell_map(2,vef_lid)
             end if
             call source_fe%set_gid(source_cell_id)
             call fe%fetch_own_dofs_vef_from_source_fe ( ivef, source_fe, source_vef_lid, field_id ) 
           end if

         end do
       end if 
       call fe%determine_has_fixed_dofs(field_id)
       call fe%next()
     end do

     call this%free_fe_cell_iterator(source_fe)
     call this%free_fe_cell_iterator(coarser_fe)
     call this%free_fe_vef_iterator(vef)
     call memfree ( visited_proper_vef_to_cell_map  ,  __FILE__, __LINE__ )
     call memfree ( visited_improper_vef_to_cell_map,  __FILE__, __LINE__ )
  else    
     ! TODO: this code is a verbatim copy of the one of its parent.
     !       we should better split the parent into additional TBPs
     !       to avoid code replication
     do while ( .not. fe%has_finished())
        if ( fe%is_local() ) then
           call fe%generate_own_dofs_cell ( field_id, current_dof_block )
        end if
        call fe%next()
     end do
  end if
  call this%free_fe_cell_iterator(fe)

  call this%set_field_num_dofs(field_id,current_dof_block - init_dof_block)
  call this%set_block_num_dofs(iblock, this%get_block_num_dofs(iblock) + & 
                                          this%get_field_num_dofs(field_id))
  
  !this%num_fixed_dofs = this%num_fixed_dofs + current_fixed_dof - init_fixed_dof
  this%num_hanging_dofs = current_fixed_dof - init_fixed_dof
  this%num_fixed_dofs = current_fixed_dof
end subroutine suhpafs_procedure_fill_fe_dofs_and_count_dofs

!========================================================================================
function suhpafs_get_aggregate_ids(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  integer(ip), pointer :: suhpafs_get_aggregate_ids(:)
  suhpafs_get_aggregate_ids => this%aggregate_ids
end function suhpafs_get_aggregate_ids

!========================================================================================
function suhpafs_get_max_separation_from_root(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), target, intent(in)    :: this
  real(rp) :: suhpafs_get_max_separation_from_root
  suhpafs_get_max_separation_from_root = this%max_separation_from_root
end function suhpafs_get_max_separation_from_root

!========================================================================================
subroutine suhpafs_allocate_and_fill_aggregate_ids(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout)    :: this

  class(cell_iterator_t), allocatable :: cell
  class(cell_iterator_t), allocatable :: cell_arround
  integer(ip), parameter :: max_num_sweeps = 5
  integer(ip) :: isweep
  logical ::  is_needed 
  logical :: has_been_aggregated
  integer(ip) :: icell_arround
  class(triangulation_t), pointer :: triangulation
  class(vef_iterator_t), allocatable :: vef
  integer(ip) :: ivef
  integer(ip) :: ifacet
  integer(ip), allocatable :: tent_distance(:)
  integer(ip), allocatable :: min_distance(:)
  integer(ip) :: min_distance_aggr_id

  integer(ip), allocatable :: distance(:,:)
  integer(ip), target :: face2dir_2d(4,2) = reshape([0,0,1,-1,1,-1,0,0],[4,2])
  integer(ip), target :: face2dir_3d(6,3) = reshape([ 0, 0, 0, 0, 1,-1,&
                                                      0, 0, 1,-1, 0, 0,&
                                                      1,-1, 0, 0, 0, 0],[6,3])
  integer(ip), pointer :: face2dir(:,:)

  triangulation => this%get_triangulation()
  call memalloc(triangulation%get_num_local_cells(),this%aggregate_ids,__FILE__,__LINE__)

  if (.not. this%use_constraints) then
    this%aggregate_ids(:) = 0
    return
  end if

  if (triangulation%get_num_dims() == 2) then
    face2dir => face2dir_2d
  else if (triangulation%get_num_dims() == 3) then
    face2dir => face2dir_3d
  else
    mcheck(.false.,'Only for 3D and 2D')
  end if

  this%max_separation_from_root = 0.0_rp

  call memalloc(triangulation%get_num_local_cells(),triangulation%get_num_dims(),distance,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_dims(),tent_distance,__FILE__,__LINE__)
  call memalloc(triangulation%get_num_dims(),min_distance,__FILE__,__LINE__)

  call triangulation%create_cell_iterator(cell)
  call triangulation%create_cell_iterator(cell_arround)
  call triangulation%create_vef_iterator(vef)

  ! Initialize by setting the roots of the aggregates
  do while (.not. cell%has_finished())
    if (cell%is_local()) then
      if (cell%is_interior()) then
        this%aggregate_ids(cell%get_gid()) = cell%get_gid()
        distance(cell%get_gid(),:) = 0
      else
        this%aggregate_ids(cell%get_gid()) = 0
      end if
    end if
    call cell%next()
  end do

  is_needed = .true.
  isweep = 1
  do while (is_needed)

    ! Check that we not reach the max num of sweeps allowed
    wassert(isweep <= max_num_sweeps, 'Max number of sweeps reached in the cut cell agglometarion algorithm. Refine your mesh!')
    if (isweep > max_num_sweeps) exit

    ! Glue to the neighbors
    call cell%first()
    is_needed = .false.
    do while (.not. cell%has_finished())
      if (cell%is_local()) then
        if ( cell%is_cut() .and. (this%aggregate_ids(cell%get_gid()) == 0) ) then

          ! TODO: We try to glue only by true neighbors
          ! For adaptive meshes, shall we look for improper neighbors as well?

          ! Glue to the face-neighbor with the smallest distance to a full element
          min_distance(:) = 99999999
          min_distance_aggr_id = 0
          ifacet = 0
          do ivef = 1, cell%get_num_vefs()
            call cell%get_vef(ivef,vef)
            if ( .not. vef%is_facet() ) cycle
            ifacet = ifacet + 1
            do icell_arround = 1,vef%get_num_cells_around()
              call vef%get_cell_around(icell_arround,cell_arround)
              if ( (isweep == 1) .and. (.not. cell_arround%is_interior()) ) cycle
              if ( this%aggregate_ids(cell_arround%get_gid()) > 0 ) then

                ! Compute the movement to reach the root element
                tent_distance = distance(cell_arround%get_gid(),:) + face2dir(ifacet,:)

                ! Find which is the best neighbor to glue into
                if ( norm2(real(tent_distance,kind=rp)) < norm2(real(min_distance,kind=rp)) ) then
                  min_distance =  tent_distance
                  min_distance_aggr_id = this%aggregate_ids(cell_arround%get_gid())
                end if

              end if
            end do
          end do

          if (min_distance_aggr_id == 0) then
            is_needed = .true.
          else
            this%aggregate_ids(cell%get_gid()) = min_distance_aggr_id
            distance(cell%get_gid(),:) = min_distance
            this%max_separation_from_root = max(this%max_separation_from_root,norm2(real(min_distance,kind=rp)))
          end if

        end if
      end if
      call cell%next()
    end do

    isweep = isweep + 1
  end do

  call triangulation%free_cell_iterator(cell)
  call triangulation%free_cell_iterator(cell_arround)
  call triangulation%free_vef_iterator(vef)

  call memfree(tent_distance,__FILE__,__LINE__)
  call memfree(min_distance,__FILE__,__LINE__)
  call memfree(distance,__FILE__,__LINE__)

end subroutine suhpafs_allocate_and_fill_aggregate_ids

!========================================================================================
subroutine suhpafs_setup_cut_cells_constraints(this)
  implicit none
  class(serial_unfitted_hp_adaptive_fe_space_t), intent(inout)    :: this

  ! UNDER QUARANTINE: TO BE UNCOMMENTED AND FIXED (eneiva help)
  integer(ip) :: improper_dof_lid
  integer(ip) :: hanging_dof_lid
  class(fe_cell_iterator_t), allocatable :: fe
  class(fe_cell_iterator_t), allocatable :: root_fe
  integer(ip) :: field_id
  integer(ip), pointer :: fe_dofs(:)
  integer(ip), pointer :: root_fe_dofs(:)
  integer(ip) :: idof, root_idof
  integer(ip) :: num_free_dofs_in_root
  integer(ip) :: num_diri_dofs_in_root
  integer(ip) :: current_pos_free
  integer(ip) :: current_pos_diri
  class(reference_fe_t), pointer :: reference_fe
  class(reference_fe_t), pointer :: root_reference_fe
  class(reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quad_ref_fe
  type(cell_map_t) :: cell_map
  type(cell_map_t), pointer :: root_cell_map
  type(quadrature_t), pointer :: root_fe_quad
  integer(ip) :: iaux
  type(point_t), pointer :: coordinates_nodes_cut_cell(:)
  type(cell_integrator_t) :: cell_integrator
  type(quadrature_t) :: nodal_quad_in_root_fe
  class(triangulation_t), pointer :: triangulation
  real(rp), allocatable  :: shape_values(:,:)
  type(point_t), pointer :: coordinates(:)
  integer(ip) :: istat
  logical, allocatable :: visited_hanging_dof_lids(:)

  field_id = 1
  mcheck(this%get_num_fields() == 1, 'Procedure implemented currently for a single field')
  mcheck(this%get_field_type(field_id) == field_type_scalar, 'Procedure implemented currently for scalar fields')

  ! Auxiliary
  triangulation => this%get_triangulation()
  call nodal_quad_in_root_fe%create(triangulation%get_num_dims(),this%get_max_num_shape_functions())

  call memalloc(this%num_hanging_dofs,visited_hanging_dof_lids,__FILE__,__LINE__)
  
  !Fill the sizes of each sub-list

  ! Init to 0
  ! Re-size to 0 to force re-initialization during second resize (to the actual/correct size)
  call this%ptr_constraining_free_dofs%resize(0)
  call this%ptr_constraining_dirichlet_dofs%resize(0)
  call this%ptr_constraining_free_dofs%resize(this%num_hanging_dofs+1,0)
  call this%ptr_constraining_dirichlet_dofs%resize(this%num_hanging_dofs+1,0)


  ! In our case, this is 0
  call this%constraints_independent_term%resize(this%num_hanging_dofs)
  do iaux = 1,this%num_hanging_dofs
    call this%constraints_independent_term%set(iaux,0.0_rp)
  end do



  ! Nodes in cut cells might depend on several nodes of their root cell. Count them!
  ! (We skip Dirichlet Dofs since they are already taken into account in previous loop)
  call this%create_fe_cell_iterator(fe)
  call this%create_fe_cell_iterator(root_fe)
  visited_hanging_dof_lids(:) = .false.
  do while (.not. fe%has_finished())
    if ( fe%is_local() .and. fe%is_cut() ) then

      call root_fe%set_gid(this%aggregate_ids(fe%get_gid()))

      call fe%get_field_fe_dofs(field_id, fe_dofs)
      call root_fe%get_field_fe_dofs(field_id, root_fe_dofs)

      num_free_dofs_in_root = count(root_fe_dofs>0,kind=ip)
      num_diri_dofs_in_root = count(root_fe_dofs<0,kind=ip)

      ! TODO
      ! num_hang_dofs_in_root = ...
      ! num_diri_dofs_in_root = count(root_fe_dofs<0,kind=ip) - num_hang_dofs_in_root
      ! Then, add how many free and diri nodes the root hanging nodes depend on

      do idof = 1, size(fe_dofs)
        if ( fe%is_fixed_dof(fe_dofs(idof)) .and. (.not. fe%is_strong_dirichlet_dof(fe_dofs(idof))) ) then
          improper_dof_lid = abs(fe_dofs(idof))
          hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs
          if ( .not. visited_hanging_dof_lids(hanging_dof_lid) ) then
            call this%ptr_constraining_free_dofs%set(hanging_dof_lid+1, num_free_dofs_in_root )
            call this%ptr_constraining_dirichlet_dofs%set(hanging_dof_lid+1, num_diri_dofs_in_root )
            visited_hanging_dof_lids(hanging_dof_lid) = .true.
          end if
        end if
      end do

    end if
    ! Needed?
    call fe%determine_has_hanging_dofs(field_id)
    call fe%next()
  end do

  ! Create the header from the sizes
  call this%p4est_triangulation%std_vector_transform_length_to_header(this%ptr_constraining_free_dofs)
  call this%p4est_triangulation%std_vector_transform_length_to_header(this%ptr_constraining_dirichlet_dofs)

  ! Allocate the vectors containing the raw data

  call this%constraining_free_dofs%resize&
    (this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)
  call this%constraining_free_dofs_coefficients%resize&
    (this%ptr_constraining_free_dofs%get(this%ptr_constraining_free_dofs%size())-1)

  call this%constraining_dirichlet_dofs%resize&
    (this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)
  call this%constraining_dirichlet_dofs_coefficients%resize&
    (this%ptr_constraining_dirichlet_dofs%get(this%ptr_constraining_dirichlet_dofs%size())-1)

  ! Compute dependencies and coefficients for the rest of constraints
  call fe%first()
  iaux = 1
  visited_hanging_dof_lids(:) = .false.
  do while (.not. fe%has_finished())
    if ( fe%is_local() .and. fe%is_cut() ) then

      call root_fe%set_gid(this%aggregate_ids(fe%get_gid()))

      call fe%get_field_fe_dofs(field_id, fe_dofs)
      call root_fe%get_field_fe_dofs(field_id, root_fe_dofs)

      ! Get the coordinates in the reference space of the nodes associated to the cut cell shape functions
      reference_fe => fe%get_reference_fe(field_id)
      massert(reference_fe%has_nodal_quadrature(),'This routine only work for interpolatory FEs.')
      nodal_quad_ref_fe => reference_fe%get_nodal_quadrature()

      ! Transform them to the physical space
      reference_fe_geo => fe%get_reference_fe_geo()
      if (iaux == 1) then
        call cell_map%create(nodal_quad_ref_fe,reference_fe_geo)
      else
        call cell_map%update_interpolation(nodal_quad_ref_fe,reference_fe_geo)
      end if
      coordinates => cell_map%get_coordinates()
      call fe%get_nodes_coordinates(coordinates)
      call cell_map%compute_quadrature_points_coordinates()
      coordinates_nodes_cut_cell => cell_map%get_quadrature_points_coordinates()

      ! Transform back to the reference space of the root_fe
      call root_fe%update_integration()
      root_fe_quad => root_fe%get_quadrature()
      root_cell_map  => root_fe%get_cell_map()
      call send_to_reference_space(coordinates_nodes_cut_cell,root_fe_quad,root_cell_map,nodal_quad_in_root_fe)

      ! Evaluate the root_fe shape functions at these points
      root_reference_fe => root_fe%get_reference_fe(field_id)
      if (iaux == 1) then
        call cell_integrator%create(nodal_quad_in_root_fe,root_reference_fe)
      else
        call cell_integrator%update_interpolation(nodal_quad_in_root_fe)
      end if
      call cell_integrator%update(root_cell_map)
      call cell_integrator%get_values(shape_values)

      do idof = 1, size(fe_dofs)
        if ( fe%is_fixed_dof(fe_dofs(idof)) .and. (.not. fe%is_strong_dirichlet_dof(fe_dofs(idof))) ) then
          improper_dof_lid = abs(fe_dofs(idof))
          hanging_dof_lid  = improper_dof_lid - this%num_dirichlet_dofs
          if ( .not. visited_hanging_dof_lids(hanging_dof_lid) ) then
            current_pos_free = this%ptr_constraining_free_dofs%get(hanging_dof_lid)
            current_pos_diri = this%ptr_constraining_dirichlet_dofs%get(hanging_dof_lid)
            do root_idof = 1,size(root_fe_dofs)
              if (root_fe_dofs(root_idof)>0) then
                call this%constraining_free_dofs%set(current_pos_free,root_fe_dofs(root_idof))
                call this%constraining_free_dofs_coefficients%set(current_pos_free,shape_values(root_idof,idof))
                current_pos_free = current_pos_free + 1
              else if (root_fe_dofs(root_idof)<0) then
                call this%constraining_dirichlet_dofs%set(current_pos_diri,root_fe_dofs(root_idof))
                call this%constraining_dirichlet_dofs_coefficients%set(current_pos_diri,shape_values(root_idof,idof))
                current_pos_diri = current_pos_diri + 1
              else
                mcheck(.false.,'Dof cannot be zero')
              end if
            end do
            visited_hanging_dof_lids(hanging_dof_lid) = .true.
          end if
        end if
      end do

      iaux = iaux + 1
    end if
    call fe%next()
  end do

  call this%free_fe_cell_iterator(fe)
  call this%free_fe_cell_iterator(root_fe)
  call cell_map%free()
  call cell_integrator%free()
  call nodal_quad_in_root_fe%free()
  call memfree(shape_values,__FILE__,__LINE__)
  call memfree(visited_hanging_dof_lids,__FILE__,__LINE__)

end subroutine suhpafs_setup_cut_cells_constraints


!========================================================================================
subroutine send_to_reference_space(phys_coords_as_point,fe_quad,cell_map,ref_coords_as_quadrature)
  implicit none
  type(point_t),      intent(in)    :: phys_coords_as_point(:)
  type(quadrature_t), intent(in)    :: fe_quad
  type(cell_map_t),     intent(in)    :: cell_map
  type(quadrature_t), intent(inout) :: ref_coords_as_quadrature

  real(rp), pointer :: det_jacobians(:)
  integer(ip) :: qpoint
  type(vector_field_t) :: b
  type(vector_field_t) :: eta
  type(vector_field_t) :: Aeta
  type(vector_field_t) :: x
  integer(ip)   :: idime
  real(rp), pointer :: ref_quad_coords(:,:)
  type(point_t), pointer :: phys_quad_coords(:)

  assert(size(phys_coords_as_point)<=ref_coords_as_quadrature%get_num_quadrature_points())
  assert(fe_quad%get_num_dims() == ref_coords_as_quadrature%get_num_dims())

  ! Check that we have an affine fe map
#ifdef DEBUG
  det_jacobians => cell_map%get_det_jacobians()
  do qpoint = 1, size(det_jacobians)
    massert( abs(det_jacobians(1) - det_jacobians(qpoint)) < 1.0e-13, 'We assume that the FE map is afine')
  end do
#endif

  ! Compute the rhs of the affine cell_map
  qpoint = 1
  ref_quad_coords  => fe_quad%get_coordinates()
  phys_quad_coords => cell_map%get_quadrature_points_coordinates()
  call eta%init(0.0)
  call x%init(0.0)
  do idime = 1, fe_quad%get_num_dims()
    call eta%set(idime,ref_quad_coords(idime,qpoint))
    call x%set(idime,phys_quad_coords(qpoint)%get(idime))
  end do
  Aeta = cell_map%apply_jacobian(qpoint,eta)
  b = x - Aeta

  ! Compute the inverse affine fe map
  ref_quad_coords  => ref_coords_as_quadrature%get_coordinates()
  do qpoint = 1,size(phys_coords_as_point) 
    call x%init(0.0)
    do idime = 1, fe_quad%get_num_dims()
      call x%set(idime,phys_coords_as_point(qpoint)%get(idime))
    end do
    x = x - b
    eta = cell_map%apply_inv_jacobian(1,x)
    do idime = 1, fe_quad%get_num_dims()
      ref_quad_coords(idime,qpoint) = eta%get(idime)
    end do
  end do

end subroutine send_to_reference_space

