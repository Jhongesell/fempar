 ! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine marching_cubes_create(this, triangulation, level_set_function)
  implicit none
  class(marching_cubes_t),            target,  intent(inout)  :: this
  class(base_static_triangulation_t), target,  intent(in)     :: triangulation
  class(level_set_function_t),        target,  intent(in)     :: level_set_function
  type(environment_t), pointer           :: par_environment
  call this%free()
  par_environment => triangulation%get_par_environment()
  this%triangulation => triangulation
  if ( par_environment%am_i_l1_task() ) then
    assert(this%fulfills_assumptions())
    this%level_set_function => level_set_function
    call this%mc_tables_create()
    call this%mc_runtime_info_create()
    call this%subnodes_data_create()
  end if
end subroutine marching_cubes_create

!========================================================================================
subroutine marching_cubes_free(this)
  implicit none
  class(marching_cubes_t), target, intent(inout) :: this
  this%triangulation => null()
  this%level_set_function => null()
  call this%mc_tables_free()
  call this%mc_runtime_info_free()
  call this%subnodes_data_free()
end subroutine marching_cubes_free

!========================================================================================
function marching_cubes_create_unfitted_cell_iterator ( this ) result (cell_iter)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  type(unfitted_cell_iterator_t) :: cell_iter
  call cell_iter%create(1, this)
end function marching_cubes_create_unfitted_cell_iterator

!========================================================================================
function marching_cubes_get_num_cut_cells( this ) result ( num_cut_cells )

  implicit none
  class(marching_cubes_t), intent(in)    :: this

  integer(ip) :: num_cut_cells
  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_cut_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_cut() ) then
      num_cut_cells = num_cut_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_num_cut_cells

!========================================================================================
function marching_cubes_get_num_interior_cells( this ) result ( num_interior_cells )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: num_interior_cells

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_interior_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_interior() ) then
      num_interior_cells = num_interior_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_num_interior_cells

!========================================================================================
function marching_cubes_get_num_exterior_cells( this ) result ( num_exterior_cells )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: num_exterior_cells

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_exterior_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_exterior() ) then
      num_exterior_cells = num_exterior_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_num_exterior_cells

!========================================================================================
function marching_cubes_get_max_num_subcells_in_cell( this ) result ( max_subcells_in_cell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_subcells_in_cell
  max_subcells_in_cell = this%mc_table_max_num_subcells
end function marching_cubes_get_max_num_subcells_in_cell

!========================================================================================
function marching_cubes_get_max_num_nodes_in_subcell( this ) result ( max_nodes_in_subcell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_nodes_in_subcell
  max_nodes_in_subcell = this%mc_table_num_nodes_subcell
end function marching_cubes_get_max_num_nodes_in_subcell

!========================================================================================
function marching_cubes_get_total_num_of_subcells( this ) result ( total_num )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: total_num

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  total_num = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    call cell%update_sub_triangulation()
    total_num = total_num + cell%get_number_of_subcells()
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_total_num_of_subcells

!========================================================================================
function marching_cubes_get_max_num_subfaces_in_cell( this ) result ( max_subfaces_in_cell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_subfaces_in_cell
  max_subfaces_in_cell = this%mc_table_max_num_subfaces
end function marching_cubes_get_max_num_subfaces_in_cell

!========================================================================================
function marching_cubes_get_max_num_nodes_in_subface( this ) result ( max_nodes_in_subface)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_nodes_in_subface
  max_nodes_in_subface = this%mc_table_num_nodes_subface
end function marching_cubes_get_max_num_nodes_in_subface

!========================================================================================
function marching_cubes_get_total_num_of_subfaces( this ) result ( total_num )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: total_num

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  total_num = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    call cell%update_sub_triangulation()
    total_num = total_num + cell%get_number_of_subfaces()
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_total_num_of_subfaces

!========================================================================================
function marching_cubes_get_max_num_subnodes_in_cell( this ) result ( max_subnodes_in_cell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_subnodes_in_cell
  max_subnodes_in_cell = this%triangulation%get_max_number_shape_functions() + this%mc_table_max_num_cut_edges
end function marching_cubes_get_max_num_subnodes_in_cell

!========================================================================================
function marching_cubes_get_num_dimensions(this) result (val)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: val
  val = this%triangulation%get_num_dimensions()
end function marching_cubes_get_num_dimensions

!========================================================================================
function marching_cubes_get_num_mc_cases(this) result (mc_cases)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: mc_cases
  mc_cases = this%mc_table_num_cases
end function marching_cubes_get_num_mc_cases

!========================================================================================
function marching_cubes_get_num_subcells_mc_case(this,mc_case) result (num_subcells)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip), intent(in) :: mc_case
  integer(ip) :: num_subcells
  num_subcells = this%mc_table_num_subcells_per_case(mc_case)
end function marching_cubes_get_num_subcells_mc_case

!========================================================================================
function marching_cubes_get_num_subfaces_mc_case(this,mc_case) result (num_subfaces)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip), intent(in) :: mc_case
  integer(ip) :: num_subfaces
  num_subfaces = this%mc_table_num_subfaces_per_case(mc_case)
end function marching_cubes_get_num_subfaces_mc_case

!========================================================================================
subroutine marching_cubes_print ( this )

  implicit none
  class(marching_cubes_t), intent(in)    :: this

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell
  type(point_t), allocatable, dimension(:) :: cell_coords, subcell_coords, subface_coords
  integer(ip) :: inode, isubcell, isubface

  ! Print basic info of triangulation
  write(*,*) " "
  write (*,'(a)') '**** print type(marching_cubes_t) [begin] ****'
  write(*,*) " "
  write (*,'(a,i10)') 'num_dimensions:           ', this%triangulation%get_num_dimensions()
  write (*,'(a,i10)') 'num_cells:                ', this%triangulation%get_num_cells()
  write (*,'(a,i10)') 'num_local_cells:          ', this%triangulation%get_num_local_cells()
  write (*,'(a,i10)') 'num_ghost_cells:          ', this%triangulation%get_num_ghost_cells()
  write (*,'(a,i10)') 'num_cut_cells:            ', this%get_num_cut_cells()
  write (*,'(a,i10)') 'num_interior_cells:       ', this%get_num_interior_cells()
  write (*,'(a,i10)') 'num_exterior_cells:       ', this%get_num_exterior_cells()
  write (*,'(a,i10)') 'max_num_nodes_in_cell:    ', this%triangulation%get_max_number_shape_functions()
  write (*,'(a,i10)') 'max_num_subcells_in_cell: ', this%get_max_num_subcells_in_cell()
  write (*,'(a,i10)') 'max_num_nodes_in_subcell: ', this%get_max_num_nodes_in_subcell()
  write (*,'(a,i10)') 'max_num_subfaces_in_cell: ', this%get_max_num_subfaces_in_cell()
  write (*,'(a,i10)') 'max_num_nodes_in_subface: ', this%get_max_num_nodes_in_subface()
  write (*,'(a,i10)') 'max_num_subnodes_in_cell: ', this%get_max_num_subnodes_in_cell()
  write(*,*) " "

  ! Print basic info of cells
  cell_iter = this%create_unfitted_cell_iterator()
  write(*,'(7a20)') 'id', 'is_cut', 'is_interior', 'is_exterior', 'num_nodes' , 'num_subcells', 'num_nodes_subcell'
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    write(*,'(i20,3L20,3i20)') cell%get_lid(), cell%is_cut(), cell%is_interior(), cell%is_exterior(), &
                               cell%get_num_nodes(), cell%get_number_of_subcells(), cell%get_number_of_subcell_nodes()
    call cell_iter%next()
  end do
  write(*,*) " "

  call memalloc( this%triangulation%get_max_number_shape_functions(), cell_coords   , __FILE__, __LINE__ )
  call memalloc( this%get_max_num_nodes_in_subcell()  , subcell_coords, __FILE__, __LINE__ )
  call memalloc( this%get_max_num_nodes_in_subface()  , subface_coords, __FILE__, __LINE__ )

  ! Print coordinates of cells and sub-cells
  write(*,'(3a7,7a11)') 'id', 'scid', 'sfid', 'x1', 'y1', 'z1', 'x2', 'y2', 'z2', 'etc.'
  call cell_iter%init()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    ! TODO where is the safe place to put this update?
    call cell%update_sub_triangulation()
    call cell%get_coordinates( cell_coords )
    write (*,'(i7,2a7,20(2x,e9.2))'  ) cell%get_lid(), ' ', ' ',(cell_coords(inode)%get_value(),inode=1,cell%get_num_nodes())
    do isubcell = 1, cell%get_number_of_subcells()
      call cell%get_phys_coords_of_subcell(isubcell,subcell_coords)
      write (*,'(a7,i7,a7,20(2x,e9.2))'  ) ' ', isubcell, ' ' ,(subcell_coords(inode)%get_value(),inode=1,cell%get_number_of_subcell_nodes())
    end do
    do isubface = 1, cell%get_number_of_subfaces()
      call cell%get_phys_coords_of_subface(isubface,subface_coords)
      write (*,'(2a7,i7,20(2x,e9.2))'  ) ' ', ' ' , isubface,(subface_coords(inode)%get_value(),inode=1,cell%get_number_of_subface_nodes())
    end do
    call cell_iter%next()
  end do

  write(*,*) " "
  write (*,'(a)') '**** print type(marching_cubes_t) [end] ****'
  write(*,*) " "

 call memfree( cell_coords   , __FILE__, __LINE__ )
 call memfree( subcell_coords, __FILE__, __LINE__ )
 call memfree( subface_coords, __FILE__, __LINE__ )
 call cell_iter%free()

end subroutine marching_cubes_print

! Private TBP

!========================================================================================
function marching_cubes_fulfills_assumptions(this) result (fulfills)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  logical :: fulfills

  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  character(:),                 allocatable :: topology
  integer(ip)                               :: num_dim, num_dim_tmp, p_order

  ! Hypothesis: All cells in the mesh are either bi-linear qua or tri-linear hex
  fulfills = .true.
  cell_iter= this%triangulation%create_cell_iterator()
  num_dim  = this%triangulation%get_num_dimensions()
  if ( (num_dim .ne. 2) .and. (num_dim .ne. 3) ) fulfills = .false.
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if (cell%is_local()) then
      reference_fe_geo => cell%get_reference_fe_geo()
      num_dim_tmp  = reference_fe_geo%get_number_dimensions()
      if (num_dim .ne. num_dim_tmp) fulfills = .false.
      p_order  = reference_fe_geo%get_order()
      if (p_order .ne. 1_ip) fulfills = .false.
      topology = reference_fe_geo%get_topology()
      if (topology .ne. topology_hex) fulfills = .false.
      if (.not. fulfills) exit
    end if
    call cell_iter%next()
  end do

end function marching_cubes_fulfills_assumptions

!========================================================================================
subroutine marching_cubes_mc_tables_create(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: num_dim

  ! To be safe
  call this%mc_tables_free()

  ! Get element type, we assume hex-like topology
  num_dim  = this%triangulation%get_num_dimensions()

  ! Fill in the sizes of the tables
  if (num_dim == 2_ip) then
    this%mc_table_num_cases         = MC_QUA4_NUM_CASES
    this%mc_table_max_num_subcells  = MC_QUA4_MAX_NUM_SUBCELLS
    this%mc_table_max_num_subfaces  = MC_QUA4_MAX_NUM_SUBFACES
    this%mc_table_max_num_cut_edges = MC_QUA4_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_QUA4_NUM_NODES_PER_SUBCELL
    this%mc_table_num_nodes_subface = MC_QUA4_NUM_NODES_PER_SUBFACE
  else
    this%mc_table_num_cases         = MC_HEX8_NUM_CASES
    this%mc_table_max_num_subcells  = MC_HEX8_MAX_NUM_SUBCELLS
    this%mc_table_max_num_subfaces  = MC_HEX8_MAX_NUM_SUBFACES
    this%mc_table_max_num_cut_edges = MC_HEX8_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_HEX8_NUM_NODES_PER_SUBCELL
    this%mc_table_num_nodes_subface = MC_HEX8_NUM_NODES_PER_SUBFACE
  end if

  ! Now, we know the sizes and can allocate
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_subcells_per_case    , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_subfaces_per_case    , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__ )

  call memalloc (this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_nodes_subcell, this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_nodes_subface, this%mc_table_max_num_subfaces, this%mc_table_num_cases, &
                 this%mc_table_subface_node_ids_per_case, __FILE__, __LINE__ )

  ! Fill tables for the selected element type
  if (num_dim == 2_ip) then
    this%mc_table_num_subcells_per_case(:)      = MC_QUA4_NUM_SUBCELLS_PER_CASE(:)
    this%mc_table_num_subfaces_per_case(:)      = MC_QUA4_NUM_SUBFACES_PER_CASE(:)
    this%mc_table_num_cut_edges_per_case(:)     = MC_QUA4_NUM_CUT_EDGES_PER_CASE(:)
    this%mc_table_inout_subcells_per_case(:,:)    = MC_QUA4_INOUT_SUBCELLS_PER_CASE(:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,:)  = MC_QUA4_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,:)  = MC_QUA4_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
  else
    this%mc_table_num_subcells_per_case(:)      = MC_HEX8_NUM_SUBCELLS_PER_CASE(:)
    this%mc_table_num_subfaces_per_case(:)      = MC_HEX8_NUM_SUBFACES_PER_CASE(:)
    this%mc_table_num_cut_edges_per_case(:)     = MC_HEX8_NUM_CUT_EDGES_PER_CASE(:)
    !this%mc_table_inout_subcells_per_case(:,:)    = MC_HEX8_INOUT_SUBCELLS_PER_CASE(:,:)
    !this%mc_table_subcell_node_ids_per_case(:,:,:)  = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
    !this%mc_table_subface_node_ids_per_case(:,:,:)  = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,1:9) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL1(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,10:18) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL2(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,19:27) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL3(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,28:36) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL4(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,37:45) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL5(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,46:54) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL6(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,55:63) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL7(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,64:72) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL8(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,73:81) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL9(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,82:90) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL10(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,91:99) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL11(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,100:108) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL12(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,109:117) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL13(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,118:126) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL14(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,127:135) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL15(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,136:144) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL16(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,145:153) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL17(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,154:162) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL18(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,163:171) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL19(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,172:180) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL20(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,181:189) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL21(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,190:198) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL22(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,199:207) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL23(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,208:216) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL24(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,217:225) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL25(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,226:234) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL26(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,235:243) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL27(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,244:252) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL28(:,:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,253:256) = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE_BL29(:,:,:)
    this%mc_table_inout_subcells_per_case(:,1:36) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL1(:,:)
    this%mc_table_inout_subcells_per_case(:,37:72) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL2(:,:)
    this%mc_table_inout_subcells_per_case(:,73:108) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL3(:,:)
    this%mc_table_inout_subcells_per_case(:,109:144) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL4(:,:)
    this%mc_table_inout_subcells_per_case(:,145:180) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL5(:,:)
    this%mc_table_inout_subcells_per_case(:,181:216) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL6(:,:)
    this%mc_table_inout_subcells_per_case(:,217:252) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL7(:,:)
    this%mc_table_inout_subcells_per_case(:,253:256) = MC_HEX8_INOUT_SUBCELLS_PER_CASE_BL8(:,:)
    this%mc_table_subface_node_ids_per_case(:,:,1:45) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL1(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,46:90) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL2(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,91:135) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL3(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,136:180) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL4(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,181:225) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL5(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,226:256) = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE_BL6(:,:,:)
  endif

  this%mc_tables_init = .true.

end subroutine marching_cubes_mc_tables_create

!========================================================================================
subroutine marching_cubes_mc_tables_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  if (allocated (this%mc_table_num_subcells_per_case    )) call memfree (this%mc_table_num_subcells_per_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_subfaces_per_case    )) call memfree (this%mc_table_num_subfaces_per_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_cut_edges_per_case   )) call memfree (this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__)
  if (allocated (this%mc_table_inout_subcells_per_case  )) call memfree (this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__)
  if (allocated (this%mc_table_subcell_node_ids_per_case)) call memfree (this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__)
  if (allocated (this%mc_table_subface_node_ids_per_case)) call memfree (this%mc_table_subface_node_ids_per_case, __FILE__, __LINE__)

  this%mc_tables_init = .false.

end subroutine marching_cubes_mc_tables_free

!========================================================================================
subroutine marching_cubes_mc_runtime_info_create(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  type(point_t), allocatable :: Xe_phys(:), Xe_ref(:)
  integer(ip), parameter :: edge_dim = 1
  integer(ip) :: inode, num_nodes
  integer(ip) :: iedge, first_edge, last_edge, cell_node, edge_node
  type(list_iterator_t) :: nodes_in_edge_iterator
  integer(ip) :: num_cells, ipoin, num_int_points
  integer(ip) :: icase, istat, num_nodes_outside
  integer(ip), parameter :: num_nodes_in_edge = 2
  integer(ip) :: nodes_in_edge(num_nodes_in_edge)
  real(rp)    :: phi_node, phi_edge(num_nodes_in_edge)

  ! To be safe
  call this%mc_runtime_info_free()

  ! Get the nodal coordinates in the reference element
  cell_iter = this%triangulation%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_nodes = cell%get_num_nodes()
  allocate( Xe_ref(1:num_nodes), stat=istat ); check(istat == 0)
  call cell%get_coordinates_ref_space( Xe_ref )

  ! Allocate and fill marching cube cases
  num_cells = this%triangulation%get_num_local_cells()
  call memalloc (num_cells, this%mc_case_per_cell, __FILE__, __LINE__ )
  allocate ( Xe_phys(num_nodes), stat=istat ); check(istat == 0)
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if (cell%is_local()) then
      call cell%get_coordinates(Xe_phys)
      icase = 0_ip
      num_nodes_outside = 0_ip
      do inode = 1, num_nodes
        call this%level_set_function%get_value(Xe_phys(inode),phi_node)
        if (phi_node < 0.0_rp) icase = ior( icase, 2_ip**(inode-1_ip) )
        if (phi_node > 0.0_rp) num_nodes_outside = num_nodes_outside + 1
      end do
      if ( num_nodes_outside == 0_ip ) then
        ! This is to avoid to set as cut an element that has negative and zero nodes 
        ! (which is in fact a full interior element)
        this%mc_case_per_cell(cell%get_lid()) = this%mc_table_num_cases
      else
        this%mc_case_per_cell(cell%get_lid()) = icase + 1
      end if
    end if
    call cell_iter%next()
  end do

  ! Allocate and fill the intersection points pointers
  call memalloc (num_cells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  this%mc_ptr_to_intersections(1) = 1
  call cell_iter%init()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
      if (cell%is_local()) then
      this%mc_ptr_to_intersections(cell%get_lid() + 1) = this%mc_ptr_to_intersections(cell%get_lid()) &
      + this%mc_table_num_cut_edges_per_case(this%mc_case_per_cell(cell%get_lid()))
    end if
    call cell_iter%next()
  end do

  ! Allocate and fill the intersection points
  num_int_points = this%mc_ptr_to_intersections(num_cells + 1) - this%mc_ptr_to_intersections(1)
  allocate ( this%mc_intersection_points( num_int_points ), stat = istat )
  check(istat == 0)
  call cell_iter%init()
  ipoin = 1
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if (cell%is_local()) then

      ! Only execute this loop for cut elements
      if ( this%mc_case_per_cell(cell%get_lid())==1 .or. this%mc_case_per_cell(cell%get_lid())==this%mc_table_num_cases ) then
        call cell_iter%next()
        cycle
      end if

      ! Get nodal coordinates
      call cell%get_coordinates(Xe_phys)

      ! Prepare Loop in cell edges
      reference_fe_geo => cell%get_reference_fe_geo()
      first_edge = reference_fe_geo%get_first_n_face_id_of_dimension(edge_dim)
      last_edge  = first_edge + reference_fe_geo%get_number_n_faces_of_dimension(edge_dim) - 1

      ! Loop in cell edges
      do iedge = first_edge, last_edge

        ! Loop in edge nodes
        nodes_in_edge_iterator = reference_fe_geo%create_nodes_n_face_iterator(iedge)
        do while (.not. nodes_in_edge_iterator%is_upper_bound())
          edge_node = nodes_in_edge_iterator%get_distance_to_lower_bound()
          cell_node = nodes_in_edge_iterator%get_current()

          ! Evaluate the levelset
          call this%level_set_function%get_value(Xe_phys(cell_node),phi_edge(edge_node))

          ! Store the nodes ids of the current edge
          nodes_in_edge(edge_node) = cell_node

          call nodes_in_edge_iterator%next()
        end do

        ! Compute the intersection points of the edge
        if ( (phi_edge(1) >= 0 .and. phi_edge(2) < 0) .or. (phi_edge(2) >= 0 .and. phi_edge(1) < 0)   ) then
          this%mc_intersection_points(ipoin) = Xe_ref(nodes_in_edge(1)) + &
          (abs(phi_edge(1))/(abs(phi_edge(1))+abs(phi_edge(2))))*( Xe_ref(nodes_in_edge(2)) - Xe_ref(nodes_in_edge(1)) )
          ipoin = ipoin + 1
        end if

      end do

    end if
    call cell_iter%next()
  end do

  deallocate( Xe_ref, stat=istat );  check(istat == 0)
  deallocate( Xe_phys, stat=istat ); check(istat == 0)

  this%mc_runtime_init = .true.

end subroutine marching_cubes_mc_runtime_info_create

!========================================================================================
subroutine marching_cubes_mc_runtime_info_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip) :: istat, i
  if (allocated (this%mc_case_per_cell       )) call memfree ( this%mc_case_per_cell        , __FILE__, __LINE__ )
  if (allocated (this%mc_ptr_to_intersections)) call memfree ( this%mc_ptr_to_intersections , __FILE__, __LINE__ )
  if (allocated (this%mc_intersection_points)) then
    deallocate(this%mc_intersection_points, stat=istat); check(istat==0)
  end if
  this%mc_runtime_init = .false.
end subroutine marching_cubes_mc_runtime_info_free

!========================================================================================
subroutine marching_cubes_subnodes_data_create( this )

  implicit none
  class(marching_cubes_t), intent(inout) :: this

  integer(ip) :: istat, icase
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: n_subcells, n_subfaces, n_subnodes, n_nodes_subcell, n_nodes_subface  

  assert(this%mc_tables_init)
  assert(this%mc_runtime_init)

  call this%subnodes_data_free()
  
  ! TODO we don't really need to allocate for all the mc cases
  allocate( this%subnodes_nodal_quadratures(1:this%get_num_mc_cases()), stat=istat); check(istat==0_ip)
  allocate( this%subnodes_fe_maps          (1:this%get_num_mc_cases()), stat=istat); check(istat==0_ip)

  ! Initialize each one of the quadratures
  cell_iter = this%triangulation%create_cell_iterator()
  call cell_iter%current(cell)
  do icase=1, this%get_num_mc_cases()
    n_subnodes =  this%mc_table_num_cut_edges_per_case(icase) + cell%get_num_nodes()
    call this%subnodes_nodal_quadratures(icase)%create(this%triangulation%get_num_dimensions(),n_subnodes)
  end do

  ! Initialize each one of the fe_maps
  reference_fe_geo => cell%get_reference_fe_geo()
  do icase=1, this%get_num_mc_cases()
    call this%subnodes_fe_maps(icase)%create( this%subnodes_nodal_quadratures(icase), reference_fe_geo)
  end do

  !Allocate place holders for the sub-mesh
  n_subcells      = this%get_max_num_subcells_in_cell()
  n_subfaces      = this%get_max_num_subfaces_in_cell()
  n_subnodes      = this%get_max_num_subnodes_in_cell()
  n_nodes_subcell = this%get_max_num_nodes_in_subcell()
  n_nodes_subface = this%get_max_num_nodes_in_subface()
  call memalloc(n_nodes_subcell,n_subcells,this%subcells_nodal_connectivities,__FILE__,__LINE__)
  call memalloc(n_nodes_subface,n_subfaces,this%subfaces_nodal_connectivities,__FILE__,__LINE__)
  call memalloc(n_subcells,this%subcell_has_been_reoriented,__FILE__,__LINE__)
  allocate( this%subnodes_ref_coords(1:n_subnodes) , stat=istat); check(istat==0_ip)

end subroutine marching_cubes_subnodes_data_create

!========================================================================================
subroutine marching_cubes_subnodes_data_free( this )

  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip) :: istat, i

  if ( allocated(this%subnodes_ref_coords) ) then
    deallocate( this%subnodes_ref_coords, stat=istat ); check( istat==0_ip )
  end if

  if ( allocated(this%subnodes_nodal_quadratures) ) then
    do i=1,size(this%subnodes_nodal_quadratures)
      call this%subnodes_nodal_quadratures(i)%free()
    end do
    deallocate( this%subnodes_nodal_quadratures, stat=istat ); check( istat==0_ip )
  end if

  if ( allocated(this%subnodes_fe_maps) ) then
    do i=1,size(this%subnodes_fe_maps)
      call this%subnodes_fe_maps(i)%free()
    end do
    deallocate( this%subnodes_fe_maps, stat=istat ); check( istat==0_ip )
  end if

  if(allocated(this%subcells_nodal_connectivities  )) call memfree(this%subcells_nodal_connectivities  ,__FILE__,__LINE__)
  if(allocated(this%subfaces_nodal_connectivities  )) call memfree(this%subfaces_nodal_connectivities  ,__FILE__,__LINE__)
  if(allocated(this%subcell_has_been_reoriented)) call memfree(this%subcell_has_been_reoriented,__FILE__,__LINE__)

end subroutine marching_cubes_subnodes_data_free


