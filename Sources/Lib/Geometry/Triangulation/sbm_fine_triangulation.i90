! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine fine_triangulation_generate_vefs(this,order)
  implicit none
  ! This routine assumes a triangulation with vertices and ghost elements
  ! Parameters
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)                , intent(in)    :: order

  integer(ip)          , allocatable :: ptr_vertices(:)
  integer(ip)          , allocatable :: lst_vertices(:)
  class(cell_iterator_t), allocatable :: icell
  class(cell_iterator_t), allocatable :: jcell
  type(vef_iterator_t)               :: vef

  type(position_hash_table_t) :: pos_ref_fe

  type(list_t), pointer    :: vertices_ivef
  type(list_t), pointer    :: vertices_jvef
  logical     :: equal
  integer(ip) :: istat, count, iboun, ivert, jvert, nnodb
  integer(ip) :: ielem, ivef, icell_type, ielem_num_vertices
  integer(ip) :: ielem_num_vefs, ielem_first_vef_id, ielem_num_vef_verts
  integer(ip) :: vertex_of_ivef(4)
  integer(ip) :: jelpo, jelem, jvef, jelem_type, jelem_num_vertices
  integer(ip) :: jelem_num_vefs, jelem_first_vef_id, jelem_num_vef_verts
  integer(ip) :: vertex_of_jvef(4)
  type(list_iterator_t) :: vertices_ivef_iterator
  type(list_iterator_t) :: vertices_jvef_iterator
  type(list_iterator_t) :: boundary_iterator
  type(p_reference_fe_t) :: reference_fe_geo_list(max_num_reference_fes_geo)


  ! Get vertices from triangulation
  call memmovealloc(this%ptr_vefs_per_cell,ptr_vertices,__FILE__,__LINE__)
  call memmovealloc(this%lst_vefs_lids,lst_vertices,__FILE__,__LINE__)

  ! Build reference_fe_geo index and list:
  ! A scalar reference fe is used for the geometry as it is always interpolated
  ! using a Lagrangian type fe and nodal values are stored into a point_t array.
  call pos_ref_fe%init(max_num_reference_fes_geo)

  call this%create_cell_iterator(icell)
  call this%create_cell_iterator(jcell)
  do while ( .not. icell%has_finished() )
     ielem = icell%get_lid()
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     if ( istat == new_index ) then
        if(this%num_dimensions==2) then
           if(ielem_num_vertices==3) then ! Triangle
              reference_fe_geo_list(icell_type) = &
                   &    make_reference_fe ( topology = topology_tet, fe_type = fe_type_lagrangian, &
                   &                        number_dimensions = this%num_dimensions, order = order, &
                   &                        field_type = field_type_scalar, continuity = .true. )
           else ! Quadrilateral
              reference_fe_geo_list(icell_type) = &
                   &    make_reference_fe ( topology = topology_hex, fe_type = fe_type_lagrangian, &
                   &                        number_dimensions = this%num_dimensions, order = order, &
                   &                        field_type = field_type_scalar, continuity = .true. )
           end if
        else
           if(ielem_num_vertices==4) then ! Tetrahedra
              reference_fe_geo_list(icell_type) = &
                   &    make_reference_fe ( topology = topology_tet, fe_type = fe_type_lagrangian, &
                   &                        number_dimensions = this%num_dimensions, order = order, &
                   &                        field_type = field_type_scalar, continuity = .true. )
           else if(ielem_num_vertices==6) then ! Prism
              assert(.false.)
           else if(ielem_num_vertices==8) then ! Hexahedra
              reference_fe_geo_list(icell_type) = &
                   &    make_reference_fe ( topology = topology_hex, fe_type = fe_type_lagrangian, &
                   &                        number_dimensions = this%num_dimensions, order = order, &
                   &                        field_type = field_type_scalar, continuity = .true. )
           end if
        end if
        ! Transfer allocated target from local variable to member variable of base_static_triangulation
        select type(reference_fe => reference_fe_geo_list(icell_type)%p)
        class is(lagrangian_reference_fe_t)
           this%reference_fe_geo_list(icell_type)%p => reference_fe
        end select
     end if
     call icell%next()
  end do
  !write(*,*) 'Ref fe list done'
  !call this%reference_fe_geo_list(1)%p%print()

  ! Compute this%ptr_vefs_per_cell and allocate this%lst_vefs_lids
  call memalloc(this%num_local_cells + this%num_ghost_cells+1, this%ptr_vefs_per_cell, __FILE__, __LINE__ )
  !call memalloc(this%num_local_cells + this%num_ghost_cells+1, this%ptr_nodes_per_cell, __FILE__, __LINE__ )
  this%ptr_vefs_per_cell(1)=1
  !this%ptr_nodes_per_cell(1)=1
  call icell%first()
  do while ( .not. icell%has_finished() )
     ielem = icell%get_lid()
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     assert(istat==old_index)
     this%ptr_vefs_per_cell(ielem+1)  = this%ptr_vefs_per_cell(ielem)  + this%reference_fe_geo_list(icell_type)%p%get_number_n_faces()
     !this%ptr_nodes_per_cell(ielem+1) = this%ptr_nodes_per_cell(ielem) + this%reference_fe_geo_list(ielem_type)%p%get_number_nodes()
     call icell%next()
  end do
  call memalloc(this%ptr_vefs_per_cell(this%num_local_cells + this%num_ghost_cells+1)-1, this%lst_vefs_lids , __FILE__, __LINE__ )
  this%lst_vefs_lids=0
  !write(*,*) 'ptr_vefs_per_cell done'
  !write(*,*) this%ptr_vefs_per_cell
  
  ! Fill vertices (dim 0 vefs)
  call icell%first()
  do while ( .not. icell%has_finished() )
     ielem = icell%get_lid()
     !write(*,*) 'Element i:',ielem
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     assert(istat==old_index)
     ! Fill vefs (only vertices)
     this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem):this%ptr_vefs_per_cell(ielem)+ielem_num_vertices-1) = &
          & lst_vertices(ptr_vertices(ielem):ptr_vertices(ielem+1)-1)
     call icell%next()
  end do
  !write(*,*) 'Vertices filled'
  
  ! Fill dim 1 vefs (this%num_vefs = number of vertices at this point)
  ! they only have two vertices
  call this%create_vef_iterator(vef)
  call icell%first()
  do while ( .not. icell%has_finished() )
     ielem = icell%get_lid()
     !write(*,*) 'Element i:',ielem
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     assert(istat==old_index)
     ielem_num_vefs     = this%reference_fe_geo_list(icell_type)%p%get_number_n_faces_of_dimension(1)
     ielem_first_vef_id = this%reference_fe_geo_list(icell_type)%p%get_first_n_face_id_of_dimension(1)
     vertices_ivef => this%reference_fe_geo_list(icell_type)%p%get_vertices_n_face()
     !write(*,*) 'num edges, first edge',ielem_num_vefs,ielem_first_vef_id
     do ivef=1,ielem_num_vefs
        if(this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)==0) then ! Not filled yet
           ! Fill vef
           this%num_vefs=this%num_vefs+1                                                                ! Count it
           this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)=this%num_vefs  ! Fill it
           vertices_ivef_iterator = vertices_ivef%create_iterator(ielem_first_vef_id+ivef-1)
           vertex_of_ivef(1) = lst_vertices(ptr_vertices(ielem)-1+vertices_ivef_iterator%get_from_current(0))
           vertex_of_ivef(2) = lst_vertices(ptr_vertices(ielem)-1+vertices_ivef_iterator%get_from_current(1))
           call vef%set_lid(vertex_of_ivef(1))
           do jelpo = 1, vef%get_num_cells_around()
              call vef%get_cell_around(jelpo, jcell)
              jelem = jcell%get_lid()
              if(jelem>ielem) then
                 jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
                 call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
                 assert(istat==old_index)
                 jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_n_faces_of_dimension(1)
                 jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_n_face_id_of_dimension(1)
                 vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_n_face()
                 do jvef=1,jelem_num_vefs
                    vertices_jvef_iterator = vertices_ivef%create_iterator(jelem_first_vef_id+jvef-1)
                    vertex_of_jvef(1) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%get_from_current(0))
                    vertex_of_jvef(2) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%get_from_current(1))
                    !write(*,*) 'vertices of j:',vertex_of_jvef
                    ! Compare, here we are using that edges have two vertices, hard coded
                    equal = (vertex_of_ivef(1)==vertex_of_jvef(1).and.vertex_of_ivef(2)==vertex_of_jvef(2)).or. &
                         &  (vertex_of_ivef(1)==vertex_of_jvef(2).and.vertex_of_ivef(2)==vertex_of_jvef(1))
                    !write(*,*) 'Are equal:',equal
                    if(equal) then 
                       ! Fill vertices
                       this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)=this%num_vefs
                       exit
                    end if
                 end do
              end if
           end do
        end if
     end do
     call icell%next()
  end do

  ! These numbers (num_faces and num_edges) might not be necessary
  if(this%num_dimensions==2) then
     this%num_edges = 0
     this%num_faces = this%num_vefs - this%num_vertices
  else if(this%num_dimensions==3) then
     this%num_edges = this%num_vefs - this%num_vertices

     ! Fill dim 2 vefs (the code is similar to that of dim 1 vefs,
     ! except for the number of vertices of each vef, that is variable)
     call icell%first()
     do while ( .not. icell%has_finished() )
        ielem = icell%get_lid()
        !write(*,*) 'Element i:',ielem
        ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
        call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
        assert(istat==old_index)
        ielem_num_vefs      = this%reference_fe_geo_list(icell_type)%p%get_number_n_faces_of_dimension(2)
        ielem_first_vef_id  = this%reference_fe_geo_list(icell_type)%p%get_first_n_face_id_of_dimension(2)
        do ivef=1,ielem_num_vefs
           if(this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)==0) then ! Not filled yet
              this%num_vefs=this%num_vefs+1                                       ! Count it
              this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)=this%num_vefs ! Fill it
              ielem_num_vef_verts = this%reference_fe_geo_list(icell_type)%p%get_number_vertices_n_face(ielem_first_vef_id+ivef-1)
              vertices_ivef => this%reference_fe_geo_list(icell_type)%p%get_vertices_n_face()
              vertices_ivef_iterator = vertices_ivef%create_iterator(ielem_first_vef_id+ivef-1)
              vertex_of_ivef = 0
              do ivert=1,ielem_num_vef_verts
                 vertex_of_ivef(ivert)=lst_vertices( ptr_vertices(ielem)-1+vertices_ivef_iterator%get_current())
                 call vertices_ivef_iterator%next()
              end do
              call vef%set_lid(vertex_of_ivef(1))
              do jelpo = 1, vef%get_num_cells_around()
                 call vef%get_cell_around(jelpo, jcell)
                 jelem = jcell%get_lid()
                 if(jelem>ielem) then
                    jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
                    call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
                    assert(istat==old_index)
                    jelem_num_vefs      = this%reference_fe_geo_list(jelem_type)%p%get_number_n_faces_of_dimension(2)
                    jelem_first_vef_id  = this%reference_fe_geo_list(jelem_type)%p%get_first_n_face_id_of_dimension(2)
                    vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_n_face()
                    do jvef=1,jelem_num_vefs
                       jelem_num_vef_verts = this%reference_fe_geo_list(jelem_type)%p%get_number_vertices_n_face(jelem_first_vef_id+jvef-1)
                       if(jelem_num_vef_verts==ielem_num_vef_verts) then
                          vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                          vertex_of_jvef = 0
                          do jvert=1,jelem_num_vef_verts
                             vertex_of_jvef(jvert)=lst_vertices( ptr_vertices(jelem)-1+vertices_jvef_iterator%get_current())
                             call vertices_jvef_iterator%next()
                          end do
                          count=0
                          do ivert=1,ielem_num_vef_verts
                             do jvert=1,jelem_num_vef_verts
                                if(vertex_of_ivef(ivert)==vertex_of_jvef(jvert)) then
                                   count=count+1
                                   exit
                                end if
                             end do
                          end do
                          equal=(count==ielem_num_vef_verts)
                          if(equal) then ! Fill it
                             this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)=this%num_vefs
                             exit
                          end if
                       end if
                    end do
                 end if
              end do
           end if
        end do
        call icell%next()
     end do
     this%num_faces=this%num_vefs-this%num_vertices-this%num_edges
  end if
  call this%free_vef_iterator(vef)

  ! Generate the ref fe position hash table using the number of vefs (instead of vertices) as keys
  call  this%reference_fe_geo_index%init(max_num_reference_fes_geo)
  if(this%num_dimensions==3) then
     ! Tetrahedra
     ielem_num_vertices=4
     ielem_num_vefs=14
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=icell_type,stat=istat)
        assert(istat==now_stored)
     end if
     ! Prisms
     ielem_num_vertices=6
     ielem_num_vefs=20
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=icell_type,stat=istat)
        assert(istat==now_stored)
     end if
     ! Hexahedra
     ielem_num_vertices=8
     ielem_num_vefs=26
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=icell_type,stat=istat)
        assert(istat==now_stored)
     end if
  else if(this%num_dimensions==2) then
     ! Triangle
     ielem_num_vertices=3
     ielem_num_vefs =6
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=icell_type,stat=istat)
        assert(istat==now_stored)
     end if
     ! Quad
     ielem_num_vertices=4
     ielem_num_vefs =8
     call pos_ref_fe%get(key=ielem_num_vertices,val=icell_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=icell_type,stat=istat)
        assert(istat==now_stored)
     end if
  end if
  call memfree(ptr_vertices,__FILE__,__LINE__)
  call memfree(lst_vertices,__FILE__,__LINE__)
  call this%free_cell_iterator(icell)
  call this%free_cell_iterator(jcell)
end subroutine fine_triangulation_generate_vefs

subroutine fine_triangulation_allocate_and_fill_geometry_and_set(this,given_vefs,vefs_geometry,vefs_set)
  implicit none
  ! This routine assumes a triangulation with vertices and ghost elements
  ! Parameters
  class(fine_triangulation_t), intent(inout) :: this
  type(list_t), intent(in) :: given_vefs
  integer(ip) , intent(in) :: vefs_geometry(:)
  integer(ip) , intent(in) :: vefs_set(:)
  integer(ip)                        :: order

  class(cell_iterator_t), allocatable  :: cell
  type(vef_iterator_t)                 :: vef

  type(list_t), pointer    :: vertices_ivef
  type(list_t), pointer    :: vertices_jvef
  logical     :: equal
  integer(ip) :: istat, count, iboun, ivert, jvert, nnodb
  integer(ip) :: ielem, ivef, ielem_type, ielem_num_vertices
  integer(ip) :: ielem_num_vefs, ielem_first_vef_id, ielem_num_vef_verts
  integer(ip) :: vertex_of_ivef(4)
  integer(ip) :: jelpo, jelem, jvef, jelem_type, jelem_num_vertices
  integer(ip) :: jelem_num_vefs, jelem_first_vef_id, jelem_num_vef_verts
  integer(ip) :: vertex_of_jvef(4)
  type(list_iterator_t) :: vertices_ivef_iterator
  type(list_iterator_t) :: vertices_jvef_iterator
  type(list_iterator_t) :: given_vefs_iterator

     assert(size(vefs_geometry)==given_vefs%get_num_pointers())
     assert(size(vefs_set)==given_vefs%get_num_pointers())

     call this%free_geometry_and_set()

     ! Identify boundary faces and assign set and geometry to vefs
     call memalloc(this%num_vefs, this%vefs_geometry, __FILE__, __LINE__ )
     call memalloc(this%num_vefs, this%vefs_set, __FILE__, __LINE__ )
     this%vefs_geometry=0
     this%vefs_set=0

     call this%create_cell_iterator(cell)
     call this%create_vef_iterator(vef)
     do iboun=1,given_vefs%get_num_pointers()
        given_vefs_iterator = given_vefs%create_iterator(iboun)
        nnodb=given_vefs%get_sublist_size(iboun)
        !write(*,*) iboun,nnodb
        if(nnodb==1) then      ! Vertex
           ivert=given_vefs_iterator%get_from_current(0)
           this%vefs_geometry(ivert)=vefs_geometry(iboun)
           this%vefs_set(ivert)=vefs_set(iboun)
        else if(nnodb==2) then ! Edge
           vertex_of_ivef(1) = given_vefs_iterator%get_from_current(0)
           vertex_of_ivef(2) = given_vefs_iterator%get_from_current(1)
           call vef%set_lid(vertex_of_ivef(1))
           elems1: do jelpo = 1, vef%get_num_cells_around()
              call vef%get_cell_around(jelpo, cell)
              jelem = cell%get_lid()
              !jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
              !call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
              !assert(istat==old_index)
              call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=jelem_type,stat=istat)
              assert(istat==key_found)
              jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_n_faces_of_dimension(1)
              jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_n_face_id_of_dimension(1)
              vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_n_face()
              do jvef=1,jelem_num_vefs
                 vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                 !vertex_of_jvef(1) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(0))
                 !vertex_of_jvef(2) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(1))
                 vertex_of_jvef(1) = this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+vertices_jvef_iterator%get_from_current(0))
                 vertex_of_jvef(2) = this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+vertices_jvef_iterator%get_from_current(1))
                 ! Compare, here we are using that edges have two vertices, hard coded
                 equal = (vertex_of_ivef(1)==vertex_of_jvef(1).and.vertex_of_ivef(2)==vertex_of_jvef(2)).or. &
                      &  (vertex_of_ivef(1)==vertex_of_jvef(2).and.vertex_of_ivef(2)==vertex_of_jvef(1))
                 if(equal) then ! Fill it
                    this%vefs_geometry( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_geometry(iboun)
                    this%vefs_set( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_set(iboun)
                    exit elems1
                 end if
              end do
           end do elems1
        else ! Face
           vertex_of_ivef = 0
           do ivert=1,nnodb
              vertex_of_ivef(ivert)= given_vefs_iterator%get_current()
              call given_vefs_iterator%next()
           end do
           ielem_num_vef_verts = nnodb
           call vef%set_lid(vertex_of_ivef(1))
           elems2: do jelpo = 1, vef%get_num_cells_around()
              call vef%get_cell_around(jelpo, cell)
              jelem = cell%get_lid()
              !jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
              !call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
              !assert(istat==old_index)
              call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=jelem_type,stat=istat)
              assert(istat==key_found)
              jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_n_faces_of_dimension(2)
              jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_n_face_id_of_dimension(2)
              vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_n_face()
              do jvef=1,jelem_num_vefs
                 jelem_num_vef_verts = this%reference_fe_geo_list(jelem_type)%p%get_number_vertices_n_face(jelem_first_vef_id+jvef-1)
                 vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                 if(jelem_num_vef_verts==nnodb) then
                    vertex_of_jvef = 0
                    do jvert=1,jelem_num_vef_verts
                       vertex_of_jvef(jvert)=this%lst_vefs_lids( this%ptr_vefs_per_cell(jelem)-1+vertices_jvef_iterator%get_current())
                       call vertices_jvef_iterator%next()
                    end do
                    count=0
                    do ivert=1,ielem_num_vef_verts
                       do jvert=1,jelem_num_vef_verts
                          if(vertex_of_ivef(ivert)==vertex_of_jvef(jvert)) then
                             count=count+1
                             exit
                          end if
                       end do
                    end do
                    equal=(count==ielem_num_vef_verts)
                    if(equal) then ! Fill it
                       this%vefs_geometry( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_geometry(iboun)
                       this%vefs_set( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_set(iboun)
                       exit elems2
                    end if
                 end if
              end do
           end do elems2
        end if
     end do
     call this%free_vef_iterator(vef)
     call this%free_cell_iterator(cell)
end subroutine fine_triangulation_allocate_and_fill_geometry_and_set

subroutine fine_triangulation_free_geometry_and_set( this )
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  if (allocated(this%vefs_geometry)) call memfree(this%vefs_geometry,__FILE__,__LINE__)
  if (allocated(this%vefs_set))      call memfree(this%vefs_set,__FILE__,__LINE__)
end subroutine fine_triangulation_free_geometry_and_set

subroutine fine_triangulation_find_vefs_at_boundary (this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)           :: ivef 
  integer(ip)           :: cell_type, istat
  class(cell_iterator_t), allocatable :: cell
  type(vef_iterator_t)  :: vef, vef_of_vef
  type(list_t), pointer :: vefs_of_vef
  type(list_t), pointer :: vertices_of_line
  type(list_iterator_t) :: vefs_of_vef_iterator
  type(list_iterator_t) :: vertices_of_line_iterator
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  
  integer(ip) :: ivef_pos_in_cell, vef_of_vef_pos_in_cell, vef_set_id, vef_geom_id
  integer(ip) :: vertex_pos_in_cell

  assert ( this%num_vefs >= 0 )
  assert ( allocated(this%vefs_type))

  call this%create_cell_iterator(cell)
  call this%create_vef_iterator(vef)
  call this%create_vef_iterator(vef_of_vef)
  do while ( .not. vef%has_finished() )     
     ivef = vef%get_lid()

     call vef%get_cell_around(1,cell) ! There is always one cell around
     reference_fe_geo => cell%get_reference_fe_geo()

     ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
     
     if(vef%get_num_cells_around()==1) then ! vef is on the boundary
        if( vef%get_dimension() == this%num_dimensions-1 ) then ! It is a face
           call vef%set_it_at_boundary()
           
           vef_set_id = vef%get_set_id()
           !vef_geom_id = vef%get_geom_id()
           vefs_of_vef => reference_fe_geo%get_n_faces_n_face() 
           ! They are also at the boundary, regardless of the number of cells they have around
           vefs_of_vef_iterator = vefs_of_vef%create_iterator(ivef_pos_in_cell)
           do while( .not. vefs_of_vef_iterator%is_upper_bound() )
              vef_of_vef_pos_in_cell = vefs_of_vef_iterator%get_current()
              call cell%get_vef(vef_of_vef_pos_in_cell, vef_of_vef)
              call vef_of_vef%set_it_at_boundary()
              !write(*,*) 'Boundary face', vef%get_lid(), vef_set_id, 'vef', vef_of_vef%get_lid(), vef_of_vef%get_set_id()
              if( vef_of_vef%get_set_id() == 0) then
                 call vef_of_vef%set_set_id(vef_set_id)
                 !call vef_of_vef%set_geom_id(vef_geom_id)
              end if
              
              ! Traverse vertices of current line
              if ( this%num_dimensions == 3 ) then
                vertices_of_line          => reference_fe_geo%get_vertices_n_face() 
                vertices_of_line_iterator = vertices_of_line%create_iterator(vef_of_vef_pos_in_cell)
                do while( .not. vertices_of_line_iterator%is_upper_bound() )
                  vertex_pos_in_cell = vertices_of_line_iterator%get_current()
                  call cell%get_vef(vertex_pos_in_cell, vef_of_vef)
                  call vef_of_vef%set_it_at_boundary()
                  !write(*,*) 'Boundary face', vef%get_lid(), vef_set_id, 'vef', vef_of_vef%get_lid(), vef_of_vef%get_set_id()
                  if( vef_of_vef%get_set_id() == 0) then
                    call vef_of_vef%set_set_id(vef_set_id)
                   !call vef_of_vef%set_geom_id(vef_geom_id)
                  end if
                  call vertices_of_line_iterator%next()
                end do
              end if 
              call vefs_of_vef_iterator%next()
           end do
         end if
     end if
     call vef%next()
  end do
  call this%free_vef_iterator(vef)
  call this%free_vef_iterator(vef_of_vef)
  call this%free_cell_iterator(cell)
end subroutine fine_triangulation_find_vefs_at_boundary

subroutine fine_triangulation_compute_vefs_dimension (this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)           :: ivef
  integer(ip)           :: cell_type, istat
  class(cell_iterator_t), allocatable :: cell
  type(vef_iterator_t)  :: vef
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  
  integer(ip) :: ivef_pos_in_cell, cell_num_vefs_of_dim0, cell_num_vefs_of_dim1

  assert ( this%num_vefs >= 0 )
  call this%free_vefs_type()
  call memalloc(this%num_vefs, this%vefs_type,__FILE__,__LINE__) 
  this%vefs_type = 0

  
  call this%create_cell_iterator(cell)
  call this%create_vef_iterator(vef)
  do while ( .not. vef%has_finished() )     
     ivef = vef%get_lid()

     call vef%get_cell_around(1,cell) ! There is always one cell around
     reference_fe_geo => cell%get_reference_fe_geo()

     cell_num_vefs_of_dim0   = reference_fe_geo%get_number_n_faces_of_dimension(0)
     cell_num_vefs_of_dim1   = reference_fe_geo%get_number_n_faces_of_dimension(1)
     ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
     if(ivef_pos_in_cell<=cell_num_vefs_of_dim0) then
        call vef%set_dimension(0)
     else if(ivef_pos_in_cell<=cell_num_vefs_of_dim0+cell_num_vefs_of_dim1) then
        call vef%set_dimension(1)
     else
        call vef%set_dimension(2)
     end if
     call vef%next()
  end do
  call this%free_vef_iterator(vef)
  call this%free_cell_iterator(cell)
end subroutine fine_triangulation_compute_vefs_dimension

subroutine fine_triangulation_allocate_and_fill_nodes(this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)           :: icell 
  integer(ip)           :: cell_type, istat
  class(cell_iterator_t), allocatable :: cell, cell2
  type(vef_iterator_t)  :: vef
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo

  integer(ip) :: ivef, ielem, jelem, jelem_type, ivef_pos_in_cell, jvef_pos_in_cell, cell_num_vertices

  ! Compute header and allocate array
  call this%free_nodes()
  call memalloc(this%num_local_cells + this%num_ghost_cells+1, this%ptr_nodes_per_cell, __FILE__, __LINE__ )

  this%ptr_nodes_per_cell(1)=1
  call this%create_cell_iterator(cell)
  do while ( .not. cell%has_finished() )
     reference_fe_geo => cell%get_reference_fe_geo()
     ielem = cell%get_lid()
     this%ptr_nodes_per_cell(ielem+1) = this%ptr_nodes_per_cell(ielem) + reference_fe_geo%get_number_shape_functions()
     call cell%next()
  end do
  call memalloc(this%ptr_nodes_per_cell(this%num_local_cells + this%num_ghost_cells+1)-1, this%lst_nodes , __FILE__, __LINE__ )
  this%lst_nodes=0

  ! Set nodes on vertices (with id = id of the vertex)
  call cell%first()
  do while ( .not. cell%has_finished() )
     if ( cell%is_local() ) then
       call cell%fill_nodes_on_vertices()
     end if  
     call cell%next()
  end do
  this%num_nodes=this%num_vertices

  call this%create_cell_iterator(cell2)
  call this%create_vef_iterator(vef)
  do while ( .not. vef%has_finished() )     
     if( (vef%get_dimension()>0) .and. (.not.vef%is_ghost()) ) then
        ivef = vef%get_lid()

        call vef%get_cell_around(1,cell) ! There is always one cell around

        ! The first cell around a local or interface vef is always local provided
        ! that we first enumerate local, followed by ghost cells, and how the dual
        ! mesh is computed (from 1st to last cell).
        assert ( cell%is_local() )
        call cell%fill_nodes_on_vef_new(ivef,this%num_nodes)
        do icell = 2, vef%get_num_cells_around()
           call vef%get_cell_around(icell,cell2)
           if ( cell2%is_local() ) then
               call cell%fill_nodes_on_vef_from_source(ivef,cell2)
           end if 
        end do

     end if
     call vef%next()
  end do
  call this%free_vef_iterator(vef)

  ! Fill nodes on volume
  call cell%first()
  do while ( .not. cell%has_finished() )
     if ( cell%is_local() ) then
       call cell%fill_internal_nodes_new(this%num_nodes)
      end if 
      call cell%next()  
  end do
  call this%free_cell_iterator(cell)
  call this%free_cell_iterator(cell2)
end subroutine fine_triangulation_allocate_and_fill_nodes

subroutine fine_triangulation_free_nodes (this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  if (allocated (this%ptr_nodes_per_cell)) call memfree ( this%ptr_nodes_per_cell, __FILE__, __LINE__ )
  if (allocated (this%lst_nodes)) call memfree ( this%lst_nodes, __FILE__, __LINE__ )
end subroutine fine_triangulation_free_nodes

subroutine fine_triangulation_allocate_and_fill_coordinates(this,vertices_coordinates)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  real(rp)                          , intent(in)    :: vertices_coordinates(:,:)
  class(cell_iterator_t), allocatable :: cell
  type(vertex_iterator_t)  :: vertex
  type(face_iterator_t)    :: face
  type(line_t), pointer     :: line
  type(list_t), pointer     :: vertices_of_vefs
  integer(ip)   :: istat, inode, l_node, order
  integer(ip)   :: vertex1, vertex2, ivef_pos_in_cell, ivef 
  integer(ip)   :: cell_num_vefs, cell_num_nodes, cell_type
  integer(ip)   :: face_num_nodes
  type(point_t) :: point1,point2
  real(rp)      :: u_param1, u_param2, param, u_param
  type(point_t), allocatable :: coordinates(:)
  type(list_iterator_t) :: vertices_of_vefs_iterator
  
  call this%free_coordinates()
  call memalloc(this%num_nodes,this%coordinates,__FILE__,__LINE__)
  
  ! Store coordinates of vertices
  call this%create_vertex_iterator(vertex)
  do while ( .not. vertex%has_finished() )
     ivef = vertex%get_lid()
     call this%coordinates(ivef)%init(vertices_coordinates(:,ivef))
     call vertex%next()
  end do
  call this%free_vef_iterator(vertex)

  ! In the case of a linear (i.e., order == 1) interpolation of the
  ! geometry, skip the rest of steps where the this%geometry member
  ! variable is involved
  order = this%reference_fe_geo_list(1)%p%get_order() 
  if (order == 1) return

   ! High order interpolation is only working in 2D
   assert(this%num_dimensions==2) 

  ! Allocate local coordinates for faces
  call memalloc(order+1, coordinates, __FILE__,__LINE__)
  
  call this%create_cell_iterator(cell)
  call this%create_face_iterator(face)
  do while ( .not. face%has_finished() )
     if ( .not. face%is_ghost() ) then
        ivef = face%get_lid()

        call face%get_cell_around (1, cell) ! there is always one element around
        ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
        cell_num_vefs = cell%get_num_vefs()
        call this%reference_fe_geo_index%get(key=cell_num_vefs,val=cell_type,stat=istat)
        assert(istat==key_found)
        vertices_of_vefs => this%reference_fe_geo_list(cell_type)%p%get_vertices_n_face()
        face_num_nodes = this%reference_fe_geo_list(cell_type)%p%get_number_own_nodes_n_face(ivef_pos_in_cell)
        call memrealloc( face_num_nodes, coordinates, __FILE__,__LINE__)
        ! assert(face_num_nodes<=10) ! see declaration of points above

        vertices_of_vefs_iterator = vertices_of_vefs%create_iterator(ivef_pos_in_cell)
        vertex1 = cell%get_vef_lid(  vertices_of_vefs_iterator%get_from_current(0) )
        vertex2 = cell%get_vef_lid(  vertices_of_vefs_iterator%get_from_current(1) )
        !write(*,*) 'vertices of vef', ivef, vvertex1, vertex2

        point1 = this%coordinates(vertex1)
        point2 = this%coordinates(vertex2)

        if(this%vefs_geometry(ivef)>0) then
           ! Put nodes according to geometry
           line => this%geometry%get_line( this%vefs_geometry(ivef) )
           u_param1 = line%get_parameter(point1,1.0e-8_rp)
           u_param2 = line%get_parameter(point2,1.0e-8_rp)
           do inode = 1,face_num_nodes
              param = real(inode,rp)/(face_num_nodes+1)
              u_param = u_param1 * (1.0_rp - param) + &
                   &            u_param2 * param 
              call line%evaluate(u_param,coordinates(inode))
           end do
        else
           ! Put nodes by linear interpolation
           do inode = 1,face_num_nodes
              u_param = real(inode,rp)/(face_num_nodes+1)
              coordinates(inode) = point1*(1.0_rp -u_param) + &
                   &               point2*u_param
           end do
        end if
        ! write(*,*) 'Vef points:' ,ivef ,vertex1, vertex2, num_points, this%vefs_geometry(ivef)
        ! write(*,*) point1%get_value(),u_param1
        ! write(*,*) point2%get_value(),u_param2
        ! write(*,*) points(1)%get_value()
        ! write(*,*) points(2)%get_value()
        ! write(*,*) points(3)%get_value()

        do inode=1,face_num_nodes
           l_node = cell%get_node_lid( this%reference_fe_geo_list(cell_type)%p%get_own_node_n_face(inode,ivef_pos_in_cell) )
           this%coordinates(l_node) = coordinates(inode)
        end do
     end if      
     call face%next()
  end do
  call this%free_vef_iterator(face)

  ! Fill internal nodes
  ! write(*,*) 'Fill internal nodes'
  call cell%first()
  do while ( .not. cell%has_finished() )
     if ( cell%is_local() ) then
       ! Reallocate coordinates (if needed) and get them from cell
       cell_num_nodes = cell%get_num_nodes()
       call memrealloc( cell_num_nodes, coordinates, __FILE__,__LINE__)
       call cell%get_coordinates(coordinates)

       ! Call reference_fe to make the blending
       !write(*,*) 'Calling blending:'
       cell_num_vefs = cell%get_num_vefs()
       call this%reference_fe_geo_index%get(key=cell_num_vefs,val=cell_type,stat=istat)
       assert(istat==key_found)
       call this%reference_fe_geo_list(cell_type)%p%blending(coordinates)

       ! Store coordinates
       call cell%set_coordinates(coordinates)
     end if
     call cell%next()
  end do
  call memfree( coordinates, __FILE__,__LINE__)
  call this%free_cell_iterator(cell)
end subroutine fine_triangulation_allocate_and_fill_coordinates
  
subroutine fine_triangulation_free_coordinates( this )
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  if (allocated(this%coordinates)) call memfree(this%coordinates,__FILE__,__LINE__)
end subroutine fine_triangulation_free_coordinates

subroutine fine_triangulation_free ( this )
  implicit none
  class(fine_triangulation_t), target, intent(inout) :: this
  integer(ip) :: icell
  call this%free_geometry_and_set()
  call this%free_nodes()
  call this%free_coordinates()
  do icell=1, max_num_reference_fes_geo
     if(associated(this%reference_fe_geo_list(icell)%p)) then
        call this%reference_fe_geo_list(icell)%p%free()
        nullify(this%reference_fe_geo_list(icell)%p)
     endif
  enddo
  call this%base_static_triangulation_t%free()  
end subroutine fine_triangulation_free
