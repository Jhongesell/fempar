

function get_number_elements ( this )
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this
  integer(ip)                 :: get_number_elements
  get_number_elements = this%triangulation%num_elems
end function get_number_elements

subroutine initialize_integration( this, max_order )
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: this  
  integer(ip), optional, intent(in)  :: max_order

  call this%initialize_quadrature()
  call this%initialize_volume_integrator()
  call this%initialize_fe_map()

end subroutine initialize_integration

subroutine initialize_quadrature( this, max_order )
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: this  
  integer(ip), optional, intent(in)  :: max_order
  integer(ip) :: i

  !write(*,*) 'this%reference_fe_geo_list',size(this%reference_fe_geo_list)
  do i = 1, size(this%reference_fe_geo_list)
     !write(*,*) 'call create quadrature'
     call this%reference_fe_geo_list(i)%p%create_quadrature( this%quadrature(i)%p, max_order )
  end do

end subroutine initialize_quadrature

subroutine initialize_fe_map( this)!, max_order )
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: this  
  !integer(ip), optional, intent(in)  :: max_order
  integer(ip) :: i

  do i = 1, size(this%fe_map)
     call this%fe_map(i)%p%set( )!max_order )
  end do

end subroutine initialize_fe_map

function get_blocks( this )
  implicit none
  class(SB_serial_fe_space_t), target, intent(in) :: this
  integer(ip), pointer :: get_blocks(:)
  get_blocks => this%field_blocks
end function get_blocks

function get_fields_coupling( this )
  implicit none
  class(SB_serial_fe_space_t), target, intent(in) :: this
  logical, pointer :: get_fields_coupling(:,:)
  get_fields_coupling => this%fields_coupling
end function get_fields_coupling

subroutine create( this, triangulation, reference_fe_array, boundary_conditions, blocks, blocks_coupling, topology, fe_type, number_dimensions )
  implicit none
  class(SB_serial_fe_space_t), target, intent(inout) :: this
  class(triangulation_t), target, intent(inout) :: triangulation
  character(*), intent(in) :: topology, fe_type
  integer(ip), intent(in)  :: number_dimensions
  type(p_reference_fe_t), target, intent(in) :: reference_fe_array(:)
  integer(ip), optional, intent(in) :: blocks(:)
  logical, optional, intent(in) :: blocks_coupling(:,:)
  type(conditions_t), intent(in)  :: boundary_conditions
  integer(ip) :: i, j, number_nodes, istat, iobje, obje_g, inode, jnode

  this%number_fe_spaces = size(reference_fe_array)
  call memalloc( this%number_fe_spaces, this%field_blocks, __FILE__, __LINE__)
  call memalloc( this%number_fe_spaces, this%number_fe_spaces, this%fields_coupling, __FILE__, __LINE__)
  if ( present(blocks) ) then
     assert( size(blocks,1) == this%number_fe_spaces )
     assert( size(blocks_coupling,1) == this%number_fe_spaces )
     assert( size(blocks_coupling,2) == this%number_fe_spaces )
     this%field_blocks = blocks
     this%fields_coupling = blocks_coupling
  else
     this%field_blocks = 1
     this%fields_coupling = .true.
  end if
  this%number_blocks = maxval(this%field_blocks)

  this%triangulation => triangulation

  ! Assuming only one reference FE for the moment  SB.alert
  allocate( this%reference_fe_geo_list(1), stat=istat )
  allocate( this%quadrature(1), stat=istat )
  allocate( this%fe_map(1), stat=istat )
  allocate( this%volume_integrator(this%number_fe_spaces), stat=istat )
  allocate( this%reference_fe_phy_list(this%number_fe_spaces), stat=istat )

  ! Order 1 for geometry SB.alert
  this%reference_fe_geo_list(1)%p => &
       start_reference_fe ( topology = topology, fe_type = fe_type, number_dimensions = number_dimensions, &
       order =  1 , field_type = "vector", continuity = .true. )						
  allocate( this%quadrature(1)%p )
  allocate( this%fe_map(1)%p )

  do i  = 1, this%number_fe_spaces
     this%reference_fe_phy_list(i)%p => reference_fe_array(i)%p
     allocate( this%volume_integrator(i)%p )
     call this%volume_integrator(i)%p%create( this%reference_fe_phy_list(i)%p, &
          this%quadrature(1)%p )
  end do
  call this%fe_map(1)%p%create( this%reference_fe_geo_list(1)%p, this%quadrature(1)%p )

  allocate(this%fe_array(this%triangulation%num_elems))



  do i = 1, this%triangulation%num_elems
     !write(*,*) '**************ielem*******************',i
     number_nodes = 0
     do j = 1, this%number_fe_spaces
        number_nodes = number_nodes + reference_fe_array(j)%p%get_number_nodes()
     end do
     this%fe_array(i)%cell => triangulation%elems(i)
     this%fe_array(i)%number_nodes = number_nodes

     this%fe_array(i)%geometry_reference_fe => this%reference_fe_geo_list(1)%p
     this%fe_array(i)%quadrature => this%quadrature(1)%p
     this%fe_array(i)%fe_map => this%fe_map(1)%p

     this%fe_array(i)%volume_integrator => this%volume_integrator
     this%fe_array(i)%reference_fe => this%reference_fe_phy_list

     allocate( this%fe_array(i)%elem2dof(this%number_fe_spaces) )
     allocate( this%fe_array(i)%bc_code(this%number_fe_spaces) )
     allocate( this%fe_array(i)%bc_value(this%number_fe_spaces) )
     do j = 1, this%number_fe_spaces
        number_nodes = this%reference_fe_phy_list(j)%p%get_number_nodes()
        allocate( this%fe_array(i)%elem2dof(j)%l(number_nodes) )
        this%fe_array(i)%elem2dof(j)%l = 0
        allocate( this%fe_array(i)%bc_code(j)%l(number_nodes) )
        allocate( this%fe_array(i)%bc_value(j)%a(number_nodes) )
        this%fe_array(i)%bc_code(j)%l = 0
        this%fe_array(i)%bc_value(j)%a = 0.0_rp



        do iobje = 1,this%fe_array(i)%reference_fe(j)%p%get_number_vefs()
           obje_g = triangulation%elems(i)%vefs(iobje)
           !write(*,*) '*************local / global object ****************',iobje,obje_g
           do inode = 1, this%fe_array(i)%reference_fe(j)%p%get_number_interior_nodes_vef(iobje)
              jnode = this%fe_array(i)%reference_fe(j)%p%get_interior_node_vef(inode,iobje)
              !write(*,*) '********* local node **************',jnode
              !write(*,*) '******* component******',this%fe_array(i)%reference_fe(j)%p%get_bc_component_node(jnode)
              !write(*,*) '******value *********',boundary_conditions%code(this%fe_array(i)%reference_fe(j)%p%get_bc_component_node(jnode),obje_g)

              this%fe_array(i)%bc_code(j)%l(jnode) = &
                   boundary_conditions%code(this%fe_array(i)%reference_fe(j)%p%get_bc_component_node(jnode),obje_g)
              this%fe_array(i)%bc_value(j)%a(jnode) = &
                   boundary_conditions%valu(this%fe_array(i)%reference_fe(j)%p%get_bc_component_node(jnode),obje_g)
           end do
        end do
     end do
     !write(*,*) '*********** bc_code ************',this%fe_array(i)%bc_code(1)%l
     !write(*,*) '*********** bc_value ************',this%fe_array(i)%bc_value(1)%a


  end do
end subroutine create

function get_fe( this, i )
  implicit none
  class(SB_serial_fe_space_t), target, intent(in) :: this
  integer(ip) :: i
  class(SB_finite_element_t), pointer :: get_fe
  get_fe => this%fe_array(i)
end function get_fe


subroutine initialize_volume_integrator( this )!, max_order )
  implicit none
  class(SB_serial_fe_space_t), intent(inout) :: this
  !integer(ip), optional, intent(in) :: max_order
  integer(ip) :: i
  do i = 1, this%number_fe_spaces
     call this%volume_integrator(i)%p%set_integration()!( max_order )
  end do
end subroutine initialize_volume_integrator


function get_max_number_nodes( this)
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this 
  integer(ip) :: get_max_number_nodes
  get_max_number_nodes = 100 ! SB.alert 
end function get_max_number_nodes

function get_number_blocks( this)
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this 
  integer(ip) :: get_number_blocks
  get_number_blocks = this%number_blocks ! SB.alert 
end function get_number_blocks

function get_number_fe_spaces( this)
  implicit none
  class(SB_serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: get_number_fe_spaces
  get_number_fe_spaces = this%number_fe_spaces ! SB.alert 
end function get_number_fe_spaces

subroutine fill_dof_info( this )
  implicit none
  class(SB_serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock, c, i

  call memalloc( this%number_blocks, this%number_dofs, __FILE__, __LINE__ )
  allocate( this%vef2dof(this%number_fe_spaces) )

  this%number_dofs = 0
  do iblock = 1, this%number_blocks
     c = 0
     do i = 1, this%number_fe_spaces
        if ( this%field_blocks(i) == iblock ) then            
           call create_element_to_dof_and_ndofs( this, this%number_dofs(iblock), i )
           call create_vef2dof( this, i )
        end if
     end do
  end do
  !write (*,*) '***************NDOFS***************',this%number_dofs

end subroutine fill_dof_info

function create_assembler(this, diagonal_blocks_symmetric_storage,&
     diagonal_blocks_symmetric, diagonal_blocks_sign)
  implicit none
  class(SB_serial_fe_space_t)          , intent(in) :: this
  class(SB_matrix_array_assembler_t), pointer :: create_assembler
  logical                        , intent(in) :: diagonal_blocks_symmetric_storage(:)
  logical                        , intent(in) :: diagonal_blocks_symmetric(:)
  integer(ip)                    , intent(in) :: diagonal_blocks_sign(:)

  class(matrix_t), pointer :: matrix
  class(array_t) , pointer :: array

  if (this%number_blocks == 1) then
     allocate ( SB_serial_scalar_matrix_array_assembler_t :: create_assembler )
     allocate ( serial_scalar_matrix_t :: matrix )
     allocate ( serial_scalar_array_t  :: array )
     select type(matrix)
        class is(serial_scalar_matrix_t)
        call matrix%create(this%number_dofs(1), &
             diagonal_blocks_symmetric_storage(1),&
             diagonal_blocks_symmetric(1),&
             diagonal_blocks_sign(1))
        class default
        check(.false.)
     end select
     select type(array)
        class is(serial_scalar_array_t)
        call array%create(this%number_dofs(1))
        class default
        check(.false.)
     end select
  else
     allocate ( SB_serial_block_matrix_array_assembler_t :: create_assembler )
     allocate ( serial_block_matrix_t :: matrix )
     allocate ( serial_block_array_t  :: array )
     select type(matrix)
        class is (serial_block_matrix_t)
        call matrix%create(this%number_blocks,this%number_dofs,this%number_dofs,&
             & diagonal_blocks_symmetric_storage,diagonal_blocks_symmetric,diagonal_blocks_sign)
        class default
        check(.false.)
     end select
     select type(array)
        class is(serial_block_array_t)
        call array%create(this%number_blocks,this%number_dofs)
        class default
        check(.false.)
     end select
  end if

  call create_assembler%set_matrix(matrix)
  call create_assembler%set_array(array)

end function create_assembler

subroutine symbolic_setup_assembler(this,matrix_array_assembler)
  implicit none
  class(SB_serial_fe_space_t)        , intent(in)    :: this
  class(SB_matrix_array_assembler_t) , intent(inout) :: matrix_array_assembler

  ! Polymorphic matrix 
  class(matrix_t), pointer :: matrix
  type(serial_scalar_matrix_t), pointer :: serial_scalar_matrix
  integer(ip) :: i,j 

  matrix => matrix_array_assembler%get_matrix()
  select type(matrix)
     class is(serial_scalar_matrix_t)

     !write(*,*) 'graph create'
     !call print_list_2d( 6, this%vef2dof(1) ) 
     call setup_dof_graph_from_block_row_col_identifiers( this, matrix, 1 )

     !call matrix%print_matrix_market(6)
     !call matrix%print(6)

     ! symbolic_setup_assembler SHOWSTOPPER => IT REQUIRES A FULL GRAPH WITH ALL ENTRIES, HERE IS THE PROBLEM !!!
     ! BUT IT CAN BE SOLVED WITH THE UNCOMPRESSED GRAPH

     !call setup_dof_graph_from_block_row_col_identifiers ( this, matrix )

     class is(serial_block_matrix_t)
     do i = 1, this%number_blocks
        do j = 1, this%number_blocks
           if ( i == j) then
              serial_scalar_matrix => matrix%get_block(i,j)

              !write(*,*) ' ********************** VEF2DOF BEFORE CALLING**********************'
              !call print_list_2d( 6, this%vef2dof(i) ) 

              call setup_dof_graph_from_block_row_col_identifiers( this, serial_scalar_matrix, i )
              !call setup_dof_graph_from_block_row_col_identifiers( this%reference_fe_array(i)%p, serial_scalar_matrix, 1 )
           else
              call matrix%set_block_to_zero(i,j)
           end if
        end do
     end do
     class default
     check(.false.)
  end select

end subroutine symbolic_setup_assembler

!*********************************************************************************
! This subroutine takes the triangulation and fills the element2dof structure at every 
! finite element, i.e., it labels all dofs related to local elements (not ghost), after a 
! count-list procedure, and puts the number of dofs in ndofs structure (per block).
! Note 1: The numbering is per every block independently, where the blocks are 
! defined at the dof_descriptor. A global dof numbering is not needed in the code, 
! when blocks are being used.
!*********************************************************************************
subroutine create_element_to_dof_and_ndofs( fe_space, init_dof, var ) 
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t)     , intent(inout) :: fe_space 
  integer(ip), optional, intent(in) :: var
  integer(ip), optional, intent(inout) :: init_dof

  ! Local variables
  integer(ip) :: iprob, count, iobje, ielem, jelem, nvapb
  integer(ip) :: obje_l, inode, l_node, elem_ext, obje_ext, prob_ext, inode_ext, inode_l
  integer(ip) :: mater, order, nnode
  integer(ip) :: touch(1,2)

  integer(ip), allocatable :: o2n(:)

  count = init_dof

  mater = 1

  call memalloc ( fe_space%get_max_number_nodes(), o2n, __FILE__, __LINE__ )

  ! Part 1: Put DOFs on VEFs, taking into account that DOFs only belong to VEFs when we do not
  ! enforce continuity (continuity(ielem) /= 0). We go through all objects, elements around the
  ! object, variables of the element, and if for the value of continuity of this element no 
  ! DOFs have already been added, we add them and touch this object for this continuity value.
  ! In FEMPAR, continuity is an elemental value. If it is different from 0, the nodes/DOFs 
  ! geometrically on the interface belong to the interface objects (VEFs). Next, we only
  ! enforce continuity for elements with same continuity value (mater below), in order to 
  ! allow for situations in which we want to have continuity in patches and discontinuity among 
  ! patches based on physical arguments (every patch would involve its own value of continuity).
  ! For hp-adaptivity, we could consider the value in continuity to be p (order) and as a result
  ! not to enforce continuity among elements with different order SINCE it would lead to ERROR
  ! to enforce continuity among elements of different order.
  do iobje = 1, fe_space%triangulation%num_vefs          
     touch = 0
     !write(*,*) 'loop iobje',iobje
     do ielem = 1, fe_space%triangulation%vefs(iobje)%num_elems_around
        jelem = fe_space%triangulation%vefs(iobje)%elems_around(ielem)
        !write(*,*) 'jelem',jelem
        if ( jelem <= fe_space%triangulation%num_elems ) then ! Local elements
           if ( fe_space%fe_array(jelem)%reference_fe(var)%p%get_continuity() ) then
              !mater = fe_space%fe_array(jelem)%continuity(g_var) ! SB.alert : continuity can be used as p 
              mater = 1 ! For the moment SB.alert
              do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                 if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
              end do
              !if ( fe_space%fe_array(jelem)%bc_code(1,obje_l) == 0 ) then
              if ( touch(mater,1) == 0 ) then                            
                 touch(mater,1) = jelem
                 touch(mater,2) = obje_l
                 !write(*,*) 'obje_l new dofs',obje_l
                 call put_new_vefs_dofs_in_vef_of_element ( fe_space%triangulation, fe_space, jelem, count, obje_l, var )
              else
                 !write(*,*) 'obje_l old dofs',obje_l
                 call put_existing_vefs_dofs_in_vef_of_element ( fe_space%triangulation, fe_space, touch, mater, iobje, jelem, o2n, obje_l, var )
              end if
              !end if
           end if
        else ! Ghost elements
           if ( fe_space%fe_array(jelem)%reference_fe(var)%p%get_continuity() ) then
              !mater = fe_space%fe_array(jelem)%continuity(g_var) ! SB.alert : continuity can be used as p 
              mater = 1
              do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                 if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
              end do
              if ( touch(mater,1) /= 0) then
                 call put_existing_vefs_dofs_in_vef_of_element ( fe_space%triangulation, fe_space, touch, mater, iobje, jelem, o2n, obje_l, var )
              end if
           end if
        end if
     end do
  end do

  ! Part 2: Put DOFs on nodes belonging to the volume object (element). For cG we only do that when 
  ! static condensation is not active. Static condensation is for all variables, elements, etc. BUT
  ! it cannot be used with dG. The following algorithm is ASSUMING that this is the case, and we are
  ! not using dG + static condensations. In any case, when creating the fe_space there is an 
  ! automatic check for satisfying that.
  ! No check about strong Dirichlet boundary conditions, because they are imposed weakly in dG, and
  ! never appear in interior nodes in cG.
  !if ( ( .not. fe_space%static_condensation )  ) then
  do ielem = 1, fe_space%triangulation%num_elems
     iobje = fe_space%triangulation%elems(ielem)%num_vefs+1
     do inode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
        !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
        !  &     fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
        l_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(inode,iobje)
        !l_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(inode)
        count = count +1
        fe_space%fe_array(ielem)%elem2dof(var)%l(l_node) = count
     end do
  end do
  !end if 

  ! Part 3: Assign total number of dofs created to fem space object
  !fe_space%number_dofs = count
  init_dof = init_dof + count

  call memfree ( o2n, __FILE__, __LINE__ )

end subroutine create_element_to_dof_and_ndofs


!*********************************************************************************
! This subroutine takes the finite element space and fills the vef2dof structure. 
! The vef2dof structure puts on top of VEFs the DOFs that are meant to be continuous 
! between elements with the same continuity label. As an example, when using dG only, 
! vef2dof is void. It is more an acceleration array than a really needed structure, 
! but it is convenient when creating the dof graph. 
!*********************************************************************************
subroutine create_vef2dof ( fe_space, var ) 
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: fe_space 
  integer(ip), intent(in) :: var

  ! Local variables
  integer(ip) :: iprob, count, iobje, ielem, jelem, nvapb
  integer(ip) :: obje_l, inode, l_node, mater, istat
  integer(ip) :: touch!(1,fe_space%num_continuity)

  associate( vef2dof => fe_space%vef2dof(var) )
    ! Part 1: Count DOFs on VEFs, using the notion of continuity described above (in elem2dof)
  vef2dof%n1 = fe_space%triangulation%num_vefs
  vef2dof%n2 = 1
  call memalloc ( fe_space%triangulation%num_vefs+1, vef2dof%p, __FILE__, __LINE__, 0 )
  do iobje = 1, fe_space%triangulation%num_vefs
     touch = 0
     do ielem = 1, fe_space%triangulation%vefs(iobje)%num_elems_around
        jelem = fe_space%triangulation%vefs(iobje)%elems_around(ielem)
        if ( jelem <= fe_space%triangulation%num_elems ) then 
           !iprob = fe_space%fe_array(jelem)%problem
           mater = 1
           if ( mater /= 0 ) then
              if (touch == 0) then
                 touch = 1
                 !if ( touch(g_var,mater) == 0 ) then
                 !   touch(g_var,mater) = 1
                 do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                    if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
                 end do


                 do inode = 1, fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(obje_l)
                    l_node = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(inode,obje_l)
                    if ( fe_space%fe_array(jelem)%bc_code(var)%l(l_node) == 0 ) then
                       vef2dof%p(iobje+1) = vef2dof%p(iobje+1) + 1
                    end	if
                 end	do


                 !!if ( fe_space%fe_array(jelem)%bc_code(1,obje_l) == 0 ) then
                 !   vef2dof%p(iobje+1) = vef2dof%p(iobje+1) + &
                 !        fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(obje_l)
                 !   !+ fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l+1) &
                 !   !     & - fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l)
                 !!end if
                 !								


              end if
           end if
        end if
     end do
  end do


  vef2dof%p(1) = 1
  do iobje = 2, fe_space%triangulation%num_vefs+1
     vef2dof%p(iobje) = vef2dof%p(iobje) + vef2dof%p(iobje-1)
  end do

  !write(*,*) 'vef2dof%p,VAR',vef2dof%p,var

  call memalloc ( vef2dof%p(fe_space%triangulation%num_vefs+1)-1, 3, vef2dof%l, __FILE__, __LINE__ )

  ! Part 2: List DOFs on VEFs, using the notion of continuity described above (in elem2dof)
  ! We note that the vef2dof%l(:,X) is defined for X = 1,2,3
  ! vef2dof%l(:,1) : DOF LID
  ! vef2dof%l(:,2) : Variable GID associated to that DOF
  ! vef2dof%l(:,3) : Continuity value associated to that DOF (to enforce continuity)
  count = 0
  do iobje = 1, fe_space%triangulation%num_vefs
     touch = 0
     do ielem = 1, fe_space%triangulation%vefs(iobje)%num_elems_around
        jelem = fe_space%triangulation%vefs(iobje)%elems_around(ielem)
        if ( jelem <= fe_space%triangulation%num_elems ) then 
           !iprob = fe_space%fe_array(jelem)%problem
           mater = 1
           if ( mater /= 0) then
              if (touch == 0) then
                 touch = 1
                 !if ( touch(g_var,mater) == 0 ) then
                 !   touch(g_var,mater) = 1
                 do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                    if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
                 end do
                 !if ( fe_space%fe_array(jelem)%bc_code(1,obje_l) == 0 ) then
                 do inode = 1, fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(obje_l)
                    !fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l), &
                    !&     !fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l+1)-1 
                    l_node = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(inode,obje_l)
                    if ( fe_space%fe_array(jelem)%bc_code(var)%l(l_node) == 0 ) then
                       !fe_space%fe_array(jelem)%nodes_per_vef%p%l(inode)
                       count = count + 1
                       vef2dof%l(count,1) = fe_space%fe_array(jelem)%elem2dof(var)%l(l_node)
                       !vef2dof%l(count,2) = 1
                       !vef2dof%l(count,3) = mater
                    end if
                 end do
                 !end if
              end if
           end if
        end if
     end do
  end do
end associate
end subroutine create_vef2dof

!*********************************************************************************
! Auxiliary function that generates new DOFs and put them in a particular VEF of a given element
!*********************************************************************************
subroutine put_new_vefs_dofs_in_vef_of_element ( trian, fe_space, jelem, &
   count, obje_l, var )
implicit none
! Parameters
type(triangulation_t), intent(in)         :: trian 
class(SB_serial_fe_space_t), intent(inout)              :: fe_space 
integer(ip), intent(inout)                  :: count
integer(ip), intent(in)                     :: jelem, obje_l, var

! Local variables
integer(ip) :: inode, l_node

do inode = 1,fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(obje_l)
   !fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l), &
   !         &     fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l+1)-1 
   l_node = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(inode,obje_l)
   !l_node = fe_space%fe_array(jelem)%nodes_per_vef%p%l(inode)
   if ( fe_space%fe_array(jelem)%bc_code(var)%l(l_node) == 0 ) then
      count = count + 1
      !write (*,*) '****PUT DOF**** (elem,obj_l,obj_g,node,idof) ',jelem,obje_l,l_node,count
      fe_space%fe_array(jelem)%elem2dof(var)%l(l_node) = count
   end	if
end do

end subroutine put_new_vefs_dofs_in_vef_of_element

!*********************************************************************************
! Auxiliary function that puts existing DOFs in a particular VEF of a given element
!*********************************************************************************
subroutine put_existing_vefs_dofs_in_vef_of_element ( trian, fe_space, touch, mater, iobje, jelem, &
   o2n, obje_l, var )
implicit none
! Parameters
type(triangulation_t), intent(in)           :: trian 
class(SB_serial_fe_space_t), intent(inout)      :: fe_space
integer(ip), intent(in)                     :: touch(:,:), mater, iobje, jelem, obje_l, var
integer(ip), intent(out)                    :: o2n(:)

! Local variables
integer(ip) :: elem_ext, obje_ext, prob_ext
integer(ip) :: nnode, order, inode, l_node, inode_ext, inode_l

elem_ext = touch(mater,1)
obje_ext = touch(mater,2)
!prob_ext = fe_space%fe_array(elem_ext)%problem
prob_ext = 1

nnode = fe_space%fe_array(elem_ext)%reference_fe(var)%p%get_number_interior_nodes_vef(obje_ext)

!fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext+1) &
!     &  -fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext) 
!write(*,*) 'jelem',jelem
!write(*,*) 'nnode',nnode
if ( nnode > 0) then  
   order = fe_space%fe_array(elem_ext)%reference_fe(var)%p%get_order()
   !write(*,*) 'order',order
   !if ( trian%vefs(iobje)%dimension == trian%num_dims .and. &
   !     & nnode ==  (order+1)**trian%num_dims ) then
   !   order = order    ! hdG case
   !elseif ( nnode ==  (order-1)**trian%vefs(iobje)%dimension ) then
   order = order -2 ! cG case SB.alert
   !else
   !   assert ( 0 == 1) ! SB.alert : Other situations possible when dG_continuity, cdG, hp-adaptivity ?
   !end if
   call fe_space%fe_array(jelem)%reference_fe(var)%p%permute_nodes_per_vef( &
        & fe_space%fe_array(elem_ext)%reference_fe(var)%p,                  &
        & o2n,obje_ext,obje_l,                                                     &
        & trian%elems(elem_ext)%vefs,                                              &
        & trian%elems(jelem)%vefs,                                                 &
        & trian%vefs(iobje)%dimension,                                             &
        & order )
   do inode = 1, fe_space%fe_array(elem_ext)%reference_fe(var)%p%get_number_interior_nodes_vef(obje_ext)
      !nodes_per_vef%p%p(obje_ext+1) - &
      !            fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext)
      inode_ext = fe_space%fe_array(elem_ext)%reference_fe(var)%p%get_interior_node_vef(inode,obje_ext)
      !l_node = fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext) + inode - 1
      !inode_ext = fe_space%fe_array(elem_ext)%nodes_per_vef%p%l(l_node )
      !inode_l = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(o2n(inode),obje_l)


      inode_l = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(o2n(inode),obje_l)

      ! PRUEBA SB.alert
      ! I am not using the o2n because I assume that I have a first order FE space, only
      ! vefs on corners and permutation not needed. The permutation must be modified for 
      ! vector-valued problems. Think about it!

      !inode_l = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(inode,obje_l)

      !l_node = fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l) + o2n(inode) - 1
      !inode_l = fe_space%fe_array(jelem)%nodes_per_vef%p%l(l_node)
      if ( fe_space%fe_array(jelem)%bc_code(var)%l(inode_l) == 0 ) then
         !write (*,*) '****EXTRACT DOF**** (object)', iobje, ' FROM: (elem,obj_l) ',elem_ext,obje_ext, ' TO  : (elem,obj_l)', jelem,obje_l
         !write(*,*) 'We take value',fe_space%fe_array(elem_ext)%elem2dof(var)%l(inode_ext),'from node',inode_ext
         !write(*,*) 'o2n',o2n
         !write(*,*) 'in position',inode_l
         fe_space%fe_array(jelem)%elem2dof(var)%l(inode_l) = fe_space%fe_array(elem_ext)%elem2dof(var)%l(inode_ext)
      end	if
   end do ! SB.alert : 1) face object for cG and hdG, where the face must have all their nodes
   !                   2) corner / edge only for cG
   !            * Never here for dG, continuity interface, hanging objects, etc.


end if


end subroutine put_existing_vefs_dofs_in_vef_of_element





! subroutine serial_fe_space_symbolic_setup_assembler(this,matrix_array_assembler)
!   implicit none
!   class(SB_serial_fe_space_t)        , intent(in)    :: this
!   class(SB_matrix_array_assembler_t) , intent(inout) :: matrix_array_assembler

!   ! Polymorphic matrix 
!   class(matrix_t), pointer :: matrix

!   matrix => matrix_array_assembler%get_matrix()
!   select type(matrix)
!      class is(serial_scalar_matrix_t)
!      call setup_dof_graph_from_block_row_col_identifiers ( this, matrix, 1 )
!      class default
!      check(.false.)
!   end select

! end subroutine serial_fe_space_symbolic_setup_assembler





!*********************************************************************************
! This subroutine takes the fe_space and creates a dof_graph. 
! The dof_graph includes both the coupling by continuity like in continuous Galerkin 
! methods, and the coupling by face terms (of discontinuous Galerkin type). The algorithm 
! considers both the case with static condensation and without it. In order to call this 
! subroutine, we need to compute first element2dof and vef2dof arrays.
! 3) It generates the local graph (to be extended in *par_create_global_dof_info_names*
!    to put additional DOFs due to face integration coupling with DOFs from ghost 
!    elements) (see explanation of the subroutine below and *ghost_dofs_by_integration*
!    in *par_create_global_dof_info_names* for more insight)
!*********************************************************************************
subroutine setup_dof_graph_from_block_row_col_identifiers(  fe_space, matrix, var ) 
implicit none
! Parameters
class(SB_serial_fe_space_t) , intent(in)     :: fe_space 
type(serial_scalar_matrix_t), intent(inout)  :: matrix
integer(ip) , intent(in) :: var

! Local variables
integer(ip) :: iprob, count, iobje, ielem, jelem, nvapb, inter, inode, l_node
integer(ip) :: idof, jdof, int_i, int_j, istat, jnode, job_g, jobje
integer(ip) :: l_dof, m_dof, m_node, posi, posf, l_mat, m_mat, knode

integer(ip) :: nvapbi, nvapbj, nnode, i, iface, jprob, l_faci, l_facj, ic

integer(ip), allocatable :: aux_ia(:)
type(hash_table_ip_ip_t) :: visited
type(graph_t), pointer :: dof_graph

! Initialize
dof_graph => matrix%get_graph()
call memalloc( dof_graph%get_nv()+1, dof_graph%ia, __FILE__,__LINE__ )
dof_graph%ia = 0

! COUNT PART
call count_nnz_dofs_vefs_vs_dofs_vefs_vol_by_continuity ( fe_space%triangulation, fe_space, dof_graph, var )
call count_nnz_dofs_vol_vs_dofs_vefs_vol_by_continuity ( fe_space%triangulation, fe_space, dof_graph, var ) 

dof_graph%ia(1) = 1
do idof = 2, fe_space%number_dofs(var)+1
   dof_graph%ia(idof) = dof_graph%ia(idof) + dof_graph%ia(idof-1)
end do

call memalloc ( dof_graph%ia(fe_space%number_dofs(var)+1)-1, dof_graph%ja, __FILE__, __LINE__ )

! LIST PART
call memalloc( dof_graph%get_nv()+1, aux_ia, __FILE__,__LINE__ )
aux_ia = dof_graph%ia
!
call list_nnz_dofs_vefs_vs_dofs_vefs_vol_by_continuity ( fe_space%triangulation, fe_space, dof_graph, aux_ia, var ) 
call list_nnz_dofs_vol_vs_dofs_vefs_vol_by_continuity ( fe_space%triangulation, fe_space, dof_graph, aux_ia, var )

do idof = 1, fe_space%number_dofs(var)
   ! Order increasingly column identifiers of current row 
   ! using heap sort algorithm
   posi = dof_graph%ia(idof)
   posf = dof_graph%ia(idof+1)-1
   call sort(posf-posi+1,dof_graph%ja(posi:posf))
end do
!call dof_graph%print( 6)
call memfree (aux_ia,__FILE__,__LINE__)

call matrix%return_graph(dof_graph)

end subroutine setup_dof_graph_from_block_row_col_identifiers



!*********************************************************************************
! Count NNZ (number of nonzero entries) for DOFs on the interface (VEFs) of elements against
! both interior and interface nodes.
!*********************************************************************************
subroutine count_nnz_dofs_vefs_vs_dofs_vefs_vol_by_continuity (  trian, fe_space, dof_graph, var )  
implicit none
! Parameters
type(triangulation_t), intent(in)         :: trian 
class(SB_serial_fe_space_t), intent(in)                 :: fe_space 
type(graph_t), intent(inout)                :: dof_graph
integer(ip), intent(in) :: var

! Local variables
type(hash_table_ip_ip_t) :: visited
integer(ip) :: idof, ielem, inode, iobje, iprob, istat
integer(ip) :: jdof, jelem, job_g, jobje, l_dof, l_mat
integer(ip) :: l_node,  m_dof, m_mat,  nvapb, touch

!write(*,*) ' ********************** VEF2DOF COMPOSITE INSIDEOUTSIEDE**********************'
!call print_list_2d( 6, fe_space%vef2dof(var) ) 

associate( vef2dof => fe_space%vef2dof(var) )

  !write(*,*) ' ********************** VEF2DOF COMPOSITE INSIDE**********************'
  !call print_list_2d( 6, vef2dof ) 
do iobje = 1, trian%num_vefs             
   if ( vef2dof%p(iobje+1)-vef2dof%p(iobje) > 0) then
      call visited%init(100) 
      do ielem = 1, trian%vefs(iobje)%num_elems_around
         jelem = trian%vefs(iobje)%elems_around(ielem)
         if ( jelem <= trian%num_elems ) then
            do jobje = 1, trian%elems(jelem)%num_vefs
               job_g = trian%elems(jelem)%vefs(jobje)
               call visited%put(key=job_g, val=touch, stat=istat)
               if ( istat == now_stored ) then   ! interface-interface
                  do idof = vef2dof%p(iobje), vef2dof%p(iobje+1)-1
                     l_dof = vef2dof%l(idof,1)
                     l_mat = 1
                     do jdof = vef2dof%p(job_g), vef2dof%p(job_g+1)-1
                        m_dof = vef2dof%l(jdof,1)
                        m_mat = 1
                        if ( .not. dof_graph%symmetric_storage ) then
                           dof_graph%ia(l_dof+1) = &
                                & dof_graph%ia(l_dof+1) + 1
                        else
                           if ( m_dof >= l_dof ) then
                              dof_graph%ia(l_dof+1) = &
                                   & dof_graph%ia(l_dof+1) + 1
                           end if
                        end if
                     end do
                  end do
               end if
            end do
            !end do
            !if (.not.fe_space%static_condensation) then  ! interface-interior
            !iprob = fe_space%fe_array(jelem)%problem
            do idof = vef2dof%p(iobje), vef2dof%p(iobje+1)-1
               l_dof = vef2dof%l(idof,1)
               l_mat = vef2dof%l(idof,3)
               m_mat = 1
               if ( .not. dof_graph%symmetric_storage ) then
                  dof_graph%ia(l_dof+1) =  dof_graph%ia(l_dof+1) &
                       + fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(jobje)
                  !                         & + fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje+1) &
                  !                         & - fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje)
               else 
                  do inode = 1, fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(jobje)
                     !fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje), &
                     !  & fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje+1)-1
                     l_node = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(inode,jobje)
                     !l_node = fe_space%fe_array(jelem)%nodes_per_vef%p%l(inode)
                     m_dof = fe_space%fe_array(jelem)%elem2dof(var)%l(l_node)
                     if ( m_dof >= l_dof ) then
                        dof_graph%ia(l_dof+1) = &
                             & dof_graph%ia(l_dof+1) + 1
                     end if
                  end do
               end if
            end do
         end if
      end do
      call visited%free
   end if
end do
end associate
end subroutine count_nnz_dofs_vefs_vs_dofs_vefs_vol_by_continuity

!*********************************************************************************
! List NNZ (number of nonzero entries) for DOFs on the interface (VEFs) of elements against
! both interior and interface nodes.
!*********************************************************************************
subroutine list_nnz_dofs_vefs_vs_dofs_vefs_vol_by_continuity ( trian, fe_space, dof_graph, aux_ia, var )  
implicit none
! Parameters
type(triangulation_t), intent(in)         :: trian 
class(SB_serial_fe_space_t), intent(in)                 :: fe_space 
type(graph_t), intent(inout)                :: dof_graph
integer(ip), intent(inout)                :: aux_ia(:)
integer(ip), intent(in) :: var

! Local variables
type(hash_table_ip_ip_t) :: visited
integer(ip) :: idof, ielem, inode, iobje, iprob, istat
integer(ip) :: jdof, jelem, job_g, jobje, l_dof, l_mat
integer(ip) :: l_node, m_dof, m_mat, nvapb, touch, count, ic

associate( vef2dof => fe_space%vef2dof(var) )
count = 0
do iobje = 1, trian%num_vefs 
 if ( vef2dof%p(iobje+1)-vef2dof%p(iobje) > 0) then
    call visited%init(100) 
    do ielem = 1, trian%vefs(iobje)%num_elems_around
       jelem = trian%vefs(iobje)%elems_around(ielem)
       if ( jelem <= trian%num_elems ) then 
          do jobje = 1, trian%elems(jelem)%num_vefs
             job_g = trian%elems(jelem)%vefs(jobje)
             call visited%put(key=job_g, val=touch, stat=istat)
             if ( istat == now_stored ) then  ! interface-interface
                do idof = vef2dof%p(iobje), vef2dof%p(iobje+1)-1
                   l_dof = vef2dof%l(idof,1)
                   do jdof = vef2dof%p(job_g), vef2dof%p(job_g+1)-1
                      m_dof = vef2dof%l(jdof,1)
                      if ( .not. dof_graph%symmetric_storage ) then
                         ic = aux_ia(l_dof)
                         dof_graph%ja(ic) = m_dof
                         aux_ia(l_dof) = aux_ia(l_dof)+1
                      else 
                         if ( m_dof >= l_dof ) then
                            ic = aux_ia(l_dof)
                            dof_graph%ja(ic) = m_dof
                            aux_ia(l_dof) = aux_ia(l_dof)+1
                         end if
                      end if
                   end do
                end do
             end if
          end do
          !end do
          !if (.not.fe_space%static_condensation) then  ! interface-interior
          !   iprob = fe_space%fe_array(jelem)%problem
          do idof = vef2dof%p(iobje), vef2dof%p(iobje+1)-1
             l_dof = vef2dof%l(idof,1)
             l_mat = vef2dof%l(idof,3)
             m_mat = 1
             if ( .not. dof_graph%symmetric_storage ) then
                do inode = 1, fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(jobje)
                   !fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje), &
                   ! & fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje+1)-1
                   l_node = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(inode,jobje)
                   !l_node = fe_space%fe_array(jelem)%nodes_per_vef%p%l(inode)
                   m_dof = fe_space%fe_array(jelem)%elem2dof(var)%l(l_node)
                   ic = aux_ia(l_dof)
                   dof_graph%ja(ic) = m_dof
                   aux_ia(l_dof) = aux_ia(l_dof)+1
                end do
             else 
                do inode = 1, fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(jobje)
                   !fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje), &
                   !  & fe_space%fe_array(jelem)%nodes_per_vef%p%p(jobje+1)-1
                   l_node = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(inode,jobje)
                   !l_node = fe_space%fe_array(jelem)%nodes_per_vef%p%l(inode)
                   m_dof = fe_space%fe_array(jelem)%elem2dof(var)%l(l_node)
                   if ( m_dof >= l_dof ) then
                      ic = aux_ia(l_dof)
                      dof_graph%ja(ic) = m_dof
                      aux_ia(l_dof) = aux_ia(l_dof)+1
                   end if
                end do
             end if
          end do
       end if
    end do
    call visited%free
 end if
end do
end associate

end subroutine list_nnz_dofs_vefs_vs_dofs_vefs_vol_by_continuity



!*********************************************************************************
! Count NNZ (number of nonzero entries) for DOFs on the interface (VEFs) of elements against
! both interior and interface nodes.
!*********************************************************************************
subroutine count_nnz_dofs_vol_vs_dofs_vefs_vol_by_continuity ( trian, fe_space, dof_graph, var )  
implicit none
! Parameters
type(triangulation_t), intent(in)         :: trian 
class(SB_serial_fe_space_t), intent(in)                 :: fe_space 
type(graph_t), intent(inout)                :: dof_graph
integer(ip), intent(in) :: var

! Local variables
integer(ip) :: ielem, inode, int_i, iobje, iprob,  jdof, jnode, job_g
integer(ip) :: jobje, l_dof, l_mat, l_node,  m_dof, m_mat
integer(ip) :: m_node, nvapbi, nvapbj

associate( vef2dof => fe_space%vef2dof(var) )
  ! As commented for elem2dof, static condensation is false for dG, by construction of the 
  ! fem space.
  !if (.not.fe_space%static_condensation) then
do ielem  = 1, trian%num_elems
iobje = trian%elems(ielem)%num_vefs+1
!iprob = fe_space%fe_array(ielem)%problem
! Interior - interior 
do inode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
   !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
   !& fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
  l_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(inode,iobje)
  !l_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(inode)
  l_dof = fe_space%fe_array(ielem)%elem2dof(var)%l(l_node)
  if ( .not. dof_graph%symmetric_storage ) then
     dof_graph%ia(l_dof+1) =  dof_graph%ia(l_dof+1) &
          + fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
     !                   &  + fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1) &
     !                   & - fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje)
  else  
     do jnode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
        !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
        !  & fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
        m_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(jnode,iobje)
        !m_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(jnode)
        m_dof = fe_space%fe_array(ielem)%elem2dof(var)%l(m_node)
        if ( m_dof >= l_dof ) then
           dof_graph%ia(l_dof+1) = &
                & dof_graph%ia(l_dof+1) + 1
        end if
     end do
  end if
end do
l_mat = 1
if ( l_mat /= 0 ) then
   ! Interior - interface 
  do jobje = 1, trian%elems(ielem)%num_vefs
     job_g = trian%elems(ielem)%vefs(jobje)
     do jdof = vef2dof%p(job_g), vef2dof%p(job_g+1)-1
        m_dof = vef2dof%l(jdof,1)
        !m_mat = vef2dof%l(jdof,3)     
        do inode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
           !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
           !  & fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
           l_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(inode,iobje) 
           !l_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(inode)
           l_dof = fe_space%fe_array(ielem)%elem2dof(var)%l(l_node)
           if ( .not. dof_graph%symmetric_storage ) then
              dof_graph%ia(l_dof+1) = &
                   & dof_graph%ia(l_dof+1) + 1 
           else if ( m_dof >= l_dof ) then
              dof_graph%ia(l_dof+1) = &
                   & dof_graph%ia(l_dof+1) + 1
           end if
        end do
     end do
  end do
end if
end do
end associate
!end if

end subroutine count_nnz_dofs_vol_vs_dofs_vefs_vol_by_continuity

!*********************************************************************************
! List NNZ (number of nonzero entries) for DOFs on the interface (VEFs) of elements against
! both interior and interface nodes.
!*********************************************************************************
subroutine list_nnz_dofs_vol_vs_dofs_vefs_vol_by_continuity ( trian, fe_space, dof_graph, aux_ia, var )  
  implicit none
  ! Parameters
  type(triangulation_t), intent(in)         :: trian 
  class(SB_serial_fe_space_t), intent(in)                 :: fe_space 
  type(graph_t), intent(inout)              :: dof_graph
  integer(ip), intent(inout)                  :: aux_ia(:) 
  integer(ip), intent(in) :: var

  ! Local variables
  integer(ip) :: ielem, inode, iobje, iprob, jdof, jnode, job_g
  integer(ip) :: jobje, l_dof, l_mat, l_node, m_dof, m_mat
  integer(ip) :: m_node, nvapbi, nvapbj, i, ic

  associate( vef2dof => fe_space%vef2dof(var) )
    !if (.not.fe_space%static_condensation) then   
  do ielem  = 1, trian%num_elems
     iobje = trian%elems(ielem)%num_vefs+1
     !iprob = fe_space%fe_array(ielem)%problem 
     !l_var = g2l(ivars,iprob)
     ! Interior - interior (inside element)
     do inode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
        !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
        !     & fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
        l_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(inode,iobje)
        !l_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(inode)
        l_dof = fe_space%fe_array(ielem)%elem2dof(var)%l(l_node)
        !l_dof = fe_space%fe_array(ielem)%elem2dof(l_node)
        if ( .not. dof_graph%symmetric_storage ) then
           do jnode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
              !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
              ! & fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
              m_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(jnode,iobje)
              !m_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(jnode)
              !m_dof = fe_space%fe_array(ielem)%elem2dof(m_node)
              m_dof = fe_space%fe_array(ielem)%elem2dof(var)%l(m_node)
              i= aux_ia(l_dof)
              dof_graph%ja(i) = m_dof
              aux_ia(l_dof) = aux_ia(l_dof)+1
           end do
        else ! ltype == csr_symm 
           do jnode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
              !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
              !  & fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
              m_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(jnode,iobje)
              !m_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(jnode)
              m_dof = fe_space%fe_array(ielem)%elem2dof(var)%l(m_node)
              !m_dof = fe_space%fe_array(ielem)%elem2dof(m_node)
              if ( m_dof >= l_dof ) then
                 ic = aux_ia(l_dof)
                 dof_graph%ja(ic) = m_dof
                 aux_ia(l_dof) = aux_ia(l_dof)+1
              end if
           end do
        end if
     end do
     if ( fe_space%fe_array(ielem)%reference_fe(var)%p%get_continuity() /= 0 ) then
        ! Interior - border (inside element)
        do jobje = 1, trian%elems(ielem)%num_vefs
           job_g = trian%elems(ielem)%vefs(jobje)
           do jdof = vef2dof%p(job_g), vef2dof%p(job_g+1)-1
              m_dof = vef2dof%l(jdof,1)    
              do inode = 1, fe_space%fe_array(ielem)%reference_fe(var)%p%get_number_interior_nodes_vef(iobje)
                 !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
                 !  & fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
                 l_node = fe_space%fe_array(ielem)%reference_fe(var)%p%get_interior_node_vef(inode,iobje) 
                 !l_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(inode)
                 l_dof = fe_space%fe_array(ielem)%elem2dof(var)%l(l_node)
                 !l_dof = fe_space%fe_array(ielem)%elem2dof(l_node)
                 if ( .not. dof_graph%symmetric_storage ) then
                    ic = aux_ia(l_dof)
                    dof_graph%ja(ic) = m_dof
                    aux_ia(l_dof) = aux_ia(l_dof)+1
                 else if ( m_dof >= l_dof ) then
                    ic = aux_ia(l_dof)
                    dof_graph%ja(ic) = m_dof
                    aux_ia(l_dof) = aux_ia(l_dof)+1
                 end if
              end do
           end do
        end do
     end if
  end do
end associate
end subroutine list_nnz_dofs_vol_vs_dofs_vefs_vol_by_continuity

subroutine print ( this )
  class(SB_serial_fe_space_t), intent(in)                 :: this 
  
  integer(ip) :: i,j
  do i  = 1, this%triangulation%num_elems
     write(*,*) '********* ELEMENT: ',i,'********'
     write(*,*) '********* ELEMENT 2 DOF********'
     do j = 1, this%number_fe_spaces
     write(*,*) '********* FE COMPONENT: ',j,'********'
     write(*,*) this%fe_array(i)%elem2dof(j)%l
   end do
end do

end subroutine print


