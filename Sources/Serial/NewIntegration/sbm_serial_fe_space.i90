subroutine create( this, &
                   triangulation, &
                   boundary_conditions, &
                   reference_fe_phy, &
                   reference_fe_geo_topology, &
                   reference_fe_geo_type, & 
                   field_blocks, &
                   field_coupling )
  implicit none
  class(SB_serial_fe_space_t), target, intent(inout) :: this
  type(triangulation_t)      , target, intent(in)    :: triangulation
  type(conditions_t)                 , intent(in)    :: boundary_conditions
  character(*)                       , intent(in)    :: reference_fe_geo_topology
  character(*)                       , intent(in)    :: reference_fe_geo_type
  type(p_reference_fe_t),      target, intent(in)    :: reference_fe_phy(:)
  integer(ip)              , optional, intent(in)    :: field_blocks(:)
  logical                  , optional, intent(in)    :: field_coupling(:,:)
  
  integer(ip) :: i, j, number_nodes, istat, iobje, obje_g, inode, jnode

  this%number_fe_spaces = size(reference_fe_phy)
  call memalloc( this%number_fe_spaces, this%field_blocks, __FILE__, __LINE__)
  call memalloc( this%number_fe_spaces, this%number_fe_spaces, this%field_coupling, __FILE__, __LINE__)
  if ( present(field_blocks) ) then
     assert( size(field_blocks) == this%number_fe_spaces )
     assert( size(field_coupling,1) == this%number_fe_spaces )
     assert( size(field_coupling,2) == this%number_fe_spaces )
     this%field_blocks   = field_blocks
     this%field_coupling = field_coupling
  else
     this%field_blocks = 1
     this%field_coupling = .true.
  end if
  this%number_blocks = maxval(this%field_blocks)

  this%triangulation => triangulation

  ! Assuming only one geometrical reference FE for the moment  SB.alert
  ! assuming we are going to use faces of 1 type
  allocate( this%reference_fe_geo_list(1), stat=istat )
  allocate( this%quadrature(1), stat=istat )
  allocate( this%fe_map(1), stat=istat )
  
  allocate( this%volume_integrator(this%number_fe_spaces), stat=istat )
  allocate( this%reference_fe_phy_list(this%number_fe_spaces), stat=istat )

  ! Order 1 for geometry SB.alert
  this%reference_fe_geo_list(1) = make_reference_fe ( topology = reference_fe_geo_topology, &
                                                      fe_type = reference_fe_geo_type, & 
                                                      number_dimensions = triangulation%num_dims, &
                                                      order=1, &
                                                      field_type = "vector", &
                                                      continuity = .true. )						
  call this%quadrature(1)%allocate()
  call this%fe_map(1)%allocate()
  do i  = 1, this%number_fe_spaces
     this%reference_fe_phy_list(i) = reference_fe_phy(i)
     call this%volume_integrator(i)%allocate()
  end do

  allocate(this%fe_array(this%triangulation%num_elems))
  do i = 1, this%triangulation%num_elems
     number_nodes = 0
     do j = 1, this%number_fe_spaces
        number_nodes = number_nodes + reference_fe_phy(j)%p%get_number_nodes()
     end do
     this%fe_array(i)%cell => triangulation%elems(i)
     this%fe_array(i)%number_nodes = number_nodes
     this%fe_array(i)%number_fe_spaces = this%number_fe_spaces

     this%fe_array(i)%reference_fe_geo => this%reference_fe_geo_list(1)%p
     this%fe_array(i)%quadrature => this%quadrature(1)%p
     this%fe_array(i)%fe_map => this%fe_map(1)%p

     this%fe_array(i)%volume_integrator => this%volume_integrator
     this%fe_array(i)%reference_fe_phy => this%reference_fe_phy_list

     allocate( this%fe_array(i)%elem2dof(this%number_fe_spaces) )
     allocate( this%fe_array(i)%bc_code(this%number_fe_spaces) )
     allocate( this%fe_array(i)%bc_value(this%number_fe_spaces) )
     do j = 1, this%number_fe_spaces
        number_nodes = this%reference_fe_phy_list(j)%p%get_number_nodes()
        allocate( this%fe_array(i)%elem2dof(j)%p(number_nodes) )
        this%fe_array(i)%elem2dof(j)%p = 0
        allocate( this%fe_array(i)%bc_code(j)%p(number_nodes) )
        allocate( this%fe_array(i)%bc_value(j)%p(number_nodes) )
        this%fe_array(i)%bc_code(j)%p = 0
        this%fe_array(i)%bc_value(j)%p = 0.0_rp
        do iobje = 1,triangulation%elems(i)%num_vefs
           obje_g = triangulation%elems(i)%vefs(iobje)
           do inode = 1, this%fe_array(i)%reference_fe_phy(j)%p%get_number_interior_nodes_vef(iobje)
              jnode = this%fe_array(i)%reference_fe_phy(j)%p%get_interior_node_vef(inode,iobje)
              this%fe_array(i)%bc_code(j)%p(jnode) = &
                   boundary_conditions%code(this%fe_array(i)%reference_fe_phy(j)%p%get_bc_component_node(jnode),obje_g)
              this%fe_array(i)%bc_value(j)%p(jnode) = &
                   boundary_conditions%valu(this%fe_array(i)%reference_fe_phy(j)%p%get_bc_component_node(jnode),obje_g)
           end do
        end do
     end do
  end do
end subroutine create

subroutine fill_dof_info( this )
  implicit none
  class(SB_serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock, i
  call memalloc( this%number_blocks, this%number_dofs, __FILE__, __LINE__ )
  allocate( this%vef2dof(this%number_fe_spaces) )
  this%number_dofs = 0
  do iblock = 1, this%number_blocks
     do i = 1, this%number_fe_spaces
        if ( this%field_blocks(i) == iblock ) then            
           call create_element_to_dof_and_ndofs( this, this%number_dofs(iblock), i )
           call create_vef2dof( this, i )
        end if
     end do
  end do
end subroutine fill_dof_info

subroutine free( this )
  implicit none
  class(SB_serial_fe_space_t), intent(inout) :: this
  
  integer(ip) :: iblock, i, j, number_nodes, istat, iobje, obje_g, inode, jnode


  ! Order 1 for geometry SB.alert
  call this%reference_fe_geo_list(1)%free()
  call this%quadrature(1)%free()
  call this%fe_map(1)%free()
		
  do i  = 1, this%number_fe_spaces
     call this%volume_integrator(i)%free()
     call this%reference_fe_phy_list(i)%free()
  end do
  
  ! Assuming only one reference FE for the moment  SB.alert
  deallocate( this%reference_fe_geo_list )
  deallocate( this%quadrature )
  deallocate( this%fe_map )
  deallocate( this%volume_integrator )
  deallocate( this%reference_fe_phy_list )
  
  do i = 1, this%triangulation%num_elems
     
     nullify(this%fe_array(i)%cell)
     this%fe_array(i)%number_nodes = 0
     this%fe_array(i)%number_fe_spaces = 0

     nullify(this%fe_array(i)%reference_fe_geo)
     nullify(this%fe_array(i)%quadrature)
     nullify(this%fe_array(i)%fe_map)

     nullify(this%fe_array(i)%volume_integrator)
     nullify(this%fe_array(i)%reference_fe_phy)

     do j = 1, this%number_fe_spaces
        deallocate( this%fe_array(i)%elem2dof(j)%p )
        deallocate( this%fe_array(i)%bc_code(j)%p )
        deallocate( this%fe_array(i)%bc_value(j)%p )
     end do
     
     deallocate( this%fe_array(i)%elem2dof )
     deallocate( this%fe_array(i)%bc_code )
     deallocate( this%fe_array(i)%bc_value )
  end do
  
  deallocate(this%fe_array)

  ! Free memory related to face (assuming one only face_integrator
  if (allocated(this%face_integrator)) then
     do j = 1, 2 * this%number_fe_spaces
        call this%face_integrator(j)%p%free
     end do
     deallocate( this%face_integrator )
  end if

  if (allocated(this%face_array)) then
     do i = 1, this%triangulation%number_interior_faces + this%triangulation%number_boundary_faces
        call this%face_array(i)%free()
     end do
  end if
  
  do iblock = 1, this%number_blocks
     do i = 1, this%number_fe_spaces
        if ( this%field_blocks(i) == iblock ) then
           call this%vef2dof(i)%free()
        end if
     end do
  end do
  
  deallocate( this%vef2dof )
  
  call memfree( this%number_dofs, __FILE__, __LINE__ )
  this%number_fe_spaces = 0
  this%number_blocks = 0
  call memfree( this%field_blocks, __FILE__, __LINE__)
  call memfree( this%field_coupling, __FILE__, __LINE__)
  nullify(this%triangulation)
end subroutine free

subroutine print ( this )
  class(SB_serial_fe_space_t), intent(in)                 :: this 
  
  integer(ip) :: i,j
  do i  = 1, this%triangulation%num_elems
     write(*,*) '********* ELEMENT: ',i,'********'
     write(*,*) '********* ELEMENT 2 DOF********'
     do j = 1, this%number_fe_spaces
        write(*,*) '********* FE COMPONENT: ',j,'********'
        write(*,*) this%fe_array(i)%elem2dof(j)%p
     end do
  end do

  do i  = 1, this%triangulation%number_interior_faces
     write(*,*) '--------------------- Face: ',i,'-------------------------'
     write(*,*) '-- Elem 1 --'
     write(*,*) this%face_array(i)%neighbour_fe(1)%p%elem2dof(1)%p
     write(*,*) '-- Elem 2 --'
     write(*,*) this%face_array(i)%neighbour_fe(2)%p%elem2dof(1)%p
  end do

end subroutine print

subroutine initialize_integration( this, max_order )
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: this  
  integer(ip), optional, intent(in)  :: max_order
  call this%initialize_quadrature(max_order)
  call this%initialize_fe_map()
  call this%initialize_volume_integrator()
end subroutine initialize_integration

subroutine initialize_quadrature( this, max_order )
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: this  
  integer(ip), optional, intent(in)  :: max_order
  integer(ip) :: i

  do i = 1, size(this%quadrature)
     call this%reference_fe_phy_list(i)%p%create_quadrature( this%quadrature(i)%p, max_order )
  end do
end subroutine initialize_quadrature

subroutine initialize_volume_integrator( this )
  implicit none
  class(SB_serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i
  do i = 1, this%number_fe_spaces
     call this%volume_integrator(i)%p%create( this%quadrature(1)%p, & 
                                              this%reference_fe_phy_list(i)%p )
  end do
end subroutine initialize_volume_integrator

subroutine initialize_fe_map(this)
  implicit none
  class(SB_serial_fe_space_t), intent(inout) :: this  
  integer(ip) :: i
  do i = 1, size(this%fe_map)
     call this%fe_map(i)%p%create( this%quadrature(i)%p, &
                                  this%reference_fe_geo_list(i)%p )
  end do
end subroutine initialize_fe_map

function create_assembler(this, &
                          diagonal_blocks_symmetric_storage,&
                          diagonal_blocks_symmetric, & 
                          diagonal_blocks_sign)
  implicit none
  class(SB_serial_fe_space_t)       , intent(in) :: this
  logical                           , intent(in) :: diagonal_blocks_symmetric_storage(this%number_blocks)
  logical                           , intent(in) :: diagonal_blocks_symmetric(this%number_blocks)
  integer(ip)                       , intent(in) :: diagonal_blocks_sign(this%number_blocks)
  class(SB_matrix_array_assembler_t), pointer    :: create_assembler
  
		! Locals
		class(matrix_t), pointer :: matrix
  class(array_t) , pointer :: array
		logical, allocatable :: blocks_coupling(:,:)
		integer(ip)          :: ife_space, jfe_space
		integer(ip)          :: iblock, jblock

  if (this%number_blocks == 1) then
     allocate ( SB_sparse_matrix_array_assembler_t :: create_assembler )
     allocate ( sparse_matrix_t :: matrix )
     allocate ( serial_scalar_array_t  :: array )
     select type(matrix)
        class is(sparse_matrix_t)
        call matrix%create(this%number_dofs(1), &
                           diagonal_blocks_symmetric_storage(1),&
                           diagonal_blocks_symmetric(1),&
                           diagonal_blocks_sign(1))
        class default
        check(.false.)
     end select
     select type(array)
        class is(serial_scalar_array_t)
        call array%create(this%number_dofs(1))
        class default
        check(.false.)
     end select
  else
     allocate ( SB_block_sparse_matrix_array_assembler_t :: create_assembler )
     allocate ( block_sparse_matrix_t :: matrix )
     allocate ( serial_block_array_t  :: array )
     select type(matrix)
        class is (block_sparse_matrix_t)
        call matrix%create(this%number_blocks,this%number_dofs,this%number_dofs,&
             &             diagonal_blocks_symmetric_storage,diagonal_blocks_symmetric,diagonal_blocks_sign)
								call memalloc ( this%number_blocks, this%number_blocks, blocks_coupling, __FILE__, __LINE__)
								blocks_coupling = .false.
								do jfe_space=1,this%number_fe_spaces
										do ife_space=1,this%number_fe_spaces
										   blocks_coupling(this%field_blocks(ife_space), this%field_blocks(jfe_space)) = & 
																													this%field_coupling(ife_space,jfe_space)
										end do
								end do
								
								do jblock=1,this%number_blocks
								  do iblock=1,this%number_blocks
            if (.not. blocks_coupling(iblock,jblock) ) then
												  call matrix%set_block_to_zero(iblock,jblock)
												end if
										end do
								end do
								
								call memfree ( blocks_coupling, __FILE__, __LINE__)
        class default
        check(.false.)
     end select
     select type(array)
        class is(serial_block_array_t)
        call array%create(this%number_blocks,this%number_dofs)
        class default
        check(.false.)
     end select
  end if

  call create_assembler%set_matrix(matrix)
  call create_assembler%set_array(array)
end function create_assembler

subroutine symbolic_setup_assembler(this,matrix_array_assembler)
  implicit none
  class(SB_serial_fe_space_t)        , intent(in)    :: this
  class(SB_matrix_array_assembler_t) , intent(inout) :: matrix_array_assembler
  ! Polymorphic matrix 
  class(matrix_t), pointer :: matrix

  matrix => matrix_array_assembler%get_matrix()
  select type(matrix)
     class is(sparse_matrix_t)
     class is(block_sparse_matrix_t)
     class default
     check(.false.)
  end select
end subroutine symbolic_setup_assembler

function get_number_elements ( this )
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this
  integer(ip)                 :: get_number_elements
  get_number_elements = this%triangulation%num_elems
end function get_number_elements

function get_number_interior_faces ( this )
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this
  integer(ip)                 :: get_number_interior_faces
  get_number_interior_faces = this%triangulation%number_interior_faces
end function get_number_interior_faces

function get_number_boundary_faces ( this )
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this
  integer(ip)                 :: get_number_boundary_faces
  get_number_boundary_faces = this%triangulation%number_boundary_faces
end function get_number_boundary_faces

function get_number_fe_spaces( this)
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this 
  integer(ip) :: get_number_fe_spaces
  get_number_fe_spaces = this%number_fe_spaces
end function get_number_fe_spaces

function get_finite_element( this, i )
  implicit none
  class(SB_serial_fe_space_t), target, intent(in) :: this
  integer(ip) :: i
  type(SB_finite_element_t), pointer :: get_finite_element
  get_finite_element => this%fe_array(i)
end function get_finite_element

function get_finite_face( this, i )
  implicit none
  class(SB_serial_fe_space_t), target, intent(in) :: this
  integer(ip) :: i
  class(finite_face_t), pointer :: get_finite_face
  get_finite_face => this%face_array(i)
end function get_finite_face

function get_number_blocks( this)
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this 
  integer(ip) :: get_number_blocks
  get_number_blocks = this%number_blocks ! SB.alert 
end function get_number_blocks

function get_field_blocks( this )
  implicit none
  class(SB_serial_fe_space_t), target, intent(in) :: this
  integer(ip), pointer :: get_field_blocks(:)
  get_field_blocks => this%field_blocks
end function get_field_blocks

function get_field_coupling( this )
  implicit none
  class(SB_serial_fe_space_t), target, intent(in) :: this
  logical, pointer :: get_field_coupling(:,:)
  get_field_coupling => this%field_coupling
end function get_field_coupling

function get_max_number_nodes( this)
  implicit none
  class(SB_serial_fe_space_t), intent(in) :: this 
  integer(ip) :: get_max_number_nodes
  get_max_number_nodes = 100 ! SB.alert 
end function get_max_number_nodes

!*********************************************************************************
! This subroutine takes the triangulation and fills the element2dof structure at every 
! finite element, i.e., it labels all dofs related to local elements (not ghost), after a 
! count-list procedure, and puts the number of dofs in ndofs structure (per block).
! Note 1: The numbering is per every block independently, where the blocks are 
! defined at the dof_descriptor. A global dof numbering is not needed in the code, 
! when blocks are being used.
!*********************************************************************************
subroutine create_element_to_dof_and_ndofs( fe_space, init_dof, var ) 
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: fe_space 
  integer(ip)                , intent(inout) :: init_dof
  integer(ip)                , intent(in)    :: var
  
  ! Local variables
  integer(ip) :: iprob, iobje, ielem, jelem, nvapb
  integer(ip) :: obje_l, inode, l_node, elem_ext, obje_ext, prob_ext, inode_ext, inode_l
  integer(ip) :: mater, order, nnode
  integer(ip) :: touch(1,2)

  integer(ip), allocatable :: o2n(:)

  mater = 1

  call memalloc ( fe_space%get_max_number_nodes(), o2n, __FILE__, __LINE__ )

  ! Part 1: Put DOFs on VEFs, taking into account that DOFs only belong to VEFs when we do not
  ! enforce continuity (continuity(ielem) /= 0). We go through all objects, elements around the
  ! object, variables of the element, and if for the value of continuity of this element no 
  ! DOFs have already been added, we add them and touch this object for this continuity value.
  ! In FEMPAR, continuity is an elemental value. If it is different from 0, the nodes/DOFs 
  ! geometrically on the interface belong to the interface objects (VEFs). Next, we only
  ! enforce continuity for elements with same continuity value (mater below), in order to 
  ! allow for situations in which we want to have continuity in patches and discontinuity among 
  ! patches based on physical arguments (every patch would involve its own value of continuity).
  ! For hp-adaptivity, we could consider the value in continuity to be p (order) and as a result
  ! not to enforce continuity among elements with different order SINCE it would lead to ERROR
  ! to enforce continuity among elements of different order.
  do iobje = 1, fe_space%triangulation%num_vefs          
     touch = 0
     !write(*,*) 'loop iobje',iobje
     do ielem = 1, fe_space%triangulation%vefs(iobje)%num_elems_around
        jelem = fe_space%triangulation%vefs(iobje)%elems_around(ielem)
        !write(*,*) 'jelem',jelem
        if ( jelem <= fe_space%triangulation%num_elems ) then ! Local elements
           if ( fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_continuity() ) then
              !mater = fe_space%fe_array(jelem)%continuity(g_var) ! SB.alert : continuity can be used as p 
              mater = 1 ! For the moment SB.alert
              do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                 if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
              end do
              !if ( fe_space%fe_array(jelem)%bc_code(1,obje_l) == 0 ) then
              if ( touch(mater,1) == 0 ) then                            
                 touch(mater,1) = jelem
                 touch(mater,2) = obje_l
                 !write(*,*) 'obje_l new dofs',obje_l
                 call put_new_vefs_dofs_in_vef_of_element ( fe_space%triangulation, fe_space, jelem, init_dof, obje_l, var )
              else
                 !write(*,*) 'obje_l old dofs',obje_l
                 call put_existing_vefs_dofs_in_vef_of_element ( fe_space%triangulation, fe_space, touch, mater, iobje, jelem, o2n, obje_l, var )
              end if
              !end if
           end if
        else ! Ghost elements
           if ( fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_continuity() ) then
              !mater = fe_space%fe_array(jelem)%continuity(g_var) ! SB.alert : continuity can be used as p 
              mater = 1
              do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                 if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
              end do
              if ( touch(mater,1) /= 0) then
                 call put_existing_vefs_dofs_in_vef_of_element ( fe_space%triangulation, fe_space, touch, mater, iobje, jelem, o2n, obje_l, var )
              end if
           end if
        end if
     end do
  end do

  ! Part 2: Put DOFs on nodes belonging to the volume object (element). For cG we only do that when 
  ! static condensation is not active. Static condensation is for all variables, elements, etc. BUT
  ! it cannot be used with dG. The following algorithm is ASSUMING that this is the case, and we are
  ! not using dG + static condensations. In any case, when creating the fe_space there is an 
  ! automatic check for satisfying that.
  ! No check about strong Dirichlet boundary conditions, because they are imposed weakly in dG, and
  ! never appear in interior nodes in cG.
  !if ( ( .not. fe_space%static_condensation )  ) then
  do ielem = 1, fe_space%triangulation%num_elems
     write(*,*) __FILE__,__LINE__,jelem,  .not. fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_continuity()
     if ( .not. fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_continuity() ) then
        do iobje = 1, fe_space%triangulation%elems(ielem)%num_vefs+1
           do inode = 1, fe_space%fe_array(ielem)%reference_fe_phy(var)%p%get_number_interior_nodes_vef(iobje)
              l_node = fe_space%fe_array(ielem)%reference_fe_phy(var)%p%get_interior_node_vef(inode,iobje)
              init_dof = init_dof + 1
              fe_space%fe_array(ielem)%elem2dof(var)%p(l_node) = init_dof
           end do
        end do
        write(*,*) 'IELEM ------------------', ielem
        write(*,*) fe_space%fe_array(ielem)%elem2dof(var)%p
     else
        iobje = fe_space%triangulation%elems(ielem)%num_vefs+1
        do inode = 1, fe_space%fe_array(ielem)%reference_fe_phy(var)%p%get_number_interior_nodes_vef(iobje)
           !fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje), &
           !  &     fe_space%fe_array(ielem)%nodes_per_vef%p%p(iobje+1)-1
           l_node = fe_space%fe_array(ielem)%reference_fe_phy(var)%p%get_interior_node_vef(inode,iobje)
           !l_node = fe_space%fe_array(ielem)%nodes_per_vef%p%l(inode)
           init_dof = init_dof +1
           fe_space%fe_array(ielem)%elem2dof(var)%p(l_node) = init_dof
        end do
     end if
  end do
  !end if 

  ! Part 3: Assign total number of dofs created to fem space object
  !fe_space%number_dofs = count
  call memfree ( o2n, __FILE__, __LINE__ )
end subroutine create_element_to_dof_and_ndofs


!*********************************************************************************
! This subroutine takes the finite element space and fills the vef2dof structure. 
! The vef2dof structure puts on top of VEFs the DOFs that are meant to be continuous 
! between elements with the same continuity label. As an example, when using dG only, 
! vef2dof is void. It is more an acceleration array than a really needed structure, 
! but it is convenient when creating the dof graph. 
!*********************************************************************************
subroutine create_vef2dof ( fe_space, var ) 
  implicit none
  ! Parameters
  class(SB_serial_fe_space_t), intent(inout) :: fe_space 
  integer(ip), intent(in) :: var

  ! Local variables
  integer(ip) :: iprob, count, iobje, ielem, jelem, nvapb
  integer(ip) :: obje_l, inode, l_node, mater, istat
  integer(ip) :: touch!(1,fe_space%num_continuity)

  associate( vef2dof => fe_space%vef2dof(var) )
    ! Part 1: Count DOFs on VEFs, using the notion of continuity described above (in elem2dof)
  call vef2dof%create(n1 = fe_space%triangulation%num_vefs, n2 = 3)
  do iobje = 1, fe_space%triangulation%num_vefs
     touch = 0
     do ielem = 1, fe_space%triangulation%vefs(iobje)%num_elems_around
        jelem = fe_space%triangulation%vefs(iobje)%elems_around(ielem)
        if ( jelem <= fe_space%triangulation%num_elems ) then 
           !iprob = fe_space%fe_array(jelem)%problem
           mater = 1
           if ( mater /= 0 ) then
              if (touch == 0) then
                 touch = 1
                 !if ( touch(g_var,mater) == 0 ) then
                 !   touch(g_var,mater) = 1
                 do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                    if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
                 end do


                 do inode = 1, fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_number_interior_nodes_vef(obje_l)
                    l_node = fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_interior_node_vef(inode,obje_l)
                    if ( fe_space%fe_array(jelem)%bc_code(var)%p(l_node) == 0 ) then
                       vef2dof%p(iobje+1) = vef2dof%p(iobje+1) + 1
                    end	if
                 end	do


                 !!if ( fe_space%fe_array(jelem)%bc_code(1,obje_l) == 0 ) then
                 !   vef2dof%p(iobje+1) = vef2dof%p(iobje+1) + &
                 !        fe_space%fe_array(jelem)%reference_fe(var)%p%get_number_interior_nodes_vef(obje_l)
                 !   !+ fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l+1) &
                 !   !     & - fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l)
                 !!end if
                 !								


              end if
           end if
        end if
     end do
  end do


  vef2dof%p(1) = 1
  do iobje = 2, fe_space%triangulation%num_vefs+1
     vef2dof%p(iobje) = vef2dof%p(iobje) + vef2dof%p(iobje-1)
  end do

  !write(*,*) 'vef2dof%p,VAR',vef2dof%p,var

  call vef2dof%allocate_list_from_pointer()

  ! Part 2: List DOFs on VEFs, using the notion of continuity described above (in elem2dof)
  ! We note that the vef2dof%l(:,X) is defined for X = 1,2,3
  ! vef2dof%l(:,1) : DOF LID
  ! vef2dof%l(:,2) : Variable GID associated to that DOF
  ! vef2dof%l(:,3) : Continuity value associated to that DOF (to enforce continuity)
  count = 0
  do iobje = 1, fe_space%triangulation%num_vefs
     touch = 0
     do ielem = 1, fe_space%triangulation%vefs(iobje)%num_elems_around
        jelem = fe_space%triangulation%vefs(iobje)%elems_around(ielem)
        if ( jelem <= fe_space%triangulation%num_elems ) then 
           !iprob = fe_space%fe_array(jelem)%problem
           mater = 1
           if ( mater /= 0) then
              if (touch == 0) then
                 touch = 1
                 !if ( touch(g_var,mater) == 0 ) then
                 !   touch(g_var,mater) = 1
                 do obje_l = 1, fe_space%triangulation%elems(jelem)%num_vefs
                    if ( fe_space%triangulation%elems(jelem)%vefs(obje_l) == iobje ) exit
                 end do
                 !if ( fe_space%fe_array(jelem)%bc_code(1,obje_l) == 0 ) then
                 do inode = 1, fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_number_interior_nodes_vef(obje_l)
                    !fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l), &
                    !&     !fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l+1)-1 
                    l_node = fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_interior_node_vef(inode,obje_l)
                    if ( fe_space%fe_array(jelem)%bc_code(var)%p(l_node) == 0 ) then
                       !fe_space%fe_array(jelem)%nodes_per_vef%p%l(inode)
                       count = count + 1
                       vef2dof%l(count,1) = fe_space%fe_array(jelem)%elem2dof(var)%p(l_node)
                       !vef2dof%l(count,2) = 1
                       !vef2dof%l(count,3) = mater
                    end if
                 end do
                 !end if
              end if
           end if
        end if
     end do
  end do
end associate
end subroutine create_vef2dof

!*********************************************************************************
! Auxiliary function that generates new DOFs and put them in a particular VEF of a given element
!*********************************************************************************
subroutine put_new_vefs_dofs_in_vef_of_element ( trian, fe_space, jelem, &
   count, obje_l, var )
implicit none
! Parameters
type(triangulation_t), intent(in)         :: trian 
class(SB_serial_fe_space_t), intent(inout)              :: fe_space 
integer(ip), intent(inout)                  :: count
integer(ip), intent(in)                     :: jelem, obje_l, var

! Local variables
integer(ip) :: inode, l_node

do inode = 1,fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_number_interior_nodes_vef(obje_l)
   !fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l), &
   !         &     fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l+1)-1 
   l_node = fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_interior_node_vef(inode,obje_l)
   !l_node = fe_space%fe_array(jelem)%nodes_per_vef%p%l(inode)
   if ( fe_space%fe_array(jelem)%bc_code(var)%p(l_node) == 0 ) then
      count = count + 1
      !write (*,*) '****PUT DOF**** (elem,obj_l,obj_g,node,idof) ',jelem,obje_l,l_node,count
      fe_space%fe_array(jelem)%elem2dof(var)%p(l_node) = count
   end	if
end do

end subroutine put_new_vefs_dofs_in_vef_of_element

!*********************************************************************************
! Auxiliary function that puts existing DOFs in a particular VEF of a given element
!*********************************************************************************
subroutine put_existing_vefs_dofs_in_vef_of_element ( trian, fe_space, touch, mater, iobje, jelem, &
   o2n, obje_l, var )
implicit none
! Parameters
type(triangulation_t), intent(in)           :: trian 
class(SB_serial_fe_space_t), intent(inout)      :: fe_space
integer(ip), intent(in)                     :: touch(:,:), mater, iobje, jelem, obje_l, var
integer(ip), intent(out)                    :: o2n(:)

! Local variables
integer(ip) :: elem_ext, obje_ext, prob_ext
integer(ip) :: nnode, order, inode, l_node, inode_ext, inode_l

elem_ext = touch(mater,1)
obje_ext = touch(mater,2)
!prob_ext = fe_space%fe_array(elem_ext)%problem
prob_ext = 1

nnode = fe_space%fe_array(elem_ext)%reference_fe_phy(var)%p%get_number_interior_nodes_vef(obje_ext)

!fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext+1) &
!     &  -fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext) 
!write(*,*) 'jelem',jelem
!write(*,*) 'nnode',nnode
if ( nnode > 0) then  
   order = fe_space%fe_array(elem_ext)%reference_fe_phy(var)%p%get_order()
   !write(*,*) 'order',order
   !if ( trian%vefs(iobje)%dimension == trian%num_dims .and. &
   !     & nnode ==  (order+1)**trian%num_dims ) then
   !   order = order    ! hdG case
   !elseif ( nnode ==  (order-1)**trian%vefs(iobje)%dimension ) then
   order = order -2 ! cG case SB.alert
   !else
   !   assert ( 0 == 1) ! SB.alert : Other situations possible when dG_continuity, cdG, hp-adaptivity ?
   !end if
   call fe_space%fe_array(jelem)%reference_fe_phy(var)%p%permute_nodes_per_vef( &
        & fe_space%fe_array(elem_ext)%reference_fe_phy(var)%p,                  &
        & o2n,obje_ext,obje_l,                                                     &
        & trian%elems(elem_ext)%vefs,                                              &
        & trian%elems(jelem)%vefs,                                                 &
        & trian%vefs(iobje)%dimension,                                             &
        & order )
   do inode = 1, fe_space%fe_array(elem_ext)%reference_fe_phy(var)%p%get_number_interior_nodes_vef(obje_ext)
      !nodes_per_vef%p%p(obje_ext+1) - &
      !            fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext)
      inode_ext = fe_space%fe_array(elem_ext)%reference_fe_phy(var)%p%get_interior_node_vef(inode,obje_ext)
      !l_node = fe_space%fe_array(elem_ext)%nodes_per_vef%p%p(obje_ext) + inode - 1
      !inode_ext = fe_space%fe_array(elem_ext)%nodes_per_vef%p%l(l_node )
      !inode_l = fe_space%fe_array(jelem)%reference_fe(var)%p%get_interior_node_vef(o2n(inode),obje_l)


      ! XXX inode_l = fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_interior_node_vef(o2n(inode),obje_l)

      ! PRUEBA SB.alert
      ! I am not using the o2n because I assume that I have a first order FE space, only
      ! DoFs on corners and permutation not needed. The permutation must be modified for 
      ! vector-valued problems. Think about it!

      inode_l = fe_space%fe_array(jelem)%reference_fe_phy(var)%p%get_interior_node_vef(inode,obje_l)

      !l_node = fe_space%fe_array(jelem)%nodes_per_vef%p%p(obje_l) + o2n(inode) - 1
      !inode_l = fe_space%fe_array(jelem)%nodes_per_vef%p%l(l_node)
      if ( fe_space%fe_array(jelem)%bc_code(var)%p(inode_l) == 0 ) then
         !write (*,*) '****EXTRACT DOF**** (object)', iobje, ' FROM: (elem,obj_l) ',elem_ext,obje_ext, ' TO  : (elem,obj_l)', jelem,obje_l
         !write(*,*) 'We take value',fe_space%fe_array(elem_ext)%elem2dof(var)%l(inode_ext),'from node',inode_ext
         !write(*,*) 'o2n',o2n
         !write(*,*) 'in position',inode_l
         fe_space%fe_array(jelem)%elem2dof(var)%p(inode_l) = fe_space%fe_array(elem_ext)%elem2dof(var)%p(inode_ext)
      end	if
   end do ! SB.alert : 1) face object for cG and hdG, where the face must have all their nodes
   !                   2) corner / edge only for cG
   !            * Never here for dG, continuity interface, hanging objects, etc.


end if


end subroutine put_existing_vefs_dofs_in_vef_of_element
