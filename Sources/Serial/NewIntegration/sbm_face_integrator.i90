!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!fe_map_face_restriction_t type procedures
subroutine fe_map_face_restriction_create( this, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this
  type(SB_quadrature_t)           , intent(in)    :: quadrature
  class(reference_fe_t)           , intent(in)    :: reference_fe_geometry

  integer(ip)           :: face_dimensions,local_face_id, istat

  call this%free()

  face_dimensions = reference_fe_geometry%number_dimensions - 1
  this%number_faces = reference_fe_geometry%get_number_vefs_of_dimension(face_dimensions)

  allocate(this%fe_map(this%number_faces),stat = istat)
  check(istat == 0)

  do local_face_id = 1,  this%number_faces
     call this%fe_map(local_face_id)%create_on_face(local_face_id,quadrature,reference_fe_geometry)
  end do

end subroutine fe_map_face_restriction_create

!==================================================================================================
subroutine fe_map_face_restriction_update( this, local_face_id, quadrature, cell_coordinates)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this
  integer(ip)                     , intent(in)    :: local_face_id
  type(SB_quadrature_t)           , intent(in)    :: quadrature
  real(rp)                        , intent(in)    :: cell_coordinates(:,:)

  this%active_face_id = local_face_id
  call this%fe_map(local_face_id)%update(quadrature, cell_coordinates)

end subroutine fe_map_face_restriction_update

!==================================================================================================
subroutine fe_map_face_restriction_free( this)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this

  integer(ip) :: local_face_id , istat

  do local_face_id = 1, this%number_faces
     call this%fe_map(local_face_id)%free()
  end do

  if (allocated(this%fe_map)) then
     deallocate(this%fe_map,stat = istat)
     check(istat == 0)
  end if

  this%number_faces = 0
  this%active_face_id = 0
end subroutine fe_map_face_restriction_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! face_map_t procedures
subroutine face_map_create(this,left_geo_reference_fe,right_geo_reference_fe, quadrature )
  implicit none
  ! Parameters
  class(face_map_t)             , intent(inout) :: this
  class(reference_fe_t), pointer, intent(in)    :: left_geo_reference_fe, right_geo_reference_fe
  type(SB_quadrature_t)         , intent(in)    :: quadrature

  call this%free()

  call this%face_map%fe_map_face_restriction_create(quadrature,left_geo_reference_fe)
  write(*,*) __FILE__,__LINE__
  call this%fe_maps(1)%create(quadrature,left_geo_reference_fe)
  if (associated(right_geo_reference_fe)) then
     call this%fe_maps(2)%create(quadrature,right_geo_reference_fe)
  end if
end subroutine face_map_create

!==================================================================================================
subroutine face_map_free(this)
  implicit none
  ! Parameters
  class(face_map_t)      , intent(inout) :: this

  integer(ip) :: i

  call this%face_map%free()

  do i=1,2
     call this%fe_maps(i)%free()
  end do

end subroutine face_map_free

!==================================================================================================
subroutine face_map_update(this,local_face_id,face_quadrature,left_reference_fe_geo,              &
     &                     left_neighbour_coordinates,right_neighbour_coordinates)
  implicit none
  ! Parameters
  class(face_map_t)      , intent(inout) :: this
  integer(ip)            , intent(in)    :: local_face_id(2)
  type(SB_quadrature_t)  , intent(in)    :: face_quadrature
  class(reference_fe_t)   , intent(in)    :: left_reference_fe_geo
  real(rp)                , intent(in)    :: left_neighbour_coordinates(:,:)
  real(rp)      , optional, intent(in)    :: right_neighbour_coordinates(:,:)

  ! we are assuming that the face coordinates have been updated beforehand
  call this%face_map%face_map_update(local_face_id(1),left_reference_fe_geo,face_quadrature)
  
  call this%fe_maps(1)%update(local_face_id(1),face_quadrature,left_neighbour_coordinates)
  if (present(right_neighbour_coordinates)) then
     call this%fe_maps(2)%update(local_face_id(2),face_quadrature,right_neighbour_coordinates)
  end if
end subroutine face_map_update

!==================================================================================================
function face_map_compute_characteristic_length(this,igaus, number_neighbours)
  implicit none
  class(face_map_t), target, intent(in) :: this
  integer(ip)              , intent(in) :: igaus, number_neighbours
  real(rp) :: face_map_compute_characteristic_length

  real(rp)    :: h
  integer(ip) :: i
  type(fe_map_t), pointer :: fe_map
  
  fe_map => this%fe_maps(1)%fe_map(this%fe_maps(1)%active_face_id)
  face_map_compute_characteristic_length = fe_map%compute_h(igaus)

  do i = 2, number_neighbours
     fe_map => this%fe_maps(i)%fe_map(this%fe_maps(i)%active_face_id)
     h = fe_map%compute_h(igaus) 
     face_map_compute_characteristic_length = min(face_map_compute_characteristic_length, h)
  end do

end function face_map_compute_characteristic_length

!==================================================================================================
function face_map_get_face_coordinates(this)
  implicit none
  ! Parameters
  class(face_map_t), target, intent(in) :: this
  type(allocatable_array_rp2_t), pointer :: face_map_get_face_coordinates

  face_map_get_face_coordinates => this%face_map%get_nodal_coordinates()
end function face_map_get_face_coordinates

!==================================================================================================
function face_map_get_neighbour_fe_map(this,neighbour_elem)
  implicit none
  ! Parameters
  class(face_map_t), target, intent(in) :: this
  integer(ip)                           :: neighbour_elem
  type(fe_map_face_restriction_t), pointer :: face_map_get_neighbour_fe_map

  face_map_get_neighbour_fe_map => this%fe_maps(neighbour_elem)
end function face_map_get_neighbour_fe_map

!=================================================================================================
subroutine face_map_get_normals (this, qpoint, normal)
  implicit none
  class(face_map_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: qpoint
  type(vector_field_t)    , intent(out)   :: normal(2)

  integer(ip) :: idime
  call normal(1)%init(0.0_rp)
  call normal(2)%init(0.0_rp)
  do idime = 1, size(this%face_map%normals,dim=1)
     call normal(1)%set(idime,this%face_map%normals(idime,qpoint))
     call normal(2)%set(idime,- this%face_map%normals(idime,qpoint))
  end do
end subroutine face_map_get_normals

!=================================================================================================
function face_map_get_det_jacobian ( this, i )
  implicit none
  class(face_map_t), intent(in) :: this
  integer(ip)    , intent(in) :: i
  real(rp) :: face_map_get_det_jacobian
  face_map_get_det_jacobian = this%face_map%get_det_jacobian(i)
end function face_map_get_det_jacobian

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_interpolation_t type procedures
subroutine interpolation_face_restriction_create(this, local_quadrature, reference_fe_phy)
  implicit none
  ! Parameters
  class(interpolation_face_restriction_t)  , intent(inout) :: this
  type(SB_quadrature_t)        ,  intent(in)   :: local_quadrature
  class(reference_fe_t), target, intent(in)    :: reference_fe_phy

  integer(ip)           :: face_dimensions,local_face_id, istat
  type(SB_quadrature_t) :: face_quadrature

  call this%free()
  this%active_face_id = -1

  this%number_shape_functions   = reference_fe_phy%number_nodes
  this%number_evaluation_points = local_quadrature%number_evaluation_points
  face_dimensions               = reference_fe_phy%number_dimensions - 1
  this%number_faces             = reference_fe_phy%get_number_vefs_of_dimension(face_dimensions)
  this%reference_fe             => reference_fe_phy

  allocate(this%interpolation(this%number_faces),stat = istat)
  check(istat == 0)

  do local_face_id =1, this%number_faces
     call reference_fe_phy%create_face_interpolation(local_face_id,local_quadrature,                  &
          &                                      this%interpolation(local_face_id))
  end do

  call this%interpolation_o_map%copy(source_interpolation = this%interpolation(1))

end subroutine interpolation_face_restriction_create

!==================================================================================================
subroutine interpolation_face_restriction_free(this)
  implicit none
  ! Parameters
  class(interpolation_face_restriction_t)  , intent(inout) :: this

  integer(ip) :: i, istat

  do i = 1, this%number_faces
     call this%interpolation(i)%free()
  end do
  call this%interpolation_o_map%free
  if (allocated(this%interpolation)) then
     deallocate(this%interpolation, stat = istat)
     check (istat == 0)
  end if
  this%number_shape_functions   = 0
  this%number_evaluation_points = 0
  this%number_faces             = 0

  this%reference_fe => NULL()
end subroutine interpolation_face_restriction_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_integrator_t type procedures
subroutine face_integrator_create(this,quadrature,left_reference_fe,right_reference_fe)
  implicit none
  ! Parameters
  class(face_integrator_t)      , intent(inout) :: this
  type(SB_quadrature_t)         , intent(in)    :: quadrature
  class(reference_fe_t), pointer, intent(in)    :: left_reference_fe, right_reference_fe

  call this%free()

  this%reference_fe(1)%p => left_reference_fe
  call this%face_interpolation(1)%create(quadrature,this%reference_fe(1)%p)

  if (associated(right_reference_fe)) then
     this%reference_fe(2)%p => right_reference_fe
     call this%face_interpolation(2)%create(quadrature,this%reference_fe(2)%p)
  end if
end subroutine face_integrator_create

!==================================================================================================
subroutine face_integrator_free(this)
  implicit none
  ! Parameters
  class(face_integrator_t)     , intent(inout) :: this

  integer(ip) :: i

  do i=1,2
     this%reference_fe(i)%p => NULL()
     call this%face_interpolation(i)%free()
  end do

end subroutine face_integrator_free

!==================================================================================================
subroutine face_integrator_update(this,local_face_id,face_map)
  implicit none
  ! Parameters
  class(face_integrator_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: local_face_id(2)
  type(face_map_t)        , intent(in)    :: face_map

  call this%reference_fe(1)%p%update_interpolation_face(local_face_id(1),face_map%fe_maps(1),     &
       &                                                this%face_interpolation(1))

  if (local_face_id(2)>0) then
     call this%reference_fe(2)%p%update_interpolation_face(local_face_id(2),face_map%fe_maps(2),  &
       &                                                   this%face_interpolation(2))
  end if
end subroutine face_integrator_update

!==================================================================================================
subroutine face_integrator_get_value_scalar (this, ishape, qpoint, ineigh, scalar_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  real(rp)                , intent(out)   :: scalar_field

  integer(ip) :: active_face_id
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  active_face_id = this%face_interpolation(ineigh)%active_face_id
  scalar_field =  this%face_interpolation(ineigh)%interpolation(active_face_id)%                  &
       &          shape_functions(ishape,qpoint)
end subroutine face_integrator_get_value_scalar

!=================================================================================================
subroutine face_integrator_get_gradient_scalar (this, ishape, qpoint, ineigh, vector_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  type(vector_field_t)    , intent(out)   :: vector_field
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  call this%reference_fe(ineigh)%p%get_gradient(this%face_interpolation(ineigh)%interpolation_o_map,   &
       &                                            ishape,qpoint,vector_field)
end subroutine face_integrator_get_gradient_scalar
