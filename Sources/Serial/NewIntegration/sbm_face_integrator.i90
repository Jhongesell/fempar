!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_map_t type procedures
subroutine face_map_create( this, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(face_map_t)    , intent(inout) :: this
  type(SB_quadrature_t), intent(in)    :: quadrature
  class(reference_fe_t), intent(in)    :: reference_fe_geometry

  integer(ip)           :: face_dimensions,local_face_id, istat

  call this%free()

  face_dimensions = reference_fe_geometry%number_dimensions - 1
  this%number_faces = reference_fe_geometry%get_number_vefs_of_dimension(face_dimensions)

  allocate(this%fe_map(this%number_faces),stat = istat)
  check(istat == 0)

  do local_face_id = 1,  this%number_faces
     call this%fe_map(local_face_id)%create_on_face(local_face_id,quadrature,reference_fe_geometry)
  end do

end subroutine face_map_create

!==================================================================================================
subroutine face_map_update( this, local_face_id, quadrature, cell_coordinates)
  implicit none
  ! Parameters
  class(face_map_t)    , intent(inout) :: this
  integer(ip)          , intent(in)    :: local_face_id
  type(SB_quadrature_t), intent(in)    :: quadrature
  real(rp)             , intent(in)    :: cell_coordinates(:,:)

  this%active_face_id = local_face_id
  call this%fe_map(local_face_id)%update_on_face(quadrature, cell_coordinates)

end subroutine face_map_update

!==================================================================================================
subroutine face_map_free( this)
  implicit none
  ! Parameters
  class(face_map_t), intent(inout) :: this

  integer(ip) :: local_face_id , istat

  do local_face_id = 1, this%number_faces
     call this%fe_map(local_face_id)%free()
  end do

  if (allocated(this%fe_map)) then
     deallocate(this%fe_map,stat = istat)
     check(istat == 0)
  end if

  this%number_faces = 0
  this%active_face_id = 0
end subroutine face_map_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_interpolation_t type procedures
subroutine face_interpolation_create(this, local_quadrature, reference_fe_phy)
  implicit none
  ! Parameters
  class(face_interpolation_t)  , intent(inout) :: this
  type(SB_quadrature_t)        ,  intent(in)   :: local_quadrature
  class(reference_fe_t), target, intent(in)    :: reference_fe_phy

  integer(ip)           :: face_dimensions,local_face_id, istat
  type(SB_quadrature_t) :: face_quadrature

  call this%free()

  this%number_shape_functions   = reference_fe_phy%number_nodes
  this%number_evaluation_points = local_quadrature%number_evaluation_points
  face_dimensions               = reference_fe_phy%number_dimensions - 1
  this%number_faces             = reference_fe_phy%get_number_vefs_of_dimension(face_dimensions)
  this%reference_fe             => reference_fe_phy

  allocate(this%interpolation(this%number_faces),stat = istat)
  check(istat == 0)

  do local_face_id =1, this%number_faces
     call reference_fe_phy%create_face_interpolation(local_face_id,local_quadrature,                  &
          &                                      this%interpolation(local_face_id))
  end do

  call this%interpolation_o_map%copy(source_interpolation = this%interpolation(1))

end subroutine face_interpolation_create

!==================================================================================================
subroutine face_interpolation_update(this, local_face_id, fe_map)
  implicit none
  ! Parameters
  class(face_interpolation_t)  , intent(inout) :: this
  integer(ip)                  , intent(in)    :: local_face_id
  type(fe_map_t)               , intent(in)    :: fe_map

  call femap_apply_to_interp(fe_map, this%interpolation(local_face_id),                  &
       &                     this%interpolation_o_map)
end subroutine face_interpolation_update

!==================================================================================================
subroutine face_interpolation_free(this)
  implicit none
  ! Parameters
  class(face_interpolation_t)  , intent(inout) :: this

  integer(ip) :: i, istat

  do i = 1, this%number_faces
     call this%interpolation(i)%free()
  end do
  call this%interpolation_o_map%free
  if (allocated(this%interpolation)) then
     deallocate(this%interpolation, stat = istat)
     check (istat == 0)
  end if
  this%number_shape_functions   = 0
  this%number_evaluation_points = 0
  this%number_faces             = 0

  this%reference_fe => NULL()
end subroutine face_interpolation_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_integrator_t type procedures
subroutine face_integrator_create(this,left_reference_fe,right_reference_fe,left_geo_reference_fe,&
     &                            right_geo_reference_fe, max_order )
  implicit none
  ! Parameters
  class(face_integrator_t)     , intent(inout) :: this
  class(reference_fe_t), target, intent(in)    :: left_reference_fe, right_reference_fe
  class(reference_fe_t)        , intent(in)    :: left_geo_reference_fe, right_geo_reference_fe
  integer(ip)       , optional , intent(in)    :: max_order

  integer(ip)           :: i, number_nodes_face, number_nodes_face_scalar, aux_vef_dimension(5)
  type(SB_quadrature_t) :: quadrature_on_faces

  call this%free()

  this%reference_fe(1)%p => left_reference_fe
  this%reference_fe(2)%p => right_reference_fe

  ! AH: This quadrature is created using the left reference element but in a future I would
  ! propose to define a reference element associated to face integration
  ! (in case we want to use diferente volume and face integration)
  call left_reference_fe%create_face_quadrature(this%quadrature, max_order)
  call this%face_map%face_map_create(this%quadrature,left_geo_reference_fe)

  ! Allocate the coordinates assuming the geometry and the interpolation are the same order
  ! AH: This needs to be improved in the future and also the variable coordinates might need 
  ! to be discussed at some point
  ! If we agree in using such a structure, clearly this code should be encapsulated somehow
  ! in reference_fe (the use of number_vef_dimension should not be explicited)
  aux_vef_dimension = left_geo_reference_fe%get_number_vefs_dimension()
  number_nodes_face = left_geo_reference_fe%get_number_nodes_vef                                  &
       &              (aux_vef_dimension(left_geo_reference_fe%number_dimensions))
  number_nodes_face_scalar = int(real(number_nodes_face)/                                         &
       &                     real(left_geo_reference_fe%number_field_components))
  call memalloc(left_geo_reference_fe%number_dimensions, number_nodes_face_scalar, this%coordinates,           &
       &        __FILE__,__LINE__)
    
  do i = 1, 2
     call this%face_interpolation(i)%create(this%quadrature,this%reference_fe(i)%p)
!!$     call create_elem_to_face_enumeration( this%reference_fe(i)%p,this%quadrature,                &
!!$          &                               this%elem_to_face_enumeration(i))
  end do
  call this%fe_maps(1)%create(this%quadrature,left_geo_reference_fe)
  call this%fe_maps(2)%create(this%quadrature,right_geo_reference_fe)
!!$  call this%fe_map(1)%create_on_faces(this%quadrature,left_geo_reference_fe,                      &
!!$       &                              this%elem_to_face_enumeration(1))
!!$  call this%fe_map(2)%create_on_faces(this%quadrature,right_geo_reference_fe,                     &
!!$       &                              this%elem_to_face_enumeration(2))

end subroutine face_integrator_create

!==================================================================================================
!face_integrator_t type procedures
subroutine face_integrator_create_boundary(this,left_reference_fe,left_geo_reference_fe,max_order)
  implicit none
  ! Parameters
  class(face_integrator_t)     , intent(inout) :: this
  class(reference_fe_t), target, intent(in)    :: left_reference_fe
  class(reference_fe_t)        , intent(in)    :: left_geo_reference_fe
  integer(ip)       , optional , intent(in)    :: max_order

  integer(ip)           :: i, number_nodes_face, number_nodes_face_scalar, aux_vef_dimension(5)
  type(SB_quadrature_t) :: quadrature_on_faces

  call this%free()

  this%reference_fe(1)%p => left_reference_fe
  this%reference_fe(2)%p => NULL()

  ! AH: This quadrature is created using the left reference element but in a future I would
  ! propose to define a reference element associated to face integration
  ! (in case we want to use diferente volume and face integration)
  call left_reference_fe%create_face_quadrature(this%quadrature, max_order)
  call this%face_map%face_map_create(this%quadrature,  left_geo_reference_fe)

  ! Allocate the coordinates assuming the geometry and the interpolation are the same order
  ! AH: This needs to be improved in the future and also the variable coordinates might need 
  ! to be discussed at some point
  ! If we agree in using such a structure, clearly this code should be encapsulated somehow
  ! in reference_fe (the use of number_vef_dimension should not be explicited)
  aux_vef_dimension = left_geo_reference_fe%get_number_vefs_dimension()
  number_nodes_face = left_geo_reference_fe%get_number_nodes_vef(aux_vef_dimension             &
       &                 (left_geo_reference_fe%number_dimensions))
  number_nodes_face_scalar = int(real(number_nodes_face)/                                      &
       &                     real(left_geo_reference_fe%number_field_components))
  call memalloc(left_geo_reference_fe%number_dimensions, number_nodes_face_scalar,             &
       &        this%coordinates,__FILE__,__LINE__)
  i = 1
  call this%face_interpolation(i)%create(this%quadrature,this%reference_fe(i)%p)
!!$  call create_elem_to_face_enumeration( this%reference_fe(i)%p,this%quadrature,                &
!!$       &                               this%elem_to_face_enumeration(i))
!!$  call this%fe_map(i)%create_on_faces(this%quadrature,left_geo_reference_fe,                   &
!!$       &                              this%elem_to_face_enumeration(i))
  call this%fe_maps(1)%create(this%quadrature,left_geo_reference_fe)
end subroutine face_integrator_create_boundary

!==================================================================================================
subroutine face_integrator_free(this)
  implicit none
  ! Parameters
  class(face_integrator_t)     , intent(inout) :: this

  integer(ip) :: i
  call this%face_map%free()
  call this%quadrature%free()

  do i=1,2
     this%reference_fe(i)%p => NULL()
     call this%face_interpolation(i)%free()
     !call this%elem_to_face_enumeration(i)%free()
     !call this%fe_map(i)%free()
     call this%fe_maps(i)%free()
  end do

  if(allocated(this%coordinates)) call memfree(this%coordinates,__FILE__,__LINE__)
end subroutine face_integrator_free

!==================================================================================================
subroutine face_integrator_update(this,local_face_id,left_reference_fe_geo,left_reference_fe_phy, &
     &                            left_neighbour_coordinates,right_neighbour_coordinates)
  implicit none
  ! Parameters
  class(face_integrator_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: local_face_id(2)
  class(reference_fe_t)   , intent(in)    :: left_reference_fe_geo
  class(reference_fe_t)   , intent(in)    :: left_reference_fe_phy
  real(rp)                , intent(in)    :: left_neighbour_coordinates(:,:)
  real(rp)                , intent(in)    :: right_neighbour_coordinates(:,:)
  !class(elem_topology_t)  , intent(in)    :: left_neighbour_topology

  integer(ip) :: i,aux_vef_dimension(5), local_vef_id
  integer(ip) :: number_corners_face_geo, local_element_corner
  !integer(ip) :: number_nodes_face_geo, local_element_node
  integer(ip) :: idime, coord_element_node, number_nodes_face_scalar,face_node_scalar
  type(list_t), pointer :: corners_vef
  !type(list_t), pointer :: nodes_vef

!!$  ! Update the coordinates
!!$  aux_vef_dimension = left_reference_fe_geo%get_number_vefs_dimension()
!!$  number_nodes_face_geo = left_reference_fe_geo%get_number_nodes_vef                              &
!!$       &                  (aux_vef_dimension(left_reference_fe_geo%number_dimensions))
!!$  local_vef_id      = aux_vef_dimension(left_reference_fe_geo%number_dimensions)+local_face_id(1) - 1
!!$  number_nodes_face_scalar = int(real(number_nodes_face_geo)/real(left_reference_fe_geo%number_field_components))
!!$  nodes_vef => left_reference_fe_geo%get_nodes_vef()
!!$  do i = 1, number_nodes_face_geo
!!$     ! For the moment reference_fe_geo is of an abstract class, maybe we should consider to
!!$     ! implement it as assuming that is always quad_lagrangian
!!$     select type(left_reference_fe_geo)
!!$        class is(quad_lagrangian_reference_fe_t)
!!$        if (left_reference_fe_geo%number_field_components == left_reference_fe_geo%number_dimensions) then
!!$           ! This is clearly not a good code. It should be discussed which is the best way to go through this.
!!$           local_element_node = nodes_vef%l(nodes_vef%p(local_vef_id) + i-1)
!!$           idime = left_reference_fe_geo%node_component_array(local_element_node,2)
!!$           coord_element_node = left_reference_fe_geo%node_component_array(local_element_node,1)
!!$           face_node_scalar = i - (idime-1)*number_nodes_face_scalar
!!$           this%coordinates(idime,face_node_scalar) = left_neighbour_coordinates(idime,coord_element_node)
!!$        elseif (left_reference_fe_geo%number_field_components == left_reference_fe_geo%number_dimensions) then
!!$           local_element_node = nodes_vef%l(nodes_vef%p(local_vef_id) + i-1)
!!$           this%coordinates(:,i) = left_neighbour_coordinates(:,local_element_node)
!!$        else
!!$           assert(.false.)
!!$        end if
!!$
!!$     end select
!!$     write(*,*) __FILE__,__LINE__, face_node_scalar
!!$     write(*,*) this%coordinates(:,face_node_scalar)
!!$  end do

  ! This is using corners_vef and assuming that the geometrical reference element is linear.
  aux_vef_dimension = left_reference_fe_geo%get_number_vefs_dimension()
  number_corners_face_geo = left_reference_fe_geo%get_number_corners_vef                          &
       &                  (aux_vef_dimension(left_reference_fe_geo%number_dimensions))
  local_vef_id      = aux_vef_dimension(left_reference_fe_geo%number_dimensions)+local_face_id(1) - 1
  corners_vef => left_reference_fe_geo%get_corners_vef()
  do i = 1, number_corners_face_geo
     local_element_corner = corners_vef%l(corners_vef%p(local_vef_id) + i-1)
     this%coordinates(:,i) = left_neighbour_coordinates(:,local_element_corner)
  end do

  ! Update the face_map
  call this%face_map%face_map_update(local_face_id(1),left_reference_fe_geo,this%quadrature,      &
       &                              this%coordinates)


!!$  call this%fe_map(1)%update_on_faces(local_face_id(1),this%quadrature,left_neighbour_coordinates,&
!!$       &                              this%elem_to_face_enumeration(1))
!!$  call this%fe_map(2)%update_on_faces(local_face_id(2),this%quadrature,right_neighbour_coordinates,&
!!$       &                              this%elem_to_face_enumeration(2))

  call this%fe_maps(1)%update(local_face_id(1),this%quadrature,left_neighbour_coordinates)
  call this%fe_maps(2)%update(local_face_id(2),this%quadrature,right_neighbour_coordinates)

  do i = 1, 2 
     call this%face_interpolation(i)%update(local_face_id(i),this%fe_maps(i)%fe_map(local_face_id(i)))
  end do
end subroutine face_integrator_update
!=================================================================================================
function face_integrator_compute_characteristic_length(this,igaus)
  class(face_integrator_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: igaus
  real(rp) :: face_integrator_compute_characteristic_length

  real(rp)    :: inverse_h(this%reference_fe(1)%p%number_dimensions), h(2)
  integer(ip) :: i
  type(fe_map_t), pointer :: fe_map

  do i = 1, 2
     fe_map => this%fe_maps(i)%fe_map(this%fe_maps(i)%active_face_id)
     inverse_h = fe_map%compute_h(igaus,this%reference_fe(i)%p%number_dimensions)
     h(i) = this%reference_fe(i)%p%compute_characteristic_length(inverse_h, igaus)
  end do
  face_integrator_compute_characteristic_length = minval(h)
     
end function face_integrator_compute_characteristic_length

!=================================================================================================
function face_integrator_get_face_map(this)
  class(face_integrator_t), target, intent(in) :: this
  type(fe_map_t)          , pointer            :: face_integrator_get_face_map
  face_integrator_get_face_map => this%face_map
end function face_integrator_get_face_map

!=================================================================================================
function face_integrator_get_face_quadrature(this)
  class(face_integrator_t), target, intent(in) :: this
  type(SB_quadrature_t)   , pointer            :: face_integrator_get_face_quadrature
  face_integrator_get_face_quadrature => this%quadrature
end function face_integrator_get_face_quadrature

!=================================================================================================
subroutine face_integrator_get_value_scalar (this, ishape, qpoint, ineigh, scalar_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  !type(scalar_field_t)    , intent(out)   :: scalar_field
  real(rp)                , intent(out)   :: scalar_field
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  scalar_field = this%face_interpolation(ineigh)%interpolation_o_map%shape_functions(ishape,qpoint)
!  call this%reference_fe(ineigh)%p%get_value(this%interpolation(ineigh)%interpolation_o_map,   &
!       &                                            ishape,qpoint,scalar_field)
end subroutine face_integrator_get_value_scalar

!=================================================================================================
subroutine face_integrator_get_gradient_scalar (this, ishape, qpoint, ineigh, vector_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  type(vector_field_t)    , intent(out)   :: vector_field
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  call this%reference_fe(ineigh)%p%get_gradient(this%face_interpolation(ineigh)%interpolation_o_map,   &
       &                                            ishape,qpoint,vector_field)
end subroutine face_integrator_get_gradient_scalar

!=================================================================================================
subroutine face_integrator_get_outside_normals (this, qpoint, outside_normal)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: qpoint
  type(vector_field_t)    , intent(out)   :: outside_normal(2)

  integer(ip) :: idime
  call outside_normal(1)%init(0.0_rp)
  call outside_normal(2)%init(0.0_rp)
  do idime = 1, this%reference_fe(1)%p%number_dimensions
     call outside_normal(1)%set(idime,this%face_map%outside_normals(idime,qpoint))
     call outside_normal(2)%set(idime,- this%face_map%outside_normals(idime,qpoint))
  end do
end subroutine face_integrator_get_outside_normals

!!$!=================================================================================================
!!$subroutine create_elem_to_face_enumeration (reference_fe,face_quadrature,elem_to_face_enumeration)
!!$  implicit none 
!!$  class(reference_fe_t), intent(in)    :: reference_fe 
!!$  type(SB_quadrature_t), intent(in)    :: face_quadrature
!!$  type(list_t)         , intent(inout) :: elem_to_face_enumeration
!!$  
!!$  integer(ip) :: igaus,i
!!$  integer(ip) :: iface,face_dimensions, number_faces
!!$
!!$  face_dimensions = reference_fe%number_dimensions - 1
!!$  number_faces = reference_fe%get_number_vefs_of_dimension(face_dimensions)
!!$
!!$  ! Create the elem_to_face_enumeration array
!!$  call elem_to_face_enumeration%create(number_faces)
!!$  do iface = 1, number_faces+1
!!$     elem_to_face_enumeration%p(iface) = face_quadrature%number_evaluation_points *    &
!!$          &                                      (iface-1) + 1
!!$  end do
!!$  call elem_to_face_enumeration%allocate_list_from_pointer()
!!$  i = 1
!!$  do iface = 1, number_faces
!!$     do igaus = 1, face_quadrature% number_evaluation_points
!!$        elem_to_face_enumeration%l(elem_to_face_enumeration%p(iface) + igaus - 1) = i
!!$        i = i + 1
!!$     end do
!!$  end do  
!!$end subroutine create_elem_to_face_enumeration
