!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_map_t type procedures
subroutine face_map_create( this, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this
  type(SB_quadrature_t)           , intent(in)    :: quadrature
  class(reference_fe_t)           , intent(in)    :: reference_fe_geometry

  integer(ip)           :: face_dimensions,local_face_id, istat

  call this%free()

  face_dimensions = reference_fe_geometry%number_dimensions - 1
  this%number_faces = reference_fe_geometry%get_number_vefs_of_dimension(face_dimensions)

  allocate(this%fe_map(this%number_faces),stat = istat)
  check(istat == 0)

  do local_face_id = 1,  this%number_faces
     call this%fe_map(local_face_id)%create_on_face(local_face_id,quadrature,reference_fe_geometry)
  end do

end subroutine face_map_create

!==================================================================================================
subroutine face_map_update( this, local_face_id, quadrature, cell_coordinates)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this
  integer(ip)                     , intent(in)    :: local_face_id
  type(SB_quadrature_t)           , intent(in)    :: quadrature
  real(rp)                        , intent(in)    :: cell_coordinates(:,:)

  this%active_face_id = local_face_id
  call this%fe_map(local_face_id)%update(quadrature, cell_coordinates)

end subroutine face_map_update

!==================================================================================================
subroutine face_map_free( this)
  implicit none
  ! Parameters
  class(fe_map_face_restriction_t), intent(inout) :: this

  integer(ip) :: local_face_id , istat

  do local_face_id = 1, this%number_faces
     call this%fe_map(local_face_id)%free()
  end do

  if (allocated(this%fe_map)) then
     deallocate(this%fe_map,stat = istat)
     check(istat == 0)
  end if

  this%number_faces = 0
  this%active_face_id = 0
end subroutine face_map_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_interpolation_t type procedures
subroutine face_interpolation_create(this, local_quadrature, reference_fe_phy)
  implicit none
  ! Parameters
  class(interpolation_face_restriction_t)  , intent(inout) :: this
  type(SB_quadrature_t)        ,  intent(in)   :: local_quadrature
  class(reference_fe_t), target, intent(in)    :: reference_fe_phy

  integer(ip)           :: face_dimensions,local_face_id, istat
  type(SB_quadrature_t) :: face_quadrature

  call this%free()

  this%number_shape_functions   = reference_fe_phy%number_nodes
  this%number_evaluation_points = local_quadrature%number_evaluation_points
  face_dimensions               = reference_fe_phy%number_dimensions - 1
  this%number_faces             = reference_fe_phy%get_number_vefs_of_dimension(face_dimensions)
  this%reference_fe             => reference_fe_phy

  allocate(this%interpolation(this%number_faces),stat = istat)
  check(istat == 0)

  do local_face_id =1, this%number_faces
     call reference_fe_phy%create_face_interpolation(local_face_id,local_quadrature,                  &
          &                                      this%interpolation(local_face_id))
  end do

  call this%interpolation_o_map%copy(source_interpolation = this%interpolation(1))

end subroutine face_interpolation_create

!==================================================================================================
subroutine face_interpolation_update(this, local_face_id, fe_map)
  implicit none
  ! Parameters
  class(interpolation_face_restriction_t)  , intent(inout) :: this
  integer(ip)                  , intent(in)    :: local_face_id
  type(fe_map_t)               , intent(in)    :: fe_map

  call femap_apply_to_interp(fe_map, this%interpolation(local_face_id),                  &
       &                     this%interpolation_o_map)
end subroutine face_interpolation_update

!==================================================================================================
subroutine face_interpolation_free(this)
  implicit none
  ! Parameters
  class(interpolation_face_restriction_t)  , intent(inout) :: this

  integer(ip) :: i, istat

  do i = 1, this%number_faces
     call this%interpolation(i)%free()
  end do
  call this%interpolation_o_map%free
  if (allocated(this%interpolation)) then
     deallocate(this%interpolation, stat = istat)
     check (istat == 0)
  end if
  this%number_shape_functions   = 0
  this%number_evaluation_points = 0
  this%number_faces             = 0

  this%reference_fe => NULL()
end subroutine face_interpolation_free

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!face_integrator_t type procedures
subroutine face_integrator_create(this,left_reference_fe,right_reference_fe,left_geo_reference_fe,&
     &                            right_geo_reference_fe, max_order )
  implicit none
  ! Parameters
  class(face_integrator_t)      , intent(inout) :: this
  class(reference_fe_t), pointer, intent(in)    :: left_reference_fe, right_reference_fe
  class(reference_fe_t), pointer, intent(in)    :: left_geo_reference_fe, right_geo_reference_fe
  integer(ip)        , optional , intent(in)    :: max_order

  integer(ip)           :: number_nodes_face, number_nodes_face_scalar, aux_vef_dimension(5)

  call this%free()

  ! AH: This quadrature is created using the left reference element but in a future I would
  ! propose to define a reference element associated to face integration
  ! (in case we want to use diferente volume and face integration)
  call left_reference_fe%create_face_quadrature(this%quadrature, max_order)
  call this%face_map%face_map_create(this%quadrature,left_geo_reference_fe)

  ! Allocate the coordinates assuming the geometry and the interpolation are the same order
  ! AH: This needs to be improved in the future and also the variable coordinates might need 
  ! to be discussed at some point
  ! If we agree in using such a structure, clearly this code should be encapsulated somehow
  ! in reference_fe (the use of number_vef_dimension should not be explicited)
  aux_vef_dimension = left_geo_reference_fe%get_number_vefs_dimension()
  number_nodes_face = left_geo_reference_fe%get_number_nodes_vef                                  &
       &              (aux_vef_dimension(left_geo_reference_fe%number_dimensions))
  number_nodes_face_scalar = int(real(number_nodes_face)/                                         &
       &                     real(left_geo_reference_fe%number_field_components))
  call memalloc(left_geo_reference_fe%number_dimensions, number_nodes_face_scalar,                &
       &        this%coordinates,__FILE__,__LINE__)
    
  this%reference_fe(1)%p => left_reference_fe
  call this%face_interpolation(1)%create(this%quadrature,this%reference_fe(1)%p)
  call this%fe_maps(1)%create(this%quadrature,left_geo_reference_fe)

  if (associated(right_reference_fe)) then
     this%reference_fe(2)%p => right_reference_fe
     call this%face_interpolation(2)%create(this%quadrature,this%reference_fe(2)%p)
  call this%fe_maps(2)%create(this%quadrature,right_geo_reference_fe)
  end if
end subroutine face_integrator_create

!==================================================================================================
subroutine face_integrator_free(this)
  implicit none
  ! Parameters
  class(face_integrator_t)     , intent(inout) :: this

  integer(ip) :: i
  call this%face_map%free()
  call this%quadrature%free()

  do i=1,2
     this%reference_fe(i)%p => NULL()
     call this%face_interpolation(i)%free()
     call this%fe_maps(i)%free()
  end do

  if(allocated(this%coordinates)) call memfree(this%coordinates,__FILE__,__LINE__)
end subroutine face_integrator_free

!==================================================================================================
subroutine face_integrator_update(this,local_face_id,left_reference_fe_geo,                       &
     &                            left_neighbour_coordinates,right_neighbour_coordinates)
  implicit none
  ! Parameters
  class(face_integrator_t), intent(inout) :: this
  integer(ip)             , intent(in)    :: local_face_id(2)
  class(reference_fe_t)   , intent(in)    :: left_reference_fe_geo
  real(rp)                , intent(in)    :: left_neighbour_coordinates(:,:)
  real(rp)      , optional, intent(in)    :: right_neighbour_coordinates(:,:)

  integer(ip)           :: i,aux_vef_dimension(5), local_vef_id
  integer(ip)           :: number_corners_face_geo, local_element_corner
  type(list_t), pointer :: corners_vef

  ! This is using corners_vef and assuming that the geometrical reference element is linear.
  aux_vef_dimension = left_reference_fe_geo%get_number_vefs_dimension()
  number_corners_face_geo = left_reference_fe_geo%get_number_corners_vef                          &
       &                  (aux_vef_dimension(left_reference_fe_geo%number_dimensions))
  local_vef_id      = aux_vef_dimension(left_reference_fe_geo%number_dimensions)+local_face_id(1)-1
  corners_vef => left_reference_fe_geo%get_corners_vef()
  do i = 1, number_corners_face_geo
     local_element_corner = corners_vef%l(corners_vef%p(local_vef_id) + i-1)
     this%coordinates(:,i) = left_neighbour_coordinates(:,local_element_corner)
  end do

  ! Update the face_map
  call this%face_map%face_map_update(local_face_id(1),left_reference_fe_geo,this%quadrature,      &
       &                              this%coordinates)

  call this%fe_maps(1)%update(local_face_id(1),this%quadrature,left_neighbour_coordinates)
  call this%face_interpolation(1)%update(local_face_id(1),this%fe_maps(1)%fe_map(local_face_id(1)))

  if (present(right_neighbour_coordinates)) then
     call this%fe_maps(2)%update(local_face_id(2),this%quadrature,right_neighbour_coordinates)
     call this%face_interpolation(2)%update(local_face_id(2),this%fe_maps(2)%fe_map(local_face_id(2)))
  end if
end subroutine face_integrator_update

!=================================================================================================
function face_integrator_compute_characteristic_length(this,igaus, number_neighbours)
  implicit none
  class(face_integrator_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: igaus, number_neighbours
  real(rp) :: face_integrator_compute_characteristic_length

  real(rp)    :: inverse_h(3), h(2)
  integer(ip) :: i
  type(fe_map_t), pointer :: fe_map
  
  fe_map => this%fe_maps(1)%fe_map(this%fe_maps(1)%active_face_id)
  h(1) = this%reference_fe(1)%p%compute_characteristic_length(fe_map, igaus)
  face_integrator_compute_characteristic_length = h(1)
  do i = 2, number_neighbours
     fe_map => this%fe_maps(i)%fe_map(this%fe_maps(i)%active_face_id)
     h(i) = this%reference_fe(i)%p%compute_characteristic_length(fe_map, igaus)
     face_integrator_compute_characteristic_length =                                              &
          &       min(face_integrator_compute_characteristic_length, h(i))
  end do
end function face_integrator_compute_characteristic_length

!=================================================================================================
function face_integrator_get_face_map(this)
  implicit none
  class(face_integrator_t), target, intent(in) :: this
  type(fe_map_t)          , pointer            :: face_integrator_get_face_map
  face_integrator_get_face_map => this%face_map
end function face_integrator_get_face_map

!=================================================================================================
function face_integrator_get_face_quadrature(this)
  implicit none
  class(face_integrator_t), target, intent(in) :: this
  type(SB_quadrature_t)   , pointer            :: face_integrator_get_face_quadrature
  face_integrator_get_face_quadrature => this%quadrature
end function face_integrator_get_face_quadrature

!=================================================================================================
subroutine face_integrator_get_value_scalar (this, ishape, qpoint, ineigh, scalar_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  !type(scalar_field_t)    , intent(out)   :: scalar_field
  real(rp)                , intent(out)   :: scalar_field
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  scalar_field = this%face_interpolation(ineigh)%interpolation_o_map%shape_functions(ishape,qpoint)
!  call this%reference_fe(ineigh)%p%get_value(this%interpolation(ineigh)%interpolation_o_map,   &
!       &                                            ishape,qpoint,scalar_field)
end subroutine face_integrator_get_value_scalar

!=================================================================================================
subroutine face_integrator_get_gradient_scalar (this, ishape, qpoint, ineigh, vector_field)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  integer(ip)             , intent(in)    :: ineigh
  type(vector_field_t)    , intent(out)   :: vector_field
  assert( this%reference_fe(ineigh)%p%field_type == field_type_scalar )
  call this%reference_fe(ineigh)%p%get_gradient(this%face_interpolation(ineigh)%interpolation_o_map,   &
       &                                            ishape,qpoint,vector_field)
end subroutine face_integrator_get_gradient_scalar

!=================================================================================================
subroutine face_integrator_get_normals (this, qpoint, normal)
  implicit none
  class(face_integrator_t), intent(in)    :: this
  integer(ip)             , intent(in)    :: qpoint
  type(vector_field_t)    , intent(out)   :: normal(2)

  integer(ip) :: idime
  call normal(1)%init(0.0_rp)
  call normal(2)%init(0.0_rp)
  do idime = 1, this%reference_fe(1)%p%number_dimensions
     call normal(1)%set(idime,this%face_map%normals(idime,qpoint))
     call normal(2)%set(idime,- this%face_map%normals(idime,qpoint))
  end do
end subroutine face_integrator_get_normals

