
! subroutine volume_integrator_compute_value_trial( this, node, gp )
!   implicit none
!   class(SB_volume_integrator_t), intent(inout) :: this
!   integer(ip), intent(in)  :: node, gp

!   call this%reference_fe%get_value( this%shape_value_trial, this%interpolation_o_map, node, gp )

! end subroutine volume_integrator_compute_value_trial

! subroutine volume_integrator_compute_gradient_trial( this, node, gp )
!   implicit none
!   class(SB_volume_integrator_t), intent(inout) :: this 
!   integer(ip), intent(in)  :: node, gp

!   call this%reference_fe%get_gradient( this%shape_gradient_trial, this%interpolation_o_map, node, gp )

! end subroutine volume_integrator_compute_gradient_trial

subroutine volume_integrator_compute_value_test( this )
  implicit none
  class(SB_volume_integrator_t), intent(inout) :: this
  class(field_type_t), pointer :: array_entry
  integer(ip) :: inode, igp
  real(rp), pointer :: value(:,:)
  
  do inode = 1, this%reference_fe%number_nodes
     do igp = 1, this%quadrature%number_integration_points
        value => this%shape_value_test%get_value(inode,igp)
        call this%reference_fe%get_value( value, this%interpolation_o_map, inode, igp )
     end do
  end do
  call this%shape_value_test%print()

end subroutine volume_integrator_compute_value_test

subroutine volume_integrator_compute_gradient_test( this )
  implicit none
  class(SB_volume_integrator_t), intent(inout) :: this 
  class(field_type_t), pointer :: array_entry
  integer(ip) :: inode, igp
  real(rp), pointer :: value(:,:)

  do inode = 1, this%reference_fe%number_nodes
     do igp = 1, this%quadrature%number_integration_points
        value => this%shape_gradient_test%get_value(inode,igp)
        call this%reference_fe%get_gradient( value, this%interpolation_o_map, inode, igp )
     end do
  end do
  call this%shape_gradient_test%print()

end subroutine volume_integrator_compute_gradient_test

subroutine volume_integrator_create( this, reference_fe, reference_fe_geometry, max_order )
  implicit none
  ! Parameters
  class(SB_volume_integrator_t), intent(out) :: this
  class(reference_fe_t), target, intent(in) :: reference_fe
  class(reference_fe_t), target, intent(in) :: reference_fe_geometry    
  integer(ip), optional, intent(in)  :: max_order

  integer(ip) :: ndime,ngaus
  ! Create quadrature
  this%reference_fe => reference_fe
  this%reference_fe_geometry => reference_fe_geometry

end subroutine volume_integrator_create

subroutine volume_integrator_free( this )
  implicit none
  ! Parameters
  class(SB_volume_integrator_t), intent(inout) :: this

  call this%quadrature%free()
  call this%interpolation%free()
  call this%interpolation_geometry%free()
  call this%interpolation_o_map%free()
  call this%fe_map%free()

  nullify(this%reference_fe)
  nullify(this%reference_fe_geometry)

end subroutine volume_integrator_free

subroutine volume_integrator_set_integration( this, max_order )
  implicit none
  ! Parameters
  class(SB_volume_integrator_t), intent(inout) :: this   
  integer(ip), optional, intent(in)  :: max_order

  integer(ip) :: ndime,ngaus
  ! Create quadrature

  call this%reference_fe%create_quadrature( this%quadrature, max_order )

  call this%reference_fe%create_interpolation( this%quadrature, this%interpolation )

  call this%reference_fe%create_interpolation( this%quadrature, this%interpolation_geometry )

  call this%interpolation_o_map%copy(from = this%interpolation)

  ndime = this%reference_fe%number_dimensions
  ngaus = this%interpolation%number_evaluation_points

  call memalloc(ndime,ndime,ngaus,this%fe_map%jacobian,__FILE__,__LINE__)
  call memalloc(ndime,ndime,ngaus,this%fe_map%inv_jacobian,__FILE__,__LINE__)
  call memalloc(ngaus,this%fe_map%det_jacobian,__FILE__,__LINE__)   
  call memalloc(ndime,ngaus,this%fe_map%coordinates_points,__FILE__,__LINE__)


  if( allocated( this%interpolation%hessian ) ) then
     call memalloc(ndime,ndime,ndime,this%interpolation%number_evaluation_points, &
          & this%fe_map%d2sdx,  __FILE__,__LINE__)
  end if


  call this%shape_value_test%start( this%reference_fe%field_type, this%reference_fe%field_components, &
       this%quadrature%number_integration_points, this%reference_fe%number_nodes )
  call this%shape_value_trial%start( this%reference_fe%field_type, this%reference_fe%field_components, &
       this%quadrature%number_integration_points, this%reference_fe%number_nodes )
  
  call this%shape_gradient_test%start( gradient_field_type(this%reference_fe%field_type), &
       this%reference_fe%field_components, &
       this%quadrature%number_integration_points, this%reference_fe%number_nodes )
  call this%shape_gradient_trial%start( gradient_field_type(this%reference_fe%field_type), &
       this%reference_fe%field_components, &
       this%quadrature%number_integration_points, this%reference_fe%number_nodes )

  call this%compute_value_test()
  call this%shape_value_test%print()
  call this%compute_gradient_test()
  call this%shape_gradient_test%print()

end subroutine volume_integrator_set_integration

subroutine volume_integrator_update(this, coordinates)
  implicit none
  ! Parameters
  class(SB_volume_integrator_t), intent(inout) :: this
  real(rp), intent(in) :: coordinates(:,:)
  ! Define fe map  by interpolation
  call create_femap( this%interpolation_geometry, coordinates, this%fe_map )
  ! Obtain physical interpolation
  call femap_apply_to_interp( this%fe_map, this%interpolation, this%interpolation_o_map )

  call this%compute_gradient_test()
end subroutine volume_integrator_update
!==================================================================================================

subroutine volume_integrator_print( this )
  implicit none
  class(SB_volume_integrator_t), intent(inout) :: this

  write(*,*) 'PRINT VOLUME INTEGRATOR: '
  write(*,*) '%%%%%%%%%%%%%%%% quadrature: %%%%%%%%%%%%%%%%'
  call this%quadrature%print()
  write(*,*) '%%%%%%%%%%%%%%%% reference_fe: %%%%%%%%%%%%%%%%'
  call this%reference_fe%print()
  write(*,*) '%%%%%%%%%%%%%%%% interpolation: %%%%%%%%%%%%%%%%'
  call this%interpolation%print()
  write(*,*) '%%%%%%%%%%%%%%%% reference_fe_geometry: %%%%%%%%%%%%%%%%'
  call this%reference_fe_geometry%print()
  write(*,*) '%%%%%%%%%%%%%%%% interpolation_geometry: %%%%%%%%%%%%%%%%'
  call this%interpolation_geometry%print()
  write(*,*) '%%%%%%%%%%%%%%%% interpolation_o_map: %%%%%%%%%%%%%%%%'
  call this%interpolation_o_map%print()
  write(*,*) '%%%%%%%%%%%%%%%% shape functions: %%%%%%%%%%%%%%%%'
  call this%shape_value_test%print()
  write(*,*) '%%%%%%%%%%%%%%%% shape functions: %%%%%%%%%%%%%%%%'
  call this%shape_gradient_test%print()

  write(*,*) '%%%%%%%%%%%%%%%% jacobian: %%%%%%%%%%%%%%%%', this%fe_map%jacobian
  write(*,*) '%%%%%%%%%%%%%%%% inverse jacobian: %%%%%%%%%%%%%%%%',this%fe_map%inv_jacobian
  write(*,*) '%%%%%%%%%%%%%%%% determinant jacobian: %%%%%%%%%%%%%%%%',this%fe_map%det_jacobian
  if ( allocated( this%interpolation%hessian ) ) then 
     write(*,*) '%%%%%%%%%%%%%%%% second derivatives: %%%%%%%%%%%%%%%%',this%fe_map%d2sdx
  end if
  write(*,*) '%%%%%%%%%%%%%%%% coordinates points: %%%%%%%%%%%%%%%%',this%fe_map%coordinates_points

end subroutine volume_integrator_print

function volume_integrator_get_reference_fe ( this )
  implicit none
  class(SB_volume_integrator_t), target, intent(in) :: this
  class(reference_fe_t), pointer :: volume_integrator_get_reference_fe
  volume_integrator_get_reference_fe => this%reference_fe
end function volume_integrator_get_reference_fe

function volume_integrator_get_quadrature ( this )
  implicit none
  class(SB_volume_integrator_t), target, intent(in) :: this
  type(SB_quadrature_t), pointer :: volume_integrator_get_quadrature
  volume_integrator_get_quadrature => this%quadrature
end function volume_integrator_get_quadrature

function volume_integrator_get_interpolation ( this )
  implicit none
  class(SB_volume_integrator_t), target, intent(in) :: this
  type(SB_interpolation_t), pointer :: volume_integrator_get_interpolation
  volume_integrator_get_interpolation => this%interpolation
end function volume_integrator_get_interpolation

function volume_integrator_get_fe_map ( this )
  implicit none
  class(SB_volume_integrator_t), target, intent(in) :: this
  type(fe_map_t), pointer :: volume_integrator_get_fe_map
  volume_integrator_get_fe_map => this%fe_map
end function volume_integrator_get_fe_map

function volume_integrator_get_gradients ( this )
  implicit none
  class(SB_volume_integrator_t), target, intent(in) :: this
  type(shape_values_t), pointer :: volume_integrator_get_gradients
  volume_integrator_get_gradients => this%shape_gradient_test
end function volume_integrator_get_gradients

function volume_integrator_get_values ( this )
  implicit none
  class(SB_volume_integrator_t), target, intent(in) :: this
  type(shape_values_t), pointer :: volume_integrator_get_values
  volume_integrator_get_values => this%shape_value_test
end function volume_integrator_get_values


subroutine fe_map_free( this )
  implicit none
  class(fe_map_t), intent(inout) :: this

! How is allocation managed?
! Memfree case
  if(allocated(this%jacobian)) call memfree(this%jacobian,__FILE__,__LINE__)
  if(allocated(this%inv_jacobian)) call memfree(this%inv_jacobian,__FILE__,__LINE__)
  if(allocated(this%det_jacobian)) call memfree(this%det_jacobian,__FILE__,__LINE__)
  if(allocated(this%d2sdx)) call memfree(this%d2sdx,__FILE__,__LINE__)
  if(allocated(this%coordinates_points)) call memfree(this%coordinates_points,__FILE__,__LINE__)

! Deallocate case
!  if(allocated(this%jacobian)) call deallocate(this%jacobian)
!  if(allocated(inv_jacobian)) call deallocate(this%inv_jacobian)
!  if(allocated(this%det_jacobian)) call deallocate(this%det_jacobian)
!  if(allocated(this%d2sdx)) call deallocate(this%d2sdx)
!  if(allocated(this%coordinates_points)) call deallocate(this%coordinates_points)

end subroutine fe_map_free


function fe_map_get_det_jacobian ( this, i )
  implicit none
  class(fe_map_t), target, intent(in) :: this
  integer(ip) :: i
  real(rp) :: fe_map_get_det_jacobian
  fe_map_get_det_jacobian = this%det_jacobian(i)
end function fe_map_get_det_jacobian

!==============================================================================
subroutine create_femap(int,elcod,map )
  !-----------------------------------------------------------------------
  ! A map obtained from the (usually isoparametric) interpolation of the geometry
  !-----------------------------------------------------------------------
  implicit none
  type(SB_interpolation_t), intent(in)    :: int
  !    real(rp)           , intent(inout) :: hnatu
  real(rp)           , intent(in)    :: elcod(:,:)
  type(fe_map_t)        , intent(inout) :: map
  ! Locals
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  real(rp)    :: hnatu
  real(rp)    :: enor0,h_tem
  integer(ip) :: ndime,nnode,nlocs,ntens
  integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
  logical :: khes

  khes = .false.
  if ( allocated( int%hessian ) ) then 
     khes = .true.
  end if

  ! ! Check and get data from int
  ! assert(int%kder==1)
  ndime = int%number_dimensions
  !nnode = int%number_shape_functions
  nnode = size(int%shape_functions,1)
  nlocs = int%number_evaluation_points

  ! ! Check elcod
  ! assert(ndime==size(elcod,dim=1))
  ! assert(nnode==size(elcod,dim=2))

  ! ! Check map allocation (jainv, detjm and hleng
  ! ! are assumed to be allocated if jacob is)
  ! assert(ndime==size(map%jacob,dim=1))
  ! assert(nlocs==size(map%jacob,dim=3))

  ! Jacobian and its inverse
  ! write(*,*) 'elcod: ',elcod

  do ilocs=1,nlocs
     ! Matmul is not thread safe
     !map%jacob(:,:,ilocs)=matmul(elcod,transpose(int%deriv(:,:,ilocs)))
     map%jacobian(:,:,ilocs)=0.0_rp
     do inode=1,nnode
        do jdime=1,ndime
           do idime=1,ndime
              map%jacobian(idime,jdime,ilocs) = map%jacobian(idime,jdime,ilocs) &
                   + elcod(idime,inode)*int%shape_derivatives(jdime,inode,ilocs)
           end do
        end do
     end do
     ! J^(-t)
     call invmtx(map%jacobian(:,:,ilocs),map%inv_jacobian(:,:,ilocs),map%det_jacobian(ilocs),ndime)
  end do

  ! Evaluation (Gauss) point coordinates
  do ilocs=1,nlocs
     map%coordinates_points(:,ilocs)=0.0_rp
     do inode=1,nnode
        do idime=1,ndime
           map%coordinates_points(idime,ilocs) = map%coordinates_points(idime,ilocs) &
                + elcod(idime,inode)*int%shape_functions(inode,ilocs)
        end do
     end do
  end do

  ! ! Second derivatives of the map
  if( khes ) then

     ntens=int%number_entries_symmetric_tensor
     ! Check that second derivativesof the map have been allocated.
     assert(ndime==size(map%d2sdx,dim=1))
     assert(nlocs==size(map%d2sdx,dim=4))

     call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
     call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
     call memalloc(ntens,wvec1,__FILE__,__LINE__)


     do ilocs=1,nlocs

        ! Transforms the array HESSI to a symmetric matrix WMAT1
        do inode=1,nnode
           do itens = 1, ntens
              wvec1(itens) = int%hessian(itens,inode,ilocs)
           end do
           call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
        end do

        ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for
        ! each node
        do inode=1,nnode
           call btdbma(wmat2(1,1,inode),wmat1(1,1,inode), &
                &        map%inv_jacobian(:,:,ilocs),ndime,ndime)
        end do

        ! Obtains (d^2 s_k / d x_i d x_j) as the solution of the system
        ! (d x_l / d s_k) (d^2 s_k / d x_i d x_j) 
        !     = - (d^2 x_l / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j), 
        ! for l,i,j = 1,...,NDIME
        do kdime=1,ndime
           do idime=1,ndime
              do jdime=1,ndime
                 map%d2sdx(kdime,idime,jdime,ilocs)=0.0_rp
                 do ldime=1,ndime
                    do inode=1,nnode
                       map%d2sdx(kdime,idime,jdime,ilocs) =    &
                            & map%d2sdx(kdime,idime,jdime,ilocs) &
                            & - map%inv_jacobian(kdime,ldime,ilocs)     &
                            &   * wmat2(idime,jdime,inode) * elcod(ldime,inode)
                    end do
                 end do
              end do
           end do
        end do

     end do

     call memfree(wmat1,__FILE__,__LINE__)
     call memfree(wmat2,__FILE__,__LINE__)

  end if


end subroutine create_femap


subroutine invmtx(a,b,deter,nsize)
  !-----------------------------------------------------------------------
  !
  ! This routine inverts a square matrix A -> Mat(nsize,nsize). The
  ! inverse is stored in B. Its determinant is DETER
  !    
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: nsize
  real(rp),    intent(in)  :: a(nsize,nsize)
  real(rp),    intent(out) :: b(nsize,nsize),deter
  integer(ip)              :: isize,jsize
  real(rp)                 :: denom,t1,t2,t3,t4

  select case (nsize)

  case(1)
     deter=a(1,1)
     if(deter==0.0_rp) return
     b(1,1) = 1.0_rp/a(1,1)

  case(2)
     deter=a(1,1)*a(2,2)-a(2,1)*a(1,2)
     if(deter/=0.0_rp) then
        denom=1.0_rp/deter
        b(1,1) = a(2,2)*denom
        b(2,2) = a(1,1)*denom
        b(2,1) =-a(2,1)*denom
        b(1,2) =-a(1,2)*denom 
     end if

  case(3)
     t1  = a(2,2)*a(3,3) - a(3,2)*a(2,3)
     t2  =-a(2,1)*a(3,3) + a(3,1)*a(2,3)
     t3  = a(2,1)*a(3,2) - a(3,1)*a(2,2)
     deter = a(1,1)*t1 + a(1,2)*t2 + a(1,3)*t3
     if(deter==0.0_rp) return
     denom = 1.0_rp/deter
     b(1,1) = t1*denom
     b(2,1) = t2*denom
     b(3,1) = t3*denom
     b(2,2) = ( a(1,1)*a(3,3) - a(3,1)*a(1,3))*denom
     b(3,2) = (-a(1,1)*a(3,2) + a(1,2)*a(3,1))*denom
     b(3,3) = ( a(1,1)*a(2,2) - a(2,1)*a(1,2))*denom
     b(1,2) = (-a(1,2)*a(3,3) + a(3,2)*a(1,3))*denom
     b(1,3) = ( a(1,2)*a(2,3) - a(2,2)*a(1,3))*denom
     b(2,3) = (-a(1,1)*a(2,3) + a(2,1)*a(1,3))*denom

  case(4)
     t1= a(2,2)*a(3,3)*a(4,4) + a(2,3)*a(3,4)*a(4,2)&
          + a(2,4)*a(3,2)*a(4,3) - a(2,3)*a(3,2)*a(4,4)&
          - a(2,2)*a(3,4)*a(4,3) - a(2,4)*a(3,3)*a(4,2)
     t2=-a(2,1)*a(3,3)*a(4,4) - a(2,3)*a(3,4)*a(4,1)&
          - a(2,4)*a(3,1)*a(4,3) + a(2,4)*a(3,3)*a(4,1)&
          + a(2,3)*a(3,1)*a(4,4) + a(2,1)*a(3,4)*a(4,3)
     t3=+a(2,1)*a(3,2)*a(4,4) + a(2,2)*a(3,4)*a(4,1)&
          + a(2,4)*a(3,1)*a(4,2) - a(2,4)*a(3,2)*a(4,1)&
          - a(2,2)*a(3,1)*a(4,4) - a(2,1)*a(3,4)*a(4,2)
     t4=-a(2,1)*a(3,2)*a(4,3) - a(2,2)*a(3,3)*a(4,1)&
          - a(2,3)*a(3,1)*a(4,2) + a(2,3)*a(3,2)*a(4,1)&
          + a(2,2)*a(3,1)*a(4,3) + a(2,1)*a(3,3)*a(4,2)
     deter= a(1,1)*t1 + a(1,2)*t2 + a(1,3)*t3 + a(1,4)*t4
     if(deter==0.0_rp) return
     denom=1.0_rp/deter
     b(1,1) = t1*denom
     b(2,1) = t2*denom
     b(3,1) = t3*denom
     b(4,1) = t4*denom
     b(1,2) =(- a(1,2)*a(3,3)*a(4,4) - a(1,3)*a(3,4)*a(4,2)&
          - a(1,4)*a(3,2)*a(4,3) + a(1,3)*a(3,2)*a(4,4)&
          + a(1,2)*a(3,4)*a(4,3) + a(1,4)*a(3,3)*a(4,2))*denom
     b(2,2) =(  a(1,1)*a(3,3)*a(4,4) + a(1,3)*a(3,4)*a(4,1)&
          + a(1,4)*a(3,1)*a(4,3) - a(1,4)*a(3,3)*a(4,1)&
          - a(1,3)*a(3,1)*a(4,4) - a(1,1)*a(3,4)*a(4,3))*denom
     b(3,2) =(- a(1,1)*a(3,2)*a(4,4) - a(1,2)*a(3,4)*a(4,1)&
          - a(1,4)*a(3,1)*a(4,2) + a(1,4)*a(3,2)*a(4,1)&
          + a(1,2)*a(3,1)*a(4,4) + a(1,1)*a(3,4)*a(4,2))*denom
     b(4,2) =(  a(1,1)*a(3,2)*a(4,3) + a(1,2)*a(3,3)*a(4,1)&
          + a(1,3)*a(3,1)*a(4,2) - a(1,3)*a(3,2)*a(4,1)&
          - a(1,2)*a(3,1)*a(4,3) - a(1,1)*a(3,3)*a(4,2))*denom
     b(1,3) =(  a(1,2)*a(2,3)*a(4,4) + a(1,3)*a(2,4)*a(4,2)&
          + a(1,4)*a(2,2)*a(4,3) - a(1,3)*a(2,2)*a(4,4)&
          - a(1,2)*a(2,4)*a(4,3) - a(1,4)*a(2,3)*a(4,2))*denom
     b(2,3) =(- a(1,1)*a(2,3)*a(4,4) - a(1,3)*a(2,4)*a(4,1)&
          - a(1,4)*a(2,1)*a(4,3) + a(1,4)*a(2,3)*a(4,1)&
          + a(1,3)*a(2,1)*a(4,4) + a(1,1)*a(2,4)*a(4,3))*denom
     b(3,3) =(  a(1,1)*a(2,2)*a(4,4) + a(1,2)*a(2,4)*a(4,1)&
          + a(1,4)*a(2,1)*a(4,2) - a(1,4)*a(2,2)*a(4,1)&
          - a(1,2)*a(2,1)*a(4,4) - a(1,1)*a(2,4)*a(4,2))*denom
     b(4,3) =(- a(1,1)*a(2,2)*a(4,3) - a(1,2)*a(2,3)*a(4,1)&
          - a(1,3)*a(2,1)*a(4,2) + a(1,3)*a(2,2)*a(4,1)&
          + a(1,2)*a(2,1)*a(4,3) + a(1,1)*a(2,3)*a(4,2))*denom
     b(1,4) =(- a(1,2)*a(2,3)*a(3,4) - a(1,3)*a(2,4)*a(3,2)&
          - a(1,4)*a(2,2)*a(3,3) + a(1,4)*a(2,3)*a(3,2)&
          + a(1,3)*a(2,2)*a(3,4) + a(1,2)*a(2,4)*a(3,3))*denom
     b(2,4) =(  a(1,1)*a(2,3)*a(3,4) + a(1,3)*a(2,4)*a(3,1)&
          + a(1,4)*a(2,1)*a(3,3) - a(1,4)*a(2,3)*a(3,1)&
          - a(1,3)*a(2,1)*a(3,4) - a(1,1)*a(2,4)*a(3,3))*denom
     b(3,4) =(- a(1,1)*a(2,2)*a(3,4) - a(1,2)*a(2,4)*a(3,1)&
          - a(1,4)*a(2,1)*a(3,2) + a(1,4)*a(2,2)*a(3,1)&
          + a(1,2)*a(2,1)*a(3,4) + a(1,1)*a(2,4)*a(3,2))*denom
     b(4,4) =(  a(1,1)*a(2,2)*a(3,3) + a(1,2)*a(2,3)*a(3,1)&
          + a(1,3)*a(2,1)*a(3,2) - a(1,3)*a(2,2)*a(3,1)&
          - a(1,2)*a(2,1)*a(3,3) - a(1,1)*a(2,3)*a(3,2))*denom

  case default
     b=a
     call invert(b,nsize,nsize)

  end select

end subroutine invmtx

!-----------------------------------------------------------------------
subroutine invert(a,nmax,ndm)
  !-----------------------------------------------------------------------
  !
  ! This routine performs the inversion of a ndm*ndm square matrix 
  ! or just part of it (nmax*nmax)
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)    :: ndm,nmax
  real(rp),    intent(inout) :: a(ndm,ndm)
  real(rp)                   :: d
  integer(ip)                :: n,j,i

  do n = 1,nmax
     d = a(n,n)
     do j = 1,nmax
        a(n,j) = -a(n,j)/d
     end do
     do i = 1,nmax
        if(n/=i) then
           do j = 1,nmax
              if(n/=j) a(i,j) = a(i,j) +a(i,n)*a(n,j)
           end do
        end if
        a(i,n) = a(i,n)/d
     end do
     a(n,n) = 1.0_rp/d
  end do

end subroutine invert


!-----------------------------------------------------------------------
subroutine vetoma(vecto,xmatr,ndime,ntens)
  !-----------------------------------------------------------------------
  !                                      
  ! This routine stores a vector VECTO as a symmetric matrix XMATR
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: ndime,ntens
  real(rp)   , intent(in)  :: vecto(ntens)
  real(rp)   , intent(out) :: xmatr(ndime,ndime)

  if(ndime.eq.2) then
     xmatr(1,1)=vecto(1)
     xmatr(1,2)=vecto(3)
     xmatr(2,1)=vecto(3)
     xmatr(2,2)=vecto(2)
  else
     xmatr(1,1)=vecto(1)
     xmatr(1,2)=vecto(4)
     xmatr(1,3)=vecto(5)
     xmatr(2,1)=vecto(4)
     xmatr(2,2)=vecto(2)
     xmatr(2,3)=vecto(6)
     xmatr(3,1)=vecto(5)
     xmatr(3,2)=vecto(6)
     xmatr(3,3)=vecto(3)
  end if

end subroutine vetoma

!-----------------------------------------------------------------------
subroutine btdbma(aglob,aloca,bmatr,n1,n2)
  !-----------------------------------------------------------------------
  !                                      
  ! This routine computes Ag = Bt Al B  when Ag and Al are stored as full
  ! matrices (Ag := aglob, Al := aloca, B := bmatr). The dimensions are
  ! Al -> Mat(n1,n1), Ag -> Mat(n2,n2), B -> Mat(n2,n1) 
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: n1,n2
  real(rp)   , intent(in)  :: aloca(n1,n1), bmatr(n1,n2)
  real(rp)   , intent(out) :: aglob(n2,n2)
  integer(ip)              :: i,j,k,l

  do i=1,n2
     do j=1,n2
        aglob(i,j)=0.0
        do k=1,n1
           do l=1,n1
              aglob(i,j)=aglob(i,j)+bmatr(k,i)*aloca(k,l)*bmatr(l,j)
           end do
        end do
     end do
  end do

end subroutine btdbma

!==============================================================================
!
!==============================================================================
subroutine femap_apply_to_interp(map,ref,phy)
  implicit none
  type(SB_interpolation_t), intent(in)    :: ref
  type(fe_map_t)        , intent(in)    :: map
  type(SB_interpolation_t), intent(inout) :: phy
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  integer(ip) :: ndime,nnode,nlocs,ntens
  integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
  logical :: khes


  khes = .false.
  if ( allocated( ref%hessian ) ) then 
     khes = .true.
  end if

  ndime = ref%number_dimensions
  ntens = ref%number_entries_symmetric_tensor
  nlocs = ref%number_evaluation_points
  !nnode = ref%number_shape_functions
  nnode = size(ref%shape_functions,1)

  ! Shape functions do not change
  ! phy%shape = ref%shape ! SB. not needed

  ! First derivatives do
  !if(phy%kder==1) then
  phy%shape_derivatives=0.0_rp
  do ilocs=1,phy%number_evaluation_points
     do inode=1,size(phy%shape_functions,1)!phy%number_shape_functions
        do idime=1,ndime
           do jdime=1,ndime
              phy%shape_derivatives(idime,inode,ilocs) = phy%shape_derivatives(idime,inode,ilocs) &
                   + map%inv_jacobian(jdime,idime,ilocs)*ref%shape_derivatives(jdime,inode,ilocs)
           end do
        end do
     end do
  end do
  !end if

  ! Second derivatives are
  !
  !    d^2 N / d x_i d x_j
  !       = (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j)
  !       + (d N / d s_k) (d^2 s_k / d x_i d x_j) 
  !
  if( khes ) then

     call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
     call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)

     do ilocs=1,nlocs

        if( khes ) then
           ! Transforms the array HESSI to a symmetric matrix WMAT1
           do inode=1,nnode
              do itens = 1, ntens
                 wvec1(itens) = ref%hessian(itens,inode,ilocs)
              end do
              call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
           end do
           ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for each node
           do inode=1,nnode
              call btdbma(wmat2(1,1,inode),wmat1(1,1,inode),map%inv_jacobian(:,:,ilocs), &
                   &        ndime,ndime)
           end do
        end if

        if( khes ) then
           ! Add second cartesian derivatives of the map times 
           ! first derivatives of shape functions
           do inode=1,nnode
              do idime=1,ndime
                 do jdime=1,ndime
                    do kdime=1,ndime
                       wmat2(idime,jdime,inode)=wmat2(idime,jdime,inode) &
                            & + ref%shape_derivatives(kdime,inode,ilocs) &
                            &   * map%d2sdx(kdime,idime,jdime,ilocs)
                    end do
                 end do
              end do
           end do
        end if

        ! Writes the Hessian matrix as an array
        do inode=1,nnode
           do itens = 1, ntens
              wvec1(itens) = phy%hessian(itens,inode,ilocs)
           end do
           call matove(wmat2(1,1,inode),wvec1,ndime,ntens)
        end do

     end do

     call memfree(wmat1,__FILE__,__LINE__)
     call memfree(wmat2,__FILE__,__LINE__)

  end if

end subroutine femap_apply_to_interp


!-----------------------------------------------------------------------
subroutine matove(xmatr,vecto,ndime,ntens)
  !-----------------------------------------------------------------------
  !                                      
  ! This routine stores a symmetric matrix XMATR into a vector VECTO
  !
  !-----------------------------------------------------------------------
  implicit none
  integer(ip), intent(in)  :: ndime,ntens
  real(rp)   , intent(in)  :: xmatr(ndime,ndime)
  real(rp)   , intent(out) :: vecto(ntens)

  if(ndime.eq.2) then
     vecto(1)=xmatr(1,1)
     vecto(3)=xmatr(1,2)
     vecto(2)=xmatr(2,2)
  else
     vecto(1)=xmatr(1,1)
     vecto(4)=xmatr(1,2)
     vecto(2)=xmatr(2,2)
     vecto(5)=xmatr(1,3)
     vecto(6)=xmatr(2,3)
     vecto(3)=xmatr(3,3)
  end if

end subroutine matove
