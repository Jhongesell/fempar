subroutine fe_map_create( this, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(fe_map_t)      , intent(inout) :: this
  type(SB_quadrature_t), intent(in)    :: quadrature
  class(reference_fe_t), intent(in)    :: reference_fe_geometry  

  integer(ip) :: number_dimensions
  integer(ip) :: number_evaluation_points
  
  call this%free()
  number_dimensions        = reference_fe_geometry%number_dimensions
  number_evaluation_points = quadrature%number_evaluation_points

  call reference_fe_geometry%create_interpolation( quadrature, this%interpolation_geometry )

  call memalloc(number_dimensions, &
                number_dimensions, &
                number_evaluation_points, &
                this%jacobian,__FILE__,__LINE__)
  
  call memalloc(number_dimensions, &
                number_dimensions, &
                number_evaluation_points, &
                this%inv_jacobian,__FILE__,__LINE__)
  
  call memalloc(number_evaluation_points, &
                this%det_jacobian,__FILE__,__LINE__)   
  
  call memalloc(number_dimensions, &
                number_evaluation_points, &
                this%coordinates_points,__FILE__,__LINE__)
end subroutine fe_map_create

!==============================================================================
subroutine fe_map_create_from_face( this, quadrature, reference_fe_geometry )
  implicit none
  ! Parameters
  class(fe_map_t)      , intent(inout) :: this
  type(SB_quadrature_t), intent(in)    :: quadrature
  class(reference_fe_t), intent(in)    :: reference_fe_geometry  

  integer(ip) :: number_dimensions, number_face_dimensions
  integer(ip) :: number_evaluation_points
  
  call this%free()
  number_dimensions        = reference_fe_geometry%number_dimensions
  number_evaluation_points = quadrature%number_evaluation_points
  number_face_dimensions   = reference_fe_geometry%number_dimensions - 1

  call reference_fe_geometry%create_face_local_interpolation                                        &
       &                     ( quadrature, this%interpolation_geometry )

  call memalloc(number_face_dimensions, &
                number_dimensions, &
                number_evaluation_points, &
                this%jacobian,__FILE__,__LINE__)
    
  call memalloc(number_evaluation_points, &
                this%det_jacobian,__FILE__,__LINE__)   
  
  call memalloc(number_dimensions, &
                number_evaluation_points, &
                this%coordinates_points,__FILE__,__LINE__)

  call memalloc(number_dimensions, &
                number_evaluation_points, &
                this%outside_normals,__FILE__,__LINE__)
end subroutine fe_map_create_from_face

  !==============================================================================
  subroutine fe_map_update( this, quadrature, cell_coordinates )
    !-----------------------------------------------------------------------
    ! A map obtained from the (usually isoparametric) interpolation of the geometry
    !-----------------------------------------------------------------------
    implicit none    
    class(fe_map_t)      , intent(inout) :: this
    type(SB_quadrature_t), intent(in)    :: quadrature
    real(rp)             , intent(in)    :: cell_coordinates(:,:)
    
    ! Locals
    real(rp), allocatable :: wmat1(:,:,:)
    real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
    real(rp)    :: hnatu
    real(rp)    :: enor0,h_tem
    integer(ip) :: ndime,nnode,nlocs,ntens
    integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
    logical :: khes

    khes = .false.
    if ( allocated( this%interpolation_geometry%hessian ) ) then 
       khes = .true.
    end if

    ndime = this%interpolation_geometry%number_dimensions
    nnode = size(this%interpolation_geometry%shape_functions,1)
    nlocs = this%interpolation_geometry%number_evaluation_points

    do ilocs=1,nlocs
       ! Matmul is not thread safe
       !map%jacob(:,:,ilocs)=matmul(elcod,transpose(int%deriv(:,:,ilocs)))
       this%jacobian(:,:,ilocs)=0.0_rp
       do inode=1,nnode
          do jdime=1,ndime
             do idime=1,ndime
                this%jacobian(idime,jdime,ilocs) = this%jacobian(idime,jdime,ilocs) &
                     + cell_coordinates(idime,inode)*this%interpolation_geometry%shape_derivatives(jdime,inode,ilocs)
             end do
          end do
       end do
       ! J^(-t)
       call invmtx(this%jacobian(:,:,ilocs),this%inv_jacobian(:,:,ilocs),this%det_jacobian(ilocs),ndime)
    end do

    ! Evaluation (Gauss) point coordinates
    do ilocs=1,nlocs
       this%coordinates_points(:,ilocs)=0.0_rp
       do inode=1,nnode
          do idime=1,ndime
             this%coordinates_points(idime,ilocs) = this%coordinates_points(idime,ilocs) &
                  + cell_coordinates(idime,inode)*this%interpolation_geometry%shape_functions(inode,ilocs)
          end do
       end do
    end do

    ! ! Second derivatives of the map
    if( khes ) then
       ntens=this%interpolation_geometry%number_entries_symmetric_tensor
       ! Check that second derivativesof the map have been allocated.
       assert(ndime==size(this%d2sdx,dim=1))
       assert(nlocs==size(this%d2sdx,dim=4))

       call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
       call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
       call memalloc(ntens,wvec1,__FILE__,__LINE__)

       do ilocs=1,nlocs
          ! Transforms the array HESSI to a symmetric matrix WMAT1
          do inode=1,nnode
             do itens = 1, ntens
                wvec1(itens) = this%interpolation_geometry%hessian(itens,inode,ilocs)
             end do
             call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
          end do

          ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for
          ! each node
          do inode=1,nnode
             call btdbma(wmat2(1,1,inode),wmat1(1,1,inode), &
                  &        this%inv_jacobian(:,:,ilocs),ndime,ndime)
          end do

          ! Obtains (d^2 s_k / d x_i d x_j) as the solution of the system
          ! (d x_l / d s_k) (d^2 s_k / d x_i d x_j) 
          !     = - (d^2 x_l / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j), 
          ! for l,i,j = 1,...,NDIME
          do kdime=1,ndime
             do idime=1,ndime
                do jdime=1,ndime
                   this%d2sdx(kdime,idime,jdime,ilocs)=0.0_rp
                   do ldime=1,ndime
                      do inode=1,nnode
                         this%d2sdx(kdime,idime,jdime,ilocs) =    &
                              & this%d2sdx(kdime,idime,jdime,ilocs) &
                              & - this%inv_jacobian(kdime,ldime,ilocs)     &
                              &   * wmat2(idime,jdime,inode) * quadrature%coordinates(ldime,inode)
                      end do
                   end do
                end do
             end do
          end do
       end do
       call memfree(wmat1,__FILE__,__LINE__)
       call memfree(wmat2,__FILE__,__LINE__)
    end if
  end subroutine fe_map_update

 subroutine fe_map_free( this )
    implicit none
    class(fe_map_t), intent(inout) :: this
    if(allocated(this%jacobian)) call memfree(this%jacobian,__FILE__,__LINE__)
    if(allocated(this%inv_jacobian)) call memfree(this%inv_jacobian,__FILE__,__LINE__)
    if(allocated(this%det_jacobian)) call memfree(this%det_jacobian,__FILE__,__LINE__)
    if(allocated(this%d2sdx)) call memfree(this%d2sdx,__FILE__,__LINE__)
    if(allocated(this%coordinates_points)) call memfree(this%coordinates_points,__FILE__,__LINE__)
    if(allocated(this%outside_normals)) call memfree(this%outside_normals,__FILE__,__LINE__)
    call this%interpolation_geometry%free()
  end subroutine fe_map_free
		
  subroutine p_fe_map_allocate( this )
    implicit none
    class(p_fe_map_t), intent(inout) :: this
    allocate(this%p)
  end subroutine p_fe_map_allocate
		
  subroutine p_fe_map_free( this )
    implicit none
    class(p_fe_map_t), intent(inout) :: this
    call this%p%free()
    deallocate(this%p)
  end subroutine p_fe_map_free
  
 subroutine fe_map_print( this )
  implicit none
  class(fe_map_t) :: this
  integer(ip) :: i,j,k
  call this%interpolation_geometry%print()
  write(*,*) '%%%%%%%%%%%%%%%% JACOBIAN: %%%%%%%%%%%%%%%%'
  do i = 1, size(this%jacobian,3)
     write(*,*) '%%%%%%%%%%%%%%%% Gauss point: ',i
     do j = 1, size(this%jacobian,1)
        do k = 1, size(this%jacobian,2)
           write(*,*) '%%%% (',j,',',k,') = ', this%jacobian(j,k,i)
        end do
     end do
  end do
end subroutine fe_map_print

function fe_map_get_det_jacobian ( this, i )
   implicit none
   class(fe_map_t), intent(in) :: this
   integer(ip)    , intent(in) :: i
   real(rp) :: fe_map_get_det_jacobian
   fe_map_get_det_jacobian = this%det_jacobian(i)
end function fe_map_get_det_jacobian

subroutine volume_integrator_create( this, quadrature, reference_fe )
  implicit none
  ! Parameters
  class(SB_volume_integrator_t), intent(inout) :: this 
  type(SB_quadrature_t)        ,  intent(in)   :: quadrature
  class(reference_fe_t), target,  intent(in)   :: reference_fe  

  call this%free()
  
  this%number_evaluation_points = quadrature%number_evaluation_points
  this%number_shape_functions   = reference_fe%number_nodes
  this%reference_fe             => reference_fe
  
  call reference_fe%create_interpolation( quadrature, this%interpolation )
  call this%interpolation_o_map%copy(source_interpolation = this%interpolation)
end subroutine volume_integrator_create

subroutine volume_integrator_update(this, reference_fe, fe_map)
  implicit none
  ! Parameters
  class(SB_volume_integrator_t), intent(inout) :: this
  class(reference_fe_t)        , intent(in)    :: reference_fe
  type(fe_map_t)               , intent(in)    :: fe_map
  call femap_apply_to_interp( fe_map, this%interpolation, this%interpolation_o_map )
end subroutine volume_integrator_update

subroutine volume_integrator_free( this )
  implicit none
  class(SB_volume_integrator_t), intent(inout) :: this
  call this%interpolation%free()
  call this%interpolation_o_map%free()
  nullify(this%reference_fe)
  this%number_evaluation_points = 0
  this%number_shape_functions = 0
end subroutine volume_integrator_free

subroutine p_volume_integrator_allocate( this )
  implicit none
  class(SB_p_volume_integrator_t), intent(inout) :: this
		allocate(this%p)
end subroutine p_volume_integrator_allocate

subroutine p_volume_integrator_free( this )
  implicit none
  class(SB_p_volume_integrator_t), intent(inout) :: this
  call this%p%free()
		deallocate(this%p)
end subroutine p_volume_integrator_free
!==================================================================================================

subroutine volume_integrator_print( this )
  implicit none
  class(SB_volume_integrator_t), intent(in) :: this
  write(*,*) 'PRINT VOLUME INTEGRATOR: '
  write(*,*) '%%%%%%%%%%%%%%%% interpolation: %%%%%%%%%%%%%%%%'
  call this%interpolation%print()
  write(*,*) '%%%%%%%%%%%%%%%% interpolation_o_map: %%%%%%%%%%%%%%%%'
  call this%interpolation_o_map%print()
end subroutine volume_integrator_print

subroutine volume_integrator_get_value_scalar (this, ishape, qpoint, scalar_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  real(rp)                     , intent(out) :: scalar_field
  assert( this%reference_fe%field_type == field_type_scalar )
  call this%reference_fe%get_value(this%interpolation_o_map,ishape,qpoint,scalar_field)
end subroutine volume_integrator_get_value_scalar

subroutine volume_integrator_get_value_vector (this, ishape, qpoint, vector_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_vector )
  call this%reference_fe%get_value(this%interpolation_o_map,ishape,qpoint,vector_field)
end subroutine volume_integrator_get_value_vector

subroutine volume_integrator_get_value_tensor (this, ishape, qpoint, tensor_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(tensor_field_t)         , intent(out)   :: tensor_field
  assert( this%reference_fe%field_type == field_type_tensor )
end subroutine volume_integrator_get_value_tensor

subroutine volume_integrator_get_value_symmetric_tensor (this, ishape, qpoint, symmetric_tensor_field)
  implicit none
  class(SB_volume_integrator_t)  , intent(in)    :: this
  integer(ip)                    , intent(in)    :: ishape
  integer(ip)                    , intent(in)    :: qpoint
  type(symmetric_tensor_field_t) , intent(out)   :: symmetric_tensor_field
  assert( this%reference_fe%field_type == field_type_tensor )
end subroutine volume_integrator_get_value_symmetric_tensor

subroutine volume_integrator_get_gradient_scalar (this, ishape, qpoint, vector_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_scalar )
  call this%reference_fe%get_gradient(this%interpolation_o_map,ishape,qpoint,vector_field)
end subroutine volume_integrator_get_gradient_scalar

subroutine volume_integrator_get_gradient_vector (this, ishape, qpoint, tensor_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(tensor_field_t)         , intent(out)   :: tensor_field
  assert( this%reference_fe%field_type == field_type_vector )
  call this%reference_fe%get_gradient(this%interpolation_o_map,ishape,qpoint,tensor_field)
end subroutine volume_integrator_get_gradient_vector

subroutine volume_integrator_get_symmetric_gradient_vector (this, ishape, qpoint, tensor_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: tensor_field
  assert( this%reference_fe%field_type == field_type_vector )  
end subroutine volume_integrator_get_symmetric_gradient_vector

subroutine volume_integrator_get_divergence_vector (this, ishape, qpoint, scalar_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  real(rp)                     , intent(out)   :: scalar_field
  assert( this%reference_fe%field_type == field_type_vector ) 
end subroutine volume_integrator_get_divergence_vector

subroutine volume_integrator_get_divergence_tensor (this, ishape, qpoint, vector_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_tensor .or. this%reference_fe%field_type == field_type_symmetric_tensor  ) 
end subroutine volume_integrator_get_divergence_tensor

subroutine volume_integrator_get_curl_vector (this, ishape, qpoint, vector_field)
  implicit none
  class(SB_volume_integrator_t), intent(in)    :: this
  integer(ip)                  , intent(in)    :: ishape
  integer(ip)                  , intent(in)    :: qpoint
  type(vector_field_t)         , intent(out)   :: vector_field
  assert( this%reference_fe%field_type == field_type_vector ) 
end subroutine volume_integrator_get_curl_vector


  subroutine invmtx(a,b,deter,nsize)
    !-----------------------------------------------------------------------
    !
    ! This routine inverts a square matrix A -> Mat(nsize,nsize). The
    ! inverse is stored in B. Its determinant is DETER
    !    
    !-----------------------------------------------------------------------
    implicit none
    integer(ip), intent(in)  :: nsize
    real(rp),    intent(in)  :: a(nsize,nsize)
    real(rp),    intent(out) :: b(nsize,nsize),deter
    integer(ip)              :: isize,jsize
    real(rp)                 :: denom,t1,t2,t3,t4

    select case (nsize)

    case(1)
       deter=a(1,1)
       if(deter==0.0_rp) return
       b(1,1) = 1.0_rp/a(1,1)

    case(2)
       deter=a(1,1)*a(2,2)-a(2,1)*a(1,2)
       if(deter/=0.0_rp) then
          denom=1.0_rp/deter
          b(1,1) = a(2,2)*denom
          b(2,2) = a(1,1)*denom
          b(2,1) =-a(2,1)*denom
          b(1,2) =-a(1,2)*denom 
       end if

    case(3)
       t1  = a(2,2)*a(3,3) - a(3,2)*a(2,3)
       t2  =-a(2,1)*a(3,3) + a(3,1)*a(2,3)
       t3  = a(2,1)*a(3,2) - a(3,1)*a(2,2)
       deter = a(1,1)*t1 + a(1,2)*t2 + a(1,3)*t3
       if(deter==0.0_rp) return
       denom = 1.0_rp/deter
       b(1,1) = t1*denom
       b(2,1) = t2*denom
       b(3,1) = t3*denom
       b(2,2) = ( a(1,1)*a(3,3) - a(3,1)*a(1,3))*denom
       b(3,2) = (-a(1,1)*a(3,2) + a(1,2)*a(3,1))*denom
       b(3,3) = ( a(1,1)*a(2,2) - a(2,1)*a(1,2))*denom
       b(1,2) = (-a(1,2)*a(3,3) + a(3,2)*a(1,3))*denom
       b(1,3) = ( a(1,2)*a(2,3) - a(2,2)*a(1,3))*denom
       b(2,3) = (-a(1,1)*a(2,3) + a(2,1)*a(1,3))*denom

    case(4)
       t1= a(2,2)*a(3,3)*a(4,4) + a(2,3)*a(3,4)*a(4,2)&
            + a(2,4)*a(3,2)*a(4,3) - a(2,3)*a(3,2)*a(4,4)&
            - a(2,2)*a(3,4)*a(4,3) - a(2,4)*a(3,3)*a(4,2)
       t2=-a(2,1)*a(3,3)*a(4,4) - a(2,3)*a(3,4)*a(4,1)&
            - a(2,4)*a(3,1)*a(4,3) + a(2,4)*a(3,3)*a(4,1)&
            + a(2,3)*a(3,1)*a(4,4) + a(2,1)*a(3,4)*a(4,3)
       t3=+a(2,1)*a(3,2)*a(4,4) + a(2,2)*a(3,4)*a(4,1)&
            + a(2,4)*a(3,1)*a(4,2) - a(2,4)*a(3,2)*a(4,1)&
            - a(2,2)*a(3,1)*a(4,4) - a(2,1)*a(3,4)*a(4,2)
       t4=-a(2,1)*a(3,2)*a(4,3) - a(2,2)*a(3,3)*a(4,1)&
            - a(2,3)*a(3,1)*a(4,2) + a(2,3)*a(3,2)*a(4,1)&
            + a(2,2)*a(3,1)*a(4,3) + a(2,1)*a(3,3)*a(4,2)
       deter= a(1,1)*t1 + a(1,2)*t2 + a(1,3)*t3 + a(1,4)*t4
       if(deter==0.0_rp) return
       denom=1.0_rp/deter
       b(1,1) = t1*denom
       b(2,1) = t2*denom
       b(3,1) = t3*denom
       b(4,1) = t4*denom
       b(1,2) =(- a(1,2)*a(3,3)*a(4,4) - a(1,3)*a(3,4)*a(4,2)&
            - a(1,4)*a(3,2)*a(4,3) + a(1,3)*a(3,2)*a(4,4)&
            + a(1,2)*a(3,4)*a(4,3) + a(1,4)*a(3,3)*a(4,2))*denom
       b(2,2) =(  a(1,1)*a(3,3)*a(4,4) + a(1,3)*a(3,4)*a(4,1)&
            + a(1,4)*a(3,1)*a(4,3) - a(1,4)*a(3,3)*a(4,1)&
            - a(1,3)*a(3,1)*a(4,4) - a(1,1)*a(3,4)*a(4,3))*denom
       b(3,2) =(- a(1,1)*a(3,2)*a(4,4) - a(1,2)*a(3,4)*a(4,1)&
            - a(1,4)*a(3,1)*a(4,2) + a(1,4)*a(3,2)*a(4,1)&
            + a(1,2)*a(3,1)*a(4,4) + a(1,1)*a(3,4)*a(4,2))*denom
       b(4,2) =(  a(1,1)*a(3,2)*a(4,3) + a(1,2)*a(3,3)*a(4,1)&
            + a(1,3)*a(3,1)*a(4,2) - a(1,3)*a(3,2)*a(4,1)&
            - a(1,2)*a(3,1)*a(4,3) - a(1,1)*a(3,3)*a(4,2))*denom
       b(1,3) =(  a(1,2)*a(2,3)*a(4,4) + a(1,3)*a(2,4)*a(4,2)&
            + a(1,4)*a(2,2)*a(4,3) - a(1,3)*a(2,2)*a(4,4)&
            - a(1,2)*a(2,4)*a(4,3) - a(1,4)*a(2,3)*a(4,2))*denom
       b(2,3) =(- a(1,1)*a(2,3)*a(4,4) - a(1,3)*a(2,4)*a(4,1)&
            - a(1,4)*a(2,1)*a(4,3) + a(1,4)*a(2,3)*a(4,1)&
            + a(1,3)*a(2,1)*a(4,4) + a(1,1)*a(2,4)*a(4,3))*denom
       b(3,3) =(  a(1,1)*a(2,2)*a(4,4) + a(1,2)*a(2,4)*a(4,1)&
            + a(1,4)*a(2,1)*a(4,2) - a(1,4)*a(2,2)*a(4,1)&
            - a(1,2)*a(2,1)*a(4,4) - a(1,1)*a(2,4)*a(4,2))*denom
       b(4,3) =(- a(1,1)*a(2,2)*a(4,3) - a(1,2)*a(2,3)*a(4,1)&
            - a(1,3)*a(2,1)*a(4,2) + a(1,3)*a(2,2)*a(4,1)&
            + a(1,2)*a(2,1)*a(4,3) + a(1,1)*a(2,3)*a(4,2))*denom
       b(1,4) =(- a(1,2)*a(2,3)*a(3,4) - a(1,3)*a(2,4)*a(3,2)&
            - a(1,4)*a(2,2)*a(3,3) + a(1,4)*a(2,3)*a(3,2)&
            + a(1,3)*a(2,2)*a(3,4) + a(1,2)*a(2,4)*a(3,3))*denom
       b(2,4) =(  a(1,1)*a(2,3)*a(3,4) + a(1,3)*a(2,4)*a(3,1)&
            + a(1,4)*a(2,1)*a(3,3) - a(1,4)*a(2,3)*a(3,1)&
            - a(1,3)*a(2,1)*a(3,4) - a(1,1)*a(2,4)*a(3,3))*denom
       b(3,4) =(- a(1,1)*a(2,2)*a(3,4) - a(1,2)*a(2,4)*a(3,1)&
            - a(1,4)*a(2,1)*a(3,2) + a(1,4)*a(2,2)*a(3,1)&
            + a(1,2)*a(2,1)*a(3,4) + a(1,1)*a(2,4)*a(3,2))*denom
       b(4,4) =(  a(1,1)*a(2,2)*a(3,3) + a(1,2)*a(2,3)*a(3,1)&
            + a(1,3)*a(2,1)*a(3,2) - a(1,3)*a(2,2)*a(3,1)&
            - a(1,2)*a(2,1)*a(3,3) - a(1,1)*a(2,3)*a(3,2))*denom

    case default
       b=a
       call invert(b,nsize,nsize)
    end select

  end subroutine invmtx

  !-----------------------------------------------------------------------
  subroutine invert(a,nmax,ndm)
    !-----------------------------------------------------------------------
    !
    ! This routine performs the inversion of a ndm*ndm square matrix 
    ! or just part of it (nmax*nmax)
    !
    !-----------------------------------------------------------------------
    implicit none
    integer(ip), intent(in)    :: ndm,nmax
    real(rp),    intent(inout) :: a(ndm,ndm)
    real(rp)                   :: d
    integer(ip)                :: n,j,i

    do n = 1,nmax
       d = a(n,n)
       do j = 1,nmax
          a(n,j) = -a(n,j)/d
       end do
       do i = 1,nmax
          if(n/=i) then
             do j = 1,nmax
                if(n/=j) a(i,j) = a(i,j) +a(i,n)*a(n,j)
             end do
          end if
          a(i,n) = a(i,n)/d
       end do
       a(n,n) = 1.0_rp/d
    end do

  end subroutine invert


  !-----------------------------------------------------------------------
  subroutine vetoma(vecto,xmatr,ndime,ntens)
    !-----------------------------------------------------------------------
    !                                      
    ! This routine stores a vector VECTO as a symmetric matrix XMATR
    !
    !-----------------------------------------------------------------------
    implicit none
    integer(ip), intent(in)  :: ndime,ntens
    real(rp)   , intent(in)  :: vecto(ntens)
    real(rp)   , intent(out) :: xmatr(ndime,ndime)

    if(ndime.eq.2) then
       xmatr(1,1)=vecto(1)
       xmatr(1,2)=vecto(3)
       xmatr(2,1)=vecto(3)
       xmatr(2,2)=vecto(2)
    else
       xmatr(1,1)=vecto(1)
       xmatr(1,2)=vecto(4)
       xmatr(1,3)=vecto(5)
       xmatr(2,1)=vecto(4)
       xmatr(2,2)=vecto(2)
       xmatr(2,3)=vecto(6)
       xmatr(3,1)=vecto(5)
       xmatr(3,2)=vecto(6)
       xmatr(3,3)=vecto(3)
    end if

  end subroutine vetoma

  !-----------------------------------------------------------------------
  subroutine btdbma(aglob,aloca,bmatr,n1,n2)
    !-----------------------------------------------------------------------
    !                                      
    ! This routine computes Ag = Bt Al B  when Ag and Al are stored as full
    ! matrices (Ag := aglob, Al := aloca, B := bmatr). The dimensions are
    ! Al -> Mat(n1,n1), Ag -> Mat(n2,n2), B -> Mat(n2,n1) 
    !
    !-----------------------------------------------------------------------
    implicit none
    integer(ip), intent(in)  :: n1,n2
    real(rp)   , intent(in)  :: aloca(n1,n1), bmatr(n1,n2)
    real(rp)   , intent(out) :: aglob(n2,n2)
    integer(ip)              :: i,j,k,l

    do i=1,n2
       do j=1,n2
          aglob(i,j)=0.0
          do k=1,n1
             do l=1,n1
                aglob(i,j)=aglob(i,j)+bmatr(k,i)*aloca(k,l)*bmatr(l,j)
             end do
          end do
       end do
    end do

  end subroutine btdbma

  !==============================================================================
  !
  !==============================================================================
  subroutine femap_apply_to_interp(map,ref,phy)
    implicit none
    type(fe_map_t)          , intent(in)    :: map
    type(SB_interpolation_t), intent(in)    :: ref
    type(SB_interpolation_t), intent(inout) :: phy
    real(rp), allocatable :: wmat1(:,:,:)
    real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
    integer(ip) :: ndime,nnode,nlocs,ntens
    integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
    logical :: khes


    khes = .false.
    if ( allocated( ref%hessian ) ) then 
       khes = .true.
    end if

    ndime = ref%number_dimensions
    ntens = ref%number_entries_symmetric_tensor
    nlocs = ref%number_evaluation_points
    !nnode = ref%number_shape_functions
    nnode = size(ref%shape_functions,1)

    ! Shape functions do not change
    ! phy%shape = ref%shape ! SB. not needed

    ! First derivatives do
    !if(phy%kder==1) then
    phy%shape_derivatives=0.0_rp
    do ilocs=1,phy%number_evaluation_points
       do inode=1,size(phy%shape_functions,1)!phy%number_shape_functions
          do idime=1,ndime
             do jdime=1,ndime
                phy%shape_derivatives(idime,inode,ilocs) = phy%shape_derivatives(idime,inode,ilocs) &
                     + map%inv_jacobian(jdime,idime,ilocs)*ref%shape_derivatives(jdime,inode,ilocs)
             end do
          end do
       end do
    end do
    !end if

    ! Second derivatives are
    !
    !    d^2 N / d x_i d x_j
    !       = (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j)
    !       + (d N / d s_k) (d^2 s_k / d x_i d x_j) 
    !
    if( khes ) then
       call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
       call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
       do ilocs=1,nlocs
          if( khes ) then
             ! Transforms the array HESSI to a symmetric matrix WMAT1
             do inode=1,nnode
                do itens = 1, ntens
                   wvec1(itens) = ref%hessian(itens,inode,ilocs)
                end do
                call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
             end do
             ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for each node
             do inode=1,nnode
                call btdbma(wmat2(1,1,inode),wmat1(1,1,inode),map%inv_jacobian(:,:,ilocs), &
                     &        ndime,ndime)
             end do
          end if
          if( khes ) then
             ! Add second cartesian derivatives of the map times 
             ! first derivatives of shape functions
             do inode=1,nnode
                do idime=1,ndime
                   do jdime=1,ndime
                      do kdime=1,ndime
                         wmat2(idime,jdime,inode)=wmat2(idime,jdime,inode) &
                              & + ref%shape_derivatives(kdime,inode,ilocs) &
                              &   * map%d2sdx(kdime,idime,jdime,ilocs)
                      end do
                   end do
                end do
             end do
          end if

          ! Writes the Hessian matrix as an array
          do inode=1,nnode
             do itens = 1, ntens
                wvec1(itens) = phy%hessian(itens,inode,ilocs)
             end do
             call matove(wmat2(1,1,inode),wvec1,ndime,ntens)
          end do
       end do
       call memfree(wmat1,__FILE__,__LINE__)
       call memfree(wmat2,__FILE__,__LINE__)
    end if
  end subroutine femap_apply_to_interp


  !-----------------------------------------------------------------------
  subroutine matove(xmatr,vecto,ndime,ntens)
    !-----------------------------------------------------------------------
    !                                      
    ! This routine stores a symmetric matrix XMATR into a vector VECTO
    !
    !-----------------------------------------------------------------------
    implicit none
    integer(ip), intent(in)  :: ndime,ntens
    real(rp)   , intent(in)  :: xmatr(ndime,ndime)
    real(rp)   , intent(out) :: vecto(ntens)

    if(ndime.eq.2) then
       vecto(1)=xmatr(1,1)
       vecto(3)=xmatr(1,2)
       vecto(2)=xmatr(2,2)
    else
       vecto(1)=xmatr(1,1)
       vecto(4)=xmatr(1,2)
       vecto(2)=xmatr(2,2)
       vecto(5)=xmatr(1,3)
       vecto(6)=xmatr(2,3)
       vecto(3)=xmatr(3,3)
    end if

  end subroutine matove
