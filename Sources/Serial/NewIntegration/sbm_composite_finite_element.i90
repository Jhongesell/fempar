

subroutine get_elem2dof( this, elem2dof, n )
  implicit none
  class(SB_simple_finite_element_t) :: this
  type(p_array_ip1_t), pointer :: elem2dof(:)
  integer(ip) :: n
  
  do i = 1, n
     elem2dof(i)%p => this%field_single_fe(i)%elem2dof
  end do
  
end subroutine get_elem2dof

!  procedure :: create => fe_create
!  procedure :: free   => fe_free
!  procedure :: print  => fe_print

!  procedure :: get_reference_fe => fe_get_reference_fe
subroutine get_volume_integrator => fe_get_volume_integrator

!  The only thing is that it will provide an array of volume_integrator

  do i = 1, number_fe_spaces
     vol(i) => this%field_fe(i)%p%volume_integrator     
  end do
end subroutine get_volume_integrator

subroutine get_elem2dof

  ! Provide the pointers to all fe_fields  

end subroutine get_elem2dof

IDEM get_bc_code => fe_get_bc_code

IDEM get_bc_value => fe_get_bc_value

subroutine get_number_nodes 

  do i = 1, number_fe_spaces
     nnode = nnode + this%field_fe(i)%p%get_number_nodes()
  end do

end subroutine get_number_nodes


* Problem (?): We need that both finite_element_t and composite_finite_element_t share the same 
  prodedures, and both must extend an abstract finite element with all these procedures. As
  a result, the one-physics fe must provide an array of index 1 for volume integrators, 
  el2dof, bcs, etc.

