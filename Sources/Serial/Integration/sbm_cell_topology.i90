!=================================================================================================
!     GEOMETRY_TREE_T TBPS
!=================================================================================================

!=================================================================================================
! This subroutine creates the n-face tree, where the geometrical n-faces are defined by 2*DIM bits.
! The "first" (from the right) DIM bits provide the "anchor node", whereas the "second" set of DIM
! bits provides the type of n-face. For every component, if we have 1 it means that the y-component
! can freely change. When = 0 it is constrained. However, it does not mean that it is constant (it
! is only for hyper-cubes). Think about the face of the tetrahedron that is not aligned with any 
! axes.
subroutine polytope_tree_create( this, number_dimensions, topology )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: number_dimensions
  integer(ip)        , intent(in)    :: topology
  integer(ip) :: c, i, d, j
  integer(ip), allocatable :: aux_array(:)
  call this%free()
  this%topology = topology
  this%number_dimensions = number_dimensions
  !     Compute number of n-face (all dimensions) for the hypercube
  !     c = (2**dim-1)*2**dim max id n-face
  c = 0
  do i = 0,number_dimensions
     c = c + 2**(number_dimensions-i)*(get_binomial_coefficient(number_dimensions,i))
  end do
  !     Pre-allocate this%n_faces_array with c (exact for hypercube)
  call memalloc ( c, this%n_face_array, __FILE__, __LINE__ )
  !     Pre-allocate the ijk_to_index. Maximum ijk_to_index is [111000]+1 for dim = 3
  !     = ISHFT(ISHFT(1_ip,dim)-1,dim) = (2**dim-1)*2**dim
  call memalloc ( ISHFT(ISHFT(1_ip,number_dimensions)-1,number_dimensions)+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  this%ijk_to_index = 0
  this%number_n_faces = 0
  !     Call the recursive fill_tree procedure starting with the volume n-face
  call this%fill_cell_tree( ISHFT(ISHFT(1_ip,number_dimensions)-1, number_dimensions ) ) ! Root n-face (volume)
  !     Re-allocate the n-faces_array to the exact number of n-faces
  call memrealloc ( this%number_n_faces, this%n_face_array, __FILE__, __LINE__ )
  !     Sort n-faces based on 1) n-face_dimension 2) its bit-based index
  call memalloc ( this%number_n_faces, aux_array, __FILE__, __LINE__ )
  aux_array = this%n_face_array
  c = 1
  d = 1
  this%n_face_array = 0
  do i = 0,number_dimensions
     do j = 1,this%number_n_faces
        if ( n_face_dimension( aux_array(j), this%number_dimensions ) == i ) then
           this%n_face_array(d) = aux_array(j)
           d = d+1
        end if
     end do    
     call sort( d-c, this%n_face_array(c:d-1) ) 
     c = d
  end do
  call memfree ( aux_array, __FILE__, __LINE__ )
  !     Create the bit-index to consecutive index array (0 for bit-indexes wo/ associated n-face)
  do i =1,this%number_n_faces
     this%ijk_to_index( this%n_face_array(i) ) = i
  end do
end subroutine polytope_tree_create

!==================================================================================================
! This recursive subroutine fills ALL the sub-n-faces (including the n-face itself). From dimension
! DIM to 0.
recursive subroutine fill_cell_tree( this, root )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: root
  type(n_face_iterator_t) :: children_iterator
  integer(ip)               :: children  
  ! If the n-face not already inserted (use ijk_to_index as touch table)

  if ( this%ijk_to_index(root) == 0 ) then 
     ! Increase one position current n-face in polytope_tree
     this%number_n_faces = this%number_n_faces + 1
     ! Put root as new n-face in polytope_tree
     this%n_face_array(this%number_n_faces) = root
     ! Mark root as touched (already inserted)
     this%ijk_to_index(root) = 1
     ! Create iterator over children of root n-face
     children_iterator = this%create_children_iterator(root)
     ! Loop over children
     do while (.not. children_iterator%has_finished() )
        children = children_iterator%current_ijk()
        !write(*,*) 'current children: '
        !write(*,'(B32)') children
        ! Put children of child (recursive call)
        call this%fill_cell_tree( children )
        ! Move to the next child
        call children_iterator%next()
     end do
  end if
end subroutine fill_cell_tree

!=================================================================================================
subroutine polytope_tree_free( this )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  if (allocated(this%n_face_array)) call memfree ( this%n_face_array, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine polytope_tree_free

!=================================================================================================
function polytope_tree_create_children_iterator(this, parent)
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: parent
  type(n_face_iterator_t) :: polytope_tree_create_children_iterator
  call polytope_tree_create_children_iterator%create(this, parent)
end function polytope_tree_create_children_iterator

!=================================================================================================
function polytope_tree_get_number_n_faces(this) 
       implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)                          :: polytope_tree_get_number_n_faces
  polytope_tree_get_number_n_faces = this%number_n_faces     
end function polytope_tree_get_number_n_faces

!=================================================================================================
function polytope_tree_get_n_face(this, n_face_index) 
       implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: n_face_index
  integer(ip)                          :: polytope_tree_get_n_face
  polytope_tree_get_n_face = this%n_face_array(n_face_index)     
end function polytope_tree_get_n_face

!=================================================================================================
function polytope_tree_get_n_face_dimension(this, n_face_index) 
       implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: n_face_index
  integer(ip)                          :: polytope_tree_get_n_face_dimension
  polytope_tree_get_n_face_dimension = n_face_dimension( this%n_face_array(n_face_index), this%number_dimensions )     
end function polytope_tree_get_n_face_dimension

!=================================================================================================
!     NODE_ARRAY_T TBPS
!=================================================================================================

!=================================================================================================
subroutine node_array_create ( this, polytope_tree, order )
  implicit none
  class(node_array_t)        , intent(inout) :: this
  type(polytope_tree_t), target, intent(in)    :: polytope_tree
  integer(ip)                , intent(in)    :: order
  call this%free()
  this%polytope_tree => polytope_tree
  this%order = order
  call this%fill()
end subroutine node_array_create

!=================================================================================================
subroutine node_array_fill ( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  type(node_iterator_t) :: node_iterator 
  integer(ip) :: i, c, m_ijk, current
  current = ISHFT(ISHFT(1_ip,this%polytope_tree%number_dimensions)-1,this%polytope_tree%number_dimensions)
  node_iterator = this%create_node_iterator( current, own_boundary = .true. )
  call node_iterator%init()
  c = 0
  m_ijk = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     m_ijk = max( m_ijk, node_iterator%current_ijk() )
     call node_iterator%next()       
  end do
  this%number_nodes = c
  call memalloc ( c, this%node_array, __FILE__, __LINE__ )
  call memalloc ( m_ijk+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  call node_iterator%init()
  c = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     this%node_array(c) =  node_iterator%current_ijk()
     call node_iterator%next()         
  end do
  ! Sort nodes based on its bit-based index
  call sort( c, this%node_array )    
  write(*,*) 'node_array',this%node_array
  do i =1,c
     write(*,*) 'n-face(',i,') :'
     write(*,'(B32)') this%node_array(i)
     this%ijk_to_index( this%node_array(i) ) = i
  end do
end subroutine node_array_fill

!=================================================================================================
subroutine node_array_print( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  integer(ip) :: i
  write(*,*) '************NODE ARRAY***********'
  write(*,*) 'number of nodes = ', this%number_nodes
  write(*,*) 'cell_tree_topology = '
  write(*,'(B32)') this%polytope_tree%topology
  write(*,*) 'nodes'
  do i = 1, this%number_nodes
     write(*,*) 'NODE: ',this%node_array(i)
     write(*,'(B32)') this%node_array(i)
  end do
  write(*,*) 'ijk_to_index: ',this%ijk_to_index
end subroutine node_array_print

!=================================================================================================
subroutine node_array_free( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  if (allocated(this%node_array)) call memfree ( this%node_array, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine node_array_free

!=================================================================================================
function  node_array_get_number_nodes(this) 
       implicit none
  class(node_array_t), intent(in) :: this
  integer(ip)                          :: node_array_get_number_nodes
  node_array_get_number_nodes = this%number_nodes
end function  node_array_get_number_nodes

!=================================================================================================
!     CHILDREN_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
subroutine n_face_iterator_create ( this, polytope_tree, parent )
  implicit none
  class(n_face_iterator_t)        , intent(inout) :: this
  type(polytope_tree_t)       , target, intent(in)    :: polytope_tree
  integer(ip)                       , intent(in)    :: parent
  !call this%free()
  this%polytope_tree => polytope_tree
  this%parent = parent
  call this%init()
end subroutine n_face_iterator_create

!=================================================================================================
subroutine n_face_iterator_init ( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  this%component = 0
  this%coordinate = 0
  if ( .not. this%is_admissible() ) then
     call this%next()
  end if
end subroutine n_face_iterator_init

!=================================================================================================
subroutine n_face_iterator_print( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  write(*,*) '***CHILDREN_ITERATOR ***'
  write(*,*) 'parent: '
  write(*,'(B32)') this%parent
  write(*,*) 'component: ',this%component
  write(*,*) 'coordinate: ',this%coordinate

end subroutine n_face_iterator_print

!=================================================================================================
recursive subroutine n_face_iterator_next ( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  if ( this%has_finished() ) return 
  if ( this%coordinate == 1 ) then
     this%component = this%component + 1
     this%coordinate = 0
  else
     this%coordinate = 1
  end if
  if ( .not. this%is_admissible() ) then
     call this%next()
  else 
  end if
end subroutine n_face_iterator_next

!=================================================================================================
function n_face_iterator_has_finished ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  logical :: n_face_iterator_has_finished
  n_face_iterator_has_finished = ( this%component >= this%polytope_tree%number_dimensions )
end function n_face_iterator_has_finished

!=================================================================================================
function n_face_iterator_current_ijk ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  integer(ip) :: n_face_iterator_current_ijk, j
  assert ( .not. this%has_finished() )
  n_face_iterator_current_ijk = this%parent
  n_face_iterator_current_ijk = IBCLR( n_face_iterator_current_ijk, this%polytope_tree%number_dimensions + this%component )
  if ( this%coordinate == 1 ) then
     if ( IBITS( this%polytope_tree%topology, this%component, 1 )  == 0 ) then
        do j = 0,this%component-1
           n_face_iterator_current_ijk = IBCLR( n_face_iterator_current_ijk, j )
        end do
     end if
     n_face_iterator_current_ijk = IBSET( n_face_iterator_current_ijk, this%component )
  end if
end function n_face_iterator_current_ijk

!=================================================================================================
function n_face_iterator_current ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  integer(ip) :: n_face_iterator_current
  n_face_iterator_current = this%polytope_tree%ijk_to_index( this%current_ijk() )
end function n_face_iterator_current

!=================================================================================================
function n_face_iterator_is_admissible( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  logical                          :: n_face_iterator_is_admissible
  n_face_iterator_is_admissible = .false. 
  if ( IBITS( this%parent, this%polytope_tree%number_dimensions + this%component, 1 ) == 1) then
     if ( IBITS( this%polytope_tree%topology, this%component, 1 ) == 1 ) then
        n_face_iterator_is_admissible = .true.
     else if ( this%coordinate == 0 .or. this%component == 0 & 
          & .or. IBITS( this%parent, this%polytope_tree%number_dimensions, this%component ) == 0 ) then  
        n_face_iterator_is_admissible = .true.
     end if
  end if
end function n_face_iterator_is_admissible

!=================================================================================================
!     NODE_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
function node_array_create_node_iterator( node_array, parent, own_boundary)
  implicit none
  class(node_array_t) , intent(in) :: node_array
  integer(ip)         , intent(in) :: parent
  logical             , intent(in) :: own_boundary 
  type(node_iterator_t) :: node_array_create_node_iterator
  call node_array_create_node_iterator%create( node_array, parent, own_boundary )
end function node_array_create_node_iterator

!=================================================================================================
subroutine node_iterator_create ( this, node_array, n_face, own_boundary )
  implicit none
  class(node_iterator_t)            , intent(inout) :: this
  type(node_array_t), target               , intent(in)    :: node_array
  integer(ip)                       , intent(in)    :: n_face
  logical                           , intent(in)    :: own_boundary
  integer(ip) :: c, i
  this%node_array => node_array
  this%topology = 0
  this%n_face = n_face
  this%own_boundary = own_boundary
  if ( own_boundary) then
     this%max_value = node_array%order
     this%min_value = 0
  else
     this%max_value = node_array%order-1
     this%min_value = 1
  end if
  ! Restrict the topology of the polytope_tree to the current n-face
  c = 0
  do i = 0, node_array%polytope_tree%number_dimensions-1
     if ( IBITS( this%n_face, node_array%polytope_tree%number_dimensions+i, 1 ) == 1 ) then 
        if ( IBITS( this%node_array%polytope_tree%topology, i, 1 ) == 1 ) this%topology = IBSET( this%topology, c )
        c = c+1
     end if
  end do
  call this%init()
end subroutine node_iterator_create

!=================================================================================================
subroutine node_iterator_init ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: c, i
  this%displacement = 0
  this%coordinate = 0
  this%overflow = .true.
  !if ( n-face_dimension(this%n-face, this%node_array%polytope_tree%number_dimensions) > 0 .or. this%own_boundary ) 
  this%overflow = .false.
  c = 0
  do i = 0, this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS( this%n_face, this%node_array%polytope_tree%number_dimensions+i, 1 ) == 0 ) then  ! if is fixed component in n-face
        if ( IBITS( this%n_face, i, 1 ) == 0 ) then   ! if coordinate of anchor node == 0
           this%coordinate(i) = 0                     ! fixed coordinate = min value
        else
           this%coordinate(i) = this%node_array%order ! fixed coordinate = max value   
        end if
     else 
        this%displacement(c) = this%min_value
        c = c+1
     end if
  end do
  if ( n_face_dimension(this%n_face, this%node_array%polytope_tree%number_dimensions) > 0 ) then
     this%displacement(0) = this%displacement(0)-1
     call this%next()
  end if
end subroutine node_iterator_init

!=================================================================================================
subroutine node_iterator_print( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  write(*,*) '***NODE_ITERATOR ***'
  write(*,*) 'n-face: '
  write(*,'(B32)') this%n_face
  write(*,*) 'displacement: ',this%displacement
end subroutine node_iterator_print

!=================================================================================================
subroutine node_iterator_next ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: comp, end_comp, i
  if ( this%has_finished() ) return 
  comp = 0 
  end_comp = n_face_dimension(this%n_face, this%node_array%polytope_tree%number_dimensions)-1
  this%overflow = .true.
  do while( comp <= end_comp)
     if ( this%overflow ) then 
        this%displacement(comp) = this%displacement(comp)+1
        if ( this%in_bound(comp, end_comp) ) then
           this%overflow = .false.
           do i = comp-1,0,-1
              if ( .not. this%in_bound( i, end_comp ) ) then
                 this%overflow = .true.
              end if
           end do
           exit
        else 
           this%displacement(comp) = this%min_value
        end if
     end if
     comp = comp+1
  end do
end subroutine node_iterator_next

!=================================================================================================
function node_iterator_in_bound( this, comp, end_comp )
  implicit none
  class(node_iterator_t), intent(in) :: this
  integer(ip)           , intent(in) :: comp, end_comp
  logical :: node_iterator_in_bound
  integer(ip) :: bound, i
  node_iterator_in_bound = .true.
  bound = this%max_value
  do i = comp+1,end_comp
     if ( IBITS( this%topology, i, 1 ) == 0 ) then
        bound = bound - this%displacement(i)
     end if
  end do
  if ( this%displacement(comp) > bound ) node_iterator_in_bound = .false.
end function node_iterator_in_bound

!=================================================================================================
function node_iterator_has_finished ( this )
  implicit none
  class(node_iterator_t), intent(in) :: this
  logical :: node_iterator_has_finished
  node_iterator_has_finished = this%overflow
end function node_iterator_has_finished

!=================================================================================================
function node_iterator_current_ijk ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current_ijk
  integer(ip) :: coord(0:this%node_array%polytope_tree%number_dimensions-1), c, comp, j
  assert ( .not. this%has_finished() )
  ! First put free coordinates as such (fixed ones introduced when initializing)
  c = 0
  do comp =0,this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS ( this%n_face, comp+this%node_array%polytope_tree%number_dimensions, 1 ) == 1 ) then
        this%coordinate(comp) = this%displacement(c)
        c = c+1
     end if
  end do
  ! Next, translate fixed coordinates if needed
  do comp =0,this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS ( this%n_face, comp+this%node_array%polytope_tree%number_dimensions, 1 ) == 0 .and. IBITS( this%n_face, comp, 1 ) == 1 ) then
        this%coordinate(comp) = this%node_array%order
        do j = comp+1,this%node_array%polytope_tree%number_dimensions-1
           if ( IBITS ( this%node_array%polytope_tree%topology, j, 1 ) == 0 .and. IBITS ( this%n_face, j+this%node_array%polytope_tree%number_dimensions, 1 ) == 1 ) then
              this%coordinate(comp) = this%coordinate(comp) - this%coordinate(j)
           end if
        end do
     end if
  end do
  node_iterator_current_ijk = ijk_to_index( this%coordinate, this%node_array%order, this%node_array%polytope_tree%number_dimensions )
end function node_iterator_current_ijk

!=================================================================================================
function node_iterator_current ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current
  node_iterator_current = this%node_array%ijk_to_index( this%current_ijk() )
end function node_iterator_current

!=================================================================================================
! SUPPORT FUNCTIONS  
!=================================================================================================

!=================================================================================================
function ijk_to_index( n, order, dim )
  integer(ip), intent(in) :: n(0:dim-1), order, dim
  integer(ip) :: ijk_to_index, i
  ijk_to_index = 0
  do i = 0,dim-1
     ijk_to_index = ijk_to_index + n(i)*((order+1)**i)
  end do
end function ijk_to_index

!=================================================================================================
function n_face_dimension( n_face, dim )
  integer(ip), intent(in) :: n_face, dim
  integer(ip) :: n_face_dimension, i
  n_face_dimension = 0
  do i = 0,dim-1
     n_face_dimension = n_face_dimension + IBITS( n_face, dim+i, 1 )
  end do
end function n_face_dimension

function facet_orientation( n_face, dim )
  integer(ip), intent(in) :: n_face, dim
  integer(ip) :: facet_orientation
  integer(ip) :: n_face_type, base_n_face_type, axis_swap
  assert( n_face_dimension( n_face, dim) == dim-1 ) ! Only has sense for facets
  facet_orientation = 0
  
  n_face_type = IBITS( n_face, dim, dim )
  base_n_face_type = IBSET(0, dim-1)-1
  axis_swap = IEOR(n_face_type,base_n_face_type)
  if ( IBITS( axis_swap, 0, 1) == 1 .and. dim > 2 ) then
     facet_orientation = 1
  else
     facet_orientation = 0
  end if
  if ( axis_swap == 0 ) facet_orientation = 1
  n_face_type = IBITS( n_face, 0, dim )
  if ( n_face_type /= 0 ) then
     facet_orientation = 1-facet_orientation
  end if
  if ( dim == 2 ) then
     facet_orientation = 1-facet_orientation
  end if
end function facet_orientation
