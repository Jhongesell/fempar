!=================================================================================================
!     GEOMETRY_TREE_T TBPS
!=================================================================================================

!=================================================================================================
! This subroutine creates the object tree, where the geometrical objects are defined by 2*DIM bits.
! The "first" (from the right) DIM bits provide the "anchor node", whereas the "second" set of DIM
! bits provides the type of object. For every component, if we have 1 it means that the y-component
! can freely change. When = 0 it is constrained. However, it does not mean that it is constant (it
! is only for hyper-cubes). Think about the face of the tetrahedron that is not aligned with any 
! axes.
subroutine geometry_tree_create( this, number_dimensions, topology )
  implicit none
  class(geometry_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: number_dimensions
  integer(ip)        , intent(in)    :: topology
  integer(ip) :: c, i, d, j
  integer(ip), allocatable :: aux_array(:)
  call this%free()
  this%topology = topology
  this%number_dimensions = number_dimensions
  !     Compute number of object (all dimensions) for the hypercube
  !     c = (2**dim-1)*2**dim max id object
  c = 0
  do i = 0,number_dimensions
     c = c + 2**(number_dimensions-i)*(get_binomial_coefficient(number_dimensions,i))
  end do
  !     Pre-allocate this%objects_array with c (exact for hypercube)
  call memalloc ( c, this%object_array, __FILE__, __LINE__ )
  !     Pre-allocate the ijk_to_index. Maximum ijk_to_index is [111000]+1 for dim = 3
  !     = ISHFT(ISHFT(1_ip,dim)-1,dim) = (2**dim-1)*2**dim
  call memalloc ( ISHFT(ISHFT(1_ip,number_dimensions)-1,number_dimensions)+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  this%ijk_to_index = 0
  this%number_objects = 0
  !     Call the recursive fill_tree procedure starting with the volume object
  call this%fill_tree( ISHFT(ISHFT(1_ip,number_dimensions)-1, number_dimensions ) ) ! Root object (volume)
  !     Re-allocate the objects_array to the exact number of objects
  call memrealloc ( this%number_objects, this%object_array, __FILE__, __LINE__ )
  !     Sort objects based on 1) object_dimension 2) its bit-based index
  call memalloc ( this%number_objects, aux_array, __FILE__, __LINE__ )
  aux_array = this%object_array
  c = 1
  d = 1
  this%object_array = 0
  do i = 0,number_dimensions
     do j = 1,this%number_objects
        if ( object_dimension( aux_array(j), this%number_dimensions ) == i ) then
           this%object_array(d) = aux_array(j)
           d = d+1
        end if
     end do    
     call sort( d-c, this%object_array(c:d-1) ) 
     c = d
  end do
  call memfree ( aux_array, __FILE__, __LINE__ )
  !     Create the bit-index to consecutive index array (0 for bit-indexes wo/ associated object)
  do i =1,this%number_objects
     this%ijk_to_index( this%object_array(i) ) = i
  end do
end subroutine geometry_tree_create

!==================================================================================================
! This recursive subroutine fills ALL the sub-objects (including the object itself). From dimension
! DIM to 0.
recursive subroutine fill_tree( this, root )
  implicit none
  class(geometry_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: root
  type(children_iterator_t) :: children_iterator
  integer(ip)               :: children  
  ! If the object not already inserted (use ijk_to_index as touch table)

  if ( this%ijk_to_index(root) == 0 ) then 
     ! Increase one position current object in object_tree
     this%number_objects = this%number_objects + 1
     write(*,*) 'NEW OBJECT IN POS', this%number_objects
     ! Put root as new object in object_tree
     this%object_array(this%number_objects) = root
     write(*,*) 'OBJECT INDEX:'
     write(*,'(B32)') root
     ! Mark root as touched (already inserted)
     this%ijk_to_index(root) = 1
     ! Create iterator over children of root object
     children_iterator = this%create_children_iterator(root)
     ! Loop over children
     do while (.not. children_iterator%has_finished() )
        children = children_iterator%current_ijk()
        !write(*,*) 'current children: '
        !write(*,'(B32)') children
        ! Put children of child (recursive call)
        call this%fill_tree( children )
        ! Move to the next child
        call children_iterator%next()
     end do
  end if
end subroutine fill_tree

!=================================================================================================
subroutine geometry_tree_free( this )
  implicit none
  class(geometry_tree_t), intent(inout) :: this
  if (allocated(this%object_array)) call memfree ( this%object_array, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine geometry_tree_free

!=================================================================================================
function geometry_tree_create_children_iterator(this, parent)
  implicit none
  class(geometry_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: parent
  type(children_iterator_t) :: geometry_tree_create_children_iterator
  call geometry_tree_create_children_iterator%create(this, parent)
end function geometry_tree_create_children_iterator

!=================================================================================================
function geometry_tree_get_number_objects(this) 
       implicit none
  class(geometry_tree_t), intent(in) :: this
  integer(ip)                          :: geometry_tree_get_number_objects
  geometry_tree_get_number_objects = this%number_objects     
end function geometry_tree_get_number_objects

!=================================================================================================
function geometry_tree_get_object(this, object_index) 
       implicit none
  class(geometry_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: object_index
  integer(ip)                          :: geometry_tree_get_object
  geometry_tree_get_object = this%object_array(object_index)     
end function geometry_tree_get_object

!=================================================================================================
!     NODE_ARRAY_T TBPS
!=================================================================================================

!=================================================================================================
subroutine node_array_create ( this, object_tree, order )
  implicit none
  class(node_array_t)        , intent(inout) :: this
  type(geometry_tree_t), target, intent(in)    :: object_tree
  integer(ip)                , intent(in)    :: order
  call this%free()
  this%object_tree => object_tree
  this%order = order
  call this%fill()
end subroutine node_array_create

!=================================================================================================
subroutine node_array_fill ( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  type(node_iterator_t) :: node_iterator 
  integer(ip) :: i, c, m_ijk, current
  current = ISHFT(ISHFT(1_ip,this%object_tree%number_dimensions)-1,this%object_tree%number_dimensions)
  node_iterator = this%create_node_iterator( current, own_boundary = .true. )
  call node_iterator%init()
  c = 0
  m_ijk = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     m_ijk = max( m_ijk, node_iterator%current_ijk() )
     call node_iterator%next()       
  end do
  this%number_nodes = c
  call memalloc ( c, this%node_array, __FILE__, __LINE__ )
  call memalloc ( m_ijk+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  call node_iterator%init()
  c = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     this%node_array(c) =  node_iterator%current_ijk()
     call node_iterator%next()         
  end do
  ! Sort nodes based on its bit-based index
  call sort( c, this%node_array )    
  write(*,*) 'node_array',this%node_array
  do i =1,c
     write(*,*) 'object(',i,') :'
     write(*,'(B32)') this%node_array(i)
     this%ijk_to_index( this%node_array(i) ) = i
  end do
end subroutine node_array_fill

!=================================================================================================
subroutine node_array_print( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  integer(ip) :: i
  write(*,*) '************NODE ARRAY***********'
  write(*,*) 'number of nodes = ', this%number_nodes
  write(*,*) 'object_tree_topology = '
  write(*,'(B32)') this%object_tree%topology
  write(*,*) 'nodes'
  do i = 1, this%number_nodes
     write(*,*) 'NODE: ',this%node_array(i)
     write(*,'(B32)') this%node_array(i)
  end do
  write(*,*) 'ijk_to_index: ',this%ijk_to_index
end subroutine node_array_print

!=================================================================================================
subroutine node_array_free( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  if (allocated(this%node_array)) call memfree ( this%node_array, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine node_array_free

!=================================================================================================
function  node_array_get_number_nodes(this) 
       implicit none
  class(node_array_t), intent(in) :: this
  integer(ip)                          :: node_array_get_number_nodes
  node_array_get_number_nodes = this%number_nodes
end function  node_array_get_number_nodes

!=================================================================================================
!     CHILDREN_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
subroutine children_iterator_create ( this, object_tree, parent )
  implicit none
  class(children_iterator_t)        , intent(inout) :: this
  type(geometry_tree_t)       , target, intent(in)    :: object_tree
  integer(ip)                       , intent(in)    :: parent
  !call this%free()
  this%object_tree => object_tree
  this%parent = parent
  call this%init()
end subroutine children_iterator_create

!=================================================================================================
subroutine children_iterator_init ( this )
  implicit none
  class(children_iterator_t), intent(inout) :: this
  this%component = 0
  this%coordinate = 0
  if ( .not. this%is_admissible() ) then
     call this%next()
  end if
end subroutine children_iterator_init

!=================================================================================================
subroutine children_iterator_print( this )
  implicit none
  class(children_iterator_t), intent(inout) :: this
  write(*,*) '***CHILDREN_ITERATOR ***'
  write(*,*) 'parent: '
  write(*,'(B32)') this%parent
  write(*,*) 'component: ',this%component
  write(*,*) 'coordinate: ',this%coordinate

end subroutine children_iterator_print

!=================================================================================================
recursive subroutine children_iterator_next ( this )
  implicit none
  class(children_iterator_t), intent(inout) :: this
  if ( this%has_finished() ) return 
  if ( this%coordinate == 1 ) then
     this%component = this%component + 1
     this%coordinate = 0
  else
     this%coordinate = 1
  end if
  if ( .not. this%is_admissible() ) then
     call this%next()
  else 
  end if
end subroutine children_iterator_next

!=================================================================================================
function children_iterator_has_finished ( this )
  implicit none
  class(children_iterator_t), intent(in) :: this
  logical :: children_iterator_has_finished
  children_iterator_has_finished = ( this%component >= this%object_tree%number_dimensions )
end function children_iterator_has_finished

!=================================================================================================
function children_iterator_current_ijk ( this )
  implicit none
  class(children_iterator_t), intent(in) :: this
  integer(ip) :: children_iterator_current_ijk, j
  assert ( .not. this%has_finished() )
  children_iterator_current_ijk = this%parent
  children_iterator_current_ijk = IBCLR( children_iterator_current_ijk, this%object_tree%number_dimensions + this%component )
  if ( this%coordinate == 1 ) then
     if ( IBITS( this%object_tree%topology, this%component, 1 )  == 0 ) then
        do j = 0,this%component-1
           children_iterator_current_ijk = IBCLR( children_iterator_current_ijk, j )
        end do
     end if
     children_iterator_current_ijk = IBSET( children_iterator_current_ijk, this%component )
  end if
end function children_iterator_current_ijk

!=================================================================================================
function children_iterator_current ( this )
  implicit none
  class(children_iterator_t), intent(in) :: this
  integer(ip) :: children_iterator_current
  children_iterator_current = this%object_tree%ijk_to_index( this%current_ijk() )
end function children_iterator_current

!=================================================================================================
function children_iterator_is_admissible( this )
  implicit none
  class(children_iterator_t), intent(inout) :: this
  logical                          :: children_iterator_is_admissible
  children_iterator_is_admissible = .false. 
  if ( IBITS( this%parent, this%object_tree%number_dimensions + this%component, 1 ) == 1) then
     if ( IBITS( this%object_tree%topology, this%component, 1 ) == 1 ) then
        children_iterator_is_admissible = .true.
     else if ( this%coordinate == 0 .or. this%component == 0 & 
          & .or. IBITS( this%parent, this%object_tree%number_dimensions, this%component ) == 0 ) then  
        children_iterator_is_admissible = .true.
     end if
  end if
end function children_iterator_is_admissible

!=================================================================================================
!     NODE_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
function node_array_create_node_iterator( node_array, parent, own_boundary)
  implicit none
  class(node_array_t) , intent(in) :: node_array
  integer(ip)         , intent(in) :: parent
  logical             , intent(in) :: own_boundary 
  type(node_iterator_t) :: node_array_create_node_iterator
  call node_array_create_node_iterator%create( node_array, parent, own_boundary )
end function node_array_create_node_iterator

!=================================================================================================
subroutine node_iterator_create ( this, node_array, object, own_boundary )
  implicit none
  class(node_iterator_t)            , intent(inout) :: this
  type(node_array_t), target               , intent(in)    :: node_array
  integer(ip)                       , intent(in)    :: object
  logical                           , intent(in)    :: own_boundary
  integer(ip) :: c, i
  this%node_array => node_array
  this%topology = 0
  this%object = object
  this%own_boundary = own_boundary
  if ( own_boundary) then
     this%max_value = node_array%order
     this%min_value = 0
  else
     this%max_value = node_array%order-1
     this%min_value = 1
  end if
  ! Restrict the topology of the object_tree to the current object
  c = 0
  do i = 0, node_array%object_tree%number_dimensions-1
     if ( IBITS( this%object, node_array%object_tree%number_dimensions+i, 1 ) == 1 ) then 
        if ( IBITS( this%node_array%object_tree%topology, i, 1 ) == 1 ) this%topology = IBSET( this%topology, c )
        c = c+1
     end if
  end do
  call this%init()
end subroutine node_iterator_create

!=================================================================================================
subroutine node_iterator_init ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: c, i
  this%displacement = 0
  this%coordinate = 0
  this%overflow = .true.
  !if ( object_dimension(this%object, this%node_array%object_tree%number_dimensions) > 0 .or. this%own_boundary ) 
  this%overflow = .false.
  c = 0
  do i = 0, this%node_array%object_tree%number_dimensions-1
     if ( IBITS( this%object, this%node_array%object_tree%number_dimensions+i, 1 ) == 0 ) then  ! if is fixed component in object
        if ( IBITS( this%object, i, 1 ) == 0 ) then   ! if coordinate of anchor node == 0
           this%coordinate(i) = 0                     ! fixed coordinate = min value
        else
           this%coordinate(i) = this%node_array%order ! fixed coordinate = max value   
        end if
     else 
        this%displacement(c) = this%min_value
        c = c+1
     end if
  end do
  if ( object_dimension(this%object, this%node_array%object_tree%number_dimensions) > 0 ) then
     this%displacement(0) = this%displacement(0)-1
     call this%next()
  end if
end subroutine node_iterator_init

!=================================================================================================
subroutine node_iterator_print( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  write(*,*) '***NODE_ITERATOR ***'
  write(*,*) 'object: '
  write(*,'(B32)') this%object
  write(*,*) 'displacement: ',this%displacement
end subroutine node_iterator_print

!=================================================================================================
subroutine node_iterator_next ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: comp, end_comp, i
  if ( this%has_finished() ) return 
  comp = 0 
  end_comp = object_dimension(this%object, this%node_array%object_tree%number_dimensions)-1
  this%overflow = .true.
  do while( comp <= end_comp)
     if ( this%overflow ) then 
        this%displacement(comp) = this%displacement(comp)+1
        if ( this%in_bound(comp, end_comp) ) then
           this%overflow = .false.
           do i = comp-1,0,-1
              if ( .not. this%in_bound( i, end_comp ) ) then
                 this%overflow = .true.
              end if
           end do
           exit
        else 
           this%displacement(comp) = this%min_value
        end if
     end if
     comp = comp+1
  end do
end subroutine node_iterator_next

!=================================================================================================
function node_iterator_in_bound( this, comp, end_comp )
  implicit none
  class(node_iterator_t), intent(in) :: this
  integer(ip)           , intent(in) :: comp, end_comp
  logical :: node_iterator_in_bound
  integer(ip) :: bound, i
  node_iterator_in_bound = .true.
  bound = this%max_value
  do i = comp+1,end_comp
     if ( IBITS( this%topology, i, 1 ) == 0 ) then
        bound = bound - this%displacement(i)
     end if
  end do
  if ( this%displacement(comp) > bound ) node_iterator_in_bound = .false.
end function node_iterator_in_bound

!=================================================================================================
function node_iterator_has_finished ( this )
  implicit none
  class(node_iterator_t), intent(in) :: this
  logical :: node_iterator_has_finished
  node_iterator_has_finished = this%overflow
end function node_iterator_has_finished

!=================================================================================================
function node_iterator_current_ijk ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current_ijk
  integer(ip) :: coord(0:this%node_array%object_tree%number_dimensions-1), c, comp, j
  assert ( .not. this%has_finished() )
  ! First put free coordinates as such (fixed ones introduced when initializing)
  c = 0
  do comp =0,this%node_array%object_tree%number_dimensions-1
     if ( IBITS ( this%object, comp+this%node_array%object_tree%number_dimensions, 1 ) == 1 ) then
        this%coordinate(comp) = this%displacement(c)
        c = c+1
     end if
  end do
  ! Next, translate fixed coordinates if needed
  do comp =0,this%node_array%object_tree%number_dimensions-1
     if ( IBITS ( this%object, comp+this%node_array%object_tree%number_dimensions, 1 ) == 0 .and. IBITS( this%object, comp, 1 ) == 1 ) then
        this%coordinate(comp) = this%node_array%order
        do j = comp+1,this%node_array%object_tree%number_dimensions-1
           if ( IBITS ( this%node_array%object_tree%topology, j, 1 ) == 0 .and. IBITS ( this%object, j+this%node_array%object_tree%number_dimensions, 1 ) == 1 ) then
              this%coordinate(comp) = this%coordinate(comp) - this%coordinate(j)
           end if
        end do
     end if
  end do
  node_iterator_current_ijk = ijk_to_index( this%coordinate, this%node_array%order, this%node_array%object_tree%number_dimensions )
end function node_iterator_current_ijk

!=================================================================================================
function node_iterator_current ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current
  node_iterator_current = this%node_array%ijk_to_index( this%current_ijk() )
end function node_iterator_current

!=================================================================================================
! SUPPORT FUNCTIONS  
!=================================================================================================

!=================================================================================================
function ijk_to_index( n, order, dim )
  integer(ip), intent(in) :: n(0:dim-1), order, dim
  integer(ip) :: ijk_to_index, i
  ijk_to_index = 0
  do i = 0,dim-1
     ijk_to_index = ijk_to_index + n(i)*((order+1)**i)
  end do
end function ijk_to_index

!=================================================================================================
function object_dimension( object, dim )
  integer(ip), intent(in) :: object, dim
  integer(ip) :: object_dimension, i
  object_dimension = 0
  do i = 0,dim-1
     object_dimension = object_dimension + IBITS( object, dim+i, 1 )
  end do
end function object_dimension

function face_orientation( object, dim )
  integer(ip), intent(in) :: object, dim
  integer(ip) :: face_orientation
  integer(ip) :: object_type, base_object_type, axis_swap
  assert( object_dimension( object, dim) == dim-1 ) ! Only has sense for faces
  face_orientation = 0
  
  object_type = IBITS( object, dim, dim )
  base_object_type = IBSET(0, dim-1)-1
  axis_swap = IEOR(object_type,base_object_type)
  if ( IBITS( axis_swap, 0, 1) == 1 .and. dim > 2 ) then
     face_orientation = 1
  else
     face_orientation = 0
  end if
  if ( axis_swap == 0 ) face_orientation = 1
  object_type = IBITS( object, 0, dim )
  if ( object_type /= 0 ) then
     face_orientation = 1-face_orientation
  end if
  if ( dim == 2 ) then
     face_orientation = 1-face_orientation
  end if
end function face_orientation
