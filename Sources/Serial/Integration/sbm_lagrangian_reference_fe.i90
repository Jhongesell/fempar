! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************************************************************
! Deferred TBP implementors from reference_fe_t
!**************************************************************************************************

!==================================================================================================
subroutine lagrangian_reference_fe_create_anisotropic_order ( this, topology, number_dimensions, order, field_type, & 
                                          &  continuity, enable_face_integration )
  implicit none 
  class(lagrangian_reference_fe_t), intent(inout) :: this
  character(*)                    , intent(in)    :: topology
  integer(ip)                     , intent(in)    :: number_dimensions
  integer(ip)                     , intent(in)    :: order(SPACE_DIM)
  character(*)                    , intent(in)    :: field_type
  logical                         , intent(in)    :: continuity
  logical              , optional , intent(in)    :: enable_face_integration

  call this%free()
  call this%set_common_data(number_dimensions,order,field_type,continuity,enable_face_integration)
  call this%set_topology ( topology )
  call this%set_fe_type( fe_type_lagrangian )
  call this%fill()
  call this%set_nodal_quadrature()
  
end subroutine lagrangian_reference_fe_create_anisotropic_order

!==================================================================================================
subroutine lagrangian_reference_fe_fill_interior_points_permutation(this,                   &
                                                                    dimension,              &
                                                                    number_interior_points, &
                                                                    interior_points_permutation )
  implicit none
  class(lagrangian_reference_fe_t) , intent(inout) :: this 
  integer(ip)                      , intent(in)    :: dimension
  integer(ip)                      , intent(in)    :: number_interior_points
  integer(ip)        , allocatable , intent(inout) :: interior_points_permutation(:,:)

  integer(ip) :: number_interior_points_x_dim
  integer(ip) :: number_of_possible_permutations
  
  if ( this%number_dimensions == 2 ) then
    assert ( dimension == 1 )
  else if ( this%number_dimensions == 3) then
    assert ( dimension == 1 .or. dimension == 2)
  else
    check(.false.)
  end if
  
  if ( allocated(interior_points_permutation) ) then 
     call memfree(interior_points_permutation,__FILE__,__LINE__)
  end if
  
  number_interior_points_x_dim = this%get_number_interior_points_x_dim(number_interior_points, &
                                                                       dimension )

  number_of_possible_permutations = this%number_rotations_per_dimension(dimension) * &
                                    this%number_orientations_per_dimension(dimension)
  
  call memalloc (number_interior_points,          &
                 number_of_possible_permutations, &
                 interior_points_permutation,     &
                 __FILE__,__LINE__)
  
  call this%fill_permutation_array(dimension,                    &
                                   number_interior_points_x_dim, &
                                   interior_points_permutation)

end subroutine lagrangian_reference_fe_fill_interior_points_permutation

!==================================================================================================
subroutine lagrangian_reference_fe_create_quadrature ( this, quadrature, max_order )
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this  
  type(quadrature_t)              , intent(inout) :: quadrature
  integer(ip)           , optional, intent(in)    :: max_order
  
  integer(ip) :: ngaus, order, idime
  ! @sbadia: to be improved to anisotropic quadratures
  if ( present(max_order) ) then
     order = max_order
  else
     order = 0
     do idime = 1,this%number_dimensions
        order = max(order,this%order(idime))
     end do
  end if
  ngaus = this%set_number_quadrature_points(order,this%number_dimensions)
  call quadrature%create( this%number_dimensions, ngaus )
  call this%fill_quadrature( quadrature )
  
end subroutine lagrangian_reference_fe_create_quadrature

!==================================================================================================
subroutine lagrangian_reference_fe_create_face_quadrature ( this, quadrature, max_order )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(inout) :: quadrature
  integer(ip)           , optional, intent(in)    :: max_order

  integer(ip) :: ngaus, order, face_dimensions, idime
  ! @sbadia: to be improved to anisotropic quadratures
  if ( present(max_order) ) then
     order = max_order
  else
     order = 0
     do idime = 1,this%number_dimensions
        order = max(order,this%order(idime))
     end do
  end if
  face_dimensions = this%number_dimensions - 1
  ngaus = this%set_number_quadrature_points(order,face_dimensions)
  call quadrature%create( face_dimensions, ngaus )
  call this%fill_quadrature( quadrature )
  
end subroutine lagrangian_reference_fe_create_face_quadrature

!==================================================================================================
subroutine lagrangian_reference_fe_create_interpolation ( this, quadrature, & 
                                                        & interpolation, compute_hessian )
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation
  logical               , optional, intent(in)    :: compute_hessian

  integer(ip) :: ntens, i

  ntens = 0
  do i = 1, this%number_dimensions
     ntens = ntens + i
  end do

  call interpolation%create( this%number_dimensions, this%number_nodes_scalar, &
                             quadrature%number_quadrature_points, ntens, compute_hessian )
  
  call this%fill_interpolation( quadrature, interpolation )
  
end subroutine lagrangian_reference_fe_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'local_face_id' of the element or
! in all the faces of the element.
subroutine lagrangian_reference_fe_create_face_interpolation( this,local_face_id, &
                                                            & local_quadrature,face_interpolation)
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip)                     , intent(in)    :: local_face_id
  type(quadrature_t)              , intent(in)    :: local_quadrature
  type(interpolation_t)           , intent(inout) :: face_interpolation

  ! Allocate the arrays of the interpolation
  call face_interpolation%create(this%number_dimensions,this%number_nodes_scalar, &
                               & local_quadrature%number_quadrature_points, 0 )

  ! Fill the values of the shape functions
  call this%fill_face_interpolation (face_interpolation,local_quadrature,local_face_id)
  
end subroutine lagrangian_reference_fe_create_face_interpolation

!==================================================================================================
! This subroutine constructs a interpolation of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine lagrangian_reference_fe_create_face_local_interpolation ( this, quadrature, &
                                                                   & interpolation)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(in)    :: quadrature
  type(interpolation_t)           , intent(inout) :: interpolation

  integer(ip) :: number_nodes_face_scalar, number_dimensions_face

  ! I am assuming the geometric aproximation of the face can be linear
  ! this might need to be modified in the future
  number_dimensions_face   = this%number_dimensions - 1
  number_nodes_face_scalar = this%compute_number_nodes_scalar( this%order(1), &         ! @sbadia: not anisotropic geometry interpolation assumed
                                                            &  number_dimensions_face )

  ! Allocate the arrays of the interpolation
  call interpolation%create( number_dimensions_face, number_nodes_face_scalar, &
                           & quadrature%number_quadrature_points, 0)

  ! Fill the values with the common routine for filling an interpolation
  call this%fill_interpolation( quadrature, interpolation )

end subroutine lagrangian_reference_fe_create_face_local_interpolation

!==================================================================================================
subroutine lagrangian_reference_fe_update_interpolation( this, fe_map,                 &
                                                       & interpolation_reference_cell, &
                                                       & interpolation_real_cell )
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(fe_map_t)                  , intent(in)    :: fe_map
  type(interpolation_t)           , intent(in)    :: interpolation_reference_cell
  type(interpolation_t)           , intent(inout) :: interpolation_real_cell

  call this%apply_femap_to_interpolation(fe_map,interpolation_reference_cell,interpolation_real_cell)
  
end subroutine lagrangian_reference_fe_update_interpolation

!==================================================================================================
subroutine lagrangian_reference_fe_update_interpolation_face( this, local_face_id,     &
                                                            & fe_map_face_restriction, &
                                                            & interpolation_face_restriction )
  implicit none 
  class(lagrangian_reference_fe_t)      , intent(in)    :: this 
  integer(ip)                           , intent(in)    :: local_face_id
  type(fe_map_face_restriction_t)       , intent(in)    :: fe_map_face_restriction
  type(interpolation_face_restriction_t), intent(inout) :: interpolation_face_restriction

  interpolation_face_restriction%active_face_id = local_face_id
  
  call this%update_interpolation(fe_map_face_restriction%fe_map(local_face_id),                   &
       &                         interpolation_face_restriction%interpolation(local_face_id),     &
       &                         interpolation_face_restriction%interpolation_o_map(local_face_id))

end subroutine lagrangian_reference_fe_update_interpolation_face

!==================================================================================================
function lagrangian_reference_fe_get_component_node( this, node )
  implicit none
  class(lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: lagrangian_reference_fe_get_component_node
  lagrangian_reference_fe_get_component_node = this%node_component_array(node,2)
end function lagrangian_reference_fe_get_component_node

!==================================================================================================
function lagrangian_reference_fe_get_scalar_from_vector_node( this, node )
  implicit none
  class(lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                     , intent(in) :: node
  integer(ip) :: lagrangian_reference_fe_get_scalar_from_vector_node
  lagrangian_reference_fe_get_scalar_from_vector_node = this%node_component_array(node,1)
end function lagrangian_reference_fe_get_scalar_from_vector_node

!==================================================================================================
function lagrangian_reference_fe_get_number_nodes_scalar(this) result(number_nodes_scalar)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                                     :: number_nodes_scalar
  number_nodes_scalar = this%number_nodes_scalar
end function lagrangian_reference_fe_get_number_nodes_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_get_value_scalar( this, actual_cell_interpolation, & 
                                                   & ishape, qpoint, scalar_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )
  scalar_field = actual_cell_interpolation%shape_functions(1,ishape,qpoint)
end subroutine lagrangian_reference_fe_get_value_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_get_value_vector( this, actual_cell_interpolation, & 
                                                   & ishape, qpoint, vector_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )
  call vector_field%init(0.0_rp)
  call vector_field%set(this%node_component_array(ishape,2), &
   & actual_cell_interpolation%shape_functions(1,this%node_component_array(ishape,1),qpoint))
end subroutine lagrangian_reference_fe_get_value_vector

!==================================================================================================
subroutine lagrangian_reference_fe_get_gradient_scalar( this, actual_cell_interpolation, & 
                                                      & ishape, qpoint, vector_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  integer(ip) :: idime
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )
  call vector_field%init(0.0_rp)
  do idime=1,this%number_dimensions
    call vector_field%set(idime,actual_cell_interpolation%shape_derivatives(1,idime,ishape,qpoint))
  end do
end subroutine lagrangian_reference_fe_get_gradient_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_get_gradient_vector( this, actual_cell_interpolation, & 
                                                      & ishape, qpoint, tensor_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(tensor_field_t)            , intent(inout) :: tensor_field
  integer(ip) :: idime
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )
  call tensor_field%init(0.0_rp)
  do idime=1,this%number_dimensions
    call tensor_field%set(idime,this%node_component_array(ishape,2), &
     & actual_cell_interpolation%shape_derivatives(1,idime,this%node_component_array(ishape,1),qpoint))
  end do
end subroutine lagrangian_reference_fe_get_gradient_vector

!==================================================================================================
subroutine lagrangian_reference_fe_get_divergence_vector( this, actual_cell_interpolation, & 
                                                        & ishape, qpoint, scalar_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  real(rp)                        , intent(inout) :: scalar_field

  ! Locals 
  integer(ip) :: idime

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )

  scalar_field = actual_cell_interpolation%shape_derivatives(1,this%node_component_array(ishape,2), &
                                                           & this%node_component_array(ishape,1), &
                                                           & qpoint)  
end subroutine lagrangian_reference_fe_get_divergence_vector 

!==================================================================================================
subroutine lagrangian_reference_fe_get_curl_vector( this, actual_cell_interpolation, &
                                                  & ishape, qpoint, vector_field )
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  integer(ip)                     , intent(in)    :: ishape
  integer(ip)                     , intent(in)    :: qpoint
  type(vector_field_t)            , intent(inout) :: vector_field
  
  ! Locals 
  integer(ip) :: idime, jdime, kdime
  ! Epsilon_{ijk} = Levi_Civita(i,j,k)
  real(rp), parameter :: Levi_Civita(3,3,3) = reshape( (/0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, -1.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, &
													                                            0.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, -1.0_rp, 0.0_rp, 0.0_rp, &
													                                            0.0_rp, -1.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp/), (/3, 3, 3/) )

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_shape_functions )
  assert( qpoint >= 1 )
  

 call vector_field%init(0.0_rp)
 
 kdime = this%node_component_array(ishape,2)
 do idime=1,SPACE_DIM 
   do jdime = 1,this%number_dimensions
      if ( ( idime .ne. jdime ) .and. (idime .ne. kdime) .and. (jdime .ne. kdime) ) then 
         call vector_field%set( idime, &
              Levi_Civita(idime,jdime,kdime)* &
              actual_cell_interpolation%shape_derivatives(1,jdime,this%node_component_array(ishape,1),qpoint) )
      end if
   end do
 end do

end subroutine lagrangian_reference_fe_get_curl_vector

!==================================================================================================
subroutine lagrangian_reference_fe_interpolate_nodal_values( this,                &
                                                          &  nodal_interpolation, &
                                                          &  nodal_values_origin, &
                                                          &  nodal_values_destination)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: nodal_interpolation
  real(rp)                        , intent(in)    :: nodal_values_origin(:)
  real(rp)                        , intent(inout) :: nodal_values_destination(:)
  integer(ip) :: qpoint, ishape, icomp, c_dest

  c_dest = 0
  do icomp = 1, this%number_field_components
     do qpoint = 1, nodal_interpolation%number_quadrature_points
        c_dest = c_dest + 1
        nodal_values_destination(c_dest) = 0.0_rp
        do ishape = 1, nodal_interpolation%number_shape_functions
           nodal_values_destination(c_dest) = nodal_values_destination(c_dest) + & 
                & nodal_interpolation%shape_functions(1,ishape,qpoint) *           &
                & nodal_values_origin(this%node_array_component(ishape,icomp))
        end do
     end do
  end do

end subroutine lagrangian_reference_fe_interpolate_nodal_values

!==================================================================================================
subroutine lagrangian_reference_fe_set_nodal_quadrature (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  
  ! Create nodal quadrature
  call this%nodal_quadrature%create( this%number_dimensions, this%number_nodes_scalar )

  ! Fill nodal quadrature
  call this%fill_nodal_quadrature ( this%nodal_quadrature )
  
end subroutine lagrangian_reference_fe_set_nodal_quadrature

!==================================================================================================
subroutine lagrangian_reference_fe_set_scalar_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values, unknown_component)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                     , intent(in)    :: code
  real(rp)                        , intent(in)    :: values(:)
  integer(ip)                     , intent(in)    :: nodal_codes(:)
  real(rp)                        , intent(inout) :: nodal_values(:)
  integer(ip)          , optional , intent(in)    :: unknown_component
  integer(ip) :: i, icomp

  assert(size(nodal_values) == this%number_shape_functions)
  assert(size(values) == this%number_nodes_scalar)

  icomp = 1
  if(present(unknown_component)) icomp = unknown_component

  do i = 1, this%number_nodes_scalar
     if(nodal_codes(this%node_array_component(i,icomp)) == code) then
        nodal_values(this%node_array_component(i,icomp)) = values(i)
     end if
  end do
  
end subroutine lagrangian_reference_fe_set_scalar_field_to_nodal_values

!==================================================================================================
subroutine lagrangian_reference_fe_set_vector_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                     , intent(in)    :: code
  type(vector_field_t)            , intent(in)    :: values(:)
  integer(ip)                     , intent(in)    :: nodal_codes(:)
  real(rp)                        , intent(inout) :: nodal_values(:)
  integer(ip) :: i, icomp

  assert(size(nodal_values) == this%number_shape_functions)
  assert(size(values) == this%number_nodes_scalar)

  do icomp = 1, this%number_field_components
     do i = 1, this%number_nodes_scalar
        if(nodal_codes(this%node_array_component(i,icomp)) == code) then
           nodal_values(this%node_array_component(i,icomp)) = values(i)%get(icomp)
        end if
     end do
  end do
     
end subroutine lagrangian_reference_fe_set_vector_field_to_nodal_values

!==================================================================================================
subroutine lagrangian_reference_fe_set_tensor_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                     , intent(in)    :: code
  type(tensor_field_t)            , intent(in)    :: values(:)
  integer(ip)                     , intent(in)    :: nodal_codes(:)
  real(rp)                        , intent(inout) :: nodal_values(:)
  integer(ip) :: i, icomp, jcomp

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine lagrangian_reference_fe_set_tensor_field_to_nodal_values

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_fe_function_scalar( this,                      &
                                                             &  actual_cell_interpolation, &
                                                             &  nodal_values,              &
                                                             &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  real(rp)                        , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, ishape

  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     quadrature_points_values(qpoint) = 0.0_rp
     do ishape = 1, actual_cell_interpolation%number_shape_functions
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
        & actual_cell_interpolation%shape_functions(1,ishape,qpoint)*nodal_values(ishape)
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_fe_function_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_fe_function_vector( this,                      &
                                                             &  actual_cell_interpolation, &
                                                             &  nodal_values,              &
                                                             &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  type(vector_field_t)            , intent(inout) :: quadrature_points_values(:)
  integer(ip) :: qpoint, inode, icomp, inode_scalar
  
  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%number_shape_functions
        inode_scalar = this%node_component_array(inode,1)
        icomp        = this%node_component_array(inode,2)
        call quadrature_points_values(qpoint)%add(icomp, &
         & actual_cell_interpolation%shape_functions(1,inode_scalar,qpoint)*nodal_values(inode))
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_fe_function_vector

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_fe_function_tensor( this,                      &
                                                             &  actual_cell_interpolation, &
                                                             &  nodal_values,              &
                                                             &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  type(tensor_field_t)            , intent(inout) :: quadrature_points_values(:)

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine lagrangian_reference_fe_evaluate_fe_function_tensor

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_scalar( this,                      &
                                                                      &  actual_cell_interpolation, &
                                                                      &  nodal_values,              &
                                                                      &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  type(vector_field_t)            , intent(inout) :: quadrature_points_values(:)
  integer(ip)                                     :: qpoint,ishape
  type(vector_field_t)                            :: gradient_shape

  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do ishape = 1, actual_cell_interpolation%number_shape_functions
        call this%get_gradient(actual_cell_interpolation,ishape,qpoint,gradient_shape)
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
             &                             gradient_shape * nodal_values(ishape)
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_scalar

!==================================================================================================
subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_vector( this,                  &
                                                                      &  actual_cell_interpolation, &
                                                                      &  nodal_values,              &
                                                                      &  quadrature_points_values)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)           , intent(in)    :: actual_cell_interpolation 
  real(rp)                        , intent(in)    :: nodal_values(:)
  type(tensor_field_t)            , intent(inout) :: quadrature_points_values(:)
  integer(ip)                                     :: qpoint, inode
  type(tensor_field_t)                            :: gradient_shape

  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%number_shape_functions
        call this%get_gradient(actual_cell_interpolation,inode,qpoint,gradient_shape)
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
             &                             gradient_shape * nodal_values(inode)
     end do
  end do

end subroutine lagrangian_reference_fe_evaluate_gradient_fe_function_vector

! Adaptivity purposes
!==================================================================================================
function lagrangian_reference_fe_get_number_subelements(this) result(number_subelements)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                                     :: number_subelements
  number_subelements = this%order(1)**this%number_dimensions ! @sbadia: It is not correct
end function lagrangian_reference_fe_get_number_subelements

!==================================================================================================
subroutine lagrangian_reference_fe_free ( this )
  implicit none 
  class(lagrangian_reference_fe_t), intent(inout) :: this 
  ! lagrangian_reference_fe_t variables
  if(allocated(this%node_component_array)) & 
       call memfree(this%node_component_array,__FILE__,__LINE__)
  if(allocated(this%node_array_component)) & 
       call memfree(this%node_array_component,__FILE__,__LINE__)
  this%number_nodes_scalar = 0
  call reference_fe_free ( this )
end subroutine lagrangian_reference_fe_free

!**************************************************************************************************
! Concrete TBPs of this derived data type
!**************************************************************************************************

!==================================================================================================
subroutine lagrangian_reference_fe_fill (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip) :: c, i, j, dimension, number_interior_nodes, number_interior_nodes_scalar
  integer(ip) :: column, inode, idime, inode_scalar, num_columns
  
  call this%fill_scalar( )
  
  call memalloc (this%number_dimensions-1,this%number_rotations_per_dimension,__FILE__,__LINE__)
  call memalloc (this%number_dimensions-1,this%number_orientations_per_dimension,__FILE__,__LINE__)
  
  if ( this%continuity ) allocate(this%own_node_permutations(this%number_dimensions-1))
  
  do dimension = 1, this%number_dimensions-1

     if (dimension == 1) then
        this%number_rotations_per_dimension(dimension) = this%get_number_vertices_per_edge()
     elseif (dimension == 2) then 
        this%number_rotations_per_dimension(dimension) = this%get_number_vertices_per_face()
     end if
     this%number_orientations_per_dimension(dimension) = dimension
     
     if ( this%continuity ) then
       ! Compute the number of interior nodes X (edge or face)
       j = this%get_first_n_face_id_of_dimension(dimension)
       number_interior_nodes = this%get_number_own_nodes_n_face(j)
          
       call this%fill_interior_points_permutation(dimension,             &
                                                  number_interior_nodes, &
                                                  this%own_node_permutations(dimension)%a)
     end if
  end do
  
  if ( this%number_field_components /= 1 ) then
     call this%fill_field_components( )
     if ( this%continuity ) then
       do dimension = 1, this%number_dimensions-1
          ! Compute the number of interior nodes x edge or face
          j = this%get_first_n_face_id_of_dimension(dimension)
          number_interior_nodes        = this%get_number_own_nodes_n_face(j)
          number_interior_nodes_scalar = number_interior_nodes/this%number_field_components
          num_columns = this%number_rotations_per_dimension(dimension) * &
                        this%number_orientations_per_dimension(dimension) 
          call memrealloc ( number_interior_nodes,                   &
                            num_columns,                             &
                            this%own_node_permutations(dimension)%a, &
                            __FILE__, __LINE__ )
          do column = 1, num_columns
             ! Fill the rest of components
             inode = number_interior_nodes_scalar
             do idime = 2, this%number_field_components
                ! This is taking advantage of the face that we know how the DoF are ordered
                ! in case this ordering change, this will not work anymore.
                do inode_scalar = 1, number_interior_nodes_scalar
                   inode = inode + 1
                   this%own_node_permutations(dimension)%a(inode,column) = & 
                              & number_interior_nodes_scalar * (idime-1) + & 
                              & this%own_node_permutations(dimension)%a(inode_scalar,column)
                end do
             end do
          end do
       end do
     end if
  else
     this%number_nodes_scalar = this%number_shape_functions
  end if
  
  call memalloc( this%number_shape_functions, 2, this%node_component_array, __FILE__, __LINE__ )
  call memalloc( this%number_nodes_scalar,     & 
               & this%number_field_components, & 
               & this%node_array_component,    & 
               & __FILE__, __LINE__ )

  c = 1
  do i = 1, this%number_field_components
     do j = 1, this%number_nodes_scalar
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do
  
end subroutine lagrangian_reference_fe_fill

!==================================================================================================
subroutine lagrangian_reference_fe_fill_field_components (this)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  call this%extend_list_components( this%nodes_n_face )
  call this%extend_list_components( this%interior_nodes_n_face )
  call this%extend_list_components( this%own_nodes_n_faces )
  call this%extend_list_components( this%face_integration_coupling_nodes_facet )
  this%number_nodes_scalar = this%number_shape_functions
  this%number_shape_functions = this%number_nodes_scalar * this%number_field_components
end subroutine lagrangian_reference_fe_fill_field_components

!==================================================================================================
subroutine lagrangian_reference_fe_fill_permutation_array (this,               &
                                                         & dimension,          &
                                                         & number_nodes_x_dim, &
                                                         & permutation_array)
  implicit none 
  class(lagrangian_reference_fe_t), intent(inout) :: this 
  integer(ip)                     , intent(in)    :: dimension
  integer(ip)                     , intent(in)    :: number_nodes_x_dim
  integer(ip)       , allocatable , intent(inout) :: permutation_array(:,:)

  integer(ip) :: irotation, iorientation, column

  column = 1
  do iorientation = 1, this%number_orientations_per_dimension(dimension)
     do irotation = 1, this%number_rotations_per_dimension(dimension)
        if (dimension == 1) then
           call this%set_permutation_1D (permutation_array(:,column), &
                                         number_nodes_x_dim,          &
                                         irotation)
        elseif (dimension == 2) then
           call this%set_permutation_2D (permutation_array(:,column), &
                                         number_nodes_x_dim,          &
                                         iorientation,                &
                                         irotation)
        else 
           check (.false.)
        end if
        column = column + 1
     end do
  end do

end subroutine lagrangian_reference_fe_fill_permutation_array

!==================================================================================================
subroutine lagrangian_reference_fe_fill_nodal_quadrature ( this, quadrature ) 
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)              , intent(inout) :: quadrature
  integer(ip) :: ndime,nquad

  ndime = quadrature%number_dimensions
  nquad = quadrature%number_quadrature_points
  
  call this%get_node_coordinates_array(quadrature%coordinates,ndime,this%order(1),nquad) ! @sbadia: to be modified
  quadrature%weight = 1.0_rp

end subroutine lagrangian_reference_fe_fill_nodal_quadrature

! @sbadia: This subroutine should be re-written with new machinery
!==================================================================================================
subroutine lagrangian_reference_fe_get_node_coordinates_array (this, coordinates,    & 
                                                             & number_of_dimensions, &
                                                             & order, number_nodes)
  implicit none 
  class(lagrangian_reference_fe_t), intent(in)    :: this
  real(rp)                        , intent(inout) :: coordinates(:,:)
  integer(ip)                     , intent(in)    :: number_of_dimensions,order,number_nodes
  integer(ip) :: ijk(number_of_dimensions),i,d
  real(rp)    :: coordinates_1D(order+1)

  call this%set_coordinates_1D(coordinates_1D,order+1) ! @sbadia: be careful

  do i=1,number_nodes

     call this%get_node_local_coordinates(ijk,i,number_of_dimensions,order)
     do d=1,number_of_dimensions
        coordinates(d,i) = coordinates_1D(ijk(d)+1)
     end do
     
  end do
  
end subroutine lagrangian_reference_fe_get_node_coordinates_array

!=================================================================================================
subroutine lagrangian_reference_fe_set_permutation_1D(this,permutation,number_nodes_x_dim,rotation)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                     , intent(inout) :: permutation(:)
  integer(ip)                     , intent(in)    :: number_nodes_x_dim,rotation
  integer(ip) :: i

  ! Generic loop+rotation identifier  
  if (rotation==1) then
     permutation = (/(i,i=1,number_nodes_x_dim)/)
  elseif (rotation==2) then
     permutation = (/(number_nodes_x_dim-i,i=0,number_nodes_x_dim-1)/)
  else
     write(*,*) __FILE__,__LINE__,'set_permutation_1D :: ERROR! Delay cannot be >1 for edges'
  end if
  
end subroutine lagrangian_reference_fe_set_permutation_1D

!==================================================================================================
subroutine lagrangian_reference_fe_extend_list_components(this, list_1d)
  implicit none
  class(lagrangian_reference_fe_t), intent(inout) :: this
  type(list_t)                    , intent(inout) :: list_1d
  type(list_t) :: list
  integer(ip)  :: ngaus, order, i, j, k, c, node_1d, aux_1, aux_2
  type(list_iterator_t) :: list_1d_iterator
  type(list_iterator_t) :: list_iterator

  call list%create(n=this%number_n_faces+1)

  !list%p(1) = 1
  !do i = 2,this%number_n-faces+2
  !   list%p(i) = list%p(i-1) + ( list_1d%p(i)-list_1d%p(i-1) ) * this%number_field_components
  !end do
  
  do i = 1,this%number_n_faces+1
    call list%sum_to_pointer_index(i, list_1d%get_sublist_size(i) * this%number_field_components)
  end do

  call list%calculate_header()
  call list%allocate_list_from_pointer()

  aux_1 = this%number_shape_functions
  do i = 1,this%number_n_faces+1
     list_iterator = list%create_iterator(i)
     do k = 1,this%number_field_components
        aux_2 = aux_1*(k-1)
        list_1d_iterator = list_1d%create_iterator(i)
        do while(.not. list_1d_iterator%is_upper_bound())
           node_1d = list_1d_iterator%get_current()
           call list_iterator%set_current(node_1d + aux_2)
           call list_1d_iterator%next()
           call list_iterator%next()
        end do
     end do
  end do
  
  list_1d = list
  call list%free() 
end subroutine lagrangian_reference_fe_extend_list_components

!==================================================================================================
subroutine lagrangian_reference_fe_apply_femap_to_interpolation(this,map,ref,phy)
  implicit none
  class(lagrangian_reference_fe_t), intent(in)    :: this 
  type(fe_map_t)                  , intent(in)    :: map
  type(interpolation_t)           , intent(in)    :: ref
  type(interpolation_t)           , intent(inout) :: phy
  real(rp), allocatable :: wmat1(:,:,:)
  real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
  integer(ip) :: ndime,nnode,nlocs,ntens
  integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
  logical     :: khes

  khes = .false.
  if ( allocated( ref%hessian ) ) then 
     khes = .true.
  end if

  ndime = ref%number_dimensions
  ntens = ref%number_entries_symmetric_tensor
  nlocs = ref%number_quadrature_points
  !nnode = ref%number_shape_functions
  nnode = size(ref%shape_functions,2)

  ! Shape functions do not change
  !phy%shape_functions = ref%shape_functions 

  ! First derivatives do
  !if(phy%kder==1) then
  phy%shape_derivatives=0.0_rp
  do ilocs=1,phy%number_quadrature_points
     do inode=1,size(phy%shape_functions,2)!phy%number_shape_functions
        do idime=1,ndime
           do jdime=1,ndime
              phy%shape_derivatives(1,idime,inode,ilocs) = phy%shape_derivatives(1,idime,inode,ilocs) &
                   + map%inv_jacobian(jdime,idime,ilocs)*ref%shape_derivatives(1,jdime,inode,ilocs)
           end do
        end do
     end do
  end do
  !end if

  ! Second derivatives are
  !
  !    d^2 N / d x_i d x_j
  !       = (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j)
  !       + (d N / d s_k) (d^2 s_k / d x_i d x_j) 
  !
  if( khes ) then
     call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
     call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
     do ilocs=1,nlocs
        if( khes ) then
           ! Transforms the array HESSI to a symmetric matrix WMAT1
           do inode=1,nnode
              do itens = 1, ntens
                 wvec1(itens) = ref%hessian(1,itens,inode,ilocs)
              end do
              call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
           end do
           ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for each node
           do inode=1,nnode
              call btdbma(wmat2(1,1,inode),wmat1(1,1,inode),map%inv_jacobian(:,:,ilocs), &
                   &        ndime,ndime)
           end do
        end if
        if( khes ) then
           ! Add second cartesian derivatives of the map times 
           ! first derivatives of shape functions
           do inode=1,nnode
              do idime=1,ndime
                 do jdime=1,ndime
                    do kdime=1,ndime
                       wmat2(idime,jdime,inode)=wmat2(idime,jdime,inode) &
                            & + ref%shape_derivatives(1,kdime,inode,ilocs) &
                            &   * map%d2sdx(kdime,idime,jdime,ilocs)
                    end do
                 end do
              end do
           end do
        end if

        ! Writes the Hessian matrix as an array
        do inode=1,nnode
           do itens = 1, ntens
              wvec1(itens) = phy%hessian(1,itens,inode,ilocs)
           end do
           call store_symmetric_matrix_as_vector(wmat2(1,1,inode),wvec1,ndime,ntens)
        end do
     end do
     call memfree(wmat1,__FILE__,__LINE__)
     call memfree(wmat2,__FILE__,__LINE__)
  end if
end subroutine lagrangian_reference_fe_apply_femap_to_interpolation

!**************************************************************************************************
! Auxiliary procedures called by the child-classes that are not bound to the attributes
!**************************************************************************************************

!=================================================================================================
! BNM(A,B)=A!/((A-B)!B!) computes the binomial coefficient of (A,B), A>B
integer (ip) function get_binomial_coefficient(a,b)
  implicit none
  integer(ip), intent(in)    :: a,b
  if (a >= b) then
     get_binomial_coefficient = int(get_factorial(a)/(get_factorial(b)*get_factorial(a-b)))
  else
     write(*,*) 'ERROR: no binomial coef for b > a'
     check(.false.)
  end if
end function get_binomial_coefficient

!==================================================================================================
! FC(i)=i! computes the factorial of i
integer(ip) function get_factorial(i)
  implicit none
  integer(ip), intent(in)    :: i
  integer(ip) :: k
  get_factorial = 1
  do k=2,i
     get_factorial = get_factorial*k
  end do
end function get_factorial

!==================================================================================================
subroutine store_symmetric_matrix_as_vector(xmatr,vecto,ndime,ntens)
  !-----------------------------------------------------------------------
  !                                      
  ! This routine stores a symmetric matrix XMATR into a vector VECTO
  !
  !-----------------------------------------------------------------------
  implicit none
  real(rp)   , intent(in)    :: xmatr(ndime,ndime)
  real(rp)   , intent(inout) :: vecto(ntens)
  integer(ip), intent(in)    :: ndime,ntens

  if(ndime.eq.2) then
     vecto(1)=xmatr(1,1)
     vecto(3)=xmatr(1,2)
     vecto(2)=xmatr(2,2)
  else
     vecto(1)=xmatr(1,1)
     vecto(4)=xmatr(1,2)
     vecto(2)=xmatr(2,2)
     vecto(5)=xmatr(1,3)
     vecto(6)=xmatr(2,3)
     vecto(3)=xmatr(3,3)
  end if

end subroutine store_symmetric_matrix_as_vector

subroutine lagrangian_reference_fe_fill_scalar (this)
implicit none
class(lagrangian_reference_fe_t), intent(inout)    :: this 
type(polytope_tree_t) :: polytope_tree
type(node_array_t)    :: node_array, vertex_array
type(node_iterator_t) :: node_iterator
type(n_face_iterator_t) :: children_iterator
type(list_iterator_t) :: list_iterator
integer(ip) :: topology, i, n_face_dim, node, children,num_n_faces
! Change topology definition to these numbers from the very beginning (not parameter, dim independent)
if ( this%topology == topology_hex) then
 topology = 2**this%number_dimensions-1
elseif ( this%topology == topology_tet ) then
 topology = 0
end if
call polytope_tree%create( this%number_dimensions, topology )  
call node_array%create( polytope_tree, this%order(1) ) ! @sbadia: to be corrected
num_n_faces = polytope_tree%get_number_n_faces()
  ! Number nodes
  this%number_shape_functions = node_array%get_number_nodes()
  ! Number n-faces ( I don¬°t like it, not volume included...)
  this%number_n_faces = num_n_faces-1
  ! number_n-faces_dimension
  this%number_n_faces_per_dimension = 0
  this%number_n_faces_per_dimension(1) = 1
  do i = 1,num_n_faces
     n_face_dim = polytope_tree%get_n_face_dimension(i)
     this%number_n_faces_per_dimension( n_face_dim+2 ) = this%number_n_faces_per_dimension( n_face_dim+2 ) + 1
  end do  
  do i = 1,this%number_dimensions+1
     this%number_n_faces_per_dimension(i+1) = this%number_n_faces_per_dimension(i+1) + this%number_n_faces_per_dimension(i)
  end do
  ! interior_nodes_n-face  
  call this%interior_nodes_n_face%create( num_n_faces )
  do i = 1,num_n_faces
     node_iterator = node_array%create_node_iterator( polytope_tree%get_n_face(i), own_boundary = .false. )
     do while (.not. node_iterator%has_finished() )
        call this%interior_nodes_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%interior_nodes_n_face%calculate_header()
  call this%interior_nodes_n_face%allocate_list_from_pointer()
  list_iterator = this%interior_nodes_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = node_array%create_node_iterator( polytope_tree%get_n_face(i), own_boundary = .false. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! nodes_n-face
  call this%nodes_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     node_iterator = node_array%create_node_iterator( polytope_tree%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%nodes_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%nodes_n_face%calculate_header()
  call this%nodes_n_face%allocate_list_from_pointer()  
  list_iterator = this%nodes_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = node_array%create_node_iterator( polytope_tree%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! vertices_n-face
  call this%vertices_n_face%create(num_n_faces)
  call vertex_array%create( polytope_tree, order = 1 )
  do i = 1,num_n_faces
     node_iterator = vertex_array%create_node_iterator( polytope_tree%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        call this%vertices_n_face%sum_to_pointer_index(i,1)
        call node_iterator%next()
     end do
  end do
  call this%vertices_n_face%calculate_header()
  call this%vertices_n_face%allocate_list_from_pointer()
  list_iterator = this%vertices_n_face%create_iterator()
  do i = 1,num_n_faces
     node_iterator = vertex_array%create_node_iterator( polytope_tree%get_n_face(i), own_boundary = .true. )
     do while (.not. node_iterator%has_finished() )
        node = node_iterator%current()
        call list_iterator%set_current(node)
        call node_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! n-faces_n-face (NEW DEFINITION; now only n_faces of inferior dimension
  call this%n_faces_n_face%create(num_n_faces)
  do i = 1,num_n_faces
     children_iterator = polytope_tree%create_children_iterator( polytope_tree%get_n_face(i) )
     do while (.not. children_iterator%has_finished() )
        call this%n_faces_n_face%sum_to_pointer_index(i,1)
        call children_iterator%next()
     end do
  end do
  call this%n_faces_n_face%calculate_header()
  call this%n_faces_n_face%allocate_list_from_pointer()
  list_iterator = this%n_faces_n_face%create_iterator()
  do i = 1,num_n_faces
     children_iterator = polytope_tree%create_children_iterator( polytope_tree%get_n_face(i) )
     do while (.not. children_iterator%has_finished() )
        children = children_iterator%current()
        call list_iterator%set_current(children)
        call children_iterator%next()
        call list_iterator%next()
     end do
  end do
  ! orientation
  call this%orientation%create(num_n_faces)
  do i = 1,num_n_faces
     if ( n_face_dimension( polytope_tree%get_n_face(i), this%number_dimensions ) == this%number_dimensions-1 ) then
        this%orientation%a(i) = facet_orientation( polytope_tree%get_n_face(i), this%number_dimensions )
     end if
  end do
  ! own_nodes_n-face and face_integration_coupling_nodes_n-face
  if ( this%continuity ) then
     this%own_nodes_n_faces = this%interior_nodes_n_face
     ! Create a void face_integration_coupling_nodes_face type(list_t)
     call this%face_integration_coupling_nodes_facet%create(n=num_n_faces )
     call this%face_integration_coupling_nodes_facet%calculate_header()
     call this%face_integration_coupling_nodes_facet%allocate_list_from_pointer()
  else
     call this%own_nodes_n_faces%create(n=num_n_faces )
     call this%own_nodes_n_faces%sum_to_pointer_index( this%own_nodes_n_faces%get_num_pointers(), this%number_shape_functions)
     call this%own_nodes_n_faces%calculate_header()
     call this%own_nodes_n_faces%allocate_list_from_pointer()
     list_iterator = this%own_nodes_n_faces%create_iterator()
     i=1
     do while(.not. list_iterator%is_upper_bound())
        call list_iterator%set_current(i)
        call list_iterator%next()
        i = i + 1 
    enddo     
     if ( this%conformity ) then
       ! Create a void face_integration_coupling_nodes_face type(list_t)
       call this%face_integration_coupling_nodes_facet%create(n=num_n_faces)
       call this%face_integration_coupling_nodes_facet%calculate_header()
       call this%face_integration_coupling_nodes_facet%allocate_list_from_pointer()
     else
        this%face_integration_coupling_nodes_facet = this%nodes_n_face
     end if
  end if
  call polytope_tree%free()
  call node_array%free()
  call vertex_array%free()
end subroutine lagrangian_reference_fe_fill_scalar

!==================================================================================================
subroutine p_lagrangian_reference_fe_free( this )
  implicit none
  class(p_lagrangian_reference_fe_t), intent(inout) :: this
  if (associated ( this%p )) then
    call this%p%free()
    deallocate ( this%p )
  end if  
end subroutine p_lagrangian_reference_fe_free
