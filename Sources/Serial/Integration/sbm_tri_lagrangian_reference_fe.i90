! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine tri_lagrangian_reference_fe_create ( this, number_dimensions, order, field_type, continuity, enable_face_integration )
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip)                         , intent(in)    :: number_dimensions
  integer(ip)                         , intent(in)    :: order
  character(*)                        , intent(in)    :: field_type
  logical                             , intent(in)    :: continuity
  logical                  , optional , intent(in)    :: enable_face_integration

  call this%free()
  call this%set_common_data ( number_dimensions, order, field_type, continuity, enable_face_integration )
  call this%set_fe_type ( fe_type_lagrangian )
  call this%fill( )
  call this%set_nodal_quadrature ()
end subroutine tri_lagrangian_reference_fe_create

subroutine tri_lagrangian_reference_fe_create_quadrature ( this, quadrature, max_order )
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this  
  type(quadrature_t)                  , intent(inout) :: quadrature
  integer(ip)               , optional, intent(in)    :: max_order
  
  integer(ip) :: ngaus, order
  order = this%order
  if ( present(max_order) ) then
     order = max_order
  else
     order = this%order
  end if
  ngaus = this%get_number_quadrature_points_of_dimension(order,this%number_dimensions)
  call quadrature%create( this%number_dimensions, ngaus )
  call this%fill_quadrature( quadrature )
end subroutine tri_lagrangian_reference_fe_create_quadrature

subroutine tri_lagrangian_reference_fe_create_face_quadrature ( this, quadrature, max_order )
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                , intent(inout) :: quadrature
  integer(ip)                , optional, intent(in)    :: max_order

  integer(ip) :: ngaus, order, face_dimensions
  order = this%order
  if ( present(max_order) ) then
     order = max_order
  else
     order = this%order
  end if
  face_dimensions = this%number_dimensions - 1
  ngaus = this%get_number_quadrature_points_of_dimension(order,face_dimensions)
  call quadrature%create( face_dimensions, ngaus )
  call this%fill_quadrature( quadrature )
end subroutine tri_lagrangian_reference_fe_create_face_quadrature

function tri_lagrangian_reference_fe_get_nquad_of_dimension( this, order, dimension )
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                         , intent(in)    :: order
  integer(ip)                         , intent(in)    :: dimension
  integer(ip) :: tri_lagrangian_reference_fe_get_nquad_of_dimension
  tri_lagrangian_reference_fe_get_nquad_of_dimension = P_nnods(order,dimension)
  if(this%number_dimensions == 2) then
     if(this%order == 3) then
        tri_lagrangian_reference_fe_get_nquad_of_dimension = 13
     end if
  elseif(this%number_dimensions == 3) then
     if( this%order == 2) then
        tri_lagrangian_reference_fe_get_nquad_of_dimension = 11
     end if
  end if
end function

subroutine tri_lagrangian_reference_fe_create_interpolation ( this, quadrature, interpolation, compute_hessian )
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                  , intent(in)    :: quadrature
  type(interpolation_t)               , intent(inout) :: interpolation
  logical                   , optional, intent(in)    :: compute_hessian

  integer(ip) :: ntens, i

  ntens = 0
  do i = 1, this%number_dimensions
     ntens = ntens + i
  end do

  call interpolation%create( this%number_dimensions, this%number_nodes_scalar, &
                             quadrature%number_quadrature_points, ntens, compute_hessian )
  
  call this%fill_interpolation( interpolation, this%order, quadrature%coordinates )
  
end subroutine tri_lagrangian_reference_fe_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'local_face_id' of the element or
! in all the faces of the element.
subroutine tri_lagrangian_reference_fe_create_face_interpolation( this,local_face_id,            &
     &                               local_quadrature,face_interpolation)
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip)                         , intent(in)    :: local_face_id
  type(quadrature_t)                  , intent(in)    :: local_quadrature
  type(interpolation_t)               , intent(inout) :: face_interpolation

  ! Allocate the arrays of the interpolation
  call face_interpolation%create(this%number_dimensions,this%number_nodes_scalar,              &
       &                         local_quadrature%number_quadrature_points, 0 )

  ! Fill the values of the shape functions
  call this%fill_face_interpolation (face_interpolation,local_quadrature,local_face_id)
end subroutine tri_lagrangian_reference_fe_create_face_interpolation

!==================================================================================================
! This subroutine constructs a interpolation of order 1 of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine tri_lagrangian_reference_fe_create_face_local_interpolation ( this, quadrature,       &
     &                                                                   interpolation)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)               , intent(in)     :: quadrature
  type(interpolation_t)            , intent(inout) :: interpolation

  integer(ip) :: nlocs
  integer(ip) :: number_nodes_face_scalar, number_dimensions_face
  integer(ip) :: face_order

  ! I am assuming the geometric aproximation of the face can be linear
  ! this might need to be modified in the future
  number_dimensions_face   = this%number_dimensions - 1
  number_nodes_face_scalar = this%get_number_nodes_scalar_dim_order( number_dimensions_face, &
                                                                  &  this%order+1 )
  face_order = this%order

  ! Allocate the arrays of the interpolation
  call interpolation%create( number_dimensions_face, number_nodes_face_scalar, &
                             quadrature%number_quadrature_points, 0)

  ! Fill the values with the common routine for filling an interpolation
  call this%fill_interpolation( interpolation, this%order, quadrature%coordinates )

end subroutine tri_lagrangian_reference_fe_create_face_local_interpolation

!=================================================================================================
! This is a TEMPORARY SUBROUTINE for the draft of the lagrangian_reference_fe_t interm. class
recursive function tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order(this,k,p)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip)                         , intent(in)    :: k,p
  integer(ip) :: tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order
  integer(ip) :: q
  if (k == 0) then
     tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order = 1
  elseif (p == 0) then
     tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order = 1
  elseif (k == 1) then
     tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order = p+1
  elseif (k == 2) then
     tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order = int((p+1)*(p+2)/2)
  else
     tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order = & 
       & this%get_number_nodes_scalar_dim_order(k-1,0)
     do q=1,p
        tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order = & 
          & tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order + & 
          & this%get_number_nodes_scalar_dim_order(k-1,q)
     end do
  end if
end function tri_lagrangian_reference_fe_get_number_nodes_scalar_dim_order

subroutine tri_lagrangian_reference_fe_update_interpolation( this, fe_map,                       &
     &                                                        interpolation_reference_cell,      &
     &                                                        interpolation_real_cell )
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(fe_map_t)                       , intent(in)    :: fe_map
  type(interpolation_t)             , intent(in)    :: interpolation_reference_cell
  type(interpolation_t)             , intent(inout) :: interpolation_real_cell

  call P_femap_apply_to_interp( fe_map, interpolation_reference_cell,interpolation_real_cell )
end subroutine tri_lagrangian_reference_fe_update_interpolation

subroutine tri_lagrangian_reference_fe_update_interpolation_face( this,  local_face_id,          &
     &                                                             fe_map_face_restriction,       &
     &                                                             interpolation_face_restriction )
  implicit none 
  class(tri_lagrangian_reference_fe_t) , intent(in)    :: this 
  integer(ip)                           , intent(in)    :: local_face_id
  type(fe_map_face_restriction_t)       , intent(in)    :: fe_map_face_restriction
  type(interpolation_face_restriction_t), intent(inout) :: interpolation_face_restriction

  interpolation_face_restriction%active_face_id = local_face_id

  call this%update_interpolation(fe_map_face_restriction%fe_map(local_face_id),                   &
       &                         interpolation_face_restriction%interpolation(local_face_id),     &
       &                         interpolation_face_restriction%interpolation_o_map)

end subroutine tri_lagrangian_reference_fe_update_interpolation_face

function tri_lagrangian_reference_fe_get_component_node( this, node )
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                          , intent(in) :: node
  integer(ip) :: tri_lagrangian_reference_fe_get_component_node
  tri_lagrangian_reference_fe_get_component_node = this%node_component_array(node,2)
end function tri_lagrangian_reference_fe_get_component_node

function tri_lagrangian_reference_fe_get_scalar_from_vector_node( this, node )
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                          , intent(in) :: node
  integer(ip) :: tri_lagrangian_reference_fe_get_scalar_from_vector_node
  tri_lagrangian_reference_fe_get_scalar_from_vector_node = this%node_component_array(node,1)
end function tri_lagrangian_reference_fe_get_scalar_from_vector_node

function tri_lagrangian_reference_fe_get_number_nodes_scalar(this) result(number_nodes_scalar)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                                          :: number_nodes_scalar

  number_nodes_scalar = this%number_nodes_scalar
end function tri_lagrangian_reference_fe_get_number_nodes_scalar

subroutine tri_lagrangian_reference_fe_get_value_scalar( this, actual_cell_interpolation, ishape, qpoint, scalar_field )
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  integer(ip)                          , intent(in)    :: ishape
  integer(ip)                          , intent(in)    :: qpoint
  real(rp)                             , intent(out)   :: scalar_field
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  scalar_field = actual_cell_interpolation%shape_functions(ishape,qpoint)
end subroutine tri_lagrangian_reference_fe_get_value_scalar
     
subroutine tri_lagrangian_reference_fe_get_value_vector( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(tri_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t)                , intent(in)    :: actual_cell_interpolation 
  integer(ip)                             , intent(in)    :: ishape
  integer(ip)                             , intent(in)    :: qpoint
  type(vector_field_t)                    , intent(out)   :: vector_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  call vector_field%init(0.0_rp)
  call vector_field%set(this%node_component_array(ishape,2), &
                        actual_cell_interpolation%shape_functions(this%node_component_array(ishape,1),qpoint))
end subroutine tri_lagrangian_reference_fe_get_value_vector
     
subroutine tri_lagrangian_reference_fe_get_gradient_scalar( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(tri_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t)                   , intent(in)    :: actual_cell_interpolation 
  integer(ip)                             , intent(in)    :: ishape
  integer(ip)                             , intent(in)    :: qpoint
  type(vector_field_t)                    , intent(out)   :: vector_field
  integer(ip) :: idime
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  call vector_field%init(0.0_rp)
  do idime=1,this%number_dimensions
    call vector_field%set(idime,actual_cell_interpolation%shape_derivatives(idime,ishape,qpoint))
  end do
end subroutine tri_lagrangian_reference_fe_get_gradient_scalar
     
subroutine tri_lagrangian_reference_fe_get_gradient_vector( this, actual_cell_interpolation, ishape, qpoint, tensor_field )
  implicit none
  class(tri_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t), intent(in)    :: actual_cell_interpolation 
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  type(tensor_field_t)    , intent(out)   :: tensor_field
  integer(ip) :: idime
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  call tensor_field%init(0.0_rp)
  do idime=1,this%number_dimensions
    call tensor_field%set(idime,this%node_component_array(ishape,2), &
                          actual_cell_interpolation%shape_derivatives(idime,this%node_component_array(ishape,1),qpoint))
  end do
end subroutine tri_lagrangian_reference_fe_get_gradient_vector

subroutine tri_lagrangian_reference_fe_get_divergence_vector( this, actual_cell_interpolation, ishape, qpoint, scalar_field )
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  integer(ip)                          , intent(in)    :: ishape
  integer(ip)                          , intent(in)    :: qpoint
  real(rp)                             , intent(out)   :: scalar_field

  ! Locals 
  integer(ip) :: idime

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )

  scalar_field = actual_cell_interpolation%shape_derivatives(this%node_component_array(ishape,2),this%node_component_array(ishape,1),qpoint)  
end subroutine tri_lagrangian_reference_fe_get_divergence_vector 

subroutine tri_lagrangian_reference_fe_get_curl_vector( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(tri_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t), intent(in)    :: actual_cell_interpolation 
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  type(vector_field_t)    , intent(out)   :: vector_field
  
  ! Locals 
  integer(ip) :: idime, jdime, kdime
  ! Epsilon_{ijk} = Levi_Civita(i,j,k)
  real(rp), parameter :: Levi_Civita(3,3,3) = reshape( (/0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, -1.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, &
													                                            0.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, -1.0_rp, 0.0_rp, 0.0_rp, &
													                                            0.0_rp, -1.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp/), (/3, 3, 3/) )

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  

 call vector_field%init(0.0_rp)

 
 
 kdime = this%node_component_array(ishape,2)
 do idime=1,3 
   do jdime = 1,this%number_dimensions
      if ( ( idime .ne. jdime ) .and. (idime .ne. kdime) .and. (jdime .ne. kdime) ) then 
         call vector_field%set( idime, &
              Levi_Civita(idime,jdime,kdime)* &
              actual_cell_interpolation%shape_derivatives(jdime,this%node_component_array(ishape,1),qpoint) )
      end if
   end do
 end do

end subroutine tri_lagrangian_reference_fe_get_curl_vector

subroutine tri_lagrangian_reference_fe_interpolate_nodal_values( this, &
                                                               &  nodal_interpolation, &
                                                               &  nodal_values_origin, &
                                                               &  nodal_values_destination)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)                , intent(in)    :: nodal_interpolation
  real(rp)                             , intent(in)    :: nodal_values_origin(:)
  real(rp)                             , intent(inout) :: nodal_values_destination(:)
  integer(ip) :: qpoint, ishape, icomp, c_dest

  c_dest = 0
  do icomp = 1, this%number_field_components
     do qpoint = 1, nodal_interpolation%number_quadrature_points
        c_dest = c_dest + 1
        nodal_values_destination(c_dest) = 0.0_rp
        do ishape = 1, nodal_interpolation%number_shape_functions
           nodal_values_destination(c_dest) = nodal_values_destination(c_dest) + & 
                & nodal_interpolation%shape_functions(ishape,qpoint) *           &
                & nodal_values_origin(this%node_array_component(ishape,icomp))
        end do
     end do
  end do

end subroutine tri_lagrangian_reference_fe_interpolate_nodal_values

!**************************************************************************************************
! Evaluate methods for fe_function_scalar/vector/tensor_t
!**************************************************************************************************

subroutine tri_lagrangian_reference_fe_evaluate_fe_function_scalar( this, &
                                                                  &  actual_cell_interpolation, &
                                                                  &  nodal_values, &
                                                                  &  quadrature_points_values)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  real(rp)                             , intent(in)    :: nodal_values(:)
  real(rp)                             , intent(inout) :: quadrature_points_values(:)
  integer(ip)                                          :: qpoint, ishape

  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     quadrature_points_values(qpoint) = 0.0_rp
     do ishape = 1, actual_cell_interpolation%number_shape_functions
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
        & actual_cell_interpolation%shape_functions(ishape,qpoint)*nodal_values(ishape)
     end do
  end do

end subroutine tri_lagrangian_reference_fe_evaluate_fe_function_scalar

subroutine tri_lagrangian_reference_fe_evaluate_fe_function_vector( this, &
                                                                  &  actual_cell_interpolation, &
                                                                  &  nodal_values, &
                                                                  &  quadrature_points_values)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  real(rp)                             , intent(in)    :: nodal_values(:)
  type(vector_field_t)                 , intent(inout) :: quadrature_points_values(:)
  integer(ip)                                          :: qpoint, inode, icomp, inode_scalar
  
  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%number_nodes
        inode_scalar = this%node_component_array(inode,1)
        icomp        = this%node_component_array(inode,2)
        call quadrature_points_values(qpoint)%add(icomp, &
         & actual_cell_interpolation%shape_functions(inode_scalar,qpoint)*nodal_values(inode))
     end do
  end do

end subroutine tri_lagrangian_reference_fe_evaluate_fe_function_vector

subroutine tri_lagrangian_reference_fe_evaluate_fe_function_tensor( this, &
                                                                  &  actual_cell_interpolation, &
                                                                  &  nodal_values, &
                                                                  &  quadrature_points_values)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  real(rp)                             , intent(in)    :: nodal_values(:)
  type(tensor_field_t)                 , intent(inout) :: quadrature_points_values(:)

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine tri_lagrangian_reference_fe_evaluate_fe_function_tensor

!==================================================================================================
function tri_lagrangian_reference_fe_check_compatibility_of_vefs                   &
     &                      (target_reference_fe,source_reference_fe, source_vef_id,target_vef_id)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)               , intent(in)  :: source_reference_fe
  integer(ip)                         , intent(in)  :: source_vef_id ! Local vef ID
  integer(ip)                         , intent(in)  :: target_vef_id ! Local vef ID
  logical :: tri_lagrangian_reference_fe_check_compatibility_of_vefs 

  select type(source_reference_fe)
     class is(tri_lagrangian_reference_fe_t)

        ! Get number nodes per dimension
        assert (target_reference_fe%order == source_reference_fe%order)
        assert (target_reference_fe%number_dimensions == source_reference_fe%number_dimensions)
        assert (target_reference_fe%get_vef_dimension(target_vef_id) == source_reference_fe%get_vef_dimension(source_vef_id))
        assert (target_reference_fe%get_vef_dimension(target_vef_id) < 3)
        assert (target_reference_fe%number_field_components == source_reference_fe%number_field_components)
        assert (target_reference_fe%get_number_own_nodes_vef(target_vef_id) == source_reference_fe%get_number_own_nodes_vef(source_vef_id))
        tri_lagrangian_reference_fe_check_compatibility_of_vefs = .true.
     class default
        tri_lagrangian_reference_fe_check_compatibility_of_vefs = .false.
  end select
 
end function tri_lagrangian_reference_fe_check_compatibility_of_vefs

!==================================================================================================
subroutine tri_lagrangian_reference_fe_fill_interior_points_permutation(this,                   &
                                                                        dimension,              &
                                                                        number_interior_points, &
                                                                        interior_points_permutation )
  implicit none
  class(tri_lagrangian_reference_fe_t) , intent(inout) :: this 
  integer(ip)                          , intent(in)    :: dimension
  integer(ip)                          , intent(in)    :: number_interior_points
  integer(ip)            , allocatable , intent(inout) :: interior_points_permutation(:,:)

  integer(ip) :: number_interior_points_x_dim
  integer(ip) :: number_of_possible_permutations
  
  if ( this%number_dimensions == 2 ) then
    assert ( dimension == 1 )
  else if ( this%number_dimensions == 3) then
    assert ( dimension == 1 .or. dimension == 2)
  else
    check(.false.)
  end if
  
  if ( allocated(interior_points_permutation) ) call memfree(interior_points_permutation,__FILE__,__LINE__)
  
  number_interior_points_x_dim = int(real(number_interior_points,rp)**(1.0_rp/real(dimension,rp)),ip)
  
  number_of_possible_permutations = this%number_rotations_per_dimension(dimension) * &
                                    this%number_orientations_per_dimension(dimension)
  
  call memalloc (number_interior_points,          &
                 number_of_possible_permutations, &
                 interior_points_permutation,     &
                 __FILE__,__LINE__)
  
  call tri_lagrangian_reference_fe_fill_permutation_array(this,                         &
                                                          dimension,                    &
                                                          number_interior_points_x_dim, &
                                                          interior_points_permutation)
  
end subroutine tri_lagrangian_reference_fe_fill_interior_points_permutation


!==================================================================================================
subroutine tri_lagrangian_reference_fe_fill (this)
  implicit none
  ! Parameters
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip) :: c, i, j, dimension, number_interior_nodes, number_interior_nodes_scalar
  integer(ip) :: column, inode, idime, inode_scalar, num_columns
  
  call tri_lagrangian_reference_fe_fill_scalar (this)
  
  call memalloc (this%number_dimensions-1,this%number_rotations_per_dimension,__FILE__,__LINE__)
  call memalloc (this%number_dimensions-1,this%number_orientations_per_dimension,__FILE__,__LINE__)
  
  if ( this%continuity ) allocate(this%own_node_permutations(this%number_dimensions-1))
  
  do dimension = 1, this%number_dimensions-1
  
     this%number_rotations_per_dimension(dimension) = dimension + 1
     this%number_orientations_per_dimension(dimension) = dimension
     
     if ( this%continuity ) then
       ! Compute the number of interior nodes X (edge or face)
       j = this%get_first_vef_id_of_dimension(dimension)
       number_interior_nodes = this%get_number_own_nodes_vef(j)
          
       call this%fill_interior_points_permutation(dimension,             &
                                                  number_interior_nodes, &
                                                  this%own_node_permutations(dimension)%a)
       
     end if
  
  end do
  
  if ( this%number_field_components /= 1 ) then
     call tri_lagrangian_reference_fe_fill_field_components( this )
     if ( this%continuity ) then
       do dimension = 1, this%number_dimensions-1
          ! Compute the number of interior nodes x edge or face
          j = this%get_first_vef_id_of_dimension(dimension)
          number_interior_nodes        = this%get_number_own_nodes_vef(j)
          number_interior_nodes_scalar = number_interior_nodes/this%number_field_components
          num_columns = this%number_rotations_per_dimension(dimension) * &
                        this%number_orientations_per_dimension(dimension) 
          call memrealloc ( number_interior_nodes, &
                            num_columns, &
                            this%own_node_permutations(dimension)%a, &
                            __FILE__, &
                            __LINE__  )
          do column = 1, num_columns
             ! Fill the rest of components
             inode = number_interior_nodes_scalar
             do idime = 2, this%number_field_components
                ! This is taking advantage of the face that we know how the DoF are ordered
                ! in case this ordering change, this will not work anymore.
                do inode_scalar = 1, number_interior_nodes_scalar
                   inode = inode + 1
                   this%own_node_permutations(dimension)%a(inode,column) = number_interior_nodes_scalar * &
                        (idime-1) +  this%own_node_permutations(dimension)%a(inode_scalar,column)
                end do
             end do
          end do
       end do
     end if
  else
     this%number_nodes_scalar = this%number_nodes
  end if
  
  call memalloc( this%number_nodes, 2, this%node_component_array, __FILE__, __LINE__ )
  call memalloc( this%number_nodes_scalar, this%number_field_components, this%node_array_component, __FILE__, __LINE__ )

  c = 1
  do i = 1, this%number_field_components
     do j = 1, this%number_nodes_scalar
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do
  
end subroutine tri_lagrangian_reference_fe_fill
!==================================================================================================

!==================================================================================================
subroutine tri_lagrangian_reference_fe_fill_permutation_array(this,               &
                                                              dimension,          &
                                                              number_nodes_x_dim, &
                                                              permutation_array)
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this 
  integer(ip)                         , intent(in)    :: dimension
  integer(ip)                         , intent(in)    :: number_nodes_x_dim
  integer(ip)                         , intent(inout) :: permutation_array(:,:)

  integer(ip) :: irotation, iorientation, column

  column = 1
  do iorientation = 1, this%number_orientations_per_dimension(dimension)
     do irotation = 1, this%number_rotations_per_dimension(dimension)
        if (dimension == 1) then
           call P_permute_or_1d(permutation_array(:,column), &
                                number_nodes_x_dim,          &
                                irotation)
        elseif (dimension == 2) then
           call P_permute_or_2d(permutation_array(:,column), &
                                number_nodes_x_dim,          &
                                iorientation,                &
                                irotation)
        else 
           check (.false.)
        end if
        column = column + 1
     end do
  end do

end subroutine tri_lagrangian_reference_fe_fill_permutation_array
!==================================================================================================

subroutine tri_lagrangian_reference_fe_free ( this )
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this 
  
  ! tri_lagrangian_reference_fe_t variables
  if(allocated(this%node_component_array)) & 
       call memfree(this%node_component_array,__FILE__,__LINE__)
  if(allocated(this%node_array_component)) & 
       call memfree(this%node_array_component,__FILE__,__LINE__)
  this%number_nodes_scalar = 0
  call reference_fe_free ( this )
end subroutine tri_lagrangian_reference_fe_free

function tri_lagrangian_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(in) :: this 
  real(rp)  :: tri_lagrangian_reference_fe_get_characteristic_length 

  tri_lagrangian_reference_fe_get_characteristic_length =  2.0_rp
end function tri_lagrangian_reference_fe_get_characteristic_length

subroutine tri_lagrangian_reference_fe_fill_field_components (this)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this
  call tri_lagrangian_reference_fe_extend_list_components( this, this%nodes_vef)
  call tri_lagrangian_reference_fe_extend_list_components( this, this%interior_nodes_vef)
  call tri_lagrangian_reference_fe_extend_list_components( this, this%own_nodes_vef )
  call tri_lagrangian_reference_fe_extend_list_components( this, this%face_integration_coupling_nodes_face )
  this%number_nodes_scalar = this%number_nodes
  this%number_nodes = this%number_nodes_scalar * this%number_field_components
end subroutine tri_lagrangian_reference_fe_fill_field_components

subroutine tri_lagrangian_reference_fe_set_nodal_quadrature (this)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this
  
  ! Create nodal quadrature
  call this%nodal_quadrature%create(this%number_dimensions,this%number_nodes_scalar)

  ! Fill nodal quadrature
  call P_fill_nodal_quadrature ( this%nodal_quadrature, this%order )
end subroutine tri_lagrangian_reference_fe_set_nodal_quadrature

subroutine tri_lagrangian_reference_fe_set_scalar_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values, unknown_component)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: code
  real(rp)                             , intent(in)    :: values(:)
  integer(ip)                          , intent(in)    :: nodal_codes(:)
  real(rp)                             , intent(inout) :: nodal_values(:)
  integer(ip), optional                , intent(in)    :: unknown_component
  integer(ip) :: i, icomp

  assert(size(nodal_values) == this%number_nodes)
  assert(size(values) == this%number_nodes_scalar)

  icomp = 1
  if(present(unknown_component)) icomp = unknown_component

  do i = 1, this%number_nodes_scalar
     if(nodal_codes(this%node_array_component(i,icomp)) == code) then
        nodal_values(this%node_array_component(i,icomp)) = values(i)
     end if
  end do
     
end subroutine tri_lagrangian_reference_fe_set_scalar_field_to_nodal_values

subroutine tri_lagrangian_reference_fe_set_vector_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: code
  type(vector_field_t)                 , intent(in)    :: values(:)
  integer(ip)                          , intent(in)    :: nodal_codes(:)
  real(rp)                             , intent(inout) :: nodal_values(:)
  integer(ip) :: i, icomp

  assert(size(nodal_values) == this%number_nodes)
  assert(size(values) == this%number_nodes_scalar)

  do icomp = 1, this%number_field_components
     do i = 1, this%number_nodes_scalar
        if(nodal_codes(this%node_array_component(i,icomp)) == code) then
           nodal_values(this%node_array_component(i,icomp)) = values(i)%get(icomp)
        end if
     end do
  end do
     
end subroutine tri_lagrangian_reference_fe_set_vector_field_to_nodal_values

subroutine tri_lagrangian_reference_fe_set_tensor_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: code
  type(tensor_field_t)                 , intent(in)    :: values(:)
  integer(ip)                          , intent(in)    :: nodal_codes(:)
  real(rp)                             , intent(inout) :: nodal_values(:)
  integer(ip) :: i, icomp, jcomp

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine tri_lagrangian_reference_fe_set_tensor_field_to_nodal_values

subroutine tri_lagrangian_reference_fe_extend_list_components(this, list_1d)
  implicit none
  ! Parameters
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this
  type(list_t), intent(inout) :: list_1d
  type(list_t) :: list

  integer(ip) :: ngaus, order, i, j, k, c, node_1d, aux_1, aux_2

  call list%create(n=this%number_vefs+1)

  list%p(1) = 1
  do i = 2,this%number_vefs+2
     list%p(i) = list%p(i-1) + ( list_1d%p(i)-list_1d%p(i-1) ) * this%number_field_components
  end do

  call list%allocate_list_from_pointer()

  aux_1 = this%number_nodes
  do i = 1,this%number_vefs+1
     c = list%p(i)
     do k = 1,this%number_field_components
        aux_2 = aux_1*(k-1)
        do j = list_1d%p(i),list_1d%p(i+1)-1
           node_1d = list_1d%l(j)
           list%l(c) = node_1d + aux_2
           c = c + 1
        end do
     end do
  end do

  call memrealloc ( size(list%p), list_1d%p, __FILE__, __LINE__ )
  call memrealloc ( size(list%l), list_1d%l, __FILE__, __LINE__ )
  list_1d = list
  call list%free() 

end subroutine tri_lagrangian_reference_fe_extend_list_components

subroutine tri_lagrangian_reference_fe_fill_scalar (this)
  implicit none
  ! Parameters
  class(tri_lagrangian_reference_fe_t), intent(inout) :: this

  ! Local variables
  integer(ip)              :: nd,p
  integer(ip)              :: i,j,k
  integer(ip)              :: co,c2,c3,c4       ! Counters
  integer(ip)              :: aux1,aux2,aux3
  integer(ip)              :: no                ! #vefs in the element
  integer(ip)              :: nn                ! #nodes 
  integer(ip)              :: nt                ! Length of ntxob
  integer(ip)              :: nc                ! #corners x #{vefs delimited by each corner}
  integer(ip), allocatable :: idm(:)            ! Stores the corners f each element
  integer(ip), allocatable :: idcro(:,:)        ! Array of corners belonging to the nth vef
  integer(ip), allocatable :: nodes(:,:)        ! Coordinates of the corners of the element
  integer(ip), allocatable :: objec(:,:)        ! Coordinates that define an vef
  type(list_iterator_t)    :: iterator

  ! Initilize values
  nd = this%number_dimensions
  p  = this%order
  no = 0
  nn = 0
  nt = 0
  nc = 0

  ! Allocate auxiliary arrays
  call memalloc(     nd+1,   idm, __FILE__, __LINE__ )
  call memalloc( nd, nd+1, nodes, __FILE__, __LINE__ )
  call memalloc( nd, nd+1, objec, __FILE__, __LINE__ )

  ! Initialize number_vefs_dimension
  this%number_vefs_dimension    = 0
  this%number_vefs_dimension(1) = 1

  ! Fill number_vefs_dimension and compute nt, nc, nn
  do k = 0,nd
     i   = P_bnm(nd+1,k+1)          ! #vefs of dimension k
     j   = P_nnods(k,p)             ! #nodes vef dim k order p
     no  = no + i                   ! compute #vefs
     nn  = nn + i*inods(k,p)        ! #nodes inside vefs of dimension k
     nt  = nt + i*j                 ! nodes in the closure of the vef
     nc  = nc + i*(k+1)             ! corners delimiting vefs of dimension k
     ! Pointer to obj id by dim. Local obj of dim k are nvef_dim(k):nvef_dim(k+1)
     this%number_vefs_dimension(k+2) = this%number_vefs_dimension(k+1) + i 
  end do

  ! Set constant values of reference_element
  this%number_vefs  = no - 1
  this%number_nodes = nn

  ! Allocate arrays
  call this%orientation%create(no)
  call this%interior_nodes_vef%create(n=no)
  call this%nodes_vef%create(n=no)
  call this%vertices_vef%create(n=no)

  ! Create auxiliar matrix nodes with the coordinates of the corners
  nodes = 0
  do k=1,nd
     nodes(k,k+1) = 1
  end do

  !Initialize pointers
  this%interior_nodes_vef%p(1) = 1
  this%nodes_vef%p(1)          = 1
  this%vertices_vef%p(1)       = 1
  
  ! Loop over dimensions
  do k = 0,nd
     aux1 = inods(k,p)            ! Interior nodes for a vef of dim k
     aux3 = P_nnods(k,p)          ! Total nodes for a vef of dim k
     if ( p == -1 ) then          ! In void_fes there are no nodes
        aux1 = 0
        aux3 = 0
     end if
     aux2 = k+1                   ! Corners for a vef of dim k

     ! Loop over vefs of dimension k
     do i = this%number_vefs_dimension(k+1),this%number_vefs_dimension(k+2)-1 
        this%interior_nodes_vef%p(i+1) = this%interior_nodes_vef%p(i) + aux1 ! assign pointers
        this%nodes_vef%p(i+1)          = this%nodes_vef%p(i)          + aux3 ! assign pointers
        this%vertices_vef%p(i+1)       = this%vertices_vef%p(i)       + aux2 ! assign pointers
     end do
  end do
  
  call this%interior_nodes_vef%allocate_list_from_pointer()
  call this%nodes_vef%allocate_list_from_pointer()
  call this%vertices_vef%allocate_list_from_pointer()

  call memalloc( nd+2, no, idcro, __FILE__, __LINE__) ! Array of dim and corners belonging to each vef
  
  ! Each vef of dimension k is defined by a set of k+1 corners (idcro stores this info)
  i = 1
  j = 1
  k = 1 
  idcro = -1
  do k=0,nd
     call crxob(idcro,k,i,idm,nd,1,no,j)
  end do
  
  do i = 1,nd+2
     
  end do
  
  ! Initialize counters
  co = 0 ! Counter of vef
  c2 = 1 ! this%interior_nodes_vef%p counter
  c3 = 0 ! this%vertices_vef%p counter
  c4 = 1 ! this%nodes_vef%p counter

  ! Loop over vefs dimensions
  do k = 0,nd

     ! Loop over the number of vefs of dimension k
     do i=1, P_bnm(nd+1,k+1)
        ! Fill this%vertices_vef%l for vef co
        co = co + 1 
        call P_orientation_vef(this%orientation%a(co),k,nd,i)
        this%vertices_vef%l(c3+1:c3+k+1) = idcro(2:k+2,co)
        c3 = c3 + k + 1

        if ( p > 0 ) then ! Do nothing for void fe
           ! Objec stores the coordinates of the corners defining vef co
           objec(:,1) = nodes(:,idcro(2,co))
           do j=1,k
              objec(:,j+1) = nodes(:,idcro(j+2,co)) - nodes(:,idcro(2,co))
           end do
           
           ! Fill ntxobj and ndxobj for vef co
           call ntxob_fill(this%nodes_vef%l,c4,0,p,1,idm,nd,k,p,objec,nt)
           call ntxob_fill(this%interior_nodes_vef%l,c2,1,p-1,1,idm,nd,k,p,objec,nt)
        end if
        
     end do
     
  end do
  
  ! Create face_integration_coupling_nodes_vef
  if ( this%continuity ) then
     this%own_nodes_vef = this%interior_nodes_vef
     ! Create a void face_integration_coupling_nodes_face type(list_t)
     call this%face_integration_coupling_nodes_face%create(n=no)
     call this%face_integration_coupling_nodes_face%calculate_header()
     call this%face_integration_coupling_nodes_face%allocate_list_from_pointer()
  else
     call this%own_nodes_vef%create(n=no)
     call this%own_nodes_vef%sum_to_pointer_index(this%own_nodes_vef%get_num_pointers(), this%number_nodes)
     call this%own_nodes_vef%calculate_header()
     call this%own_nodes_vef%allocate_list_from_pointer()
     
     iterator = this%own_nodes_vef%create_iterator()
     i=1
     do while(.not. iterator%is_upper_bound())
        call iterator%set_current(i)
        call iterator%next()
        i = i + 1 
    enddo
     
     if ( this%conformity ) then
       ! Create a void face_integration_coupling_nodes_face type(list_t)
       call this%face_integration_coupling_nodes_face%create(n=no)
       call this%face_integration_coupling_nodes_face%calculate_header()
       call this%face_integration_coupling_nodes_face%allocate_list_from_pointer()
     else
       this%face_integration_coupling_nodes_face = this%nodes_vef
     end if
  end if

  ! Deallocate auxiliary arrays
  call memfree(   idm, __FILE__, __LINE__ )  
  call memfree( idcro, __FILE__, __LINE__ )
  call memfree( nodes, __FILE__, __LINE__ )
  call memfree( objec, __FILE__, __LINE__ )
  
end subroutine tri_lagrangian_reference_fe_fill_scalar

!=================================================================================================
! BNM(A,B)=A!/((A-B)!B!) computes the binomial coefficient of (A,B), A>B
integer (ip) function P_bnm(a,b)
  implicit none
  integer(ip) :: a,b
  if (a >= b) then
     P_bnm = int(P_fc(a)/(P_fc(b)*P_fc(a-b)))
  else
     write(*,*) 'ERROR: no binomial coef for b > a'
     check(.false.)
  end if
end function P_bnm

!==================================================================================================
subroutine P_orientation_vef(o,od,nd,io)
  implicit none
  ! Parameters
  integer(ip), intent(out) :: o
  integer(ip), intent(in)  :: od,nd,io  ! io=numbering of the vef in the od dimension

  if (nd == 3 .and. od == 2) then
     o = modulo(io+1,2)
  elseif (nd>3) then
     write(*,*) __FILE__,__LINE__,'WARNING!! the orientation is not defined for dimension >3'
  else
     o = 0
  end if
end subroutine P_orientation_vef

!==================================================================================================
! FC(k)=k! computes the factorial of k 
integer(ip) function P_fc(i)
  implicit none
  integer(ip) :: i, k
  P_fc = 1
  do k=2,i
     P_fc = P_fc*k
  end do
end function P_fc

!-------------------------------------------------------------------------
subroutine tri_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  ! 
  !     This routine sets up the integration constants of open rules for
  !     triangles and tetrahedra
  ! 
  !             NDIME = 2             NDIME = 3
  ! 
  !          NGAUS  EXACT POL.     NGAUS  EXACT POL. 
  !          -----  ----------     -----  ----------
  !            1       p1            1       p1
  !            3       p2            4       p2
  !            4       p3            5       p3
  !            6       p4           11       p4
  !            7       p5           14       p5
  !           13       p7
  !           19       p9
  !           28       p11
  !
  !-----------------------------------------------------------------------
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t), intent(inout) :: quadrature
  real(rp)    :: a,b,c,d,e,f,g,h,p,q,r,s,t,u,v,w,x,y,z
  real(rp)    :: w1,w2,w3,w4,w5,w6,w7,w8
  real(rp)    :: ex1,et1,ez1,ex2,et2,ez2
  integer(ip) :: ndime,ngaus

  ndime = quadrature%number_dimensions
  ngaus = quadrature%number_quadrature_points

  ! Line integral (the same as for brick elements)
  if(ndime==1) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)=0.0_rp
        quadrature%weight(  1)=2.0_rp
     else if(ngaus==2) then
        quadrature%coordinates(1,1)=-0.577350269189626_rp
        quadrature%coordinates(1,2)= 0.577350269189626_rp
        quadrature%weight(  1)= 1.0_rp
        quadrature%weight(  2)= 1.0_rp
     else if(ngaus==3) then
        quadrature%coordinates(1,1)=-0.774596669241483_rp
        quadrature%coordinates(1,2)= 0.0_rp
        quadrature%coordinates(1,3)= 0.774596669241483_rp
        quadrature%weight(  1)= 0.555555555555556_rp
        quadrature%weight(  2)= 0.888888888888889_rp
        quadrature%weight(  3)= 0.555555555555556_rp
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        stop
     end if

     ! Area integral (triangles)
  else if(ndime==2) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/3.0_rp
        quadrature%weight(  1)= 1.0_rp/2.0_rp
     else if(ngaus==3) then
        quadrature%coordinates(1,2)= 2.0_rp/3.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,3)= 2.0_rp/3.0_rp
        quadrature%coordinates(1,1)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/6.0_rp
        quadrature%weight(  2)= 1.0_rp/6.0_rp
        quadrature%weight(  3)= 1.0_rp/6.0_rp
        quadrature%weight(  1)= 1.0_rp/6.0_rp
     else if(ngaus==4) then
        quadrature%coordinates(1,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/3.0_rp
        quadrature%coordinates(1,2)= 1.0_rp/5.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/5.0_rp
        quadrature%coordinates(1,3)= 3.0_rp/5.0_rp
        quadrature%coordinates(2,3)= 1.0_rp/5.0_rp
        quadrature%coordinates(1,4)= 1.0_rp/5.0_rp
        quadrature%coordinates(2,4)= 3.0_rp/5.0_rp
        quadrature%weight(  1)=-27.0_rp/96.0_rp
        quadrature%weight(  2)= 25.0_rp/96.0_rp
        quadrature%weight(  3)= 25.0_rp/96.0_rp
        quadrature%weight(  4)= 25.0_rp/96.0_rp 
     else if(ngaus==6) then
        ex1 = 0.816847572980459_rp
        et1 = 0.091576213509771_rp
        ez1 = 0.091576213509771_rp
        ex2 = 0.108103018168070_rp
        et2 = 0.445948490915965_rp
        ez2 = 0.445948490915965_rp
        quadrature%coordinates(1,3)= ex1
        quadrature%coordinates(2,3)= et1
        quadrature%coordinates(1,1)= et1
        quadrature%coordinates(2,1)= ez1
        quadrature%coordinates(1,6)= ez1
        quadrature%coordinates(2,6)= ex1
        quadrature%coordinates(1,4)= ex2
        quadrature%coordinates(2,4)= et2
        quadrature%coordinates(1,5)= et2
        quadrature%coordinates(2,5)= ez2
        quadrature%coordinates(1,2)= ez2
        quadrature%coordinates(2,2)= ex2
        a = 0.054975870996713638_rp
        b = 0.1116907969117165_rp    
        quadrature%weight(3)  = a
        quadrature%weight(1)  = a
        quadrature%weight(6)  = a
        quadrature%weight(4)  = b
        quadrature%weight(5)  = b
        quadrature%weight(2)  = b
     else if(ngaus==7) then
        a = 1.0_rp / 3.0_rp
        b = ( 9.0_rp + 2.0_rp * sqrt ( 15.0_rp ) ) / 21.0_rp
        c = ( 6.0_rp -          sqrt ( 15.0_rp ) ) / 21.0_rp
        d = ( 9.0_rp - 2.0_rp * sqrt ( 15.0_rp ) ) / 21.0_rp
        e = ( 6.0_rp +          sqrt ( 15.0_rp ) ) / 21.0_rp
        w1 = 0.1125_rp
        w2 = ( 155.0_rp - sqrt ( 15.0_rp ) ) / 2400.0_rp
        w3 = ( 155.0_rp + sqrt ( 15.0_rp ) ) / 2400.0_rp
        quadrature%coordinates(1,1)= a
        quadrature%coordinates(2,1)= a
        quadrature%coordinates(1,2)= b
        quadrature%coordinates(2,2)= c
        quadrature%coordinates(1,3)= c
        quadrature%coordinates(2,3)= b
        quadrature%coordinates(1,4)= c
        quadrature%coordinates(2,4)= c
        quadrature%coordinates(1,5)= d
        quadrature%coordinates(2,5)= e
        quadrature%coordinates(1,6)= e
        quadrature%coordinates(2,6)= d
        quadrature%coordinates(1,7)= e
        quadrature%coordinates(2,7)= e
        quadrature%weight(  1)= w1
        quadrature%weight(  2)= w2
        quadrature%weight(  3)= w2
        quadrature%weight(  4)= w2
        quadrature%weight(  5)= w3
        quadrature%weight(  6)= w3
        quadrature%weight(  7)= w3
     else if(ngaus==13) then
        a = 0.333333333333333_rp
        b = 0.479308067841923_rp
        c = 0.869739794195568_rp
        d = 0.638444188569809_rp
        e = 0.260345966079038_rp
        f = 0.065130102902216_rp
        g = 0.312865496004875_rp
        h = 0.048690315425316_rp
        w1=-0.149570044467670_rp/2.0_rp
        w2= 0.175615257433204_rp/2.0_rp
        w3= 0.053347235608839_rp/2.0_rp
        w4= 0.077113760890257_rp/2.0_rp
        quadrature%coordinates(1, 1)= a
        quadrature%coordinates(2, 1)= a         
        quadrature%coordinates(1, 2)= e
        quadrature%coordinates(2, 2)= e
        quadrature%coordinates(1, 3)= b
        quadrature%coordinates(2, 3)= e        
        quadrature%coordinates(1, 4)= e
        quadrature%coordinates(2, 4)= b        
        quadrature%coordinates(1, 5)= f
        quadrature%coordinates(2, 5)= f        
        quadrature%coordinates(1, 6)= c
        quadrature%coordinates(2, 6)= f        
        quadrature%coordinates(1, 7)= f
        quadrature%coordinates(2, 7)= c        
        quadrature%coordinates(1, 8)= d
        quadrature%coordinates(2, 8)= g        
        quadrature%coordinates(1, 9)= d
        quadrature%coordinates(2, 9)= h        
        quadrature%coordinates(1,10)= g
        quadrature%coordinates(2,10)= d        
        quadrature%coordinates(1,11)= g
        quadrature%coordinates(2,11)= h        
        quadrature%coordinates(1,12)= h
        quadrature%coordinates(2,12)= d        
        quadrature%coordinates(1,13)= h
        quadrature%coordinates(2,13)= g
        quadrature%weight( 1) = w1
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2
        quadrature%weight( 4) = w2
        quadrature%weight( 5) = w3
        quadrature%weight( 6) = w3
        quadrature%weight( 7) = w3
        quadrature%weight( 8) = w4
        quadrature%weight( 9) = w4
        quadrature%weight(10) = w4
        quadrature%weight(11) = w4
        quadrature%weight(12) = w4
        quadrature%weight(13) = w4
     else if(ngaus.eq.19) then
        a = 1.0_rp / 3.0_rp
        b = 0.02063496160252593_rp
        c = 0.4896825191987370_rp
        d = 0.1258208170141290_rp
        e = 0.4370895914929355_rp
        f = 0.6235929287619356_rp
        g = 0.1882035356190322_rp
        r = 0.9105409732110941_rp
        s = 0.04472951339445297_rp
        t = 0.7411985987844980_rp
        u = 0.03683841205473626_rp
        v = 0.22196288916076574_rp

        w1 = 0.09713579628279610_rp/2.0_rp
        w2 = 0.03133470022713983_rp/2.0_rp
        w3 = 0.07782754100477543_rp/2.0_rp
        w4 = 0.07964773892720910_rp/2.0_rp
        w5 = 0.02557767565869810_rp/2.0_rp
        w6 = 0.04328353937728940_rp/2.0_rp

        quadrature%coordinates(1, 1) = a 
        quadrature%coordinates(1, 2) = b
        quadrature%coordinates(1, 3) = c 
        quadrature%coordinates(1, 4) = c 
        quadrature%coordinates(1, 5) = d 
        quadrature%coordinates(1, 6) = e
        quadrature%coordinates(1, 7) = e
        quadrature%coordinates(1, 8) = f 
        quadrature%coordinates(1, 9) = g 
        quadrature%coordinates(1,10) = g
        quadrature%coordinates(1,11) = r
        quadrature%coordinates(1,12) = s
        quadrature%coordinates(1,13) = s
        quadrature%coordinates(1,14) = t
        quadrature%coordinates(1,15) = t
        quadrature%coordinates(1,16) = u
        quadrature%coordinates(1,17) = u
        quadrature%coordinates(1,18) = v
        quadrature%coordinates(1,19) = v

        quadrature%coordinates(2, 1) = a
        quadrature%coordinates(2, 2) = c
        quadrature%coordinates(2, 3) = b
        quadrature%coordinates(2, 4) = c
        quadrature%coordinates(2, 5) = e
        quadrature%coordinates(2, 6) = d
        quadrature%coordinates(2, 7) = e
        quadrature%coordinates(2, 8) = g
        quadrature%coordinates(2, 9) = f
        quadrature%coordinates(2,10) = g
        quadrature%coordinates(2,11) = s
        quadrature%coordinates(2,12) = r
        quadrature%coordinates(2,13) = s
        quadrature%coordinates(2,14) = u
        quadrature%coordinates(2,15) = v
        quadrature%coordinates(2,16) = t
        quadrature%coordinates(2,17) = v
        quadrature%coordinates(2,18) = t
        quadrature%coordinates(2,19) = u

        quadrature%weight( 1) = w1
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2
        quadrature%weight( 4) = w2
        quadrature%weight( 5) = w3
        quadrature%weight( 6) = w3
        quadrature%weight( 7) = w3
        quadrature%weight( 8) = w4
        quadrature%weight( 9) = w4
        quadrature%weight(10) = w4
        quadrature%weight(11) = w5
        quadrature%weight(12) = w5
        quadrature%weight(13) = w5
        quadrature%weight(14) = w6
        quadrature%weight(15) = w6
        quadrature%weight(16) = w6
        quadrature%weight(17) = w6
        quadrature%weight(18) = w6
        quadrature%weight(19) = w6
     else if(ngaus.eq.28) then
        a = 1.0_rp / 3.0_rp
        b = 0.9480217181434233_rp
        c = 0.02598914092828833_rp
        d = 0.8114249947041546_rp
        e = 0.09428750264792270_rp
        f = 0.01072644996557060_rp
        g = 0.4946367750172147_rp
        p = 0.5853132347709715_rp
        q = 0.2073433826145142_rp
        r = 0.1221843885990187_rp
        s = 0.4389078057004907_rp
        t = 0.6779376548825902_rp
        u = 0.04484167758913055_rp
        v = 0.27722066752827925_rp
        w = 0.8588702812826364_rp
        x = 0.0_rp
        y = 0.1411297187173636_rp

        w1 = 0.08797730116222190_rp/2.0_rp
        w2 = 0.008744311553736190_rp/2.0_rp
        w3 = 0.03808157199393533_rp/2.0_rp
        w4 = 0.01885544805613125_rp/2.0_rp
        w5 = 0.07215969754474100_rp/2.0_rp
        w6 = 0.06932913870553720_rp/2.0_rp
        w7 = 0.04105631542928860_rp/2.0_rp
        w8 = 0.007362383783300573_rp/2.0_rp

        quadrature%coordinates(1, 1) = a  
        quadrature%coordinates(1, 2) = b  
        quadrature%coordinates(1, 3) = c  
        quadrature%coordinates(1, 4) = c  
        quadrature%coordinates(1, 5) = d  
        quadrature%coordinates(1, 6) = e  
        quadrature%coordinates(1, 7) = e  
        quadrature%coordinates(1, 8) = f  
        quadrature%coordinates(1, 9) = g
        quadrature%coordinates(1,10) = g
        quadrature%coordinates(1,11) = p 
        quadrature%coordinates(1,12) = q 
        quadrature%coordinates(1,13) = q
        quadrature%coordinates(1,14) = r 
        quadrature%coordinates(1,15) = s 
        quadrature%coordinates(1,16) = s 
        quadrature%coordinates(1,17) = t 
        quadrature%coordinates(1,18) = t 
        quadrature%coordinates(1,19) = u 
        quadrature%coordinates(1,20) = u 
        quadrature%coordinates(1,21) = v 
        quadrature%coordinates(1,22) = v 
        quadrature%coordinates(1,23) = w 
        quadrature%coordinates(1,24) = w 
        quadrature%coordinates(1,25) = x 
        quadrature%coordinates(1,26) = x 
        quadrature%coordinates(1,27) = y 
        quadrature%coordinates(1,28) = y

        quadrature%coordinates(2, 1) = a  
        quadrature%coordinates(2, 2) = c  
        quadrature%coordinates(2, 3) = b  
        quadrature%coordinates(2, 4) = c  
        quadrature%coordinates(2, 5) = e  
        quadrature%coordinates(2, 6) = d  
        quadrature%coordinates(2, 7) = e  
        quadrature%coordinates(2, 8) = g  
        quadrature%coordinates(2, 9) = f  
        quadrature%coordinates(2,10) = g  
        quadrature%coordinates(2,11) = q  
        quadrature%coordinates(2,12) = p  
        quadrature%coordinates(2,13) = q
        quadrature%coordinates(2,14) = s  
        quadrature%coordinates(2,15) = r  
        quadrature%coordinates(2,16) = s  
        quadrature%coordinates(2,17) = u  
        quadrature%coordinates(2,18) = v  
        quadrature%coordinates(2,19) = t  
        quadrature%coordinates(2,20) = v  
        quadrature%coordinates(2,21) = t  
        quadrature%coordinates(2,22) = u  
        quadrature%coordinates(2,23) = x  
        quadrature%coordinates(2,24) = y  
        quadrature%coordinates(2,25) = w  
        quadrature%coordinates(2,26) = y  
        quadrature%coordinates(2,27) = w  
        quadrature%coordinates(2,28) = x

        quadrature%weight( 1) = w1 
        quadrature%weight( 2) = w2
        quadrature%weight( 3) = w2 
        quadrature%weight( 4) = w2 
        quadrature%weight( 5) = w3 
        quadrature%weight( 6) = w3 
        quadrature%weight( 7) = w3 
        quadrature%weight( 8) = w4 
        quadrature%weight( 9) = w4 
        quadrature%weight(10) = w4 
        quadrature%weight(11) = w5 
        quadrature%weight(12) = w5 
        quadrature%weight(13) = w5
        quadrature%weight(14) = w6 
        quadrature%weight(15) = w6 
        quadrature%weight(16) = w6 
        quadrature%weight(17) = w7 
        quadrature%weight(18) = w7 
        quadrature%weight(19) = w7 
        quadrature%weight(20) = w7 
        quadrature%weight(21) = w7 
        quadrature%weight(22) = w7 
        quadrature%weight(23) = w8 
        quadrature%weight(24) = w8 
        quadrature%weight(25) = w8 
        quadrature%weight(26) = w8 
        quadrature%weight(27) = w8 
        quadrature%weight(28) = w8
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        stop
     end if

     ! Volume integral ( tetrahedra )
  else if(ndime==3) then
     if(ngaus==1) then
        quadrature%coordinates(1,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(3,1)= 1.0_rp/4.0_rp
        quadrature%weight(1)  = 1.0_rp/6.0_rp
     else if(ngaus==4) then
        a=0.5854101966249685_rp
        b=0.1381966011250105_rp
        quadrature%coordinates(1,1)= b
        quadrature%coordinates(2,1)= b
        quadrature%coordinates(3,1)= b
        quadrature%coordinates(1,2)= a
        quadrature%coordinates(2,2)= b
        quadrature%coordinates(3,2)= b
        quadrature%coordinates(1,3)= b
        quadrature%coordinates(2,3)= a
        quadrature%coordinates(3,3)= b
        quadrature%coordinates(1,4)= b
        quadrature%coordinates(2,4)= b
        quadrature%coordinates(3,4)= a
        quadrature%weight(  1)= 1.0_rp/24.0_rp
        quadrature%weight(  2)= 1.0_rp/24.0_rp
        quadrature%weight(  3)= 1.0_rp/24.0_rp
        quadrature%weight(  4)= 1.0_rp/24.0_rp
     else if(ngaus==5) then
        quadrature%coordinates(1,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(2,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(3,1)= 1.0_rp/4.0_rp
        quadrature%coordinates(1,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,2)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,3)= 1.0_rp/2.0_rp
        quadrature%coordinates(2,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,3)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,4)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,4)= 1.0_rp/2.0_rp
        quadrature%coordinates(3,4)= 1.0_rp/6.0_rp
        quadrature%coordinates(1,5)= 1.0_rp/6.0_rp
        quadrature%coordinates(2,5)= 1.0_rp/6.0_rp
        quadrature%coordinates(3,5)= 1.0_rp/2.0_rp
        quadrature%weight(  1)=-2.0_rp/15.0_rp
        quadrature%weight(  2)= 1.5_rp/20.0_rp
        quadrature%weight(  3)= 1.5_rp/20.0_rp
        quadrature%weight(  4)= 1.5_rp/20.0_rp
        quadrature%weight(  5)= 1.5_rp/20.0_rp
     else if(ngaus==11) then
        a=0.3994035761667992_rp
        b=0.1005964238332008_rp
        c=343.0_rp/7500.0_rp/6.0_rp
        d=56.0_rp/375.0_rp/6.0_rp
        quadrature%coordinates(1,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(2,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(3,1) = 1.0_rp/4.0_rp
        quadrature%coordinates(1,2) = 11.0_rp/14.0_rp
        quadrature%coordinates(2,2) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,2) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,3) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,3) = 11.0_rp/14.0_rp
        quadrature%coordinates(3,3) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,4) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,4) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,4) = 11.0_rp/14.0_rp
        quadrature%coordinates(1,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(2,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(3,5) = 1.0_rp/14.0_rp
        quadrature%coordinates(1,6) = a
        quadrature%coordinates(2,6) = a
        quadrature%coordinates(3,6) = b
        quadrature%coordinates(1,7) = a
        quadrature%coordinates(2,7) = b
        quadrature%coordinates(3,7) = a
        quadrature%coordinates(1,8) = a
        quadrature%coordinates(2,8) = b
        quadrature%coordinates(3,8) = b
        quadrature%coordinates(1,9) = b
        quadrature%coordinates(2,9) = a
        quadrature%coordinates(3,9) = a
        quadrature%coordinates(1,10)= b
        quadrature%coordinates(2,10)= a
        quadrature%coordinates(3,10)= b
        quadrature%coordinates(1,11)= b
        quadrature%coordinates(2,11)= b
        quadrature%coordinates(3,11)= a
        quadrature%weight(1)   =-148.0_rp/1875.0_rp/6.0_rp
        quadrature%weight(2)   = c
        quadrature%weight(3)   = c
        quadrature%weight(4)   = c
        quadrature%weight(5)   = c
        quadrature%weight(6)   = d
        quadrature%weight(7)   = d
        quadrature%weight(8)   = d
        quadrature%weight(9)   = d
        quadrature%weight(10)  = d
        quadrature%weight(11)  = d
     else if(ngaus==14) then
        a=0.0673422422100983_rp
        b=0.3108859192633005_rp
        c=0.7217942490673264_rp
        d=0.0927352503108912_rp
        e=0.4544962958743506_rp
        f=0.0455037041256494_rp
        p=0.1126879257180162_rp/6.0_rp
        q=0.0734930431163619_rp/6.0_rp
        r=0.0425460207770812_rp/6.0_rp
        quadrature%coordinates(1,1) = a
        quadrature%coordinates(2,1) = b
        quadrature%coordinates(3,1) = b
        quadrature%coordinates(1,2) = b
        quadrature%coordinates(2,2) = a
        quadrature%coordinates(3,2) = b
        quadrature%coordinates(1,3) = b
        quadrature%coordinates(2,3) = b
        quadrature%coordinates(3,3) = a
        quadrature%coordinates(1,4) = b
        quadrature%coordinates(2,4) = b
        quadrature%coordinates(3,4) = b
        quadrature%coordinates(1,5) = c
        quadrature%coordinates(2,5) = d
        quadrature%coordinates(3,5) = d
        quadrature%coordinates(1,6) = d
        quadrature%coordinates(2,6) = c
        quadrature%coordinates(3,6) = d
        quadrature%coordinates(1,7) = d
        quadrature%coordinates(2,7) = d
        quadrature%coordinates(3,7) = c
        quadrature%coordinates(1,8) = d
        quadrature%coordinates(2,8) = d
        quadrature%coordinates(3,8) = d
        quadrature%coordinates(1,9) = e
        quadrature%coordinates(2,9) = e
        quadrature%coordinates(3,9) = f
        quadrature%coordinates(1,10)= e
        quadrature%coordinates(2,10)= f
        quadrature%coordinates(3,10)= e
        quadrature%coordinates(1,11)= e
        quadrature%coordinates(2,11)= f
        quadrature%coordinates(3,11)= f
        quadrature%coordinates(1,12)= f
        quadrature%coordinates(2,12)= e
        quadrature%coordinates(3,12)= e
        quadrature%coordinates(1,13)= f
        quadrature%coordinates(2,13)= e
        quadrature%coordinates(3,13)= f
        quadrature%coordinates(1,14)= f
        quadrature%coordinates(2,14)= f
        quadrature%coordinates(3,14)= e
        quadrature%weight(1)   = p
        quadrature%weight(2)   = p
        quadrature%weight(3)   = p
        quadrature%weight(4)   = p
        quadrature%weight(5)   = q
        quadrature%weight(6)   = q
        quadrature%weight(7)   = q
        quadrature%weight(8)   = q
        quadrature%weight(9)   = r
        quadrature%weight(10)  = r
        quadrature%weight(11)  = r
        quadrature%weight(12)  = r
        quadrature%weight(13)  = r
        quadrature%weight(14)  = r
     else
        write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',ndime,ngaus
        stop
     end if
  end if
  
end subroutine tri_lagrangian_reference_fe_fill_quadrature

!-----------------------------------------------------------------------
subroutine P_fill_nodal_quadrature ( quadrature, order ) 
  implicit none
  type(quadrature_t), intent(inout)  :: quadrature
  integer(ip)       , intent(in)     :: order
  
  integer(ip)              :: ndime,iquad,nquad

  ndime = quadrature%number_dimensions
  nquad = quadrature%number_quadrature_points
  
  call P_reference_coordinates(quadrature%coordinates,ndime,order,nquad)
  quadrature%weight = 1.0_rp

end subroutine P_fill_nodal_quadrature

subroutine tri_lagrangian_reference_fe_fill_interpolation ( this, interpolation, order, coord_ip ) 
  implicit none 
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  type(interpolation_t)               , intent(inout) :: interpolation
  integer(ip)                         , intent(in)    :: order
  real(rp)                            , intent(in)    :: coord_ip(:,:)

  logical     :: khes
  integer(ip) :: iquad

  khes = .false.
  if ( allocated( interpolation%hessian ) ) then 
     khes = .true.
  end if

  if ( allocated( interpolation%hessian ) )  then 
     do iquad = 1,interpolation%number_quadrature_points
        call evaluate_shape_functions_and_derivatives( coord_ip(:,iquad),                             &
                                                       interpolation%number_dimensions,               &
                                                       interpolation%number_shape_functions,          &
                                                       interpolation%number_entries_symmetric_tensor, &
                                                       interpolation%shape_functions(:,iquad),        &
                                                       interpolation%shape_derivatives(:,:,iquad),    &
                                                       interpolation%hessian(:,:,iquad) )
     end do
  else
     do iquad = 1,interpolation%number_quadrature_points
        call evaluate_shape_functions_and_derivatives( coord_ip(:,iquad),                             &
                                                       interpolation%number_dimensions,               &
                                                       interpolation%number_shape_functions,          &
                                                       interpolation%number_entries_symmetric_tensor, &
                                                       interpolation%shape_functions(:,iquad),        &
                                                       interpolation%shape_derivatives(:,:,iquad) )
     end do
  end if
  
end subroutine tri_lagrangian_reference_fe_fill_interpolation

!==================================================================================================
subroutine P_reference_coordinates(coordinates, num_dimensions,        &
     &                             order, number_nodes)
  implicit none
  ! Parameters
  integer(ip), intent(in)    :: num_dimensions,order,number_nodes
  real(rp),    intent(inout) :: coordinates(num_dimensions,number_nodes)
  ! Local variables
  integer(ip) :: ijk(num_dimensions),i,d
  real(rp)    :: c1d(order+1)

  call P_coord_1d(c1d,order+1)

  do i=1,number_nodes

     call P_ijkg(ijk,i,num_dimensions,order)
     do d=1,num_dimensions
        coordinates(d,i) = c1d(ijk(d)+1)
     end do
     
  end do
  
end subroutine P_reference_coordinates

!==================================================================================================
subroutine P_coord_1d (x,n)
    implicit none
    ! Parameters
    integer(ip), intent(in)  :: n
    real(rp)   , intent(out) :: x(n)

    ! Local variables
    integer(ip)              :: i

    do i = 0,n-1
       x(i+1) = real(i)/(real(n)-1)
    end do
end subroutine P_coord_1d

!==================================================================================================
subroutine evaluate_shape_functions_and_derivatives(coord,ndime,nnode,ntens,shape,deriv,heslo)
  !-----------------------------------------------------------------------
  !
  ! This routine evaluates shape functions and their first and second
  ! derivatives for 2D or 3D continuos standard interpolation elements.
  !
  !    TRIANGLES       3   6  &  10  nodes
  !    TETRAHEDRA          4  &  10  nodes
  !
  !-----------------------------------------------------------------------
  implicit none
  real(rp)             , intent(in)    :: coord(:)
  integer(ip)          , intent(in)    :: ndime,nnode,ntens
  real(rp)             , intent(inout) :: shape(:),deriv(:,:)
  real(rp)   , optional, intent(inout) :: heslo(:,:)
  integer(ip) :: i
  real(rp)    :: a1,a2,a3,a4,c
  if(ndime==2) then
     ! Linear triangle
     if(nnode==3) then     
        shape(1)=1.0_rp-coord(1)-coord(2)                                
        shape(2)=coord(1)                                  
        shape(3)=coord(2)                                           
        deriv(1,1)=-1.0_rp                                   !  3 
        deriv(1,2)= 1.0_rp                                   !
        deriv(1,3)= 0.0_rp                                   !
        deriv(2,1)=-1.0_rp                                   !         
        deriv(2,2)= 0.0_rp                                   !  1       2
        deriv(2,3)= 1.0_rp
     ! Quadratic triangle
     else if(nnode==6) then
        a1=1.0_rp-coord(1)-coord(2)
        a2=coord(1)                                             
        a3=coord(2)
        shape( 1)=(2.0_rp*a1-1.0_rp)*a1                      !  6
        shape( 3)=(2.0_rp*a2-1.0_rp)*a2                      !   
        shape( 6)=(2.0_rp*a3-1.0_rp)*a3                      !   
        shape( 2)=4.0_rp*a1*a2                               !  4      5
        shape( 5)=4.0_rp*a2*a3                               !     
        shape( 4)=4.0_rp*a1*a3                               !                                !  1     2     3
        deriv(1,1)= 1.0_rp-4.0_rp*a1                        
        deriv(1,3)= 4.0_rp*a2-1.0_rp    
        deriv(1,6)= 0.0_rp           
        deriv(1,2)= 4.0_rp*(a1-a2)   
        deriv(1,5)= 4.0_rp*a3        
        deriv(1,4)=-4.0_rp*a3       
        deriv(2,1)= 1.0_rp-4.0_rp*a1    
        deriv(2,3)= 0.0_rp           
        deriv(2,6)= 4.0_rp*a3-1.0_rp    
        deriv(2,2)=-4.0_rp*a2       
        deriv(2,5)= 4.0_rp*a2        
        deriv(2,4)= 4.0_rp*(a1-a3)
        if (present(heslo)) then
           heslo(1,1)= 4.0_rp
           heslo(1,3)= 4.0_rp
           heslo(1,2)=-8.0_rp
           heslo(2,1)= 4.0_rp
           heslo(2,6)= 4.0_rp
           heslo(2,4)=-8.0_rp
           heslo(3,1)= 4.0_rp
           heslo(3,2)=-4.0_rp
           heslo(3,5)= 4.0_rp
           heslo(3,4)=-4.0_rp
        end if
     ! Cubic triangle
     else if(nnode==10) then
        c=9.0_rp/2.0_rp
        a1=1.0_rp-coord(1)-coord(2)
        a2=2.0_rp/3.0_rp-coord(1)-coord(2)
        a3=1.0_rp/3.0_rp-coord(1)-coord(2)
        shape( 1)=c*a1*a2*a3                                 !  10
        shape( 4)=c*(1.0_rp/3.0_rp-coord(1))*(2.0_rp/3.0_rp-coord(1))*coord(1)    !
        shape(10)=c*(1.0_rp/3.0_rp-coord(2))*(2.0_rp/3.0_rp-coord(2))*coord(2)    !
        shape( 2)= 3.0_rp*c*a1*a2*coord(1)                          !  8    9
        shape( 3)=-3.0_rp*c*a1*(1.0_rp/3.0_rp-coord(1))*coord(1)           !
        shape( 7)=-3.0_rp*c*(1.0_rp/3.0_rp-coord(1))*coord(1)*coord(2)            !
        shape( 9)=-3.0_rp*c*coord(1)*(1.0_rp/3.0_rp-coord(2))*coord(2)            !  5    6     7
        shape( 8)=-3.0_rp*c*a1*(1.0_rp/3.0_rp-coord(2))*coord(2)           !
        shape( 5)= 3.0_rp*c*a1*a2*coord(2)                          !
        shape( 6)= 6.0_rp*c*a1*coord(1)*coord(2)                           !  1    2    3    4
        deriv(1, 1)=-c*(a1*a2+a1*a3+a2*a3)       
        deriv(1, 4)=-c*((2.0_rp/3.0_rp-coord(1))*coord(1)&
             + (1.0_rp/3.0_rp-coord(1))*coord(1)-(1.0_rp/3.0_rp-coord(1))*(2.0_rp/3.0_rp-coord(1)))
        deriv(1, 10)=0.0_rp
        deriv(1, 2)= 3.0_rp*c*(a1*a2-a1*coord(1)-a2*coord(1))
        deriv(1, 3)=-3.0_rp*c*(a1*(1.0_rp/3.0_rp-coord(1))&
             - a1*coord(1)-(1.0_rp/3.0_rp-coord(1))*coord(1))
        deriv(1, 7)=-3.0_rp*c*((1.0_rp/3.0_rp-coord(1))*coord(2)-coord(1)*coord(2))
        deriv(1, 9)=-3.0_rp*c*((1.0_rp/3.0_rp-coord(2))*coord(2))
        deriv(1, 8)= 3.0_rp*c*((1.0_rp/3.0_rp-coord(2))*coord(2))
        deriv(1, 5)= 3.0_rp*c*(-a1*coord(2)-a2*coord(2))
        deriv(1,6)= 6.0_rp*c*(a1*coord(2)-coord(1)*coord(2))
        deriv(2, 1)=-c*(a1*a2+a1*a3+a2*a3)
        deriv(2, 4)= 0.0_rp
        deriv(2, 10)=-c*((2.0_rp/3.0_rp-coord(2))*coord(2)&
             + (1.0_rp/3.0_rp-coord(2))*coord(2)-(1.0_rp/3.0_rp-coord(2))*(2.0_rp/3.0_rp-coord(2)))
        deriv(2, 2)= 3.0_rp*c*(-a1*coord(1)-a2*coord(1))
        deriv(2, 3)=-3.0_rp*c*(-(1.0_rp/3.0_rp-coord(1))*coord(1))
        deriv(2, 7)=-3.0_rp*c*((1.0_rp/3.0_rp-coord(1))*coord(1))
        deriv(2, 9)=-3.0_rp*c*((1.0_rp/3.0_rp-coord(2))*coord(1)-coord(1)*coord(2))
        deriv(2, 8)=-3.0_rp*c*(-(1.0_rp/3.0_rp-coord(2))*coord(2)&
             - a1*coord(2)+a1*(1.0_rp/3.0_rp-coord(2)))
        deriv(2, 5)= 3.0_rp*c*(-a1*coord(2)-a2*coord(2)+a1*a2)
        deriv(2,6)= 6.0_rp*c*(a1*coord(1)-coord(1)*coord(2))
        if (present(heslo)) then
           heslo(1, 1)= c*2.0_rp*(a1+a2+a3) 
           heslo(1, 4)= c*(6.0_rp*coord(1)-2.0_rp) 
           heslo(1, 10)= 0.0_rp 
           heslo(1, 2)= c*( 18.0_rp*coord(1)+12.0_rp*coord(2)-10.0_rp)
           heslo(1, 3)= c*(-18.0_rp*coord(1)- 6.0_rp*coord(2)+ 8.0_rp)
           heslo(1, 7)= c*6.0_rp*coord(2) 
           heslo(1, 9)= 0.0_rp 
           heslo(1, 8)= 0.0_rp  
           heslo(1, 5)= c*6.0_rp*coord(2) 
           heslo(1,6)=-c*12.0_rp*coord(2) 
           heslo(2, 1)= c*2.0_rp*(a1+a2+a3) 
           heslo(2, 4)= 0.0_rp 
           heslo(2, 10)= c*(6.0_rp*coord(2)-2.0_rp) 
           heslo(2, 2)= c*6.0_rp*coord(1)
           heslo(2, 3)= 0.0_rp
           heslo(2, 7)= 0.0_rp
           heslo(2, 9)= c*6.0_rp*coord(1)
           heslo(2, 8)= c*( -6.0_rp*coord(1)-18.0*coord(2)+ 8.0_rp)
           heslo(2, 5)= c*( 12.0_rp*coord(1)+18.0*coord(2)-10.0_rp)
           heslo(2,6)=-c*12.0_rp*coord(1)
           heslo(3, 1)= 2.0_rp*c*(a1+a2+a3) 
           heslo(3, 4)= 0.0_rp  
           heslo(3, 10)= 0.0_rp 
           heslo(3, 2)= c*( 12.0_rp*coord(1)+6.0_rp*coord(2)-5.0_rp) 
           heslo(3, 3)= c*(- 6.0_rp*coord(1)+1.0_rp) 
           heslo(3, 7)= c*(  6.0_rp*coord(1)-1.0_rp) 
           heslo(3, 9)= c*(  6.0_rp*coord(2)-1.0_rp) 
           heslo(3, 8)= c*(- 6.0_rp*coord(2)+1.0_rp)  
           heslo(3, 5)= c*(  6.0_rp*coord(1)+12.0_rp*coord(2)-5.0_rp) 
           heslo(3,6)= c*(-12.0_rp*coord(1)-12.0_rp*coord(2)+6.0_rp) 
        end if
     end if
  elseif (ndime==3) then
     ! Linear tetrahedron 
     if(nnode==4) then
        shape(   1) = 1.0_rp-coord(1)-coord(2)-coord(3)
        shape(   2) = coord(1)
        shape(   3) = coord(2)
        shape(   4) = coord(3)
        deriv(1, 1) =-1.0_rp
        deriv(2, 1) =-1.0_rp
        deriv(3, 1) =-1.0_rp
        deriv(3, 4) = 1.0_rp
        deriv(1, 2) = 1.0_rp
        deriv(2, 3) = 1.0_rp
     ! Quadratic tetrahedron 
     else if(nnode==10) then
        a1= 1.0_rp-coord(1)-coord(2)-coord(3)
        a2=coord(1)
        a3=coord(2)
        a4=coord(3)
        shape(   1) = (2.0_rp*a1-1.0_rp)*a1
        deriv(1, 1) = 1.0_rp-4.0_rp*a1
        deriv(2, 1) = 1.0_rp-4.0_rp*a1
        deriv(3, 1) = 1.0_rp-4.0_rp*a1
        shape(   3) = (2.0_rp*a2-1.0_rp)*a2
        deriv(1, 3) = 4.0_rp*a2-1.0_rp
        shape(   6) = (2.0_rp*a3-1.0_rp)*a3
        deriv(2, 6) = 4.0_rp*a3-1.0_rp
        shape(  10) = (2.0_rp*a4-1.0_rp)*a4
        deriv(3,10) = 4.0_rp*a4-1.0_rp
        shape(   2) = 4.0_rp*a1*a2
        deriv(1, 2) = 4.0_rp*(a1-a2)
        deriv(2, 2) =-4.0_rp*a2
        deriv(3, 2) =-4.0_rp*a2
        shape(   5) = 4.0_rp*a2*a3
        deriv(1, 5) = 4.0_rp*a3
        deriv(2, 5) = 4.0_rp*a2
        shape(   4) = 4.0_rp*a1*a3
        deriv(1, 4) =-4.0_rp*a3
        deriv(2, 4) = 4.0_rp*(a1-a3)
        deriv(3, 4) =-4.0_rp*a3
        shape(   7) = 4.0_rp*a1*a4
        deriv(1, 7) =-4.0_rp*a4
        deriv(2, 7) =-4.0_rp*a4
        deriv(3, 7) = 4.0_rp*(a1-a4)
        shape(   8) = 4.0_rp*a2*a4
        deriv(1, 8) = 4.0_rp*a4
        deriv(3, 8) = 4.0_rp*a2
        shape(   9) = 4.0_rp*a3*a4
        deriv(2, 9) = 4.0_rp*a4
        deriv(3, 9) = 4.0_rp*a3
        if (present(heslo)) then
           do i = 1,6
              heslo(i, 1) = 4.0_rp
           end do
           heslo(1, 3) = 4.0_rp
           heslo(2, 6) = 4.0_rp
           heslo(3,10) = 4.0_rp
           heslo(1, 2) =-8.0_rp
           heslo(4, 2) =-4.0_rp
           heslo(5, 2) =-4.0_rp
           heslo(4, 5) = 4.0_rp
           heslo(2, 4) =-8.0_rp
           heslo(4, 4) =-4.0_rp
           heslo(6, 4) =-4.0_rp
           heslo(3, 7) =-8.0_rp
           heslo(5, 7) =-4.0_rp
           heslo(6, 7) =-4.0_rp
           heslo(5, 8) = 4.0_rp
           heslo(6, 9) = 4.0_rp
        end if
     end if
  end if
end subroutine evaluate_shape_functions_and_derivatives

!==================================================================================================
! P_IJKG(i,g,nd,p) returns coordinates of the g-th node in an elem(nd,p)
subroutine P_ijkg(i,g,nd,p)
  implicit none
  ! Parameters
  integer(ip), intent(in)  :: nd,g,p
  integer(ip), intent(out) :: i(nd)

  ! Local variables
  integer(ip)              :: k,g0,g1,g2,j,q

  g0 = g-1
  j  = 0 
  do while (pnods(nd,p-j+1,p)<=g0)
     j=j+1
  end do
  i(nd) = j-1
  g0 = g0 - pnods(nd,p-i(nd)+1,p)

  do k=1,nd-1
     g2 = 0
     j  = 0
     q = p-i(nd-k+1)
     do while (pnods(nd-k,q-j+1,q)<=g0)
        j=j+1
     end do
     i(nd-k) = j-1
     g0 = g0 - pnods(nd-k,q-i(nd-k)+1,q)
  end do
end subroutine P_ijkg

!=================================================================================================
subroutine  P_permute_or_1d( o2n,p,r )
  implicit none
  integer(ip), intent(in)    :: p,r
  integer(ip), intent(inout) :: o2n(p)

  ! Local variables
  integer(ip) :: i

  ! Generic loop+rotation identifier  
  if (r==1) then
     o2n = (/(i,i=1,p)/)
  elseif (r==2) then
     o2n = (/(p-i,i=0,p-1)/)
  else
     write(*,*) __FILE__,__LINE__,'P_permute_or_1d:: ERROR! Delay cannot be >1 for edges'
  end if
end subroutine P_permute_or_1d

!=================================================================================================
subroutine  P_permute_or_2d( o2n,p,o,r )
  implicit none
  integer(ip), intent(in)    :: p,o,r
  integer(ip), intent(inout) :: o2n(int(((p+1)**2+p+1)/2))

  ! Local variables
  integer(ip) :: o_r,i,j,ij_t(3)     ! ij_t = (i,j,p-i-j)
  integer(ip) :: ij_n(2),go,gn
  integer(ip) :: ij_perm_tet(2,6) = reshape((/ 1, 2, 2, 3, 3, 1, 2, 1, 3, 2, 1, 3/), (/2,6/) )

  ! Generic loop+rotation identifier  
  o_r = 3*(o-1)+r
  do j = 0,p-1
     ij_t(2) = j
     do i = 0,p-j-1
        ij_t(1) = i
        ij_t(3) = p-i-j-1
        ! Get the global numbering of node (i,j)
        go = P_gijk(ij_t(1:2),2,p-1)
        ! i,j coordinates for the o_r permutation
        ij_n(1:2) = ij_t(ij_perm_tet(1:2,o_r)) 
        ! Store the global numbering of node ij_n 
        o2n(go) = P_gijk(ij_n,2,p-1)
     end do
  end do
  
end subroutine P_permute_or_2d

!=================================================================================================
! P_NNODS(k,p) computes the #nodes in a simplex of dim k and order p
integer(ip) recursive function P_nnods(k,p) result(nnods)
  implicit none
  !integer(ip)                :: nnods
  integer(ip), intent(in)    :: k, p

  integer(ip) :: q
  if (k == 0) then
     nnods = 1
  elseif (p == 0) then
     nnods = 1
  elseif (k == 1) then
     nnods = p+1
  elseif (k == 2) then
     nnods = int((p+1)*(p+2)/2)
  else
     nnods = P_nnods(k-1,0)
     do q=1,p
        nnods = nnods + P_nnods(k-1,q)
     end do
  end if
end function P_nnods

!=================================================================================================
! PNODS(k,pi,pf) computes the sum of nodes in simplices of dimension k of order pi,...,pf
integer(ip) function pnods(k,pi,pf)

  implicit none
  integer(ip), intent(in)    :: k, pi,pf

  integer(ip) :: q
  if (k == 0) then
     pnods = 1
  elseif (pi > pf) then
     pnods = 0
  else
     pnods = P_nnods(k-1,pi)
     do q=pi+1,pf
        pnods = pnods + P_nnods(k-1,q)
     end do
  end if
end function pnods

!=================================================================================================
! INODS(k,p) computes the #{interior nodes} in a simplex of dim k and order p
integer(ip) recursive function inods(k,p) result(inodes)
  implicit none
  ! Parameters
  integer(ip), intent(in)    :: k, p

  ! Variables
  integer(ip) :: q
  if (k == 0) then
     inodes = 1
  elseif (p == 1) then
     inodes = 0
  elseif (k == 1) then
     inodes = p-1
  elseif (k == 2) then
     inodes = int((p-2)*(p-1)/2)
  else
     inodes = inods(k-1,1)
     do q=2,p-1
        inodes = inodes+ inods(k-1,q)
     end do
  end if
end function inods

!==================================================================================================
! CRXOB constructs idcro and idm
! idcro(:,cc) = (k,idm(1:k+1))
! k   :: vef dimension
! i   :: position of idm we are modifying
! idm :: array of dimension k+1 that will give the corners in the element
! n   :: global dimension
! in  :: value of the corner we can count from (knowing that idm(i)<idm(i+1))
! no  :: total amount of vefs
! cc  :: counter of the vefs
recursive subroutine crxob(idcro,k,i,idm,n,in,no,cc)
  implicit none
  ! Parameters
  integer(ip), intent(in)    :: k,i,n,in,no
  integer(ip), intent(inout) :: idcro(n+2,no),idm(n+1),cc

  ! Local variables
  integer(ip)  :: j,m

  do j=in,n+1
     idm(i) = j
     if(i+1<k+2) then
        call crxob(idcro,k,i+1,idm,n,idm(i)+1,no,cc)
     else
        idcro(1,cc) = k
        idcro(2:k+2,cc) = idm(1:k+1)
        cc = cc + 1
     end if
  end do

end subroutine crxob

!==================================================================================================
! NTXOB_FILL constructs ntxob%l
recursive subroutine ntxob_fill(ntxob,c3,ini,end,i,idm,nd,k,p,objec,nt)
  implicit none
  ! Parameters
  integer(ip), intent(in)    :: ini,end,nd,k,p,objec(nd,nd+1),nt,i
  integer(ip), intent(inout) :: ntxob(nt),c3,idm(nd)

  ! Local variables
  integer(ip) :: j,ijk(nd),m

  if (k==0) then
     ! Dimension 0: objec gives the coordinates of the corner
     ijk = p*objec(:,1)
     ntxob(c3) = P_gijk(ijk,nd,p)
     c3 = c3 + 1
  else
     ! Loop over the possible values of the i-th factor
     do j=ini,end
        ! Assign value of the i-th factor
        idm(i) = j
        if (i<k) then
           ! Assign values of the i+1-th factor
           call ntxob_fill(ntxob,c3,ini,end-j,i+1,idm,nd,k,p,objec,nt)
        else
           ! Compute the coordinate of the c3-th node: objec(:,1)+idm*objec(:,2:k)
           ijk = p*objec(:,1)
           do m=1,k
              ijk = ijk+idm(k-m+1)*objec(:,m+1)
           end do
           ! Store in ntxob the corresponding identifier of the node
           ntxob(c3) = P_gijk(ijk,nd,p)
           c3 = c3 + 1
        end if
     end do
  end if
end subroutine ntxob_fill

!==================================================================================================
! P_GIJK(i,nd,p) returns the generic identifier of a node with coordinates i in an elem(nd,p)
integer(ip) function P_gijk(i,nd,p)
  implicit none
  integer(ip) :: nd, i(nd),p,k,q

  if (sum(i)>p) then
     write(*,*) 'ijk', i
     write(*,*) 'tets_setting:: gijk:: ERROR i+j+k<=p'
     stop
  end if

  P_gijk = 1
  do k =1,nd-1
     q = p-i(k+1)
     P_gijk = P_gijk + pnods(k,q-i(k)+1,q)
  end do
  P_gijk = P_gijk + pnods(k,p-i(nd)+1,p)
end function P_gijk

!==================================================================================================
subroutine tri_lagrangian_reference_fe_fill_face_interpolation (this,face_interpolation,local_quadrature,local_face_id)
  implicit none
  class(tri_lagrangian_reference_fe_t), intent(in)    :: this
  type(interpolation_t)               , intent(inout) :: face_interpolation
  type(quadrature_t)                  , intent(in)    :: local_quadrature
  integer(ip)                         , intent(in)    :: local_face_id

  type(interpolation_t)               :: interp_1D_corners, local_interpolation
  type(quadrature_t)                  :: nodal_coordinates_1D
  integer(ip)                         :: order_of_approximation
  type(tri_lagrangian_reference_fe_t) :: face_reference_fe, reference_fe_1D

  write(*,*) __FILE__,__LINE__,'Creation of 2 reference_FE!!'

  ! Create a 1D interpolation evaluated on the corners
  call nodal_coordinates_1D%create(1,2)
  nodal_coordinates_1D%coordinates(1,1) = -1.0_rp
  nodal_coordinates_1D%coordinates(1,2) =  1.0_rp
  call reference_fe_1D%create(1,this%order,this%field_type,this%continuity)
  call reference_fe_1D%create_interpolation(nodal_coordinates_1D,interp_1D_corners)

  ! Create a ndime-1 interpolation on the local Gauss points in each face
  call face_reference_fe%create(this%number_dimensions-1,this%order,this%field_type,this%continuity)
  call face_reference_fe%create_interpolation(local_quadrature,local_interpolation)

  order_of_approximation = this%order
  ! Create the interpolation
  call face_P_shapen(face_interpolation%shape_functions,face_interpolation%shape_derivatives,    &
       &             local_interpolation%shape_functions,local_interpolation%shape_derivatives,  &
       &             interp_1D_corners%shape_functions,interp_1D_corners%shape_derivatives,      &
       &             face_interpolation%number_dimensions,order_of_approximation,                &
       &             face_interpolation%number_quadrature_points,local_face_id)

  call face_reference_fe%free()
  call reference_fe_1D%free
  call local_interpolation%free()
  call interp_1D_corners%free()
  call nodal_coordinates_1D%free()

end subroutine tri_lagrangian_reference_fe_fill_face_interpolation

!==================================================================================================
subroutine face_P_shapen(shapf,derif,shp,drv,sh1,dr1,nd,p,ng,local_face_id)
  implicit none
  ! Parameters
  integer(ip)           , intent(in)  :: nd,p,ng, local_face_id
  real(rp)              , intent(in)  :: shp((p+1)**(nd-1),ng),drv(nd-1,(p+1)**(nd-1),ng) ! Face interpolation
  real(rp)              , intent(in)  :: sh1(p+1,2),dr1(1,p+1,2)
  real(rp)              , intent(out) :: shapf(   (p+1)**nd,ng)
  real(rp)              , intent(out) :: derif(nd,(p+1)**nd,ng)

  ! Local variable
  integer(ip) :: ifc, id, j, ijk(nd), ij(nd-1), d, inode, jnode, ig, d2
  integer(ip) :: ig0, ign

  ! Initialize
  shapf = 1.0_rp
  derif = 1.0_rp

  do inode = 1, (p+1)**nd ! node identifier

     ! Set coordinates of node i
     call P_ijkg(ijk,inode,nd,p)

     ifc = 0
     do id = nd,1,-1   ! face normal direction

        ! Set node coordinate in the face
        j = 1
        do d = 1,nd
           if (d .ne. id) then
              ij(j) = ijk(d)
              j = j+1
           end if
        end do
        jnode = P_gijk(ij,nd-1,p)

        do j = 1,2        ! 1 ---> -, 2 ---> +
           ifc = ifc + 1  ! face identifier
         
           if (ifc == local_face_id) then
              ig0 = 0
              ign = ng
           else
              cycle
           end if
           
           do ig = 1, ign  ! Loop over face Gauss Points    
              shapf(inode,ig0 + ig) = sh1(ijk(id)+1,j)*shp(jnode,ig)

              d2 = 0
              do d =1, nd
                 if (d == id) then
                    derif(d,inode,ig0 + ig) = dr1(1,ijk(id)+1,j)*shp(jnode,ig)
                 else
                    d2 = d2+1
                    derif(d,inode,ig0 + ig) = sh1(ijk(id)+1,j)*drv(d2,jnode,ig)
                 end if
              end do
           end do
        end do
     end do
  end do

end subroutine face_P_shapen

!==============================================================================
  subroutine P_femap_apply_to_interp(map,ref,phy)
    implicit none
    type(fe_map_t)          , intent(in)    :: map
    type(interpolation_t), intent(in)    :: ref
    type(interpolation_t), intent(inout) :: phy
    real(rp), allocatable :: wmat1(:,:,:)
    real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
    integer(ip) :: ndime,nnode,nlocs,ntens
    integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
    logical :: khes


    khes = .false.
    if ( allocated( ref%hessian ) ) then 
       khes = .true.
    end if

    ndime = ref%number_dimensions
    ntens = ref%number_entries_symmetric_tensor
    nlocs = ref%number_quadrature_points
    !nnode = ref%number_shape_functions
    nnode = size(ref%shape_functions,1)

    ! Shape functions do not change
    !phy%shape_functions = ref%shape_functions 

    ! First derivatives do
    !if(phy%kder==1) then
    phy%shape_derivatives=0.0_rp
    do ilocs=1,phy%number_quadrature_points
       do inode=1,size(phy%shape_functions,1)!phy%number_shape_functions
          do idime=1,ndime
             do jdime=1,ndime
                phy%shape_derivatives(idime,inode,ilocs) = phy%shape_derivatives(idime,inode,ilocs) &
                     + map%inv_jacobian(jdime,idime,ilocs)*ref%shape_derivatives(jdime,inode,ilocs)
             end do
          end do
       end do
    end do
    !end if

    ! Second derivatives are
    !
    !    d^2 N / d x_i d x_j
    !       = (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j)
    !       + (d N / d s_k) (d^2 s_k / d x_i d x_j) 
    !
    if( khes ) then
       call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
       call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
       do ilocs=1,nlocs
          if( khes ) then
             ! Transforms the array HESSI to a symmetric matrix WMAT1
             do inode=1,nnode
                do itens = 1, ntens
                   wvec1(itens) = ref%hessian(itens,inode,ilocs)
                end do
                call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
             end do
             ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for each node
             do inode=1,nnode
                call btdbma(wmat2(1,1,inode),wmat1(1,1,inode),map%inv_jacobian(:,:,ilocs), &
                     &        ndime,ndime)
             end do
          end if
          if( khes ) then
             ! Add second cartesian derivatives of the map times 
             ! first derivatives of shape functions
             do inode=1,nnode
                do idime=1,ndime
                   do jdime=1,ndime
                      do kdime=1,ndime
                         wmat2(idime,jdime,inode)=wmat2(idime,jdime,inode) &
                              & + ref%shape_derivatives(kdime,inode,ilocs) &
                              &   * map%d2sdx(kdime,idime,jdime,ilocs)
                      end do
                   end do
                end do
             end do
          end if

          ! Writes the Hessian matrix as an array
          do inode=1,nnode
             do itens = 1, ntens
                wvec1(itens) = phy%hessian(itens,inode,ilocs)
             end do
             call P_matove(wmat2(1,1,inode),wvec1,ndime,ntens)
          end do
       end do
       call memfree(wmat1,__FILE__,__LINE__)
       call memfree(wmat2,__FILE__,__LINE__)
    end if
  end subroutine P_femap_apply_to_interp

!==================================================================================================
  subroutine P_matove(xmatr,vecto,ndime,ntens)
    !-----------------------------------------------------------------------
    !                                      
    ! This routine stores a symmetric matrix XMATR into a vector VECTO
    !
    !-----------------------------------------------------------------------
    implicit none
    integer(ip), intent(in)  :: ndime,ntens
    real(rp)   , intent(in)  :: xmatr(ndime,ndime)
    real(rp)   , intent(out) :: vecto(ntens)

    if(ndime.eq.2) then
       vecto(1)=xmatr(1,1)
       vecto(3)=xmatr(1,2)
       vecto(2)=xmatr(2,2)
    else
       vecto(1)=xmatr(1,1)
       vecto(4)=xmatr(1,2)
       vecto(2)=xmatr(2,2)
       vecto(5)=xmatr(1,3)
       vecto(6)=xmatr(2,3)
       vecto(3)=xmatr(3,3)
    end if

  end subroutine P_matove

!==================================================================================================
  subroutine tri_lagrangian_reference_fe_get_subelements_connectivity(this, connectivity)
    implicit none
    class(tri_lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip),                           intent(inout) :: connectivity(:, :)
    integer(ip)                                          :: num_subelems
    integer(ip)                                          :: subelem
    integer(ip)                                          :: geo_nnodes
    integer(ip)                                          :: local_node
    integer(ip)                                          :: first_coord(this%number_dimensions)
    integer(ip)                                          :: local_coord(this%number_dimensions)
    integer(ip)                                          :: global_coord(this%number_dimensions)
   
    num_subelems = this%get_number_subelements()
    geo_nnodes = this%get_number_vertices()
    assert(size(connectivity,1) == geo_nnodes)
    assert(size(connectivity,2) == num_subelems)

    do subelem = 1, num_subelems
      call P_ijkg(first_coord,subelem,this%number_dimensions,this%order-1)
      do local_node = 1, geo_nnodes
        call P_ijkg(local_coord,local_node,this%number_dimensions,1)
        global_coord = first_coord + local_coord
        connectivity(local_node, subelem) = P_gijk(global_coord,this%number_dimensions,this%order)
      end do
    end do
  end subroutine tri_lagrangian_reference_fe_get_subelements_connectivity

!==================================================================================================
  function tri_lagrangian_reference_fe_get_number_subelements(this) result(number_subelements)
    implicit none
    class(tri_lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip)                                          :: number_subelements

    number_subelements = this%order**this%number_dimensions
  end function tri_lagrangian_reference_fe_get_number_subelements
  
