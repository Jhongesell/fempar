! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
module reference_fe_names
  use allocatable_array_ip1_names
  use allocatable_array_ip2_names
  use field_names
  use types_names
  use list_types_names
  use memor_names
  use sort_names
  implicit none
# include "debug.i90"

  private

  ! This module includes all the reference FE related machinery that is required
  ! to integrate FE schemes. It includes the following types:
  !
  ! * reference_fe_t: the basic reference_fe object, which is an abstract type
  ! * lagrangian_reference_fe_t: an intermediate abstract class 
  ! * hex_lagrangian_reference_fe_t: one particular concrete version of the 
  !   lagrangian_reference_fe_t for quadrilaterals and hexahedra
  ! * hex_lagrangian_reference_fe_t: one particular concrete version of the 
  !   lagrangian_reference_fe_t for triangles and tetrahedra
  ! * quadrature_t: Set of points and weights to perform numerical integration.
  !   It is created by the concrete reference_fe_t by providing the maximum order
  !   to be integrated exactly for zero order terms, e.g., mass matrix
  ! * interpolation_t: The value of the reference FE shape functions (first and second
  !   order derivatives) on the quadrature points. It is generated by a concrete 
  !   reference_fe_t and a quadrature_t. It is computed in the concrete reference_fe_t
  ! * fe_map_t: It provides the mapping from a physical FE to the reference FE
  !   (jacobian, etc.)
  ! * volume_integrator_t: It aggregates all the aforementioned structures to be
  !   used in the FE element integration subroutine. In particular, one 
  !   reference_fe_t for the unknowns and one for the geometry (for non-isoparametric
  !   cases), one quadrature, and the corresponding interpolation. Further, it 
  !   includes the physical FE to the reference one in a fe_map_t and the
  !   composition of the FE map and the interpolation, to provide derivatives in the
  !   physical space

  type quadrature_t
     private
     integer(ip)           ::   &
          number_dimensions,    &
          number_quadrature_points
     real(rp), allocatable :: &
          coordinates(:,:),   &   
          weight(:)                         
   contains
     procedure, non_overridable :: create => quadrature_create
     procedure, non_overridable :: free   => quadrature_free
     procedure, non_overridable :: print  => quadrature_print
     procedure, non_overridable :: get_number_dimensions => quadrature_get_number_dimensions
     procedure, non_overridable :: get_number_quadrature_points => quadrature_get_number_quadrature_points
     procedure, non_overridable :: get_weight => quadrature_get_weight
  end type quadrature_t

  type p_quadrature_t
     type(quadrature_t), pointer :: p => NULL()
   contains
     procedure :: allocate => p_quadrature_allocate
     procedure :: free     => p_quadrature_free
  end type p_quadrature_t

  ! Types
  public :: quadrature_t, p_quadrature_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type interpolation_t
     private
     integer(ip)                ::  &
          number_dimensions,        &      
          number_shape_functions,   &      
          number_quadrature_points, &      
          number_entries_symmetric_tensor
     real(rp), allocatable      ::  &
          shape_functions(:,:,:),     &   
          shape_derivatives(:,:,:,:), &   
          hessian(:,:,:,:)     
   contains
     procedure, non_overridable :: create => interpolation_create
     procedure, non_overridable :: free   => interpolation_free
     procedure, non_overridable :: copy   => interpolation_copy
     procedure, non_overridable :: print  => interpolation_print
  end type interpolation_t

  public :: interpolation_t
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  type interpolation_face_restriction_t
     private
     integer(ip)                           :: number_shape_functions
     integer(ip)                           :: number_quadrature_points
     integer(ip)                           :: number_faces
     integer(ip)                           :: active_face_id
     type(interpolation_t), allocatable    :: interpolation(:)
     type(interpolation_t), allocatable    :: interpolation_o_map(:)
   contains
     procedure, non_overridable :: create => interpolation_face_restriction_create
     procedure, non_overridable :: free   => interpolation_face_restriction_free
  end type interpolation_face_restriction_t

  public :: interpolation_face_restriction_t

 !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type fe_map_t
     private
     ! Map's Jacobian (number_dimensions,number_dimensions,number_quadrature_points)
     real(rp), allocatable    :: jacobian(:,:,:)    
     ! Map's Jacobian inverse (number_dimensions,number_dimensions,number_quadrature_points)       
     real(rp), allocatable    :: inv_jacobian(:,:,:)     
     ! Map's Jacobian det (number_quadrature_points)  
     real(rp), allocatable    :: det_jacobian(:)  
     ! Map's 2nd derivatives (number_dime,number_dime,number_dime,number_quadrature_points)         
     real(rp), allocatable    :: d2sdx(:,:,:,:)     
     ! Coordinates of git  points (number_dimensions,number_quadrature_points)       
     type(point_t), allocatable    :: coordinates_quadrature(:)  
     ! Coordinates of evaluation points (number_dimensions,number_corners of element/face)  
     type(point_t), allocatable    :: coordinates_nodes(:)  
     ! Vector normals outside the face (only allocated when using fe_map to integrate on faces) 
     real(rp), allocatable    :: normals(:,:)  
     ! Geometry interpolation_t in the reference element domain    
     type(interpolation_t) :: interpolation_geometry   
     ! Characteristic length of the reference element
     real(rp)                 :: reference_fe_characteristic_length
     ! Number of dimensions
     integer(ip)              :: number_dimensions
     ! Number of quadrature points
     integer(ip)              :: number_quadrature_points
   contains
     procedure, non_overridable :: create                         => fe_map_create
     procedure, non_overridable :: create_on_face                 => fe_map_create_on_face
     procedure, non_overridable :: fe_map_face_map_create         => fe_map_face_map_create
     procedure, non_overridable :: update                         => fe_map_update
     procedure, non_overridable :: face_map_update                => fe_map_face_map_update
     procedure, non_overridable :: free                           => fe_map_free
     procedure, non_overridable :: print                          => fe_map_print
     procedure, non_overridable :: get_det_jacobian               => fe_map_get_det_jacobian
     procedure, non_overridable :: compute_h                      => fe_map_compute_h
     procedure, non_overridable :: compute_h_min                  => fe_map_compute_h_min
     procedure, non_overridable :: compute_h_max                  => fe_map_compute_h_max
     procedure, non_overridable :: get_coordinates                => fe_map_get_coordinates
     procedure, non_overridable :: get_inv_jacobian_tensor        => fe_map_get_inv_jacobian_tensor
     procedure, non_overridable :: get_reference_h                => fe_map_get_reference_h
     procedure, non_overridable :: apply_inv_jacobian             => fe_map_apply_inv_jacobian
     procedure, non_overridable :: compute_quadrature_coordinates => fe_map_compute_quadrature_coordinates
     procedure, non_overridable :: get_quadrature_coordinates     => fe_map_get_quadrature_coordinates
  end type fe_map_t

  type p_fe_map_t
     class(fe_map_t), pointer :: p => NULL()   
   contains
     procedure :: allocate => p_fe_map_allocate
     procedure :: free     => p_fe_map_free
  end type p_fe_map_t

  public :: fe_map_t, p_fe_map_t
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  type fe_map_face_restriction_t
     private
     integer(ip)                 :: number_faces = 0
     integer(ip)                 :: active_face_id
     type(fe_map_t), allocatable :: fe_map(:)
   contains
     procedure, non_overridable :: create => fe_map_face_restriction_create
     procedure, non_overridable :: update => fe_map_face_restriction_update
     procedure, non_overridable :: free   => fe_map_face_restriction_free
     procedure, non_overridable :: get_coordinates => fe_map_face_restriction_get_coordinates
  end type fe_map_face_restriction_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  character(*), parameter :: field_type_scalar           = 'scalar'
  character(*), parameter :: field_type_vector           = 'vector'
  character(*), parameter :: field_type_tensor           = 'tensor'
  character(*), parameter :: field_type_symmetric_tensor = 'symmetric_tensor'
  
  character(*), parameter :: topology_hex = "hex"
  character(*), parameter :: topology_tet = "tet"
  character(*), parameter :: fe_type_lagrangian = "Lagrangian"
  character(*), parameter :: fe_type_vector_lagrangian = "Vector_Lagrangian"
  
  ! Abstract reference_fe
  type, abstract ::  reference_fe_t
     private
     character(:), allocatable :: &
          topology,               &    ! topology of element, 'tet', 'quad', 'prism', ...
          fe_type,                &    ! 'Lagrangian', 'RT', ...
          field_type                   ! 'scalar', 'vector', 'tensor', 'symmetric_tensor'

     integer(ip)              ::    &        
          number_dimensions,        &
          order,                    &
          number_field_components

     logical                  ::    &
          continuity,               &      ! CG(.true.)/DG(.false.)
          conformity                       ! .true. for discontinuous L2 conforming spaces 
                                           ! that do not require to enforce weakly continuity

     integer(ip)              ::    &
          number_n_faces,              &        
          number_shape_functions,             &        
          number_n_faces_per_dimension(5)

     type(allocatable_array_ip1_t)  :: orientation        ! orientation of the n-faces 
     type(list_t)                   :: interior_nodes_n_face ! interior nodes per n-face
     type(list_t)                   :: nodes_n_face          ! all nodes per n-face
     type(list_t)                   :: vertices_n_face       ! vertices per n-face
     type(list_t)                   :: n_faces_n_face           ! all n-faces per n-face
     type(list_t)                   :: own_nodes_n_faces
     type(list_t)                   :: face_integration_coupling_nodes_facet
     type(quadrature_t)             :: nodal_quadrature

     

     integer(ip), allocatable :: number_rotations_per_dimension(:)
     integer(ip), allocatable :: number_orientations_per_dimension(:)
     type(allocatable_array_ip2_t), allocatable :: own_node_permutations(:)
   contains
     ! TBPs
     ! Fill topology, fe_type, number_dimensions, order, continuity 
     procedure(create_interface)                        , deferred :: create 
     ! TBP to create a quadrature for a reference_fe_t
     procedure(create_quadrature_interface)             , deferred :: create_quadrature
     !procedure(create_quadrature_on_faces_interface)    , deferred :: create_quadrature_on_faces
     procedure(create_face_quadrature_interface)        , deferred :: create_face_quadrature
     ! TBP to create an interpolation from a quadrature_t and reference_fe_t, 
     ! i.e., the value of the shape functions of the reference element on the quadrature points. 
     procedure(create_interpolation_interface)          , deferred :: create_interpolation 
     procedure(create_face_interpolation_interface)     , deferred :: create_face_interpolation
     procedure(create_face_local_interpolation_interface),deferred :: create_face_local_interpolation
     procedure(update_interpolation_interface)          , deferred :: update_interpolation
     procedure(update_interpolation_face_interface)     , deferred :: update_interpolation_face
     procedure(get_component_node_interface)            , deferred :: get_component_node
     procedure(get_scalar_from_vector_node_interface)   , deferred :: get_scalar_from_vector_node
     procedure (get_number_nodes_scalar_interface),       deferred :: get_number_nodes_scalar
     
     procedure(get_value_scalar_interface)           , deferred :: get_value_scalar
     procedure(get_value_vector_interface)           , deferred :: get_value_vector
     !procedure(get_value_tensor_interface)          , deferred :: get_value_tensor           ! Pending
     !procedure(get_value_symmetric_tensor_interface), deferred :: get_value_symmetric_tensor ! Pending
     generic :: get_value => get_value_scalar,get_value_vector!                                      &
!          &                !,get_value_tensor,get_value_symmetric_tensor
    
     procedure(get_gradient_scalar_interface)          , deferred :: get_gradient_scalar
     procedure(get_gradient_vector_interface)          , deferred :: get_gradient_vector
     !procedure(get_gradient_tensor_interface)          , deferred :: get_gradient_tensor ! Pending
     generic :: get_gradient => get_gradient_scalar,get_gradient_vector!                             &
!          &                   !,get_value_tensor,get_value_symmetric_tensor
                                                                                     
     !procedure(get_symmetric_gradient_vector_interface), deferred :: get_symmetric_gradient_vector ! Pending
     !generic :: get_symmetric_gradient => get_symmetric_gradient_scalar

     procedure(get_divergence_vector_interface)        , deferred :: get_divergence_vector ! Pending
   !  procedure(get_divergence_tensor_interface)        , deferred :: get_divergence_tensor ! Pending
     generic :: get_divergence => get_divergence_vector !, get_divergence_tensor
                                                                                     
     procedure(get_curl_vector_interface)              , deferred :: get_curl_vector ! Pending
     generic :: get_curl => get_curl_vector

     procedure(evaluate_fe_function_scalar_interface), deferred :: evaluate_fe_function_scalar
     procedure(evaluate_fe_function_vector_interface), deferred :: evaluate_fe_function_vector
     procedure(evaluate_fe_function_tensor_interface), deferred :: evaluate_fe_function_tensor
     generic :: evaluate_fe_function => evaluate_fe_function_scalar, &
                                      & evaluate_fe_function_vector, &
                                      & evaluate_fe_function_tensor

     procedure(evaluate_gradient_fe_function_scalar_interface), deferred :: evaluate_gradient_fe_function_scalar
     procedure(evaluate_gradient_fe_function_vector_interface), deferred :: evaluate_gradient_fe_function_vector
     generic :: evaluate_gradient_fe_function => evaluate_gradient_fe_function_scalar, &
                                               & evaluate_gradient_fe_function_vector
     
     ! Blending function to generate interpolations in the interior (given values on the boundary)
     procedure(blending_interface), deferred :: blending

     ! This subroutine gives the reodering (o2n) of the nodes of an n-face given an orientation 'o'
     ! and a delay 'r' wrt to a refence element sharing the same n-face.
     procedure (check_compatibility_of_n_faces_interface), deferred :: &
          &     check_compatibility_of_n_faces
     procedure (get_characteristic_length_interface) , deferred :: get_characteristic_length
     procedure (set_nodal_quadrature_interface), deferred :: set_nodal_quadrature          
     procedure (fill_interior_points_permutation_interface), deferred :: fill_interior_points_permutation

     procedure (set_scalar_field_to_nodal_values_interface), deferred :: set_scalar_field_to_nodal_values
     procedure (set_vector_field_to_nodal_values_interface), deferred :: set_vector_field_to_nodal_values
     procedure (set_tensor_field_to_nodal_values_interface), deferred :: set_tensor_field_to_nodal_values
     generic :: set_field_to_nodal_values => set_scalar_field_to_nodal_values, &
                                           & set_vector_field_to_nodal_values, &
                                           & set_tensor_field_to_nodal_values

     procedure (interpolate_nodal_values_interface), deferred :: interpolate_nodal_values

     procedure (get_number_subelements_interface),       deferred :: get_number_subelements
     procedure (get_subelements_connectivity_interface), deferred :: get_subelements_connectivity


     ! generic part of the subroutine above
     procedure :: free  => reference_fe_free
     procedure :: print => reference_fe_print

     ! Set number_dimensions, order, continuity, field_type, number_field_components
     procedure :: set_common_data => reference_fe_set_common_data
     procedure :: set_topology => reference_fe_set_topology
     procedure :: set_fe_type => reference_fe_set_fe_type

     ! Getters
     procedure :: get_topology => reference_fe_get_topology
     procedure :: get_fe_type => reference_fe_get_fe_type
     procedure :: get_field_type => reference_fe_get_field_type
     procedure :: get_number_dimensions => reference_fe_get_number_dimensions
     procedure :: get_order => reference_fe_get_order
     procedure :: get_continuity => reference_fe_get_continuity
     procedure :: get_conformity => reference_fe_get_conformity
     procedure :: get_number_field_components => reference_fe_get_number_field_components
     procedure :: get_number_n_faces => reference_fe_get_number_n_faces
     procedure :: get_number_vertices => reference_fe_get_number_vertices
     procedure :: get_first_vertex_id => reference_fe_get_first_vertex_id
     procedure :: get_number_vertices_per_edge => reference_fe_get_number_vertices_per_edge
     procedure :: get_number_vertices_per_face => reference_fe_get_number_vertices_per_face
     procedure :: get_number_edges => reference_fe_get_number_edges
     procedure :: get_first_edge_id => reference_fe_get_first_edge_id
     procedure :: get_number_faces => reference_fe_get_number_faces
     procedure :: get_first_face_id => reference_fe_get_first_face_id
     procedure :: get_number_n_faces_of_dimension  => reference_fe_get_number_n_faces_of_dimension
     procedure :: get_first_n_face_id_of_dimension => reference_fe_get_first_n_face_id_of_dimension 
     procedure :: get_number_shape_functions => reference_fe_get_number_shape_functions
     procedure :: get_n_face_dimension  => reference_fe_get_n_face_dimension
     procedure :: get_vertices_n_face  =>   reference_fe_get_vertices_n_face
     procedure :: get_nodes_n_face   =>   reference_fe_get_nodes_n_face
     procedure :: get_n_faces_n_face   =>   reference_fe_get_n_faces_n_face
     procedure :: get_number_vertices_n_face => reference_fe_get_number_vertices_n_face

     procedure :: get_number_dofs_on_n_face => reference_fe_get_number_dofs_on_n_face
     procedure :: create_dofs_on_n_face_iterator => reference_fe_create_dofs_on_n_face_iterator
     
     procedure :: get_number_own_nodes_n_face => reference_fe_get_number_own_nodes_n_face
     procedure :: create_own_dofs_on_n_face_iterator => reference_fe_create_own_dofs_on_n_face_iterator
     procedure :: get_own_node_n_face => reference_fe_get_own_node_n_face

     procedure :: get_face_integration_coupling_number_nodes_face => reference_fe_get_face_integration_coupling_number_nodes_facet
     procedure :: get_face_integration_coupling_node_face => reference_fe_get_facet_integration_coupling_node_facet
     procedure :: create_facet_integration_coupling_dofs_iterator => create_facet_integration_coupling_dofs_iterator
     procedure :: get_orientation => reference_fe_get_orientation     
     procedure :: get_nodal_quadrature => reference_fe_get_nodal_quadrature
     procedure :: compute_relative_orientation => reference_fe_compute_relative_orientation
     procedure :: compute_relative_rotation => reference_fe_compute_relative_rotation
     procedure :: get_permuted_own_node_n_face  => reference_fe_get_permuted_own_node_n_face
  end type reference_fe_t

  type p_reference_fe_t
    class(reference_fe_t), pointer :: p => NULL()
  contains
    procedure :: free => p_reference_fe_free
  end type p_reference_fe_t

  abstract interface
     subroutine create_interface ( this, topology, number_dimensions, order, field_type, continuity, enable_face_integration )
       import :: reference_fe_t, ip
       implicit none 
       class(reference_fe_t), intent(inout) :: this 
       character(*)         , intent(in)    :: topology
       integer(ip)          , intent(in)    :: number_dimensions
       integer(ip)          , intent(in)    :: order
       character(*)         , intent(in)    :: field_type
       logical              , intent(in)    :: continuity
       logical, optional    , intent(in)    :: enable_face_integration
     end subroutine create_interface
     
     subroutine create_quadrature_interface ( this, quadrature, max_order )
       import :: reference_fe_t, quadrature_t, ip
       implicit none 
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(inout) :: quadrature
       integer(ip), optional, intent(in)    :: max_order
     end subroutine create_quadrature_interface
 
     subroutine create_face_quadrature_interface ( this, quadrature, max_order  )
       import :: reference_fe_t, quadrature_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(inout) :: quadrature
       integer(ip), optional, intent(in)    :: max_order
     end subroutine create_face_quadrature_interface
     
     subroutine create_interpolation_interface ( this, quadrature, interpolation, compute_hessian )
       import :: reference_fe_t, quadrature_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this 
       type(quadrature_t)   , intent(in)    :: quadrature
       type(interpolation_t), intent(inout) :: interpolation
       logical    , optional, intent(in)    :: compute_hessian
     end subroutine create_interpolation_interface

     subroutine create_face_local_interpolation_interface ( this, quadrature, interpolation )
       import :: reference_fe_t, quadrature_t, interpolation_t
       implicit none
       class(reference_fe_t), intent(in)    :: this
       type(quadrature_t)   , intent(in)    :: quadrature
       type(interpolation_t), intent(inout) :: interpolation
     end subroutine create_face_local_interpolation_interface

     subroutine create_face_interpolation_interface ( this, local_face_id , local_quadrature,       &
          &                                           face_interpolation)
       import :: reference_fe_t, ip, quadrature_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this
       integer(ip)          , intent(in)    :: local_face_id
       type(quadrature_t)   , intent(in)    :: local_quadrature
       type(interpolation_t), intent(inout) :: face_interpolation
     end subroutine create_face_interpolation_interface
 
     function get_component_node_interface( this, node )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this 
       integer(ip)          , intent(in) :: node
       integer(ip) :: get_component_node_interface
     end function get_component_node_interface
 
     function get_scalar_from_vector_node_interface( this, node )
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this 
       integer(ip)          , intent(in) :: node
       integer(ip) :: get_scalar_from_vector_node_interface
     end function get_scalar_from_vector_node_interface

     function get_number_nodes_scalar_interface(this) result(number_nodes_scalar)
     import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in) :: this
       integer(ip)                       :: number_nodes_scalar
     end function get_number_nodes_scalar_interface

     subroutine get_value_scalar_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 scalar_field )
       import :: reference_fe_t, interpolation_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       real(rp)             , intent(inout) :: scalar_field
     end subroutine get_value_scalar_interface
     
     subroutine get_value_vector_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_value_vector_interface
     
     subroutine get_gradient_scalar_interface( this, actual_cell_interpolation, ishape, qpoint,     &
          &                                    vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_gradient_scalar_interface
     
     subroutine get_gradient_vector_interface( this, actual_cell_interpolation, ishape, qpoint,     &
          &                                    tensor_field )
       import :: reference_fe_t, interpolation_t, tensor_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(tensor_field_t) , intent(inout) :: tensor_field
     end subroutine get_gradient_vector_interface

     subroutine get_divergence_vector_interface( this, actual_cell_interpolation, ishape, qpoint,        &
          &                                 scalar_field )
      import :: reference_fe_t, interpolation_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       real(rp)             , intent(inout) :: scalar_field
     end subroutine get_divergence_vector_interface

     subroutine get_curl_vector_interface( this, actual_cell_interpolation, ishape, qpoint,     &
          &                                    vector_field )
       import :: reference_fe_t, interpolation_t, vector_field_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       integer(ip)          , intent(in)    :: ishape
       integer(ip)          , intent(in)    :: qpoint
       type(vector_field_t) , intent(inout) :: vector_field
     end subroutine get_curl_vector_interface

     subroutine evaluate_fe_function_scalar_interface( this,                      &
                                                     & actual_cell_interpolation, &
                                                     & nodal_values,              &
                                                     & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       real(rp)             , intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_scalar_interface

     subroutine evaluate_fe_function_vector_interface( this,                      &
                                                     & actual_cell_interpolation, &
                                                     & nodal_values,              &
                                                     & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, vector_field_t
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       type(vector_field_t) , intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_vector_interface

     subroutine evaluate_fe_function_tensor_interface( this,                      &
                                                     & actual_cell_interpolation, &
                                                     & nodal_values,              &
                                                     & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, tensor_field_t
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       type(tensor_field_t) , intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_fe_function_tensor_interface     

     subroutine evaluate_gradient_fe_function_scalar_interface( this,             &
                                                     & actual_cell_interpolation, &
                                                     & nodal_values,              &
                                                     & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, vector_field_t
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       type(vector_field_t) , intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_gradient_fe_function_scalar_interface

     subroutine evaluate_gradient_fe_function_vector_interface( this,             &
                                                     & actual_cell_interpolation, &
                                                     & nodal_values,              &
                                                     & quadrature_points_values)
       import :: reference_fe_t, interpolation_t, rp, tensor_field_t
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: actual_cell_interpolation 
       real(rp)             , intent(in)    :: nodal_values(:)
       type(tensor_field_t) , intent(inout) :: quadrature_points_values(:)
     end subroutine evaluate_gradient_fe_function_vector_interface

     subroutine blending_interface( this,values)
       import :: reference_fe_t, point_t
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       type(point_t)        , intent(inout) :: values(:)     
     end subroutine blending_interface

     function check_compatibility_of_n_faces_interface(target_reference_fe, &
          &                       source_reference_fe, source_n_face_id,target_n_face_id)
       import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: target_reference_fe
       class(reference_fe_t), intent(in)    :: source_reference_fe
       integer(ip)          , intent(in)    :: source_n_face_id
       integer(ip)          , intent(in)    :: target_n_face_id 
       logical :: check_compatibility_of_n_faces_interface
     end function  check_compatibility_of_n_faces_interface

     function get_characteristic_length_interface( this)
       import :: reference_fe_t, rp
       implicit none 
       class(reference_fe_t), intent(in) :: this 
       real(rp)  :: get_characteristic_length_interface 
     end function get_characteristic_length_interface

     subroutine update_interpolation_interface ( this, fe_map, interpolation_reference_cell,        &
          &                            interpolation_real_cell )
       import :: reference_fe_t, fe_map_t, interpolation_t
       implicit none 
       class(reference_fe_t), intent(in)    :: this 
       type(fe_map_t)       , intent(in)    :: fe_map
       type(interpolation_t), intent(in)    :: interpolation_reference_cell
       type(interpolation_t), intent(inout) :: interpolation_real_cell
     end subroutine update_interpolation_interface

     subroutine update_interpolation_face_interface ( this, local_face_id,fe_map_face_restriction,  &
          &                                           interpolation_face_restriction)
       import :: reference_fe_t, ip, fe_map_face_restriction_t,  interpolation_face_restriction_t
       implicit none 
       class(reference_fe_t)                 , intent(in)    :: this 
       integer(ip)                           , intent(in)    :: local_face_id
       type(fe_map_face_restriction_t)       , intent(in)    :: fe_map_face_restriction
       type(interpolation_face_restriction_t), intent(inout) :: interpolation_face_restriction
     end subroutine update_interpolation_face_interface

     subroutine set_nodal_quadrature_interface ( this )
       import :: reference_fe_t
       implicit none
       class(reference_fe_t), intent(inout) :: this 
     end subroutine set_nodal_quadrature_interface

     subroutine set_scalar_field_to_nodal_values_interface ( this, code, values, nodal_codes, &
          &                                                  nodal_values, unknown_component)
       import :: reference_fe_t, rp, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       integer(ip)          , intent(in)    :: code
       real(rp)             , intent(in)    :: values(:)
       integer(ip)          , intent(in)    :: nodal_codes(:)
       real(rp)             , intent(inout) :: nodal_values(:)
       integer(ip), optional, intent(in)    :: unknown_component
     end subroutine set_scalar_field_to_nodal_values_interface

     subroutine set_vector_field_to_nodal_values_interface ( this, code, values, nodal_codes, &
          &                                                  nodal_values)
       import :: reference_fe_t, vector_field_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this
       integer(ip)          , intent(in)    :: code
       type(vector_field_t) , intent(in)    :: values(:)
       integer(ip)          , intent(in)    :: nodal_codes(:)
       real(rp)             , intent(inout) :: nodal_values(:)
     end subroutine set_vector_field_to_nodal_values_interface

     subroutine set_tensor_field_to_nodal_values_interface ( this, code, values, nodal_codes, &
          &                                                  nodal_values)
       import :: reference_fe_t, tensor_field_t, ip, rp
       implicit none
       class(reference_fe_t), intent(in)    :: this 
       integer(ip)          , intent(in)    :: code
       type(tensor_field_t) , intent(in)    :: values(:)
       integer(ip)          , intent(in)    :: nodal_codes(:)
       real(rp)             , intent(inout) :: nodal_values(:)
     end subroutine set_tensor_field_to_nodal_values_interface
               
     subroutine fill_interior_points_permutation_interface( this,&
                                                            dimension,&
                                                            number_interior_points,&
                                                            interior_points_permutation )
       import :: reference_fe_t, ip
       implicit none 
       class(reference_fe_t)                 , intent(inout) :: this 
       integer(ip)                           , intent(in)    :: dimension
       integer(ip)                           , intent(in)    :: number_interior_points
       integer(ip)             , allocatable , intent(inout) :: interior_points_permutation(:,:)
     end subroutine fill_interior_points_permutation_interface

     subroutine interpolate_nodal_values_interface(this,nodal_interpolation,nodal_values_origin, &
          &                                        nodal_values_destination)
       import :: reference_fe_t, interpolation_t, rp
       implicit none 
       class(reference_fe_t), intent(in)    :: this 
       type(interpolation_t), intent(in)    :: nodal_interpolation
       real(rp)             , intent(in)    :: nodal_values_origin(:)
       real(rp)             , intent(inout) :: nodal_values_destination(:)
     end subroutine interpolate_nodal_values_interface
     
     function get_number_subelements_interface(this) result(number_subelements)
     import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       integer(ip)                          :: number_subelements
     end function get_number_subelements_interface

     subroutine get_subelements_connectivity_interface(this, connectivity)
     import :: reference_fe_t, ip
       implicit none
       class(reference_fe_t), intent(in)    :: this
       integer(ip),           intent(inout) :: connectivity(:,:)
     end subroutine get_subelements_connectivity_interface
  end interface

  public :: reference_fe_t, p_reference_fe_t
  public :: field_type_scalar, field_type_vector, field_type_tensor, field_type_symmetric_tensor
  public :: topology_hex, topology_tet, fe_type_lagrangian, fe_type_vector_lagrangian
  
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, abstract, extends(reference_fe_t) :: vector_lagrangian_reference_fe_t
     private
     integer(ip)              :: number_nodes_scalar
     integer(ip), allocatable :: node_component_array(:,:)
     integer(ip), allocatable :: node_array_component(:,:)
   contains
     ! Additional deferred methods
     !procedure (fill_scalar_interface)            , private, deferred :: fill_scalar
     procedure (vlrfe_fill_quadrature_interface)        , private, deferred :: vlrfe_fill_quadrature   
     procedure (vlrfe_fill_interpolation_interface)     , private, deferred :: vlrfe_fill_interpolation
     procedure (vlrfe_fill_face_interpolation_interface), private, deferred :: vlrfe_fill_face_interpolation
     procedure (vlrfe_get_node_local_id_interface)      , private, deferred :: vlrfe_get_node_local_id
     procedure (vlrfe_get_node_local_coordinates_interface)      , private, deferred :: &
              & vlrfe_get_node_local_coordinates
     procedure (vlrfe_set_coordinates_1D_interface)              , private, deferred :: &
              & vlrfe_set_coordinates_1D
     procedure (vlrfe_set_permutation_2D_interface)              , private, deferred :: &
              & vlrfe_set_permutation_2D
     procedure (vlrfe_set_number_quadrature_points_interface)    , private, deferred :: &
              & vlrfe_set_number_quadrature_points
     procedure (vlrfe_compute_number_nodes_scalar_interface)     , private, deferred :: &
              & vlrfe_compute_number_nodes_scalar
     procedure (vlrfe_get_number_interior_points_x_dim_interface), private, deferred :: &
              & vlrfe_get_number_interior_points_x_dim

     procedure :: create                    => vlrfe_create
     procedure :: fill_vector               => vlrfe_fill_vector
     procedure :: fill_interior_points_permutation     & 
      & => vlrfe_fill_interior_points_permutation
     procedure :: create_quadrature         => vlrfe_create_quadrature
     procedure :: create_face_quadrature    => vlrfe_create_face_quadrature
     procedure :: create_interpolation      => vlrfe_create_interpolation
     procedure :: create_face_interpolation => vlrfe_create_face_interpolation
     procedure :: create_face_local_interpolation      & 
      & => vlrfe_create_face_local_interpolation
     procedure :: update_interpolation      => vlrfe_update_interpolation
     procedure :: update_interpolation_face => vlrfe_update_interpolation_face
     procedure :: get_component_node        => vlrfe_get_component_node
     procedure :: get_scalar_from_vector_node          & 
      & => vlrfe_get_scalar_from_vector_node
     procedure :: get_number_nodes_scalar   => vlrfe_get_number_nodes_scalar
     procedure :: get_value_scalar          => vlrfe_get_value_scalar
     procedure :: get_value_vector          => vlrfe_get_value_vector
     procedure :: get_gradient_scalar       => vlrfe_get_gradient_scalar
     procedure :: get_gradient_vector       => vlrfe_get_gradient_vector
     procedure :: get_divergence_vector     => vlrfe_get_divergence_vector
     procedure :: get_curl_vector           => vlrfe_get_curl_vector
     procedure :: interpolate_nodal_values  => vlrfe_interpolate_nodal_values
     procedure :: set_nodal_quadrature      => vlrfe_set_nodal_quadrature
     procedure :: set_scalar_field_to_nodal_values     & 
      & => vlrfe_set_scalar_field_to_nodal_values
     procedure :: set_vector_field_to_nodal_values     & 
      & => vlrfe_set_vector_field_to_nodal_values
     procedure :: set_tensor_field_to_nodal_values     & 
      & => vlrfe_set_tensor_field_to_nodal_values
     procedure :: evaluate_fe_function_scalar          &
      & => vlrfe_evaluate_fe_function_scalar
     procedure :: evaluate_fe_function_vector          & 
      & => vlrfe_evaluate_fe_function_vector
     procedure :: evaluate_fe_function_tensor          & 
      & => vlrfe_evaluate_fe_function_tensor
     procedure :: evaluate_gradient_fe_function_scalar & 
      & => vlrfe_eval_grad_fe_function_scalar
     procedure :: evaluate_gradient_fe_function_vector &
      & => vlrfe_eval_grad_fe_function_vector
     procedure :: get_number_subelements    => vlrfe_get_number_subelements
     procedure :: free                      => vlrfe_free
     ! Concrete TBPs of this derived data type
     procedure, private, non_overridable :: fill                         & 
      & => vlrfe_fill
     procedure, private, non_overridable :: fill_field_components        & 
      & => vlrfe_fill_field_components
     procedure, private, non_overridable :: fill_permutation_array       &
      & => vlrfe_fill_permutation_array
     procedure, private, non_overridable :: fill_nodal_quadrature        &
      & => vlrfe_fill_nodal_quadrature
     procedure, private, non_overridable :: get_node_coordinates_array   & 
      & => vlrfe_get_node_coordinates_array
     procedure, private, non_overridable :: set_permutation_1D           & 
      & => vlrfe_set_permutation_1D
     procedure, private, non_overridable :: extend_list_components       & 
      & => vlrfe_extend_list_components
     procedure, private, non_overridable :: apply_femap_to_interpolation & 
      & => vlrfe_apply_femap_to_interpolation
  end type vector_lagrangian_reference_fe_t
  
  abstract interface
  
     subroutine fill_vector_interface ( this )
     import :: vector_lagrangian_reference_fe_t
       implicit none 
       class(vector_lagrangian_reference_fe_t), intent(inout) :: this 
     end subroutine fill_vector_interface
     
     subroutine vlrfe_fill_quadrature_interface ( this, quadrature )
     import :: vector_lagrangian_reference_fe_t, quadrature_t
       implicit none 
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       type(quadrature_t)              , intent(inout) :: quadrature       
     end subroutine vlrfe_fill_quadrature_interface
     
     subroutine vlrfe_fill_interpolation_interface ( this, interpolation, coord_ip )
     import :: vector_lagrangian_reference_fe_t, interpolation_t, ip, rp
       implicit none 
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       type(interpolation_t)           , intent(inout) :: interpolation  
       real(rp)                        , intent(in)    :: coord_ip(:,:)
     end subroutine vlrfe_fill_interpolation_interface
 
     subroutine vlrfe_fill_face_interpolation_interface ( this,               &
                                                    face_interpolation, &
                                                    local_quadrature,   &
                                                    local_face_id )
     import :: vector_lagrangian_reference_fe_t, interpolation_t, quadrature_t, ip
       implicit none 
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       type(interpolation_t)           , intent(inout) :: face_interpolation
       type(quadrature_t)              , intent(in)    :: local_quadrature
       integer(ip)                     , intent(in)    :: local_face_id
     end subroutine vlrfe_fill_face_interpolation_interface
     
     function vlrfe_get_node_local_id_interface ( this,                 &
                                            local_coordinates,    &
                                            number_of_dimensions, &
                                            order )
     import :: vector_lagrangian_reference_fe_t, ip
       implicit none
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: local_coordinates(:)
       integer(ip)                     , intent(in)    :: number_of_dimensions
       integer(ip)                     , intent(in)    :: order
       integer(ip) :: vlrfe_get_node_local_id_interface
     end function vlrfe_get_node_local_id_interface
     
     subroutine vlrfe_get_node_local_coordinates_interface( this,                 &
                                                      local_coordinates,    &
                                                      local_id,             &
                                                      number_of_dimensions, &
                                                      order )
     import :: vector_lagrangian_reference_fe_t, ip
       implicit none
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(inout) :: local_coordinates(:)
       integer(ip)                     , intent(in)    :: local_id
       integer(ip)                     , intent(in)    :: number_of_dimensions
       integer(ip)                     , intent(in)    :: order       
     end subroutine vlrfe_get_node_local_coordinates_interface

     subroutine vlrfe_set_coordinates_1D_interface (this, abscissae, number_of_points)
     import :: vector_lagrangian_reference_fe_t, ip, rp
       implicit none
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: number_of_points
       real(rp)                        , intent(inout) :: abscissae(:)
     end subroutine vlrfe_set_coordinates_1D_interface
     
     subroutine vlrfe_set_permutation_2D_interface ( this,               &
                                               permutation,        &
                                               number_nodes_x_dim, &
                                               orientation,        &
                                               rotation )
     import :: vector_lagrangian_reference_fe_t, ip
       implicit none 
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(inout) :: permutation(:)
       integer(ip)                     , intent(in)    :: number_nodes_x_dim
       integer(ip)                     , intent(in)    :: orientation
       integer(ip)                     , intent(in)    :: rotation
     end subroutine vlrfe_set_permutation_2D_interface
     
     function vlrfe_set_number_quadrature_points_interface ( this, order, dimension )
     import :: vector_lagrangian_reference_fe_t, ip
       implicit none 
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: order    
       integer(ip)                     , intent(in)    :: dimension
       integer(ip) :: vlrfe_set_number_quadrature_points_interface
     end function vlrfe_set_number_quadrature_points_interface
     
     function vlrfe_compute_number_nodes_scalar_interface ( this, order, dimension )
     import :: vector_lagrangian_reference_fe_t, ip
       implicit none 
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: order    
       integer(ip)                     , intent(in)    :: dimension
       integer(ip) :: vlrfe_compute_number_nodes_scalar_interface
     end function vlrfe_compute_number_nodes_scalar_interface

     function vlrfe_get_number_interior_points_x_dim_interface ( this,                   &
                                                           number_interior_points, &
                                                           dimension)
     import :: vector_lagrangian_reference_fe_t, ip
       implicit none
       class(vector_lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: number_interior_points
       integer(ip)                     , intent(in)    :: dimension
       integer(ip) :: vlrfe_get_number_interior_points_x_dim_interface
     end function vlrfe_get_number_interior_points_x_dim_interface
     
  end interface
  
  public :: vector_lagrangian_reference_fe_t  

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, abstract, extends(reference_fe_t) :: lagrangian_reference_fe_t
     private
     integer(ip)              :: number_nodes_scalar
     integer(ip), allocatable :: node_component_array(:,:)
     integer(ip), allocatable :: node_array_component(:,:)
   contains
     ! Additional deferred methods
     !procedure (fill_scalar_interface)            , private, deferred :: fill_scalar
     procedure (fill_quadrature_interface)        , private, deferred :: fill_quadrature   
     procedure (fill_interpolation_interface)     , private, deferred :: fill_interpolation
     procedure (fill_face_interpolation_interface), private, deferred :: fill_face_interpolation
     procedure (get_node_local_id_interface)      , private, deferred :: get_node_local_id
     procedure (get_node_local_coordinates_interface)      , private, deferred :: &
              & get_node_local_coordinates
     procedure (set_coordinates_1D_interface)              , private, deferred :: &
              & set_coordinates_1D
     procedure (set_permutation_2D_interface)              , private, deferred :: &
              & set_permutation_2D
     procedure (set_number_quadrature_points_interface)    , private, deferred :: &
              & set_number_quadrature_points
     procedure (compute_number_nodes_scalar_interface)     , private, deferred :: &
              & compute_number_nodes_scalar
     procedure (get_number_interior_points_x_dim_interface), private, deferred :: &
              & get_number_interior_points_x_dim

     procedure :: create                    => lagrangian_reference_fe_create
     procedure :: fill_scalar               => lagrangian_reference_fe_fill_scalar
     procedure :: fill_interior_points_permutation     & 
      & => lagrangian_reference_fe_fill_interior_points_permutation
     procedure :: create_quadrature         => lagrangian_reference_fe_create_quadrature
     procedure :: create_face_quadrature    => lagrangian_reference_fe_create_face_quadrature
     procedure :: create_interpolation      => lagrangian_reference_fe_create_interpolation
     procedure :: create_face_interpolation => lagrangian_reference_fe_create_face_interpolation
     procedure :: create_face_local_interpolation      & 
      & => lagrangian_reference_fe_create_face_local_interpolation
     procedure :: update_interpolation      => lagrangian_reference_fe_update_interpolation
     procedure :: update_interpolation_face => lagrangian_reference_fe_update_interpolation_face
     procedure :: get_component_node        => lagrangian_reference_fe_get_component_node
     procedure :: get_scalar_from_vector_node          & 
      & => lagrangian_reference_fe_get_scalar_from_vector_node
     procedure :: get_number_nodes_scalar   => lagrangian_reference_fe_get_number_nodes_scalar
     procedure :: get_value_scalar          => lagrangian_reference_fe_get_value_scalar
     procedure :: get_value_vector          => lagrangian_reference_fe_get_value_vector
     procedure :: get_gradient_scalar       => lagrangian_reference_fe_get_gradient_scalar
     procedure :: get_gradient_vector       => lagrangian_reference_fe_get_gradient_vector
     procedure :: get_divergence_vector     => lagrangian_reference_fe_get_divergence_vector
     procedure :: get_curl_vector           => lagrangian_reference_fe_get_curl_vector
     procedure :: interpolate_nodal_values  => lagrangian_reference_fe_interpolate_nodal_values
     procedure :: set_nodal_quadrature      => lagrangian_reference_fe_set_nodal_quadrature
     procedure :: set_scalar_field_to_nodal_values     & 
      & => lagrangian_reference_fe_set_scalar_field_to_nodal_values
     procedure :: set_vector_field_to_nodal_values     & 
      & => lagrangian_reference_fe_set_vector_field_to_nodal_values
     procedure :: set_tensor_field_to_nodal_values     & 
      & => lagrangian_reference_fe_set_tensor_field_to_nodal_values
     procedure :: evaluate_fe_function_scalar          &
      & => lagrangian_reference_fe_evaluate_fe_function_scalar
     procedure :: evaluate_fe_function_vector          & 
      & => lagrangian_reference_fe_evaluate_fe_function_vector
     procedure :: evaluate_fe_function_tensor          & 
      & => lagrangian_reference_fe_evaluate_fe_function_tensor
     procedure :: evaluate_gradient_fe_function_scalar & 
      & => lagrangian_reference_fe_evaluate_gradient_fe_function_scalar
     procedure :: evaluate_gradient_fe_function_vector &
      & => lagrangian_reference_fe_evaluate_gradient_fe_function_vector
     procedure :: get_number_subelements    => lagrangian_reference_fe_get_number_subelements
     procedure :: free                      => lagrangian_reference_fe_free
     ! Concrete TBPs of this derived data type
     procedure, private, non_overridable :: fill                         & 
      & => lagrangian_reference_fe_fill
     procedure, private, non_overridable :: fill_field_components        & 
      & => lagrangian_reference_fe_fill_field_components
     procedure, private, non_overridable :: fill_permutation_array       &
      & => lagrangian_reference_fe_fill_permutation_array
     procedure, private, non_overridable :: fill_nodal_quadrature        &
      & => lagrangian_reference_fe_fill_nodal_quadrature
     procedure, private, non_overridable :: get_node_coordinates_array   & 
      & => lagrangian_reference_fe_get_node_coordinates_array
     procedure, private, non_overridable :: set_permutation_1D           & 
      & => lagrangian_reference_fe_set_permutation_1D
     procedure, private, non_overridable :: extend_list_components       & 
      & => lagrangian_reference_fe_extend_list_components
     procedure, private, non_overridable :: apply_femap_to_interpolation & 
      & => lagrangian_reference_fe_apply_femap_to_interpolation
  end type lagrangian_reference_fe_t

  abstract interface
  
     subroutine fill_scalar_interface ( this )
     import :: lagrangian_reference_fe_t
       implicit none 
       class(lagrangian_reference_fe_t), intent(inout) :: this 
     end subroutine fill_scalar_interface
     
     subroutine fill_quadrature_interface ( this, quadrature )
     import :: lagrangian_reference_fe_t, quadrature_t
       implicit none 
       class(lagrangian_reference_fe_t), intent(in)    :: this
       type(quadrature_t)              , intent(inout) :: quadrature       
     end subroutine fill_quadrature_interface
     
     subroutine fill_interpolation_interface ( this, interpolation, coord_ip )
     import :: lagrangian_reference_fe_t, interpolation_t, ip, rp
       implicit none 
       class(lagrangian_reference_fe_t), intent(in)    :: this
       type(interpolation_t)           , intent(inout) :: interpolation  
       real(rp)                        , intent(in)    :: coord_ip(:,:)
     end subroutine fill_interpolation_interface
 
     subroutine fill_face_interpolation_interface ( this,               &
                                                    face_interpolation, &
                                                    local_quadrature,   &
                                                    local_face_id )
     import :: lagrangian_reference_fe_t, interpolation_t, quadrature_t, ip
       implicit none 
       class(lagrangian_reference_fe_t), intent(in)    :: this
       type(interpolation_t)           , intent(inout) :: face_interpolation
       type(quadrature_t)              , intent(in)    :: local_quadrature
       integer(ip)                     , intent(in)    :: local_face_id
     end subroutine fill_face_interpolation_interface
     
     function get_node_local_id_interface ( this,                 &
                                            local_coordinates,    &
                                            number_of_dimensions, &
                                            order )
     import :: lagrangian_reference_fe_t, ip
       implicit none
       class(lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: local_coordinates(:)
       integer(ip)                     , intent(in)    :: number_of_dimensions
       integer(ip)                     , intent(in)    :: order
       integer(ip) :: get_node_local_id_interface
     end function get_node_local_id_interface
     
     subroutine get_node_local_coordinates_interface( this,                 &
                                                      local_coordinates,    &
                                                      local_id,             &
                                                      number_of_dimensions, &
                                                      order )
     import :: lagrangian_reference_fe_t, ip
       implicit none
       class(lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(inout) :: local_coordinates(:)
       integer(ip)                     , intent(in)    :: local_id
       integer(ip)                     , intent(in)    :: number_of_dimensions
       integer(ip)                     , intent(in)    :: order       
     end subroutine get_node_local_coordinates_interface

     subroutine set_coordinates_1D_interface (this, abscissae, number_of_points)
     import :: lagrangian_reference_fe_t, ip, rp
       implicit none
       class(lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: number_of_points
       real(rp)                        , intent(inout) :: abscissae(:)
     end subroutine set_coordinates_1D_interface
     
     subroutine set_permutation_2D_interface ( this,               &
                                               permutation,        &
                                               number_nodes_x_dim, &
                                               orientation,        &
                                               rotation )
     import :: lagrangian_reference_fe_t, ip
       implicit none 
       class(lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(inout) :: permutation(:)
       integer(ip)                     , intent(in)    :: number_nodes_x_dim
       integer(ip)                     , intent(in)    :: orientation
       integer(ip)                     , intent(in)    :: rotation
     end subroutine set_permutation_2D_interface
     
     function set_number_quadrature_points_interface ( this, order, dimension )
     import :: lagrangian_reference_fe_t, ip
       implicit none 
       class(lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: order    
       integer(ip)                     , intent(in)    :: dimension
       integer(ip) :: set_number_quadrature_points_interface
     end function set_number_quadrature_points_interface
     
     function compute_number_nodes_scalar_interface ( this, order, dimension )
     import :: lagrangian_reference_fe_t, ip
       implicit none 
       class(lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: order    
       integer(ip)                     , intent(in)    :: dimension
       integer(ip) :: compute_number_nodes_scalar_interface
     end function compute_number_nodes_scalar_interface

     function get_number_interior_points_x_dim_interface ( this,                   &
                                                           number_interior_points, &
                                                           dimension)
     import :: lagrangian_reference_fe_t, ip
       implicit none
       class(lagrangian_reference_fe_t), intent(in)    :: this
       integer(ip)                     , intent(in)    :: number_interior_points
       integer(ip)                     , intent(in)    :: dimension
       integer(ip) :: get_number_interior_points_x_dim_interface
     end function get_number_interior_points_x_dim_interface
     
  end interface
  
  public :: lagrangian_reference_fe_t  
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, extends(lagrangian_reference_fe_t) :: tet_lagrangian_reference_fe_t
     private
   contains 
     ! Deferred TBP implementors from reference_fe_t
     procedure :: check_compatibility_of_n_faces                                 &
           &   => tet_lagrangian_reference_fe_check_compatibility_of_n_faces
     procedure :: get_characteristic_length                                   &
           &   => tet_lagrangian_reference_fe_get_characteristic_length
     procedure :: get_subelements_connectivity                                &
           &   => tet_lagrangian_reference_fe_get_subelements_connectivity
     procedure :: blending                                                    &
           &   => tet_lagrangian_reference_fe_blending 
     ! Deferred TBP implementors from lagrangian_reference_fe_t
     !procedure, private :: fill_scalar                                        &
     !      & => tet_lagrangian_reference_fe_fill_scalar
     procedure, private :: fill_quadrature                                    &
           & => tet_lagrangian_reference_fe_fill_quadrature
     procedure, private :: fill_interpolation                                 &
           & => tet_lagrangian_reference_fe_fill_interpolation
     procedure, private :: fill_face_interpolation                            &
           & => tet_lagrangian_reference_fe_fill_face_interpolation
     procedure, private :: get_node_local_id                                  &
           & => tet_lagrangian_reference_fe_get_node_local_id
     procedure, private :: get_node_local_coordinates                         &
           & => tet_lagrangian_reference_fe_get_node_local_coordinates
     procedure, private :: set_coordinates_1D                                 &
           & => tet_lagrangian_reference_fe_set_coordinates_1D
     procedure, private :: set_permutation_2D                                 &
           & => tet_lagrangian_reference_fe_set_permutation_2D
     procedure, private :: set_number_quadrature_points                       &
           & => tet_lagrangian_reference_fe_set_number_quadrature_points
     procedure, private :: compute_number_nodes_scalar                        &
           & => tet_lagrangian_reference_fe_compute_number_nodes_scalar
     procedure, private :: get_number_interior_points_x_dim                   &
           & => tet_lagrangian_reference_fe_get_number_interior_points_x_dim
     ! Concrete TBPs of this derived data type
     procedure, private, non_overridable :: fill_nodes_n_face                    &
           & => tet_lagrangian_reference_fe_fill_nodes_n_face
     procedure, private, non_overridable :: fill_n_face_dimension_and_vertices   &
           & => tet_lagrangian_reference_fe_fill_n_face_dimension_and_vertices
     procedure, private, non_overridable :: compute_number_interior_nodes     &
           & => tet_lagrangian_reference_fe_compute_number_interior_nodes
     procedure, private, non_overridable :: compute_sum_of_nodes_in_simplices &
           & => tet_lagrangian_reference_fe_compute_sum_of_nodes_in_simplices
     procedure, private, non_overridable :: evaluate_interpolation            &
           & => tet_lagrangian_reference_fe_evaluate_interpolation
     procedure, private, non_overridable :: get_n_face_orientation               &
           & => tet_lagrangian_reference_fe_get_n_face_orientation
  end type tet_lagrangian_reference_fe_t
  
  public :: tet_lagrangian_reference_fe_t
  
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, extends(vector_lagrangian_reference_fe_t) :: tet_vector_lagrangian_reference_fe_t
     private
   contains 
     ! Deferred TBP implementors from reference_fe_t
     procedure :: check_compatibility_of_n_faces                                 &
           &   => tet_vlrfe_check_compatibility_of_n_faces
     procedure :: get_characteristic_length                                   &
           &   => tet_vlrfe_get_characteristic_length
     procedure :: get_subelements_connectivity                                &
           &   => tet_vlrfe_get_subelements_connectivity
     procedure :: blending                                                    &
           &   => tet_vlrfe_blending 
     ! Deferred TBP implementors from lagrangian_reference_fe_t
     !procedure, private :: fill_scalar                                        &
     !      & => tet_vlrfe_fill_scalar
     procedure, private :: vlrfe_fill_quadrature                                    &
           & => tet_vlrfe_fill_quadrature
     procedure, private :: vlrfe_fill_interpolation                                 &
           & => tet_vlrfe_fill_interpolation
     procedure, private :: vlrfe_fill_face_interpolation                            &
           & => tet_vlrfe_fill_face_interpolation
     procedure, private :: vlrfe_get_node_local_id                                  &
           & => tet_vlrfe_get_node_local_id
     procedure, private :: vlrfe_get_node_local_coordinates                         &
           & => tet_vlrfe_get_node_local_coordinates
     procedure, private :: vlrfe_set_coordinates_1D                                 &
           & => tet_vlrfe_set_coordinates_1D
     procedure, private :: vlrfe_set_permutation_2D                                 &
           & => tet_vlrfe_set_permutation_2D
     procedure, private :: vlrfe_set_number_quadrature_points                       &
           & => tet_vlrfe_set_number_quadrature_points
     procedure, private :: vlrfe_compute_number_nodes_scalar                        &
           & => tet_vlrfe_compute_number_nodes_scalar
     procedure, private :: vlrfe_get_number_interior_points_x_dim                   &
           & => tet_vlrfe_get_number_interior_points_x_dim
     ! Concrete TBPs of this derived data type
     procedure, private, non_overridable :: vlrfe_fill_nodes_n_face                    &
           & => tet_vlrfe_fill_nodes_n_face
     procedure, private, non_overridable :: vlrfe_fill_n_face_dimension_and_vertices   &
           & => tet_vlrfe_fill_n_face_dimension_and_vertices
     procedure, private, non_overridable :: vlrfe_compute_number_interior_nodes     &
           & => tet_vlrfe_compute_number_interior_nodes
     procedure, private, non_overridable :: vlrfe_compute_sum_of_nodes_in_simplices &
           & => tet_vlrfe_compute_sum_of_nodes_in_simplices
     procedure, private, non_overridable :: vlrfe_evaluate_interpolation            &
           & => tet_vlrfe_evaluate_interpolation
     procedure, private, non_overridable :: vlrfe_get_n_face_orientation               &
           & => tet_vlrfe_get_n_face_orientation
  end type tet_vector_lagrangian_reference_fe_t
  
  public :: tet_vector_lagrangian_reference_fe_t
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type, extends(lagrangian_reference_fe_t) :: hex_lagrangian_reference_fe_t
     private
   contains 
     ! Deferred TBP implementors from reference_fe_t
     procedure :: check_compatibility_of_n_faces                                 &
           &   => hex_lagrangian_reference_fe_check_compatibility_of_n_faces
     procedure :: get_characteristic_length                                   &
           &   => hex_lagrangian_reference_fe_get_characteristic_length
     procedure :: get_subelements_connectivity                                &
           &   => hex_lagrangian_reference_fe_get_subelements_connectivity
     procedure :: blending                                                    &
           &   => hex_lagrangian_reference_fe_blending
           
     ! Deferred TBP implementors from lagrangian_reference_fe_t
     !procedure, private :: fill_scalar => hex_lagrangian_reference_fe_fill_scalar
     procedure, private :: fill_quadrature                                    &
           & => hex_lagrangian_reference_fe_fill_quadrature
     procedure, private :: fill_interpolation                                 &
           & => hex_lagrangian_reference_fe_fill_interpolation
     procedure, private :: fill_face_interpolation                            &
           & => hex_lagrangian_reference_fe_fill_face_interpolation
     procedure, private :: get_node_local_id                                  &
           & => hex_lagrangian_reference_fe_get_node_local_id
     procedure, private :: get_node_local_coordinates                         &
           & => hex_lagrangian_reference_fe_get_node_local_coordinates
     procedure, private :: set_coordinates_1D                                 &
           & => hex_lagrangian_reference_fe_set_coordinates_1D
     procedure, private :: set_permutation_2D                                 &
           & => hex_lagrangian_reference_fe_set_permutation_2D
     procedure, private :: set_number_quadrature_points                       &
           & => hex_lagrangian_reference_fe_set_number_quadrature_points
     procedure, private :: compute_number_nodes_scalar                        &
           & => hex_lagrangian_reference_fe_compute_number_nodes_scalar
     procedure, private :: get_number_interior_points_x_dim                   &
           & => hex_lagrangian_reference_fe_get_number_interior_points_x_dim
     ! Concrete TBPs of this derived data type
     procedure, private, non_overridable :: fill_n_face_dimension_and_directions &
           & => hex_lagrangian_reference_fe_fill_n_face_dims_and_directions
     procedure, private, non_overridable :: fill_n_face_local_coordinates_nodes  &
           & => hex_lagrangian_reference_fe_fill_n_face_local_coordinates_nodes
     procedure, private, non_overridable :: evaluate_interpolation_1D         &
           & => hex_lagrangian_reference_fe_evaluate_interpolation_1D 
     procedure, private, non_overridable :: evaluate_interpolation            &
           & => hex_lagrangian_reference_fe_evaluate_interpolation 
     procedure, private, non_overridable :: evaluate_face_interpolation       &
           & => hex_lagrangian_reference_fe_evaluate_face_interpolation
     procedure, private, non_overridable :: get_n_face_orientation               &
           & => hex_lagrangian_reference_fe_get_n_face_orientation
  end type hex_lagrangian_reference_fe_t
  
  public :: hex_lagrangian_reference_fe_t
  
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  type polytope_tree_t
     private
     integer(ip)              :: number_dimensions
     integer(ip)              :: topology
     integer(ip)              :: number_n_faces 
     integer(ip), allocatable :: n_face_array(:)     
     integer(ip), allocatable :: ijk_to_index(:)
   contains
     procedure          :: create                   => polytope_tree_create 
     procedure          :: create_children_iterator => polytope_tree_create_children_iterator
     procedure          :: get_n_face               => polytope_tree_get_n_face
     procedure          :: get_n_face_dimension     => polytope_tree_get_n_face_dimension
     procedure          :: get_number_n_faces       => polytope_tree_get_number_n_faces
     procedure          :: free                     => polytope_tree_free
     procedure, private :: fill_cell_tree 
  end type polytope_tree_t

  public :: polytope_tree_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type node_array_t
     private
     type(polytope_tree_t), pointer :: polytope_tree
     integer(ip)                    :: order
     integer(ip)                    :: number_nodes
     integer(ip), allocatable       :: node_array(:)
     integer(ip), allocatable       :: ijk_to_index(:)
   contains
     procedure :: create               => node_array_create
     procedure :: print                => node_array_print
     procedure :: free                 => node_array_free
     procedure :: create_node_iterator => node_array_create_node_iterator
     procedure :: get_number_nodes     => node_array_get_number_nodes
     procedure, private :: fill        => node_array_fill
  end type node_array_t

  public :: node_array_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type n_face_iterator_t
     private 
     type(polytope_tree_t), pointer :: polytope_tree
     integer(ip)                  :: parent
     integer(ip)                  :: component
     integer(ip)                  :: coordinate
   contains
     procedure :: create        => n_face_iterator_create     
     procedure :: current       => n_face_iterator_current
     procedure :: init          => n_face_iterator_init
     procedure :: next          => n_face_iterator_next
     procedure :: has_finished  => n_face_iterator_has_finished
     procedure :: print         => n_face_iterator_print
     procedure, private :: current_ijk   => n_face_iterator_current_ijk 
     procedure, private :: is_admissible => n_face_iterator_is_admissible   
  end type n_face_iterator_t

  public :: n_face_iterator_t

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  type node_iterator_t
     private 
     type(node_array_t), pointer :: node_array
     logical                     :: own_boundary
     integer(ip)                 :: n_face
     integer(ip)                 :: topology
     integer(ip)                 :: displacement(0:SPACE_DIM-1)
     integer(ip)                 :: coordinate(0:SPACE_DIM-1)
     logical                     :: overflow
     integer(ip)                  :: max_value ! 0 or 1
     integer(ip)                  :: min_value ! order or order-1
   contains
     procedure :: create        => node_iterator_create     
     procedure :: current       => node_iterator_current
     procedure :: init          => node_iterator_init
     procedure :: next          => node_iterator_next
     procedure :: has_finished  => node_iterator_has_finished
     !procedure :: free          => node_iterator_free
     procedure :: print         => node_iterator_print
     procedure, private :: current_ijk => node_iterator_current_ijk  
     procedure, private :: in_bound    => node_iterator_in_bound 
  end type node_iterator_t

  public :: node_iterator_t
  
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type volume_integrator_t 
  private
  integer(ip)                    :: number_shape_functions
  integer(ip)                    :: number_quadrature_points
  class(reference_fe_t), pointer :: reference_fe
  type(interpolation_t)          :: interpolation      ! Unknown interpolation_t in the reference element domain
  type(interpolation_t)          :: interpolation_o_map! Unknown interpolation_t in the physical element domain
contains

  procedure, non_overridable :: create => volume_integrator_create
  procedure, non_overridable :: free   => volume_integrator_free
  procedure, non_overridable :: update => volume_integrator_update
  procedure, non_overridable :: print  => volume_integrator_print
  
  procedure, non_overridable :: get_interpolation_reference_cell =>                               &
       &                                   volume_integrator_get_interpolation_reference_cell
  procedure, non_overridable :: get_interpolation_real_cell =>                                    &
       &                                   volume_integrator_get_interpolation_real_cell


  procedure, non_overridable, private :: get_value_scalar           => volume_integrator_get_value_scalar
  procedure, non_overridable, private :: get_value_vector           => volume_integrator_get_value_vector
  procedure, non_overridable, private :: get_value_tensor           => volume_integrator_get_value_tensor
  procedure, non_overridable, private :: get_value_symmetric_tensor => volume_integrator_get_value_symmetric_tensor
  generic            :: get_value => get_value_scalar, &
                                     get_value_vector, &
                                     get_value_tensor, &
                                     get_value_symmetric_tensor
    
  procedure, non_overridable, private :: get_gradient_scalar => volume_integrator_get_gradient_scalar
  procedure, non_overridable, private :: get_gradient_vector => volume_integrator_get_gradient_vector
  generic                             :: get_gradient => get_gradient_scalar, &
                                                         get_gradient_vector 

  procedure, non_overridable, private :: get_symmetric_gradient_vector => volume_integrator_get_symmetric_gradient_vector
  generic                             :: get_symmetric_gradient => get_symmetric_gradient_vector
  
  procedure, non_overridable, private :: get_divergence_vector => volume_integrator_get_divergence_vector
  procedure, non_overridable, private :: get_divergence_tensor => volume_integrator_get_divergence_tensor
  generic                             :: get_divergence => get_divergence_vector, &
                                                           get_divergence_tensor

  procedure, non_overridable, private :: get_curl_vector => volume_integrator_get_curl_vector
  generic                             :: get_curl => get_curl_vector
  
  ! We might want to have the following in the future:
  !  (x) get_hessian (scalar,vector)
  !  (x) get_third_derivative (scalar,vector)
  ! But note that in such a case we would require higher-to-2 rank tensors
  ! (i.e., type(tensor_field_t) is a rank-2 tensor)
  
  procedure, non_overridable, private :: volume_integrator_evaluate_fe_function_scalar
  procedure, non_overridable, private :: volume_integrator_evaluate_fe_function_vector
  procedure, non_overridable, private :: volume_integrator_evaluate_fe_function_tensor
  generic :: evaluate_fe_function => volume_integrator_evaluate_fe_function_scalar, &
                                   & volume_integrator_evaluate_fe_function_vector, &
                                   & volume_integrator_evaluate_fe_function_tensor
  
  procedure, non_overridable, private :: volume_integrator_evaluate_gradient_fe_function_scalar
  procedure, non_overridable, private :: volume_integrator_evaluate_gradient_fe_function_vector
  generic :: evaluate_gradient_fe_function => volume_integrator_evaluate_gradient_fe_function_scalar, &
                                            & volume_integrator_evaluate_gradient_fe_function_vector

end type volume_integrator_t

type p_volume_integrator_t
  type(volume_integrator_t), pointer :: p => NULL() 
contains
  procedure :: allocate => p_volume_integrator_allocate 
  procedure :: free     => p_volume_integrator_free
end type p_volume_integrator_t

public :: volume_integrator_t, p_volume_integrator_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type face_map_t
   private
   logical                         :: is_boundary
   type(fe_map_t)                  :: face_map
   type(fe_map_face_restriction_t) :: fe_maps(2)
   integer(ip)                     :: number_dimensions
 contains
   procedure, non_overridable :: create               => face_map_create
   procedure, non_overridable :: free                 => face_map_free
   procedure, non_overridable :: update               => face_map_update
   procedure, non_overridable :: compute_characteristic_length                                      &
        &                                             => face_map_compute_characteristic_length
   procedure, non_overridable :: get_quadrature_coordinates                                         &
        &                                             => face_map_get_quadrature_coordinates
   procedure, non_overridable :: get_face_coordinates => face_map_get_face_coordinates
   procedure, non_overridable :: get_coordinates_neighbour                                          &
        &                                             => face_map_get_coordinates_neighbour
   procedure, non_overridable :: get_neighbour_fe_map => face_map_get_neighbour_fe_map
   procedure, non_overridable :: get_normals          => face_map_get_normals
   procedure, non_overridable :: get_det_jacobian     => face_map_get_det_jacobian
end type face_map_t

public :: face_map_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type face_integrator_t
   private
   logical                                :: is_boundary
   type(interpolation_face_restriction_t) :: interpolation_face_restriction(2)
   type(p_reference_fe_t)                 :: reference_fe(2)
   integer(ip)                            :: current_qpoints_perm_cols(2)
   integer(ip), allocatable               :: qpoints_perm(:,:)
 contains
   procedure, non_overridable :: create            => face_integrator_create
   procedure, non_overridable :: update            => face_integrator_update
   procedure, non_overridable :: free              => face_integrator_free
   procedure, non_overridable :: get_value_scalar  => face_integrator_get_value_scalar
   generic                    :: get_value         => get_value_scalar
   procedure, non_overridable :: get_gradient_scalar  => face_integrator_get_gradient_scalar
   generic                    :: get_gradient => get_gradient_scalar
   procedure, non_overridable :: get_current_qpoints_perm => face_integrator_get_current_qpoints_perm
   
   procedure, non_overridable, private :: face_integrator_evaluate_fe_function_scalar
   procedure, non_overridable, private :: face_integrator_evaluate_fe_function_vector
   procedure, non_overridable, private :: face_integrator_evaluate_fe_function_tensor
   generic :: evaluate_fe_function => face_integrator_evaluate_fe_function_scalar, &
                                    & face_integrator_evaluate_fe_function_vector, &
                                    & face_integrator_evaluate_fe_function_tensor

   procedure, non_overridable, private :: face_integrator_evaluate_gradient_fe_function_scalar
   procedure, non_overridable, private :: face_integrator_evaluate_gradient_fe_function_vector
   generic :: evaluate_gradient_fe_function => face_integrator_evaluate_gradient_fe_function_scalar, &
                                             & face_integrator_evaluate_gradient_fe_function_vector

end type face_integrator_t

type p_face_integrator_t
  type(face_integrator_t)          , pointer :: p => NULL()
end type p_face_integrator_t

public :: face_integrator_t, p_face_integrator_t

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

contains

  ! Includes with all the TBP and supporting subroutines for the types above.
  ! In a future, we would like to use the submodule features of FORTRAN 2008.

#include "sbm_quadrature.i90"

#include "sbm_interpolation.i90"

#include "sbm_reference_fe.i90"

#include "sbm_lagrangian_reference_fe.i90"

#include "sbm_vector_lagrangian_reference_fe.i90"

#include "sbm_hex_lagrangian_reference_fe.i90"

#include "sbm_tet_lagrangian_reference_fe.i90"

#include "sbm_tet_vector_lagrangian_reference_fe.i90"

#include "sbm_polytope_topology.i90"

#include "sbm_volume_integrator.i90"

#include "sbm_face_integrator.i90"

end module reference_fe_names
