! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! NOTATION
! ========
!
! The following work is applicable to any space dimension. Thus, the use of face, edge, vertex, etc. can be misleading.
! In this regard, in order to be precise, we use the notion of polytope for the original object. Its boundary is defined 
! for n-faces, where $n < d$, $d$ being the space dimension. We use the notation n-face to define any sub-object of the
! polytope and even the polytope itself when $n = d$. E.g., in 3D, the n-face concept leads to the cell (3-face), the
! faces (2-faces), the edges (1-faces), and the vertices (0-faces). Finally, the $(d-1)$-faces can also be denoted as 
! facets. E.g., a facet is a face in 3D and an edge in 2D. 0-faces are vertices, 1-faces are edges, 2-faces are faces, 
! and 3-faces are cells.
!
! POLYTOPE DEFINITION
! ===================
!
! A polytope is mathematically defined as the convex hull of a finite set of points. Thus, a polytope has flat sides.
!
! In particular, we are interested on polytopes that can be generated by two types of extensions from previous dimensions.
! One case of extension is the extrusion, leading to hypercubes, or n-cubes. Another type of extension is the one 
! used to generate triangles, which can be defined as the Duffy transformation of the extrusion. The first extension is 
! called the "prysm" extension (denoted by 1) and the second one is the "pyramid" extension (denoted by 0).
!
! Given an closed domain $\Omega \subset \R^d$, we generate its the prysm extension $Q(\Omega) \subset \R^{d+1} = \Omega \times [0,1]$.
! On the other hand, the pyramid extension $T(\Omega)$ is defined as
! $$
! Q(\Omega) = \{ x \in \R^{d+1} | x \in (\Omega(1-z),z), z \in [0,1] \}. 
! $$
! As a result, in dimension d, we can define an object by the type of action being used at every dimension, starting from the ${0}$ vertex.
! In 1D, both actions lead to the line segment $[0,1]$. In 2D, using the prysm action, we get the square, whereas the pyramid action gives
! the triangle. Thus, a polytope that can be defined as the combination of these actions is represented in the computer by d bits.
!
! E.g., in 3D, we have the cube 111 (or 110), the prysm 101 (or 100), the pyramid 011 (or 010), and the tetrahedrom 001 (or 000). 
! The non-uniqueness in 1D leads to two possible definitions of the polytope. Thus, we can just define the topology of these polytopes by
! an integer.
!
! N-FACES
! =======
!
! Now, given an object defined by its d-bits topology, we can represent any n-face as follows. Let us start with the polytope itself. 
! The polytope is a d-dimensional object, and thus, there is no restriction among the d space coordinates of its nodes. Thus, we 
! say that all coordinates are free. It is represented by d-bits, where 1 means that the coordinate is free and 0 means that it is fixed.
! As a result, the polytope itself is 111. 

! Now, we can consider its (d-1)-faces (facets). In any face, there is one and only one constraint among coordinates. Let us consider
! for simplicity that we have a 3-cube. In this case, we have the faces 011 (Z-faces, since its normal is aligned with the Z-axis), 
! the faces 101 (Y-faces), and the faces 110 (X-faces). For a given type of face, we have two possible values of the fixed component,
! 0 or 1. Thus, together with the type of n-face, we have to provide the anchor vertex (0-face). It leads, as expected, to 6 facets, 
! two per n-face type. For any dimension, a d-cube has 2d facets. As a result, any n-face can be uniquely defined by 2d-bits, the 
! type and the anchor node. We note that the coordinate value related to a coordinate that is free has no sense, and in this case, 
! the coordinate value is enforced to 0. E.g., for the 3d cube we have the six faces 011|000, 011|100, 101|000, 101|010, 110|000, and
! 110|001. Everything applies verbatim for edges and vertices. Further, all these concepts can be applied to any dimension.

! The use of this ideas to define n-faces of polytopes that involve pyramid actions is slightly more complicated. Its relies on the
! following observation. Assume that we start with a (d-1)-polytope A, and denote by S the set of its vertices. The d-polytope P(A)
! has card(S)+1 vertices, where the new vertex has coordinate d equal to 1 and the rest equal to zero, whereas the other are the
! ones in S (with 0 value on the d-coordinate). Based on these arguments, the set of admissible n-faces is restricted. One can not
! have vertices such that, if the d-coordinate is equal to 1, it has some other coordinate different from 0. 
! Thus, we cannot have an edge with a free coordinate in a position n<d and a fixed coordinate equal to 1 in position d. One of the
! vertices of the corner would be 1 in position d and n, which is not a vertex of the object itself. Among all potential edges, 
! we can only consider those that when the free coordinate is n \neq d, the anchor node is 0. E.g., in 2D, the edge
! 01|10 is not admissible, because it would lead to the vertex 00|11, which is not in the object, and only 3 nodes are possible.
!
! We can extend this restriction to arbitrary dimensions. Let us assume that we have a polytope A, with all its edges and faces.
! Let us assume that n-1-faces satisfy that a free coordinate in m < d implies anchor node 0. Now, let us assume
! that we have an n-dimensional object with n<d and anchor node different from 0. It leads to n-1-faces that do not belong to the
! polytope. We have proved it by induction.
!
! As a result, given an n-face, we can easily proceed as for n-cubes, but only considering those n-1-faces that are suitable, i.e.,
! an n-dimensional object with n<d must have anchor node 0. This check is easy to implement
!
! do i = 2:dim
!    if ( t(i) == 0. and. (  c(i) == 1 .and. f(i) == 0 ) )! Current coordinate is obtained by 1 (pyramid) and == 1
!       do k = 1:i-1
!          if ( (c(k) == 1 .and. f(k) == 0)  .or. f(k) == 1 ) ! Coordinate fixed to 1 or free
!             NOT SUITABLE  break
!          end if
!       end do
!    end if
! end do
!
! where t is the topology, f the type of n-face, and c the anchor vertex.
!
! As a result, using these ideas, we can extract n-1-faces of a given n-face. 
!
! In FEMPAR, we have implemented the polytope_tree_t, which includes the topology and the number of dimensions of the polytope. Since the bit-based
! definition of the n-faces above is non-consecutive and it mixes objects of different dimensions, we define another numbering for the objects. Thus,
! first, given the polytope we generate all its n-faces, recursively obtaining the n-1-faces of an n-face. Next, we re-number these objects. The 
! permutation from the bit-based to the new numbering is in ijk_to_index and its inverse permutation in n_face_array.
!
! We also provide an iterator over the facets of an n-face of a given polytope in n_face_iterator_t. This iterator implements the notion of admissibility
! described above. These subroutines have to work with bits in order to answer queries.
!
! NODES
! =====
!
! Let us consider a (O+1)-partition of every dimension in the [0,1]^d d-cube, and denote by S the set of vertices of such partition. Every vertex can
! easily be defined by d integers with values from 0 to O+1. For an arbitrary polytope defined as above, we can define the set of vertices in S 
! that belong to the polytope or any of its n-faces. It leads to the Lagrangian nodes of order O for an arbitrary polytope. Further,
! these queries can be for the open and closed n-face.
!
! We have created the node_array_t structure, that given a polytope provides the list of all nodes for a given order, based on a lexicographical 
! index. Again, since this index is non consecutive for non-cube polytopes, we renumber the nodes with the permutation table node_array. Its inverse
! is in ijk_to_index. 
!
! Further, given an n-face of the polytope, we provide an iterator over the nodes that belong to that n-face (considering the n-face an open or closed set).
! Let us consider the 3D case for simplicity. This iterator is performing the loop
!
! do k = 0,O
! do j = 0,O-k*t(3)
! do i = 0,O-k*t(2)-j*t(1)
!
! where t is the topology and O the order. 
!
! NODE ITERATOR ON N-FACES
! ========================
!
! The same applies for any n-face. We can create the node_iterator_t over any n-face of the poytope. The idea is the same as above, but working on the
! dimension n. E.g., the loop above performed for the n-face dimension, e.g., only i and j for an edge in 2D. However, it is only part of the story. It leads
! to the node numbering (ijk) in the n space dimension. Next, we have to translate/rotate it to the original space. 
!
! This is the reason why the ijk index in iterator_t is called "displacement", since it denotes the displacement with respect to the anchor node of the n-face
! of the free indices. In order to go from the displacement to the real coordinates, we proceed as follows (see node_iterator_current_ijk subroutine):
!
! 1) First, we put the free coordinates as such in the coordinates array (in the correct position). The fixed component is also put taking the value of the
! anchor node, i.e., 0 if the anchor node coordinate is 0 and order if 1.
!
! 2) The first step is enough for n-cubes (displacement and coordinates are identical). However, for pyramid actions, n-faces are not parallel to the axis. Thus, 
! we have to take it into account. Let us consider the edge in the reference triangle that is not parallel to any edge. At this point, we have nodes in that 
! edge with a constant X-coordinate, when it is not true. The fact is that any Y-displacement comes with a -1 displacement in X. Thus, taking the displacement
! obtained above, putting the Y-coordinate equal to the Y-displacement, and computing the X-coordinate as the X-displacement minus the Y-displacement, we get
! the right ijk index in that edge.
!
! We can also extend it to any n-face in any dimension (see node_iterator_current_ijk subroutine). The algorithm is to take the fixed component (initialized
! as commented above) and iterate over the superior index dimensions, check whether the corresponding action at that dimension is pyramid, and if yes, subtract
! the corresponding free coordinate to the current coordinate.
!
!=================================================================================================
!     GEOMETRY_TREE_T TBPS
!=================================================================================================

!=================================================================================================
! This subroutine creates the n-face tree, where the geometrical n-faces are defined by 2*DIM bits.
! The "first" (from the right) DIM bits provide the "anchor node", whereas the "second" set of DIM
! bits provides the type of n-face. For every component, if we have 1 it means that the y-component
! can freely change. When = 0 it is constrained. However, it does not mean that it is constant (it
! is only for hyper-cubes). Think about the face of the tetrahedron that is not aligned with any 
! axes.
subroutine polytope_tree_create( this, number_dimensions, topology )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: number_dimensions
  integer(ip)        , intent(in)    :: topology
  integer(ip) :: c, i, d, j
  integer(ip), allocatable :: aux_array(:)
  call this%free()
  this%topology = topology
  this%number_dimensions = number_dimensions
  !     Compute number of n-face (all dimensions) for the hypercube
  !     c = (2**dim-1)*2**dim max id n-face
  c = 0
  do i = 0,number_dimensions
     c = c + 2**(number_dimensions-i)*(get_binomial_coefficient(number_dimensions,i))
  end do
  !     Pre-allocate this%n_faces_array with c (exact for hypercube)
  call memalloc ( c, this%n_face_array, __FILE__, __LINE__ )
  !     Pre-allocate the ijk_to_index. Maximum ijk_to_index is [111000]+1 for dim = 3
  !     = ISHFT(ISHFT(1_ip,dim)-1,dim) = (2**dim-1)*2**dim
  call memalloc ( ISHFT(ISHFT(1_ip,number_dimensions)-1,number_dimensions)+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  this%ijk_to_index = 0
  this%number_n_faces = 0
  !     Call the recursive fill_tree procedure starting with the volume n-face
  call this%fill_cell_tree( ISHFT(ISHFT(1_ip,number_dimensions)-1, number_dimensions ) ) ! Root n-face (volume)
  !     Re-allocate the n-faces_array to the exact number of n-faces
  call memrealloc ( this%number_n_faces, this%n_face_array, __FILE__, __LINE__ )
  !     Sort n-faces based on 1) n-face_dimension 2) its bit-based index
  call memalloc ( this%number_n_faces, aux_array, __FILE__, __LINE__ )
  aux_array = this%n_face_array
  c = 1
  d = 1
  this%n_face_array = 0
  do i = 0,number_dimensions
     do j = 1,this%number_n_faces
        if ( n_face_dimension( aux_array(j), this%number_dimensions ) == i ) then
           this%n_face_array(d) = aux_array(j)
           d = d+1
        end if
     end do
     call sort( d-c, this%n_face_array(c:d-1) ) 
     c = d
  end do
  call memfree ( aux_array, __FILE__, __LINE__ )
  !     Create the bit-index to consecutive index array (0 for bit-indexes wo/ associated n-face)
  do i =1,this%number_n_faces
     this%ijk_to_index( this%n_face_array(i) ) = i
  end do
end subroutine polytope_tree_create

!==================================================================================================
! This recursive subroutine fills ALL the sub-n-faces (including the n-face itself). From dimension
! DIM to 0.
recursive subroutine fill_cell_tree( this, root )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: root
  type(n_face_iterator_t) :: children_iterator
  integer(ip)               :: children  
  ! If the n-face not already inserted (use ijk_to_index as touch table)

  if ( this%ijk_to_index(root) == 0 ) then 
     ! Increase one position current n-face in polytope_tree
     this%number_n_faces = this%number_n_faces + 1
     ! Put root as new n-face in polytope_tree
     this%n_face_array(this%number_n_faces) = root
     ! Mark root as touched (already inserted)
     this%ijk_to_index(root) = 1
     ! Create iterator over children of root n-face
     children_iterator = this%create_children_iterator(root)
     ! Loop over children
     do while (.not. children_iterator%has_finished() )
        children = children_iterator%current_ijk()
        !write(*,*) 'current children: '
        !write(*,'(B32)') children
        ! Put children of child (recursive call)
        call this%fill_cell_tree( children )
        ! Move to the next child
        call children_iterator%next()
     end do
  end if
end subroutine fill_cell_tree

!=================================================================================================
subroutine polytope_tree_free( this )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  if (allocated(this%n_face_array)) call memfree ( this%n_face_array, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine polytope_tree_free

!=================================================================================================
function polytope_tree_create_children_iterator(this, parent)
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: parent
  type(n_face_iterator_t) :: polytope_tree_create_children_iterator
  call polytope_tree_create_children_iterator%create(this, parent)
end function polytope_tree_create_children_iterator

!=================================================================================================
function polytope_tree_get_number_n_faces(this) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)                          :: polytope_tree_get_number_n_faces
  polytope_tree_get_number_n_faces = this%number_n_faces     
end function polytope_tree_get_number_n_faces

!=================================================================================================
function polytope_tree_get_n_face(this, n_face_index) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: n_face_index
  integer(ip)                          :: polytope_tree_get_n_face
  polytope_tree_get_n_face = this%n_face_array(n_face_index)     
end function polytope_tree_get_n_face

!=================================================================================================
function polytope_tree_get_n_face_dimension(this, n_face_index) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: n_face_index
  integer(ip)                          :: polytope_tree_get_n_face_dimension
  polytope_tree_get_n_face_dimension = n_face_dimension( this%n_face_array(n_face_index), this%number_dimensions )     
end function polytope_tree_get_n_face_dimension

!=================================================================================================
function polytope_tree_n_face_dir_is_fixed(this, n_face_index, dir) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)           , intent(in) :: n_face_index
  integer(ip)           , intent(in) :: dir
  integer(ip)                        :: polytope_tree_n_face_dir_is_fixed
  polytope_tree_n_face_dir_is_fixed = IBITS( this%n_face_array(n_face_index), this%number_dimensions + dir, 1 )
end function polytope_tree_n_face_dir_is_fixed

!=================================================================================================
function polytope_tree_n_face_dir_coordinate(this, n_face_index, dir) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)           , intent(in) :: n_face_index
  integer(ip)           , intent(in) :: dir
  integer(ip)                        :: polytope_tree_n_face_dir_coordinate
  polytope_tree_n_face_dir_coordinate = IBITS( this%n_face_array(n_face_index), dir, 1 )
end function polytope_tree_n_face_dir_coordinate

!=================================================================================================
function polytope_tree_n_face_type(this, n_face_index) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)           , intent(in) :: n_face_index
  integer(ip)                        :: polytope_tree_n_face_type
  polytope_tree_n_face_type = IBITS( this%n_face_array(n_face_index), this%number_dimensions, this%number_dimensions )
end function polytope_tree_n_face_type

!=================================================================================================
function polytope_tree_n_face_coordinate(this, n_face_index) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)           , intent(in) :: n_face_index
  integer(ip)                        :: polytope_tree_n_face_coordinate
  polytope_tree_n_face_coordinate = IBITS( this%n_face_array(n_face_index), 0, this%number_dimensions )
end function polytope_tree_n_face_coordinate

!=================================================================================================
!     NODE_ARRAY_T TBPS
!=================================================================================================

!=================================================================================================
subroutine node_array_create ( this, polytope_tree, order )
  implicit none
  class(node_array_t)        , intent(inout) :: this
  type(polytope_tree_t), target, intent(in)    :: polytope_tree
  integer(ip)                , intent(in)    :: order(SPACE_DIM)
  call this%free()
  this%polytope_tree => polytope_tree
  this%order = order
  call this%fill()
end subroutine node_array_create

!=================================================================================================
subroutine node_array_fill ( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  type(node_iterator_t) :: node_iterator 
  integer(ip) :: i, c, m_ijk, current
  current = ISHFT(ISHFT(1_ip,this%polytope_tree%number_dimensions)-1,this%polytope_tree%number_dimensions)
  node_iterator = this%create_node_iterator( current, own_boundary = .true. )
  call node_iterator%init()
  c = 0
  m_ijk = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     m_ijk = max( m_ijk, node_iterator%current_ijk() )
     call node_iterator%next()       
  end do
  this%number_nodes = c
  call memalloc ( c, this%node_array, __FILE__, __LINE__ )
  call memalloc ( SPACE_DIM, c, this%coordinates, __FILE__, __LINE__ )
  call memalloc ( m_ijk+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  call node_iterator%init()
  c = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     this%node_array(c) =  node_iterator%current_ijk()
     this%coordinates(:,c) = node_iterator%coordinate(:)
     call node_iterator%next()         
  end do
  ! Sort nodes based on its bit-based index
  call sort( c, this%node_array )    
  !write(*,*) 'node_array',this%node_array
  do i =1,c
     !write(*,*) 'n-face(',i,') :'
     !write(*,'(B32)') this%node_array(i)
     this%ijk_to_index( this%node_array(i) ) = i
  end do
end subroutine node_array_fill

!=================================================================================================
subroutine node_array_print( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  integer(ip) :: i
  write(*,*) '************NODE ARRAY***********'
  write(*,*) 'number of nodes = ', this%number_nodes
  write(*,*) 'cell_tree_topology = '
  write(*,'(B32)') this%polytope_tree%topology
  write(*,*) 'nodes'
  do i = 1, this%number_nodes
     write(*,*) 'NODE: ',this%node_array(i)
     write(*,'(B32)') this%node_array(i)
     write(*,*) 'COORDINATE: ',this%coordinates(:,i)
  end do
  write(*,*) 'ijk_to_index: ',this%ijk_to_index
end subroutine node_array_print

!=================================================================================================
subroutine node_array_free( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  if (allocated(this%node_array)) call memfree ( this%node_array, __FILE__, __LINE__ )
  if (allocated(this%coordinates)) call memfree ( this%coordinates, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine node_array_free

!=================================================================================================
function  node_array_get_number_nodes(this) 
  implicit none
  class(node_array_t), intent(in) :: this
  integer(ip)                          :: node_array_get_number_nodes
  node_array_get_number_nodes = this%number_nodes
end function  node_array_get_number_nodes

!=================================================================================================
!     N_FACE_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
subroutine n_face_iterator_create ( this, polytope_tree, parent )
  implicit none
  class(n_face_iterator_t)        , intent(inout) :: this
  type(polytope_tree_t)       , target, intent(in)    :: polytope_tree
  integer(ip)                       , intent(in)    :: parent
  !call this%free()
  this%polytope_tree => polytope_tree
  this%parent = parent
  call this%init()
end subroutine n_face_iterator_create

!=================================================================================================
subroutine n_face_iterator_init ( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  this%component = 0
  this%coordinate = 0
  if ( .not. this%is_admissible() ) then
     call this%next()
  end if
end subroutine n_face_iterator_init

!=================================================================================================
subroutine n_face_iterator_print( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  write(*,*) '***CHILDREN_ITERATOR ***'
  write(*,*) 'parent: '
  write(*,'(B32)') this%parent
  write(*,*) 'component: ',this%component
  write(*,*) 'coordinate: ',this%coordinate

end subroutine n_face_iterator_print

!=================================================================================================
recursive subroutine n_face_iterator_next ( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  if ( this%has_finished() ) return 
  if ( this%coordinate == 1 ) then
     this%component = this%component + 1
     this%coordinate = 0
  else
     this%coordinate = 1
  end if
  if ( .not. this%is_admissible() ) then
     call this%next()
  else 
  end if
end subroutine n_face_iterator_next

!=================================================================================================
function n_face_iterator_has_finished ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  logical :: n_face_iterator_has_finished
  n_face_iterator_has_finished = ( this%component >= this%polytope_tree%number_dimensions )
end function n_face_iterator_has_finished

!=================================================================================================
function n_face_iterator_current_ijk ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  integer(ip) :: n_face_iterator_current_ijk, j
  assert ( .not. this%has_finished() )
  n_face_iterator_current_ijk = this%parent
  n_face_iterator_current_ijk = IBCLR( n_face_iterator_current_ijk, this%polytope_tree%number_dimensions + this%component )
  if ( this%coordinate == 1 ) then
     if ( IBITS( this%polytope_tree%topology, this%component, 1 )  == 0 ) then
        do j = 0,this%component-1
           n_face_iterator_current_ijk = IBCLR( n_face_iterator_current_ijk, j )
        end do
     end if
     n_face_iterator_current_ijk = IBSET( n_face_iterator_current_ijk, this%component )
  end if
end function n_face_iterator_current_ijk

!=================================================================================================
function n_face_iterator_current ( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  integer(ip) :: n_face_iterator_current
  n_face_iterator_current = this%polytope_tree%ijk_to_index( this%current_ijk() )
end function n_face_iterator_current

!=================================================================================================
function n_face_iterator_is_admissible( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  logical                          :: n_face_iterator_is_admissible
  n_face_iterator_is_admissible = .false. 
  if ( IBITS( this%parent, this%polytope_tree%number_dimensions + this%component, 1 ) == 1) then
     if ( IBITS( this%polytope_tree%topology, this%component, 1 ) == 1 ) then
        n_face_iterator_is_admissible = .true.
     else if ( this%coordinate == 0 .or. this%component == 0 & 
          & .or. IBITS( this%parent, this%polytope_tree%number_dimensions, this%component ) == 0 ) then  
        n_face_iterator_is_admissible = .true.
     end if
  end if
end function n_face_iterator_is_admissible

!=================================================================================================
!     NODE_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
function node_array_create_node_iterator( node_array, parent, own_boundary)
  implicit none
  class(node_array_t) , intent(in) :: node_array
  integer(ip)         , intent(in) :: parent
  logical             , intent(in) :: own_boundary 
  type(node_iterator_t) :: node_array_create_node_iterator
  call node_array_create_node_iterator%create( node_array, parent, own_boundary )
end function node_array_create_node_iterator

!=================================================================================================
subroutine node_iterator_create ( this, node_array, n_face, own_boundary )
  implicit none
  class(node_iterator_t)            , intent(inout) :: this
  type(node_array_t), target               , intent(in)    :: node_array
  integer(ip)                       , intent(in)    :: n_face
  logical                           , intent(in)    :: own_boundary
  integer(ip) :: c, i
  this%node_array => node_array
  this%topology = 0
  this%n_face = n_face
  this%own_boundary = own_boundary
  if ( own_boundary) then
     this%max_value = node_array%order
     this%min_value = 0
  else
     this%max_value = node_array%order-1
     this%min_value = 1
  end if
  ! Restrict the topology of the polytope_tree to the current n-face
  c = 0
  do i = 0, node_array%polytope_tree%number_dimensions-1
     if ( IBITS( this%n_face, node_array%polytope_tree%number_dimensions+i, 1 ) == 1 ) then 
        if ( IBITS( this%node_array%polytope_tree%topology, i, 1 ) == 1 ) this%topology = IBSET( this%topology, c )
        c = c+1
     end if
  end do
  call this%init()
end subroutine node_iterator_create

!=================================================================================================
subroutine node_iterator_init ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: c, i
  this%displacement = 0
  this%coordinate = 0
  this%overflow = .true.
  !if ( n-face_dimension(this%n-face, this%node_array%polytope_tree%number_dimensions) > 0 .or. this%own_boundary ) 
  this%overflow = .false.
  c = 0
  do i = 0, this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS( this%n_face, this%node_array%polytope_tree%number_dimensions+i, 1 ) == 0 ) then  ! if is fixed component in n-face
        if ( IBITS( this%n_face, i, 1 ) == 0 ) then   ! if coordinate of anchor node == 0
           this%coordinate(i) = 0                     ! fixed coordinate = min value
        else
           this%coordinate(i) = this%node_array%order(i+1) ! fixed coordinate = max value   
        end if
     else 
        this%displacement(c) = this%min_value
        c = c+1
     end if
  end do
  if ( n_face_dimension(this%n_face, this%node_array%polytope_tree%number_dimensions) > 0 ) then
     this%displacement(0) = this%displacement(0)-1
     call this%next()
  end if
end subroutine node_iterator_init

!=================================================================================================
subroutine node_iterator_print( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  write(*,*) '***NODE_ITERATOR ***'
  write(*,*) 'n-face: '
  write(*,'(B32)') this%n_face
  write(*,*) 'displacement: ',this%displacement
end subroutine node_iterator_print

!=================================================================================================
subroutine node_iterator_next ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: comp, end_comp, i
  if ( this%has_finished() ) return 
  comp = 0 
  end_comp = n_face_dimension(this%n_face, this%node_array%polytope_tree%number_dimensions)-1
  this%overflow = .true.
  do while( comp <= end_comp)
     if ( this%overflow ) then 
        this%displacement(comp) = this%displacement(comp)+1
        if ( this%in_bound(comp, end_comp) ) then
           this%overflow = .false.
           do i = comp-1,0,-1
              if ( .not. this%in_bound( i, end_comp ) ) then
                 this%overflow = .true.
              end if
           end do
           exit
        else 
           this%displacement(comp) = this%min_value
        end if
     end if
     comp = comp+1
  end do
end subroutine node_iterator_next

!=================================================================================================
function node_iterator_in_bound( this, comp, end_comp )
  implicit none
  class(node_iterator_t), intent(in) :: this
  integer(ip)           , intent(in) :: comp, end_comp
  logical :: node_iterator_in_bound
  integer(ip) :: bound, i
  node_iterator_in_bound = .true.
  bound = this%max_value(comp)
  do i = comp+1,end_comp
     if ( IBITS( this%topology, i, 1 ) == 0 ) then
        bound = bound - this%displacement(i)
     end if
  end do
  if ( this%displacement(comp) > bound ) node_iterator_in_bound = .false.
end function node_iterator_in_bound

!=================================================================================================
function node_iterator_has_finished ( this )
  implicit none
  class(node_iterator_t), intent(in) :: this
  logical :: node_iterator_has_finished
  node_iterator_has_finished = this%overflow
end function node_iterator_has_finished

!=================================================================================================
function node_iterator_current_ijk ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current_ijk
  integer(ip) :: coord(0:this%node_array%polytope_tree%number_dimensions-1), c, comp, j
  assert ( .not. this%has_finished() )
  ! First put free coordinates as such (fixed ones introduced when initializing)
  c = 0
  do comp =0,this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS ( this%n_face, comp+this%node_array%polytope_tree%number_dimensions, 1 ) == 1 ) then
        this%coordinate(comp) = this%displacement(c)
        c = c+1
     end if
  end do
  ! Next, translate fixed coordinates if needed
  do comp =0,this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS ( this%n_face, comp+this%node_array%polytope_tree%number_dimensions, 1 ) == 0 .and. IBITS( this%n_face, comp, 1 ) == 1 ) then
        this%coordinate(comp) = this%node_array%order(comp+1)
        do j = comp+1,this%node_array%polytope_tree%number_dimensions-1
           if ( IBITS ( this%node_array%polytope_tree%topology, j, 1 ) == 0 .and. IBITS ( this%n_face, j+this%node_array%polytope_tree%number_dimensions, 1 ) == 1 ) then
              this%coordinate(comp) = this%coordinate(comp) - this%coordinate(j)
           end if
        end do
     end if
  end do
  node_iterator_current_ijk = ijk_to_index( this%coordinate, this%node_array%order, this%node_array%polytope_tree%number_dimensions )
end function node_iterator_current_ijk

!=================================================================================================
function node_iterator_current ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current
  node_iterator_current = this%node_array%ijk_to_index( this%current_ijk() )
end function node_iterator_current

!=================================================================================================
! SUPPORT FUNCTIONS  
!=================================================================================================

!=================================================================================================
pure function ijk_to_index( n, order, dim )
  implicit none
  integer(ip), intent(in) :: dim, n(0:dim-1), order(1:SPACE_DIM)
  integer(ip) :: ijk_to_index, i, aux_order(0:SPACE_DIM-1)
  ijk_to_index = 0
  aux_order(0) = 1
  do i = 1,dim-1
     aux_order(i) = aux_order(i-1)*(order(i)+1)
  end do
  do i = 0,dim-1
     ijk_to_index = ijk_to_index + n(i)*aux_order(i)!((order+1)**i)
  end do
end function ijk_to_index

!=================================================================================================
pure function n_face_dimension( n_face, dim )
  implicit none
  integer(ip), intent(in) :: n_face, dim
  integer(ip) :: n_face_dimension, i
  n_face_dimension = 0
  do i = 0,dim-1
     n_face_dimension = n_face_dimension + IBITS( n_face, dim+i, 1 )
  end do
end function n_face_dimension



! The following subroutine implements the required information to permute nodes on n-faces of 
! contiguous FEs. We note that the required permutations are expressed in terms of a set of 
! tables, in order to be efficient. However, this work has been implemented only for 2D and
! 3D problems. Even though the extension to 4D is possible, we have not performed it. The 
! main reason is that for topologically structured meshes of (possible deformed) n-cubes, 
! the only permutation is the identity, since all faces are "properly oriented", i.e., any
! pair of contiguous n-faces order their shared nodes locally the same way. For 3D general
! "non-oriented" meshes + a prysm-type 4D extension, it could also be easily implemented, since
! "3D faces" + extrusion permutations can easily be generated and the 4D new faces, e.g.,
! time interfaces in space-time problems, are properly oriented. However, this work has not 
! been performed yet, since it is not needed now in FEMPAR. 
!
! On the other hand, this work is working for n-cubes ONLY. The extension to TETs is possible, 
! but not obvious, and requires more work. Again, it is not something being used in FEMPAR 
! at the time of August 2016, and we postpone this work to when it will be needed.
!
! Let us consider a pair of n-cubes, with n = 1,2,3. Given a face of one cube and a face of 
! the other cube that are in touch, we need to know how to permute local nodes in one element
! to sort the shared elements the same way as generated by the local nubmering of the other
! element. 
!
! In 1D, there is nothing to permute, since 1D elements are only shared via vertices,
! i.e., only one node per pair. 
!
! In 2D, we have edges among elements. In an edge, we have two cases, based on the anchor 
! node of the edge in both sides. If the anchor node is the same,
! since the anchor node is always the one with minimum ijk_to_index number, both edges are
! have the same orientation and the permutation is the identity. If the anchor nodes are
! different, i.e., one is one extremum and the other one the other extremum of the edge,
! as above, they are ordering the nodes in opposite order, thus the permutation is N:1,
! N being the number of (interior) nodes in the edge. Thus, in 2D there are two "rotations"
! since we have two potential anchor nodes. But for a given anchor node only one "orientation"
! is possible. Elements with only vertices in common do not require permutation for obvious
! reasons. 
!
! ROT1   ROT2
! 1  2 | 2  1   PERM1
!
! In 3D, when we have two faces in common, given one face as the master face, the slave face
! can have the anchor node in four potential positions, the vertices of the face. Thus, we
! have to consider four possible rotations in 3D. On the other hand, even when two faces
! have the same anchor node (possibly after performing the rotation), one still has two
! possible orientations of the edge, depending whether the X-axis/Y-axis in the master/slave
! face coincide or are swapped. Thus, we have 8 possible situations, 4 rotations times 2
! permutations.
!  ROT1    ROT2   ROT3   ROT4
! | 3  4 | 4  2 | 1  3 | 2  1 |  PERM1  
! | 1  2 | 3  1 | 2  4 | 4  3 | 
!
! | 2  4 | 4  3 | 1  2 | 3  1 |  PERM2  
! | 1  3 | 2  1 | 3  4 | 4  2 | 
!
! These 8 combinations are stored in the own_node_permutations array (when called the subroutine 
! with idime = 2). Further, when two elements share an edge, we only have two possibilities as in 
! 2D, since the anchor node is always the one with less index. Thus, we use the same permutation
! table in 3D for edges as in 2D, stored in own_node_permutations array when called the subroutine 
! with idime = 1.
!
! Finally, looking at a 3D-cube,
!
!  Z
!(101)|________ F4(110)
! F2 /|        |
!   /3| 3    4 |
!  /4 | 1    2 |
!  |  |________|_ Y
!  | 1/ 1   3  /
!  |2/ 2   4  /
!  |/_______ / F0(011)
! X
! 
! one can check that two cubes sharing F0-F2 with the same anchor node have the same orientation,
! but F0-F4 and F2-F4 have different orientations. Analogously, if F0-F2 have the same orientation,
! F0-F3 (the only parallel face to F2) have a different orientation, etc. Further FX-FX always 
! have different orientation. And if FX-FY have same/different orientation, FY-FX have same/different
! orientation. All these combinations are considered in the code as follows. First, we
! construct the orientation array of size the number of faces:
! orientation = [F00, F01, F02, F03, F04, F05] = [1 0 0 1 1 0]
!
! This array is computed in 'facet_orientation' below. The mathematical reasoning behind this 
! function is the following. E.g., in 3D we have a face of type XXX = 011, 101, 110. Given 
! the basis face type (the type with minimum index), e.g., 011 in 3D, we can compute the axes
! that have to be swapped to go from the base face to the target face. E.g., given 101 and the
! base face 011, it tells us that we have to swap the Y and Z axes (rotate with respect to X). 
! For 110, the X and Z axes. Next, we have to check whether or not the original ordering in the
! base face changes in the new face. E.g., given the (i,j,0) ordering in 011 for i,j=1,N, when
! rotating with respect to X to have a 101 face, we have (i',0,j') = (i,0,j), thus leading to the
! identity permutation. However, when rotating with respect to Y to have a 110 face we get 
! (0,j',k') = (0,j,i) and thus a change of orientation.
! 
! This way, we can compute the orientation FYZ for any face Y and Z that share the same 
! anchor node. The reason is that, given a cube, we can rotate it with respect to the axis
! defined above in such a way that FY is now located in the FZ position (the cube is not anymore
! in [0,1]^3 but in [0,1]^2 * [-1,0] (this is the case when rotating with respect to Z). 
! Now we can put another cube in the original position and we have two cubes sharing the faces 
! FY (new cube) and FZ (old cube), and where the permutation is the one computed above.
!
! I would say that all this is general for n-cubes with n>3. We have two faces 11110111 and
! 11011111, the algorithm tells us that U and W axes have to be swapped, we can compute the
! permutation array in that case, etc. But it requires more thinking. 
!
! In any case, what is next is an efficient way to deal with 3D and is by no purpose general.  
! We can easily check that FXY = mod(1 + FOX - FOY, 2). This is the way we compute the orientation
! at every pair of faces in 'reference_fe_compute_relative_orientation'. The rotation of the axes of the
! slave face in order to put the origin on the anchor node of the master face is computed by taking
! the global index of the anchor node and loof for it in the list of global indices of the face. It
! provides a value from 1 to 4. Computing rotation*orientation, we have a number from 1 to 8 that
! we can use to pick the right permutation in own_node_permutations(idime=2).
!
! A similar thing can be done for 4D, even though the logics are different. For instance, two
! objects sharing the same face have the same orientation (!) (@sbadia: I have plotted a tesseract
! (see https://en.wikipedia.org/wiki/Hypercube) and i think it is like this). The following procedure
! is dimension independent but I have not implemented it YET this way. I consider the 4D case for
! simplicity in the exposition.
!
! Let us consider a facet FX of the n-cube. This facet has only one fixed component, denoted by j.
! I consider that the anchor node coordinate j=0 (the other only option is j=1). We denote the original
! n-cube as Omega_0. Now, let us consider the permutation to be done with respect to two n-cubes
! sharing face FX, with the same anchor node. Now, we consider two \pi/2 rotations with respect to the
! axis i \neq j (e.g., the largest i \neq j) plus one translation with vector e_i = \delta_ij (Kronecker).
! It leads to (x1,x2,...,xi,...,xj,..,xn) -> (x1,x2,...,1-xi,...,-xj,..,xn).
! We note that: 1) it is a rigid-body motion by construction, obvious check. 2) The original
! facet is invariant with respect to it, i.e., x such that x_j = 0 still satisfies x_j = 0 after the 
! movement. On the other hand, the new domain after the transformation is \Omega_1 = 
! { xa \in [0,1] for a \neq j, x_j \in [-1,0]}. Thus, \Omega_0 and \Omega_1 are two n-cubes sharing
! face F0 = {x \in \Omega_0,1 | x_j = 0}. If F0 is such that x_j = 1, the only difference is that 
! the traslation is e_i + 2e_j. Thus (x1,x2,...,xi,...,xj,..,xn) -> (x1,x2,...,1-xi,...,2-xj,..,xn).
! We can easily check that the same properties as above hold. In particular, the face 
! F0 = {x \in \Omega_0,1 | x_j = 1} is invariant with respect to the rigid-body motion.
!
! In any case, the anchor node of the face is not invariant (in general) with respect to the 
! transformation. The anchor node initial position is x(0) = 0/1 e_j, and the new position is
! x(1) = -e_i. So, we consider another rigid body motion from \Omega_1 to \Omega_2 as follows.   
! The idea is to start with x(1) and do as many rotations as needed to
! end up with x(2) = x(0). We note that there are n-2 possible rotations in a facet. Think
! about a 3-cube with one node in the origin that one wants to move to another corner. There
! are multiple ways to do it. First, consider a change of coordinates, x' -> x + 1/2(1,...,1).
! Thus, x(0)' = x(0) + 1/2, x(1)' = x(1) + 1/2. We consider a rotation of the face F0 
! with respect to x_j' and origin axis such that x(1)' = x(0)'. We start with x(0)_i, i = 0,
! and check if they are equal (only the sign is really needed to check since all values are +-1/2.
! If same sign, go to i+1. Otherwise, if same sign between x(1)'_i and x(1)'_i+1, perform the
! permutation Rx'_k = x'_k, k \neq i,1+i, Rx'i = -x_i+1, Rx'_i+1 = x_i, and if different sign
! Rx'i = x_i+1, Rx'_i+1 = -x_i. When we reach i = n-1, we have the typical 2D case, with four
! possible choices. We perform the typical (x,y) -> (y,-x) permutation till these two
! coordinates are also equal. At the end of the algorithm, we have defined a rotation matrix 
! that does not modify x_j such that x(0)' = x(1)'. Next, we move back the axis to the origin,
! x -> x' - 1/2(1,...,1). We note that, 1) all these rotations are rigid-body motions. 2)
! the face F0 is invariant with respect to them and the n-cube \Omega_1 is also invariant
! with respect to these rotations. 3) The anchor node of F0 is invariant with respect to the
! composition of the previous and this rigid body motions. As a result, we have now a mapping 
! from \Omega_0 to \Omega_1 such that the elements share the face F0 with same anchor node.
! The coordinates (ijk) of the nodes after mapping can easily be computed. Sorting the
! ijk_to_label of the original F0 nodes after the mapping leads to the desired permutation.
!
! In terms of implementation, it is easy to code the set of rotations + traslations that define
! the mapping instead of using the permutation arrays. Given a ijk, we apply the mapping, compute
! the ijk' and the corresponding ijk_to_label. In 4D we have 6 possible orientations
! ijk, ikj, jik, jki, kij, kji). Possibly, we could check for every pair of faces, the type of
! permutation needed, as for 2D 3D below.
!
! @sbadia: It requires a little bit of work and there is not 4D machinery yet and even with
! 4D machinery is unclear to me we will need it, since we can assume that we do have oriented
! meshes in 4D. Thus, the following implementation is focused to 2D and 3D.
!=================================================================================================
!
! This subroutine takes the type of two n-faces and checks the required permutation of axes.
! It is for F0 and F2 or F4 in 3D (with anchor node in 0). Thus, the cube after the rotation
! of the axes out of this, leads to the new cube. The new cube and the original cube share 
! one face, F0 in the new cube (after rotation) and F2/F4 in the new one. By construction,
! they share the anchor node 0. Thus, we can fill all the permutations for any face, using
! the 3D properties above.
!=================================================================================================
function facet_orientation( n_face, dim )
  implicit none
  integer(ip), intent(in) :: n_face, dim
  integer(ip) :: facet_orientation
  integer(ip) :: n_face_type, base_n_face_type, axis_swap
  assert( n_face_dimension( n_face, dim) == dim-1 ) ! Only has sense for facets
  facet_orientation = 0

  n_face_type = IBITS( n_face, dim, dim )
  base_n_face_type = IBSET(0, dim-1)-1
  axis_swap = IEOR(n_face_type,base_n_face_type)
  if ( IBITS( axis_swap, 0, 1) == 1 .and. dim > 2 ) then
     facet_orientation = 1
  else
     facet_orientation = 0
  end if
  if ( axis_swap == 0 ) facet_orientation = 1
  n_face_type = IBITS( n_face, 0, dim )
  if ( n_face_type /= 0 ) then
     facet_orientation = 1-facet_orientation
  end if
  if ( dim == 2 ) then
     facet_orientation = 1-facet_orientation
  end if
end function facet_orientation
! 
! Here, we take (i,j) nodes, i,j=0,n-1 in one face. Next, we consider how the nodes change after
! rotations (2 or 4, in 2 and 3D respectively). For every rotation, we consider the possible 
! orientations (1 or 2, in 2 and 3D respectively). It is dimension independent. In fact, one could
! also compute the possible permutations e.g. in 4D (there are 6 possible orientations
! ijk, ikj, jik, jki, kij, kji). But I am not sure it is the way to proceed, as commented above.
! 
! Note: We assume isotropic order, since anisotropic methods cannot be used unless meshes are
! oriented. Think about Q_k+1,k.
!=================================================================================================
subroutine node_array_fill_permutations( order, idime, base_polytope, own_node_permutations)
  implicit none
  integer(ip)                  , intent(in)    :: order
  integer(ip)                  , intent(in)    :: idime
  type(polytope_tree_t)        , intent(in)    :: base_polytope
  type(allocatable_array_ip2_t), intent(inout) :: own_node_permutations
  type(polytope_tree_t) :: n_face
  type(node_array_t)    :: nodes_n_face, vertices_n_face
  integer(ip)           :: n_face_type, topology_n_face, c, iorie, j
  type(node_iterator_t) :: node_iterator, vertex_iterator
  integer(ip)           :: ijk_node(SPACE_DIM), ijk_anchor_node(SPACE_DIM)
  integer(ip)           :: ijk_rot(SPACE_DIM), ijk_perm(SPACE_DIM), order_vector(SPACE_DIM),aux, ones(SPACE_DIM)
  order_vector = order
  ones = 1
  if ( order > 1 ) then 
     ! We go through all the nodes of the first n-face of this dimension
     n_face_type = 0
     do j = 0,idime-1
        n_face_type = IBSET(n_face_type,idime+j) 
     end do
     topology_n_face = IBITS(base_polytope%topology,0,idime)
     ! It only works for isotropic order **IMPORTANT**
     ! It is NOT a limitation of the code but a limitation of anisotropic Lagrangian spaces
     ! based on node continuity, since they require that all n-faces will be oriented to 
     ! have sense
     call n_face%create( idime, topology_n_face )
     call nodes_n_face%create( n_face, order_vector )
     call vertices_n_face%create( n_face, order = ones )
     node_iterator = nodes_n_face%create_node_iterator( n_face_type, own_boundary = .false. )
     vertex_iterator = vertices_n_face%create_node_iterator( n_face_type, own_boundary = .true. )
     c = 0
     call node_iterator%init()
     do while (.not. node_iterator%has_finished() )
        c = c+1
        call node_iterator%next() 
     end do
     call own_node_permutations%create(c, idime * vertices_n_face%number_nodes )
     c = 0
     do iorie = 1,idime
        call vertex_iterator%init()
        do while (.not. vertex_iterator%has_finished() )
           aux =  vertex_iterator%current_ijk()
           ! Chapuza
           ijk_anchor_node = vertex_iterator%coordinate
           !WRITE(*,*) 'ROTATION, ORIGINAL ANCHOR NODE:',ijk_anchor_node(1:idime)

           c = c+1
           !WRITE(*,*) 'ORIENTATION:',iorie
           call node_iterator%init()
           do while (.not. node_iterator%has_finished() )
              aux =  node_iterator%current_ijk()
              ! Chapuza
              ijk_node = node_iterator%coordinate
              !write(*,*) 'Current node IJK:',ijk_node(1:idime)
              !write(*,*) '***Current node:***',ijk_to_index(ijk_node-1, order_vector-2,idime)+1

              ! Now rotate the n-face based on the anchor node
              ! If the anchor node is in the original position (0) perm = Id
              ijk_rot =  rotate(ijk_node,ijk_anchor_node,idime, order )
              ! Next, consider the possible orientations

              ijk_perm = change_orientation(ijk_rot,iorie,idime)
              !write(*,*) 'ROTATED node IJK:', ijk_rot(1:idime)
              !write(*,*) 'ROTATED + ORIENTED node IJK:', ijk_perm(1:idime)
              !write(*,*) '***final node:***', ijk_to_index(ijk_perm-1, order_vector-2,idime)+1
              !write(*,*) 'ROTATED + ORIENTED node OLD ARRAY:', nodes_n_face%ijk_to_index(ijk_to_index(ijk_perm,this%order,idime))
              !write(*,*) 'node iterator number:', ijk_to_index(ijk_node-1,this%order-2,idime)+1
              own_node_permutations%a(ijk_to_index(ijk_node-1, order_vector-2,idime)+1,c) =  ijk_to_index(ijk_perm-1, order_vector-2,idime)+1
              !nodes_n_face%ijk_to_index(ijk_to_index(ijk_perm,this%order,idime))
              ! Be careful, ijk_perm is not contiguous for TETs, etc.
              call node_iterator%next() 
           end do
           call vertex_iterator%next() 
        end do
     end do
     call n_face%free()
     call nodes_n_face%free()
     call vertices_n_face%free()
  end if
end subroutine node_array_fill_permutations

subroutine node_array_compute_num_rot_and_perm( idime, base_polytope, num_rot, num_perm)
  implicit none
  integer(ip)                  , intent(in)    :: idime
  type(polytope_tree_t)        , intent(in)    :: base_polytope
  integer(ip)                  , intent(inout) :: num_rot, num_perm
  
  type(polytope_tree_t) :: n_face
  type(node_array_t)    :: vertices_n_face
  integer(ip)           :: n_face_type, topology_n_face, j
  integer(ip)           :: ones(SPACE_DIM)

  ones = 1
  
  ! We go through all the nodes of the first n-face of this dimension
  n_face_type = 0
  do j = 0,idime-1
     n_face_type = IBSET(n_face_type,idime+j) 
  end do

  topology_n_face = IBITS(base_polytope%topology,0,idime)

  call n_face%create( idime, topology_n_face )
  call vertices_n_face%create( n_face, order = ones )     

  num_rot  = vertices_n_face%number_nodes
  num_perm = idime

  call n_face%free()
  call vertices_n_face%free()
  
end subroutine node_array_compute_num_rot_and_perm
!
! Here we compute (x,y) -> (y,1-x) rotations (with respect to 1/2,1/2). Given the position of 
! the anchor node in the master face, we consider the permutations of this type till the anchor node 
! of the slave node (origin) coincides. In 2D, x -> 1-x.
!=================================================================================================
function rotate( ijk_node, ijk_anchor_node, face_dim, order )
  implicit none
  integer(ip), intent(in) :: ijk_node(SPACE_DIM), ijk_anchor_node(SPACE_DIM), face_dim, order
  integer(ip) :: i, rotate(SPACE_DIM), aux1, aux2, rot_vertex(SPACE_DIM)
  rot_vertex = ijk_anchor_node
  rotate = ijk_node
  do while ( sum(rot_vertex(1:face_dim)) /= 0 )
     aux1 = rotate(1)
     aux2 = rot_vertex(1)
     do i = 1,face_dim-1
        rotate(i) = rotate(i+1)
        rot_vertex(i) = rot_vertex(i+1)
     end do
     rotate(face_dim) = order - aux1
     rot_vertex(face_dim) = 1 - aux2
  end do
end function rotate
!
! The change of orientation in 3D is ij -> ij or ji. In 2D, i -> i.
!=================================================================================================
pure function change_orientation( ijk_node, orientation, face_dim )
  implicit none
  integer(ip), intent(in) :: ijk_node(SPACE_DIM), orientation, face_dim
  integer(ip) :: change_orientation(SPACE_DIM)
  ! if ( dim == 1) nothing to be done
  if ( orientation == 2 .and. face_dim == 2 ) then
     change_orientation(1) = ijk_node(2)
     change_orientation(2) = ijk_node(1)
  else
     change_orientation = ijk_node
  end if
end function change_orientation
