! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! NOTATION
! ========
!
! The following work is applicable to any space dimension. Thus, the use of face, edge, vertex, etc. can be misleading.
! In this regard, in order to be precise, we use the notion of polytope for the original object. Its boundary is defined 
! for n-faces, where $n < d$, $d$ being the space dimension. We use the notation n-face to define any sub-object of the
! polytope and even the polytope itself when $n = d$. E.g., in 3D, the n-face concept leads to the cell (3-face), the
! faces (2-faces), the edges (1-faces), and the vertices (0-faces). Finally, the $(d-1)$-faces can also be denoted as 
! facets. E.g., a facet is a face in 3D and an edge in 2D. 0-faces are vertices, 1-faces are edges, 2-faces are faces, 
! and 3-faces are cells.
!
! POLYTOPE DEFINITION
! ===================
!
! A polytope is mathematically defined as the convex hull of a finite set of points. Thus, a polytope has flat sides.
!
! In particular, we are interested on polytopes that can be generated by two types of extensions from previous dimensions.
! One case of extension is the extrusion, leading to hypercubes, or n-cubes. Another type of extension is the one 
! used to generate triangles, which can be defined as the Duffy transformation of the extrusion. The first extension is 
! called the "prysm" extension (denoted by 1) and the second one is the "pyramid" extension (denoted by 0).
!
! Given an closed domain $\Omega \subset \R^d$, we generate its the prysm extension $Q(\Omega) \subset \R^{d+1} = \Omega \times [0,1]$.
! On the other hand, the pyramid extension $T(\Omega)$ is defined as
! $$
! Q(\Omega) = \{ x \in \R^{d+1} | x \in (\Omega(1-z),z), z \in [0,1] \}. 
! $$
! As a result, in dimension d, we can define an object by the type of action being used at every dimension, starting from the ${0}$ vertex.
! In 1D, both actions lead to the line segment $[0,1]$. In 2D, using the prysm action, we get the square, whereas the pyramid action gives
! the triangle. Thus, a polytope that can be defined as the combination of these actions is represented in the computer by d bits.
!
! E.g., in 3D, we have the cube 111 (or 110), the prysm 101 (or 100), the pyramid 011 (or 010), and the tetrahedrom 001 (or 000). 
! The non-uniqueness in 1D leads to two possible definitions of the polytope. Thus, we can just define the topology of these polytopes by
! an integer.
!
! N-FACES
! =======
!
! Now, given an object defined by its d-bits topology, we can represent any n-face as follows. Let us start with the polytope itself. 
! The polytope is a d-dimensional object, and thus, there is no restriction among the d space coordinates of its nodes. Thus, we 
! say that all coordinates are free. It is represented by d-bits, where 1 means that the coordinate is free and 0 means that it is fixed.
! As a result, the polytope itself is 111. 

! Now, we can consider its (d-1)-faces (facets). In any face, there is one and only one constraint among coordinates. Let us consider
! for simplicity that we have a 3-cube. In this case, we have the faces 011 (Z-faces, since its normal is aligned with the Z-axis), 
! the faces 101 (Y-faces), and the faces 110 (X-faces). For a given type of face, we have two possible values of the fixed component,
! 0 or 1. Thus, together with the type of n-face, we have to provide the anchor vertex (0-face). It leads, as expected, to 6 facets, 
! two per n-face type. For any dimension, a d-cube has 2d facets. As a result, any n-face can be uniquely defined by 2d-bits, the 
! type and the anchor node. We note that the coordinate value related to a coordinate that is free has no sense, and in this case, 
! the coordinate value is enforced to 0. E.g., for the 3d cube we have the six faces 011|000, 011|100, 101|000, 101|010, 110|000, and
! 110|001. Everything applies verbatim for edges and vertices. Further, all these concepts can be applied to any dimension.

! The use of this ideas to define n-faces of polytopes that involve pyramid actions is slightly more complicated. Its relies on the
! following observation. Assume that we start with a (d-1)-polytope A, and denote by S the set of its vertices. The d-polytope P(A)
! has card(S)+1 vertices, where the new vertex has coordinate d equal to 1 and the rest equal to zero, whereas the other are the
! ones in S (with 0 value on the d-coordinate). Based on these arguments, the set of admissible n-faces is restricted. One can not
! have vertices such that, if the d-coordinate is equal to 1, it has some other coordinate different from 0. 
! Thus, we cannot have an edge with a free coordinate in a position n<d and a fixed coordinate equal to 1 in position d. One of the
! vertices of the corner would be 1 in position d and n, which is not a vertex of the object itself. Among all potential edges, 
! we can only consider those that when the free coordinate is n \neq d, the anchor node is 0. E.g., in 2D, the edge
! 01|10 is not admissible, because it would lead to the vertex 00|11, which is not in the object, and only 3 nodes are possible.
!
! We can extend this restriction to arbitrary dimensions. Let us assume that we have a polytope A, with all its edges and faces.
! Let us assume that n-1-faces satisfy that a free coordinate in m < d implies anchor node 0. Now, let us assume
! that we have an n-dimensional object with n<d and anchor node different from 0. It leads to n-1-faces that do not belong to the
! polytope. We have proved it by induction.
!
! As a result, given an n-face, we can easily proceed as for n-cubes, but only considering those n-1-faces that are suitable, i.e.,
! an n-dimensional object with n<d must have anchor node 0. This check is easy to implement
!
! do i = 2:dim
!    if ( t(i) == 0. and. (  c(i) == 1 .and. f(i) == 0 ) )! Current coordinate is obtained by 1 (pyramid) and == 1
!       do k = 1:i-1
!          if ( (c(k) == 1 .and. f(k) == 0)  .or. f(k) == 1 ) ! Coordinate fixed to 1 or free
!             NOT SUITABLE  break
!          end if
!       end do
!    end if
! end do
!
! where t is the topology, f the type of n-face, and c the anchor vertex.
!
! As a result, using these ideas, we can extract n-1-faces of a given n-face. 
!
! In FEMPAR, we have implemented the polytope_tree_t, which includes the topology and the number of dimensions of the polytope. Since the bit-based
! definition of the n-faces above is non-consecutive and it mixes objects of different dimensions, we define another numbering for the objects. Thus,
! first, given the polytope we generate all its n-faces, recursively obtaining the n-1-faces of an n-face. Next, we re-number these objects. The 
! permutation from the bit-based to the new numbering is in ijk_to_index and its inverse permutation in n_face_array.
!
! We also provide an iterator over the facets of an n-face of a given polytope in n_face_iterator_t. This iterator implements the notion of admissibility
! described above. These subroutines have to work with bits in order to answer queries.
!
! NODES
! =====
!
! Let us consider a (O+1)-partition of every dimension in the [0,1]^d d-cube, and denote by S the set of vertices of such partition. Every vertex can
! easily be defined by d integers with values from 0 to O+1. For an arbitrary polytope defined as above, we can define the set of vertices in S 
! that belong to the polytope or any of its n-faces. It leads to the Lagrangian nodes of order O for an arbitrary polytope. Further,
! these queries can be for the open and closed n-face.
!
! We have created the node_array_t structure, that given a polytope provides the list of all nodes for a given order, based on a lexicographical 
! index. Again, since this index is non consecutive for non-cube polytopes, we renumber the nodes with the permutation table node_array. Its inverse
! is in ijk_to_index. 
!
! Further, given an n-face of the polytope, we provide an iterator over the nodes that belong to that n-face (considering the n-face an open or closed set).
! Let us consider the 3D case for simplicity. This iterator is performing the loop
!
! do k = 0,O
! do j = 0,O-k*t(3)
! do i = 0,O-k*t(2)-j*t(1)
!
! where t is the topology and O the order. 
!
! NODE ITERATOR ON N-FACES
! ========================
!
! The same applies for any n-face. We can create the node_iterator_t over any n-face of the poytope. The idea is the same as above, but working on the
! dimension n. E.g., the loop above performed for the n-face dimension, e.g., only i and j for an edge in 2D. However, it is only part of the story. It leads
! to the node numbering (ijk) in the n space dimension. Next, we have to translate/rotate it to the original space. 
!
! This is the reason why the ijk index in iterator_t is called "displacement", since it denotes the displacement with respect to the anchor node of the n-face
! of the free indices. In order to go from the displacement to the real coordinates, we proceed as follows (see node_iterator_current_ijk subroutine):
!
! 1) First, we put the free coordinates as such in the coordinates array (in the correct position). The fixed component is also put taking the value of the
! anchor node, i.e., 0 if the anchor node coordinate is 0 and order if 1.
!
! 2) The first step is enough for n-cubes (displacement and coordinates are identical). However, for pyramid actions, n-faces are not parallel to the axis. Thus, 
! we have to take it into account. Let us consider the edge in the reference triangle that is not parallel to any edge. At this point, we have nodes in that 
! edge with a constant X-coordinate, when it is not true. The fact is that any Y-displacement comes with a -1 displacement in X. Thus, taking the displacement
! obtained above, putting the Y-coordinate equal to the Y-displacement, and computing the X-coordinate as the X-displacement minus the Y-displacement, we get
! the right ijk index in that edge.
!
! We can also extend it to any n-face in any dimension (see node_iterator_current_ijk subroutine). The algorithm is to take the fixed component (initialized
! as commented above) and iterate over the superior index dimensions, check whether the corresponding action at that dimension is pyramid, and if yes, subtract
! the corresponding free coordinate to the current coordinate.
!
!=================================================================================================
!     GEOMETRY_TREE_T TBPS
!=================================================================================================

!=================================================================================================
! This subroutine creates the n-face tree, where the geometrical n-faces are defined by 2*DIM bits.
! The "first" (from the right) DIM bits provide the "anchor node", whereas the "second" set of DIM
! bits provides the type of n-face. For every component, if we have 1 it means that the y-component
! can freely change. When = 0 it is constrained. However, it does not mean that it is constant (it
! is only for hyper-cubes). Think about the face of the tetrahedron that is not aligned with any 
! axes.
subroutine polytope_tree_create( this, number_dimensions, topology )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: number_dimensions
  integer(ip)        , intent(in)    :: topology
  integer(ip) :: c, i, d, j
  integer(ip), allocatable :: aux_array(:)
  call this%free()
  this%topology = topology
  this%number_dimensions = number_dimensions
  !     Compute number of n-face (all dimensions) for the hypercube
  !     c = (2**dim-1)*2**dim max id n-face
  c = 0
  do i = 0,number_dimensions
     c = c + 2**(number_dimensions-i)*(get_binomial_coefficient(number_dimensions,i))
  end do
  !     Pre-allocate this%n_faces_array with c (exact for hypercube)
  call memalloc ( c, this%n_face_array, __FILE__, __LINE__ )
  !     Pre-allocate the ijk_to_index. Maximum ijk_to_index is [111000]+1 for dim = 3
  !     = ISHFT(ISHFT(1_ip,dim)-1,dim) = (2**dim-1)*2**dim
  call memalloc ( ISHFT(ISHFT(1_ip,number_dimensions)-1,number_dimensions)+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  this%ijk_to_index = 0
  this%number_n_faces = 0
  !     Call the recursive fill_tree procedure starting with the volume n-face
  call this%fill_cell_tree( ISHFT(ISHFT(1_ip,number_dimensions)-1, number_dimensions ) ) ! Root n-face (volume)
  !     Re-allocate the n-faces_array to the exact number of n-faces
  call memrealloc ( this%number_n_faces, this%n_face_array, __FILE__, __LINE__ )
  !     Sort n-faces based on 1) n-face_dimension 2) its bit-based index
  call memalloc ( this%number_n_faces, aux_array, __FILE__, __LINE__ )
  aux_array = this%n_face_array
  c = 1
  d = 1
  this%n_face_array = 0
  do i = 0,number_dimensions
     do j = 1,this%number_n_faces
        if ( n_face_dimension( aux_array(j), this%number_dimensions ) == i ) then
           this%n_face_array(d) = aux_array(j)
           d = d+1
        end if
     end do    
     call sort( d-c, this%n_face_array(c:d-1) ) 
     c = d
  end do
  call memfree ( aux_array, __FILE__, __LINE__ )
  !     Create the bit-index to consecutive index array (0 for bit-indexes wo/ associated n-face)
  do i =1,this%number_n_faces
     this%ijk_to_index( this%n_face_array(i) ) = i
  end do
end subroutine polytope_tree_create

!==================================================================================================
! This recursive subroutine fills ALL the sub-n-faces (including the n-face itself). From dimension
! DIM to 0.
recursive subroutine fill_cell_tree( this, root )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  integer(ip)        , intent(in)    :: root
  type(n_face_iterator_t) :: children_iterator
  integer(ip)               :: children  
  ! If the n-face not already inserted (use ijk_to_index as touch table)

  if ( this%ijk_to_index(root) == 0 ) then 
     ! Increase one position current n-face in polytope_tree
     this%number_n_faces = this%number_n_faces + 1
     ! Put root as new n-face in polytope_tree
     this%n_face_array(this%number_n_faces) = root
     ! Mark root as touched (already inserted)
     this%ijk_to_index(root) = 1
     ! Create iterator over children of root n-face
     children_iterator = this%create_children_iterator(root)
     ! Loop over children
     do while (.not. children_iterator%has_finished() )
        children = children_iterator%current_ijk()
        !write(*,*) 'current children: '
        !write(*,'(B32)') children
        ! Put children of child (recursive call)
        call this%fill_cell_tree( children )
        ! Move to the next child
        call children_iterator%next()
     end do
  end if
end subroutine fill_cell_tree

!=================================================================================================
subroutine polytope_tree_free( this )
  implicit none
  class(polytope_tree_t), intent(inout) :: this
  if (allocated(this%n_face_array)) call memfree ( this%n_face_array, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine polytope_tree_free

!=================================================================================================
function polytope_tree_create_children_iterator(this, parent)
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: parent
  type(n_face_iterator_t) :: polytope_tree_create_children_iterator
  call polytope_tree_create_children_iterator%create(this, parent)
end function polytope_tree_create_children_iterator

!=================================================================================================
function polytope_tree_get_number_n_faces(this) 
       implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)                          :: polytope_tree_get_number_n_faces
  polytope_tree_get_number_n_faces = this%number_n_faces     
end function polytope_tree_get_number_n_faces

!=================================================================================================
function polytope_tree_get_n_face(this, n_face_index) 
       implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: n_face_index
  integer(ip)                          :: polytope_tree_get_n_face
  polytope_tree_get_n_face = this%n_face_array(n_face_index)     
end function polytope_tree_get_n_face

!=================================================================================================
function polytope_tree_get_n_face_dimension(this, n_face_index) 
       implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)         , intent(in) :: n_face_index
  integer(ip)                          :: polytope_tree_get_n_face_dimension
  polytope_tree_get_n_face_dimension = n_face_dimension( this%n_face_array(n_face_index), this%number_dimensions )     
end function polytope_tree_get_n_face_dimension

!=================================================================================================
function polytope_tree_n_face_dir_is_fixed(this, n_face_index, dir) 
       implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)           , intent(in) :: n_face_index
  integer(ip)           , intent(in) :: dir
  integer(ip)                        :: polytope_tree_n_face_dir_is_fixed
  polytope_tree_n_face_dir_is_fixed = IBITS( this%n_face_array(n_face_index), this%number_dimensions + dir, 1 )
end function polytope_tree_n_face_dir_is_fixed

!=================================================================================================
function polytope_tree_n_face_dir_coordinate(this, n_face_index, dir) 
  implicit none
  class(polytope_tree_t), intent(in) :: this
  integer(ip)           , intent(in) :: n_face_index
  integer(ip)           , intent(in) :: dir
  integer(ip)                        :: polytope_tree_n_face_dir_coordinate
  polytope_tree_n_face_dir_coordinate = IBITS( this%n_face_array(n_face_index), dir, 1 )
end function polytope_tree_n_face_dir_coordinate

!=================================================================================================
!     NODE_ARRAY_T TBPS
!=================================================================================================

!=================================================================================================
subroutine node_array_create ( this, polytope_tree, order )
  implicit none
  class(node_array_t)        , intent(inout) :: this
  type(polytope_tree_t), target, intent(in)    :: polytope_tree
  integer(ip)                , intent(in)    :: order(SPACE_DIM)
  call this%free()
  this%polytope_tree => polytope_tree
  this%order = order
  call this%fill()
end subroutine node_array_create

!=================================================================================================
subroutine node_array_fill ( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  type(node_iterator_t) :: node_iterator 
  integer(ip) :: i, c, m_ijk, current
  current = ISHFT(ISHFT(1_ip,this%polytope_tree%number_dimensions)-1,this%polytope_tree%number_dimensions)
  node_iterator = this%create_node_iterator( current, own_boundary = .true. )
  call node_iterator%init()
  c = 0
  m_ijk = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     m_ijk = max( m_ijk, node_iterator%current_ijk() )
     call node_iterator%next()       
  end do
  this%number_nodes = c
  call memalloc ( c, this%node_array, __FILE__, __LINE__ )
  call memalloc ( SPACE_DIM, c, this%coordinates, __FILE__, __LINE__ )
  call memalloc ( m_ijk+1, this%ijk_to_index, __FILE__, __LINE__, lb1 = 0 )
  call node_iterator%init()
  c = 0
  do while (.not. node_iterator%has_finished() )
     c = c+1
     this%node_array(c) =  node_iterator%current_ijk()
     this%coordinates(:,c) = node_iterator%coordinate(:)
     call node_iterator%next()         
  end do
  ! Sort nodes based on its bit-based index
  call sort( c, this%node_array )    
  write(*,*) 'node_array',this%node_array
  do i =1,c
     !write(*,*) 'n-face(',i,') :'
     !write(*,'(B32)') this%node_array(i)
     this%ijk_to_index( this%node_array(i) ) = i
  end do
end subroutine node_array_fill

!=================================================================================================
subroutine node_array_print( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  integer(ip) :: i
  write(*,*) '************NODE ARRAY***********'
  write(*,*) 'number of nodes = ', this%number_nodes
  write(*,*) 'cell_tree_topology = '
  write(*,'(B32)') this%polytope_tree%topology
  write(*,*) 'nodes'
  do i = 1, this%number_nodes
     write(*,*) 'NODE: ',this%node_array(i)
     write(*,'(B32)') this%node_array(i)
     write(*,*) 'COORDINATE: ',this%coordinates(:,i)
  end do
  write(*,*) 'ijk_to_index: ',this%ijk_to_index
end subroutine node_array_print

!=================================================================================================
subroutine node_array_free( this )
  implicit none
  class(node_array_t), intent(inout) :: this
  if (allocated(this%node_array)) call memfree ( this%node_array, __FILE__, __LINE__ )
  if (allocated(this%coordinates)) call memfree ( this%coordinates, __FILE__, __LINE__ )
  if (allocated(this%ijk_to_index)) call memfree ( this%ijk_to_index, __FILE__, __LINE__ )
end subroutine node_array_free

!=================================================================================================
function  node_array_get_number_nodes(this) 
       implicit none
  class(node_array_t), intent(in) :: this
  integer(ip)                          :: node_array_get_number_nodes
  node_array_get_number_nodes = this%number_nodes
end function  node_array_get_number_nodes

!=================================================================================================
!     N_FACE_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
subroutine n_face_iterator_create ( this, polytope_tree, parent )
  implicit none
  class(n_face_iterator_t)        , intent(inout) :: this
  type(polytope_tree_t)       , target, intent(in)    :: polytope_tree
  integer(ip)                       , intent(in)    :: parent
  !call this%free()
  this%polytope_tree => polytope_tree
  this%parent = parent
  call this%init()
end subroutine n_face_iterator_create

!=================================================================================================
subroutine n_face_iterator_init ( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  this%component = 0
  this%coordinate = 0
  if ( .not. this%is_admissible() ) then
     call this%next()
  end if
end subroutine n_face_iterator_init

!=================================================================================================
subroutine n_face_iterator_print( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  write(*,*) '***CHILDREN_ITERATOR ***'
  write(*,*) 'parent: '
  write(*,'(B32)') this%parent
  write(*,*) 'component: ',this%component
  write(*,*) 'coordinate: ',this%coordinate

end subroutine n_face_iterator_print

!=================================================================================================
recursive subroutine n_face_iterator_next ( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  if ( this%has_finished() ) return 
  if ( this%coordinate == 1 ) then
     this%component = this%component + 1
     this%coordinate = 0
  else
     this%coordinate = 1
  end if
  if ( .not. this%is_admissible() ) then
     call this%next()
  else 
  end if
end subroutine n_face_iterator_next

!=================================================================================================
function n_face_iterator_has_finished ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  logical :: n_face_iterator_has_finished
  n_face_iterator_has_finished = ( this%component >= this%polytope_tree%number_dimensions )
end function n_face_iterator_has_finished

!=================================================================================================
function n_face_iterator_current_ijk ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  integer(ip) :: n_face_iterator_current_ijk, j
  assert ( .not. this%has_finished() )
  n_face_iterator_current_ijk = this%parent
  n_face_iterator_current_ijk = IBCLR( n_face_iterator_current_ijk, this%polytope_tree%number_dimensions + this%component )
  if ( this%coordinate == 1 ) then
     if ( IBITS( this%polytope_tree%topology, this%component, 1 )  == 0 ) then
        do j = 0,this%component-1
           n_face_iterator_current_ijk = IBCLR( n_face_iterator_current_ijk, j )
        end do
     end if
     n_face_iterator_current_ijk = IBSET( n_face_iterator_current_ijk, this%component )
  end if
end function n_face_iterator_current_ijk

!=================================================================================================
function n_face_iterator_current ( this )
  implicit none
  class(n_face_iterator_t), intent(in) :: this
  integer(ip) :: n_face_iterator_current
  n_face_iterator_current = this%polytope_tree%ijk_to_index( this%current_ijk() )
end function n_face_iterator_current

!=================================================================================================
function n_face_iterator_is_admissible( this )
  implicit none
  class(n_face_iterator_t), intent(inout) :: this
  logical                          :: n_face_iterator_is_admissible
  n_face_iterator_is_admissible = .false. 
  if ( IBITS( this%parent, this%polytope_tree%number_dimensions + this%component, 1 ) == 1) then
     if ( IBITS( this%polytope_tree%topology, this%component, 1 ) == 1 ) then
        n_face_iterator_is_admissible = .true.
     else if ( this%coordinate == 0 .or. this%component == 0 & 
          & .or. IBITS( this%parent, this%polytope_tree%number_dimensions, this%component ) == 0 ) then  
        n_face_iterator_is_admissible = .true.
     end if
  end if
end function n_face_iterator_is_admissible

!=================================================================================================
!     NODE_ITERATOR_T TBPS
!=================================================================================================

!=================================================================================================
function node_array_create_node_iterator( node_array, parent, own_boundary)
  implicit none
  class(node_array_t) , intent(in) :: node_array
  integer(ip)         , intent(in) :: parent
  logical             , intent(in) :: own_boundary 
  type(node_iterator_t) :: node_array_create_node_iterator
  call node_array_create_node_iterator%create( node_array, parent, own_boundary )
end function node_array_create_node_iterator

!=================================================================================================
subroutine node_iterator_create ( this, node_array, n_face, own_boundary )
  implicit none
  class(node_iterator_t)            , intent(inout) :: this
  type(node_array_t), target               , intent(in)    :: node_array
  integer(ip)                       , intent(in)    :: n_face
  logical                           , intent(in)    :: own_boundary
  integer(ip) :: c, i
  this%node_array => node_array
  this%topology = 0
  this%n_face = n_face
  this%own_boundary = own_boundary
  if ( own_boundary) then
     this%max_value = node_array%order
     this%min_value = 0
  else
     this%max_value = node_array%order-1
     this%min_value = 1
  end if
  ! Restrict the topology of the polytope_tree to the current n-face
  c = 0
  do i = 0, node_array%polytope_tree%number_dimensions-1
     if ( IBITS( this%n_face, node_array%polytope_tree%number_dimensions+i, 1 ) == 1 ) then 
        if ( IBITS( this%node_array%polytope_tree%topology, i, 1 ) == 1 ) this%topology = IBSET( this%topology, c )
        c = c+1
     end if
  end do
  call this%init()
end subroutine node_iterator_create

!=================================================================================================
subroutine node_iterator_init ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: c, i
  this%displacement = 0
  this%coordinate = 0
  this%overflow = .true.
  !if ( n-face_dimension(this%n-face, this%node_array%polytope_tree%number_dimensions) > 0 .or. this%own_boundary ) 
  this%overflow = .false.
  c = 0
  do i = 0, this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS( this%n_face, this%node_array%polytope_tree%number_dimensions+i, 1 ) == 0 ) then  ! if is fixed component in n-face
        if ( IBITS( this%n_face, i, 1 ) == 0 ) then   ! if coordinate of anchor node == 0
           this%coordinate(i) = 0                     ! fixed coordinate = min value
        else
           this%coordinate(i) = this%node_array%order(i+1) ! fixed coordinate = max value   
        end if
     else 
        this%displacement(c) = this%min_value
        c = c+1
     end if
  end do
  if ( n_face_dimension(this%n_face, this%node_array%polytope_tree%number_dimensions) > 0 ) then
     this%displacement(0) = this%displacement(0)-1
     call this%next()
  end if
end subroutine node_iterator_init

!=================================================================================================
subroutine node_iterator_print( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  write(*,*) '***NODE_ITERATOR ***'
  write(*,*) 'n-face: '
  write(*,'(B32)') this%n_face
  write(*,*) 'displacement: ',this%displacement
end subroutine node_iterator_print

!=================================================================================================
subroutine node_iterator_next ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: comp, end_comp, i
  if ( this%has_finished() ) return 
  comp = 0 
  end_comp = n_face_dimension(this%n_face, this%node_array%polytope_tree%number_dimensions)-1
  this%overflow = .true.
  do while( comp <= end_comp)
     if ( this%overflow ) then 
        this%displacement(comp) = this%displacement(comp)+1
        if ( this%in_bound(comp, end_comp) ) then
           this%overflow = .false.
           do i = comp-1,0,-1
              if ( .not. this%in_bound( i, end_comp ) ) then
                 this%overflow = .true.
              end if
           end do
           exit
        else 
           this%displacement(comp) = this%min_value
        end if
     end if
     comp = comp+1
  end do
end subroutine node_iterator_next

!=================================================================================================
function node_iterator_in_bound( this, comp, end_comp )
  implicit none
  class(node_iterator_t), intent(in) :: this
  integer(ip)           , intent(in) :: comp, end_comp
  logical :: node_iterator_in_bound
  integer(ip) :: bound, i
  node_iterator_in_bound = .true.
  bound = this%max_value(comp)
  do i = comp+1,end_comp
     if ( IBITS( this%topology, i, 1 ) == 0 ) then
        bound = bound - this%displacement(i)
     end if
  end do
  if ( this%displacement(comp) > bound ) node_iterator_in_bound = .false.
end function node_iterator_in_bound

!=================================================================================================
function node_iterator_has_finished ( this )
  implicit none
  class(node_iterator_t), intent(in) :: this
  logical :: node_iterator_has_finished
  node_iterator_has_finished = this%overflow
end function node_iterator_has_finished

!=================================================================================================
function node_iterator_current_ijk ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current_ijk
  integer(ip) :: coord(0:this%node_array%polytope_tree%number_dimensions-1), c, comp, j
  assert ( .not. this%has_finished() )
  ! First put free coordinates as such (fixed ones introduced when initializing)
  c = 0
  do comp =0,this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS ( this%n_face, comp+this%node_array%polytope_tree%number_dimensions, 1 ) == 1 ) then
        this%coordinate(comp) = this%displacement(c)
        c = c+1
     end if
  end do
  ! Next, translate fixed coordinates if needed
  do comp =0,this%node_array%polytope_tree%number_dimensions-1
     if ( IBITS ( this%n_face, comp+this%node_array%polytope_tree%number_dimensions, 1 ) == 0 .and. IBITS( this%n_face, comp, 1 ) == 1 ) then
        this%coordinate(comp) = this%node_array%order(comp+1)
        do j = comp+1,this%node_array%polytope_tree%number_dimensions-1
           if ( IBITS ( this%node_array%polytope_tree%topology, j, 1 ) == 0 .and. IBITS ( this%n_face, j+this%node_array%polytope_tree%number_dimensions, 1 ) == 1 ) then
              this%coordinate(comp) = this%coordinate(comp) - this%coordinate(j)
           end if
        end do
     end if
  end do
  node_iterator_current_ijk = ijk_to_index( this%coordinate, this%node_array%order, this%node_array%polytope_tree%number_dimensions )
end function node_iterator_current_ijk

!=================================================================================================
function node_iterator_current ( this )
  implicit none
  class(node_iterator_t), intent(inout) :: this
  integer(ip) :: node_iterator_current
  node_iterator_current = this%node_array%ijk_to_index( this%current_ijk() )
end function node_iterator_current

!=================================================================================================
! SUPPORT FUNCTIONS  
!=================================================================================================

!=================================================================================================
function ijk_to_index( n, order, dim )
  integer(ip), intent(in) :: n(0:dim-1), order(1:SPACE_DIM), dim
  integer(ip) :: ijk_to_index, i, aux_order(0:SPACE_DIM-1)
  ijk_to_index = 0
  aux_order(0) = 1
  do i = 1,dim-1
     aux_order(i) = aux_order(i-1)*(order(i)+1)
  end do
  do i = 0,dim-1
     ijk_to_index = ijk_to_index + n(i)*aux_order(i)!((order+1)**i)
  end do
end function ijk_to_index

!=================================================================================================
function n_face_dimension( n_face, dim )
  integer(ip), intent(in) :: n_face, dim
  integer(ip) :: n_face_dimension, i
  n_face_dimension = 0
  do i = 0,dim-1
     n_face_dimension = n_face_dimension + IBITS( n_face, dim+i, 1 )
  end do
end function n_face_dimension

function facet_orientation( n_face, dim )
  integer(ip), intent(in) :: n_face, dim
  integer(ip) :: facet_orientation
  integer(ip) :: n_face_type, base_n_face_type, axis_swap
  assert( n_face_dimension( n_face, dim) == dim-1 ) ! Only has sense for facets
  facet_orientation = 0
  
  n_face_type = IBITS( n_face, dim, dim )
  base_n_face_type = IBSET(0, dim-1)-1
  axis_swap = IEOR(n_face_type,base_n_face_type)
  if ( IBITS( axis_swap, 0, 1) == 1 .and. dim > 2 ) then
     facet_orientation = 1
  else
     facet_orientation = 0
  end if
  if ( axis_swap == 0 ) facet_orientation = 1
  n_face_type = IBITS( n_face, 0, dim )
  if ( n_face_type /= 0 ) then
     facet_orientation = 1-facet_orientation
  end if
  if ( dim == 2 ) then
     facet_orientation = 1-facet_orientation
  end if
end function facet_orientation
