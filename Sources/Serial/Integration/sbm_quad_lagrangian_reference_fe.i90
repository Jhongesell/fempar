! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine quad_lagrangian_reference_fe_create ( this, number_dimensions, order, field_type, continuity, enable_face_integration )
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip)                          , intent(in)    :: number_dimensions
  integer(ip)                          , intent(in)    :: order
  character(*)                         , intent(in)    :: field_type
  logical                              , intent(in)    :: continuity
  logical                   , optional , intent(in)    :: enable_face_integration

  call this%free()
  call this%set_common_data ( number_dimensions, order, field_type, continuity, enable_face_integration )
  call this%set_fe_type ( fe_type_lagrangian )
  call this%fill( )
  call this%set_nodal_quadrature ()
end subroutine quad_lagrangian_reference_fe_create

subroutine quad_lagrangian_reference_fe_create_quadrature ( this, quadrature, max_order )
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this  
  type(quadrature_t)                   , intent(inout) :: quadrature
  integer(ip)                , optional, intent(in)    :: max_order
  
  integer(ip) :: ngaus, order
  order = this%order
  if ( present(max_order) ) then
     order = max_order
  else
     order = this%order
  end if
  ngaus = this%get_number_quadrature_points_of_dimension(order,this%number_dimensions)
  call quadrature%create( this%number_dimensions, ngaus )
  call this%fill_quadrature( quadrature )
end subroutine quad_lagrangian_reference_fe_create_quadrature

subroutine quad_lagrangian_reference_fe_create_face_quadrature ( this, quadrature, max_order )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                   , intent(inout) :: quadrature
  integer(ip)                , optional, intent(in)    :: max_order

  integer(ip) :: ngaus, order, face_dimensions
  order = this%order
  if ( present(max_order) ) then
     order = max_order
  else
     order = this%order
  end if
  face_dimensions = this%number_dimensions - 1
  ngaus = this%get_number_quadrature_points_of_dimension(order,face_dimensions)
  call quadrature%create( face_dimensions, ngaus )
  call this%fill_quadrature( quadrature )
end subroutine quad_lagrangian_reference_fe_create_face_quadrature

function quad_lagrangian_reference_fe_get_nquad_of_dimension( this, order, dimension )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: order
  integer(ip)                          , intent(in)    :: dimension
  integer(ip) :: quad_lagrangian_reference_fe_get_nquad_of_dimension
  quad_lagrangian_reference_fe_get_nquad_of_dimension = (order + 1)**dimension
end function

subroutine quad_lagrangian_reference_fe_create_interpolation ( this, quadrature, interpolation, compute_hessian )
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(quadrature_t)                   , intent(in)    :: quadrature
  type(interpolation_t)                , intent(inout) :: interpolation
  logical                    , optional, intent(in)    :: compute_hessian

  integer(ip) :: ntens, i

  ntens = 0
  do i = 1, this%number_dimensions
     ntens = ntens + i
  end do

  call interpolation%create( this%number_dimensions, this%number_nodes_scalar, &
                             quadrature%number_quadrature_points, ntens, compute_hessian )
  
  call this%fill_interpolation( interpolation, this%order, quadrature%coordinates )
  
end subroutine quad_lagrangian_reference_fe_create_interpolation

!==================================================================================================
! This routine creates the interpolation corresponding to the evaluation of the shape functions on
! integration points given by local_quadrature either on the face 'local_face_id' of the element or
! in all the faces of the element.
subroutine quad_lagrangian_reference_fe_create_face_interpolation( this,local_face_id,            &
     &                               local_quadrature,face_interpolation)
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  integer(ip)                          , intent(in)    :: local_face_id
  type(quadrature_t)                   , intent(in)    :: local_quadrature
  type(interpolation_t)                , intent(inout) :: face_interpolation

  ! Allocate the arrays of the interpolation
  call face_interpolation%create(this%number_dimensions,this%number_nodes_scalar,              &
       &                         local_quadrature%number_quadrature_points, 0 )

  ! Fill the values of the shape functions
  call this%fill_face_interpolation (face_interpolation,local_quadrature,local_face_id)
end subroutine quad_lagrangian_reference_fe_create_face_interpolation

!==================================================================================================
! This subroutine constructs a interpolation of order 1 of an element of one dimension less.
! This is used to construct the geometrical interpolation of the face
subroutine quad_lagrangian_reference_fe_create_face_local_interpolation ( this, quadrature,       &
     &                                                                    interpolation)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)               , intent(in)     :: quadrature
  type(interpolation_t)            , intent(inout) :: interpolation

  integer(ip) :: number_nodes_face_scalar, number_dimensions_face

  ! I am assuming the geometric aproximation of the face can be linear
  ! this might need to be modified in the future
  number_dimensions_face   = this%number_dimensions - 1
  number_nodes_face_scalar = this%get_number_nodes_scalar_dim_order( number_dimensions_face, &
                                                                  &  this%order )

  ! Allocate the arrays of the interpolation
  call interpolation%create( number_dimensions_face, number_nodes_face_scalar, &
                             quadrature%number_quadrature_points, 0)

  ! Fill the values with the common routine for filling an interpolation
  call this%fill_interpolation( interpolation, this%order, quadrature%coordinates )

end subroutine quad_lagrangian_reference_fe_create_face_local_interpolation

!=================================================================================================
! This is a TEMPORARY SUBROUTINE for the draft of the lagrangian_reference_fe_t interm. class
function quad_lagrangian_reference_fe_get_number_nodes_scalar_dim_order(this,k,p)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: k, p
  integer(ip) :: quad_lagrangian_reference_fe_get_number_nodes_scalar_dim_order 
  quad_lagrangian_reference_fe_get_number_nodes_scalar_dim_order = int((p+1)**k)
end function quad_lagrangian_reference_fe_get_number_nodes_scalar_dim_order

subroutine quad_lagrangian_reference_fe_update_interpolation( this, fe_map,                       &
     &                                                        interpolation_reference_cell,       &
     &                                                        interpolation_real_cell )
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(fe_map_t)                       , intent(in)    :: fe_map
  type(interpolation_t)                , intent(in)    :: interpolation_reference_cell
  type(interpolation_t)                , intent(inout) :: interpolation_real_cell

  call this%apply_femap_to_interpolation( fe_map, interpolation_reference_cell,interpolation_real_cell )
end subroutine quad_lagrangian_reference_fe_update_interpolation

subroutine quad_lagrangian_reference_fe_update_interpolation_face( this,  local_face_id,          &
     &                                                             fe_map_face_restriction,       &
     &                                                             interpolation_face_restriction )
  implicit none 
  class(quad_lagrangian_reference_fe_t) , intent(in)    :: this 
  integer(ip)                           , intent(in)    :: local_face_id
  type(fe_map_face_restriction_t)       , intent(in)    :: fe_map_face_restriction
  type(interpolation_face_restriction_t), intent(inout) :: interpolation_face_restriction

  interpolation_face_restriction%active_face_id = local_face_id

  call this%update_interpolation(fe_map_face_restriction%fe_map(local_face_id),                   &
       &                         interpolation_face_restriction%interpolation(local_face_id),     &
       &                         interpolation_face_restriction%interpolation_o_map)

end subroutine quad_lagrangian_reference_fe_update_interpolation_face

function quad_lagrangian_reference_fe_get_component_node( this, node )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                          , intent(in) :: node
  integer(ip) :: quad_lagrangian_reference_fe_get_component_node
  quad_lagrangian_reference_fe_get_component_node = this%node_component_array(node,2)
end function quad_lagrangian_reference_fe_get_component_node

function quad_lagrangian_reference_fe_get_scalar_from_vector_node( this, node )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in) :: this 
  integer(ip)                          , intent(in) :: node
  integer(ip) :: quad_lagrangian_reference_fe_get_scalar_from_vector_node
  quad_lagrangian_reference_fe_get_scalar_from_vector_node = this%node_component_array(node,1)
end function quad_lagrangian_reference_fe_get_scalar_from_vector_node

function quad_lagrangian_reference_fe_get_number_nodes_scalar(this) result(number_nodes_scalar)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                                          :: number_nodes_scalar

  number_nodes_scalar = this%number_nodes_scalar
end function quad_lagrangian_reference_fe_get_number_nodes_scalar

subroutine quad_lagrangian_reference_fe_get_value_scalar( this, actual_cell_interpolation, ishape, qpoint, scalar_field )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  integer(ip)                          , intent(in)    :: ishape
  integer(ip)                          , intent(in)    :: qpoint
  real(rp)                             , intent(out)   :: scalar_field
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  scalar_field = actual_cell_interpolation%shape_functions(ishape,qpoint)
end subroutine quad_lagrangian_reference_fe_get_value_scalar
     
subroutine quad_lagrangian_reference_fe_get_value_vector( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(quad_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t)                , intent(in)    :: actual_cell_interpolation 
  integer(ip)                             , intent(in)    :: ishape
  integer(ip)                             , intent(in)    :: qpoint
  type(vector_field_t)                    , intent(out)   :: vector_field
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  call vector_field%init(0.0_rp)
  call vector_field%set(this%node_component_array(ishape,2), &
                        actual_cell_interpolation%shape_functions(this%node_component_array(ishape,1),qpoint))
end subroutine quad_lagrangian_reference_fe_get_value_vector
     
subroutine quad_lagrangian_reference_fe_get_gradient_scalar( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(quad_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t)                   , intent(in)    :: actual_cell_interpolation 
  integer(ip)                             , intent(in)    :: ishape
  integer(ip)                             , intent(in)    :: qpoint
  type(vector_field_t)                    , intent(out)   :: vector_field
  integer(ip) :: idime
  assert( this%field_type == field_type_scalar )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  call vector_field%init(0.0_rp)
  do idime=1,this%number_dimensions
    call vector_field%set(idime,actual_cell_interpolation%shape_derivatives(idime,ishape,qpoint))
  end do
end subroutine quad_lagrangian_reference_fe_get_gradient_scalar
     
subroutine quad_lagrangian_reference_fe_get_gradient_vector( this, actual_cell_interpolation, ishape, qpoint, tensor_field )
  implicit none
  class(quad_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t), intent(in)    :: actual_cell_interpolation 
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  type(tensor_field_t)    , intent(out)   :: tensor_field
  integer(ip) :: idime
  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  call tensor_field%init(0.0_rp)
  do idime=1,this%number_dimensions
    call tensor_field%set(idime,this%node_component_array(ishape,2), &
                          actual_cell_interpolation%shape_derivatives(idime,this%node_component_array(ishape,1),qpoint))
  end do
end subroutine quad_lagrangian_reference_fe_get_gradient_vector

subroutine quad_lagrangian_reference_fe_get_divergence_vector( this, actual_cell_interpolation, ishape, qpoint, scalar_field )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  integer(ip)                          , intent(in)    :: ishape
  integer(ip)                          , intent(in)    :: qpoint
  real(rp)                             , intent(out)   :: scalar_field

  ! Locals 
  integer(ip) :: idime

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )

  scalar_field = actual_cell_interpolation%shape_derivatives(this%node_component_array(ishape,2),this%node_component_array(ishape,1),qpoint)  
end subroutine quad_lagrangian_reference_fe_get_divergence_vector 

subroutine quad_lagrangian_reference_fe_get_curl_vector( this, actual_cell_interpolation, ishape, qpoint, vector_field )
  implicit none
  class(quad_lagrangian_reference_fe_t)   , intent(in)    :: this 
  type(interpolation_t), intent(in)    :: actual_cell_interpolation 
  integer(ip)             , intent(in)    :: ishape
  integer(ip)             , intent(in)    :: qpoint
  type(vector_field_t)    , intent(out)   :: vector_field
  
  ! Locals 
  integer(ip) :: idime, jdime, kdime
  ! Epsilon_{ijk} = Levi_Civita(i,j,k)
  real(rp), parameter :: Levi_Civita(3,3,3) = reshape( (/0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, -1.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, &
													                                            0.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, -1.0_rp, 0.0_rp, 0.0_rp, &
													                                            0.0_rp, -1.0_rp, 0.0_rp, 1.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp, 0.0_rp/), (/3, 3, 3/) )

  assert( this%field_type == field_type_vector )
  assert( ishape >= 1 .and. ishape <= this%number_nodes )
  assert( qpoint >= 1 )
  

 call vector_field%init(0.0_rp)

 
 
 kdime = this%node_component_array(ishape,2)
 do idime=1,3 
   do jdime = 1,this%number_dimensions
      if ( ( idime .ne. jdime ) .and. (idime .ne. kdime) .and. (jdime .ne. kdime) ) then 
         call vector_field%set( idime, &
              Levi_Civita(idime,jdime,kdime)* &
              actual_cell_interpolation%shape_derivatives(jdime,this%node_component_array(ishape,1),qpoint) )
      end if
   end do
 end do

end subroutine quad_lagrangian_reference_fe_get_curl_vector

subroutine quad_lagrangian_reference_fe_interpolate_nodal_values( this, &
                                                               &  nodal_interpolation, &
                                                               &  nodal_values_origin, &
                                                               &  nodal_values_destination)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)                , intent(in)    :: nodal_interpolation
  real(rp)                             , intent(in)    :: nodal_values_origin(:)
  real(rp)                             , intent(inout) :: nodal_values_destination(:)
  integer(ip) :: qpoint, ishape, icomp, c_dest

  c_dest = 0
  do icomp = 1, this%number_field_components
     do qpoint = 1, nodal_interpolation%number_quadrature_points
        c_dest = c_dest + 1
        nodal_values_destination(c_dest) = 0.0_rp
        do ishape = 1, nodal_interpolation%number_shape_functions
           nodal_values_destination(c_dest) = nodal_values_destination(c_dest) + & 
                & nodal_interpolation%shape_functions(ishape,qpoint) *           &
                & nodal_values_origin(this%node_array_component(ishape,icomp))
        end do
     end do
  end do

end subroutine quad_lagrangian_reference_fe_interpolate_nodal_values

!**************************************************************************************************
! Evaluate methods for fe_function_scalar/vector/tensor_t
!**************************************************************************************************

subroutine quad_lagrangian_reference_fe_evaluate_fe_function_scalar( this, &
                                                                  &  actual_cell_interpolation, &
                                                                  &  nodal_values, &
                                                                  &  quadrature_points_values)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  real(rp)                             , intent(in)    :: nodal_values(:)
  real(rp)                             , intent(inout) :: quadrature_points_values(:)
  integer(ip)                                          :: qpoint, ishape

  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     quadrature_points_values(qpoint) = 0.0_rp
     do ishape = 1, actual_cell_interpolation%number_shape_functions
        quadrature_points_values(qpoint) = quadrature_points_values(qpoint) + & 
        & actual_cell_interpolation%shape_functions(ishape,qpoint)*nodal_values(ishape)
     end do
  end do

end subroutine quad_lagrangian_reference_fe_evaluate_fe_function_scalar

subroutine quad_lagrangian_reference_fe_evaluate_fe_function_vector( this, &
                                                                  &  actual_cell_interpolation, &
                                                                  &  nodal_values, &
                                                                  &  quadrature_points_values)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  real(rp)                             , intent(in)    :: nodal_values(:)
  type(vector_field_t)                 , intent(inout) :: quadrature_points_values(:)
  integer(ip)                                          :: qpoint, inode, icomp, inode_scalar
  
  do qpoint = 1, actual_cell_interpolation%number_quadrature_points
     call quadrature_points_values(qpoint)%init(0.0_rp)
     do inode = 1, this%number_nodes
        inode_scalar = this%node_component_array(inode,1)
        icomp        = this%node_component_array(inode,2)
        call quadrature_points_values(qpoint)%add(icomp, &
         & actual_cell_interpolation%shape_functions(inode_scalar,qpoint)*nodal_values(inode))
     end do
  end do

end subroutine quad_lagrangian_reference_fe_evaluate_fe_function_vector

subroutine quad_lagrangian_reference_fe_evaluate_fe_function_tensor( this, &
                                                                  &  actual_cell_interpolation, &
                                                                  &  nodal_values, &
                                                                  &  quadrature_points_values)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
  type(interpolation_t)             , intent(in)    :: actual_cell_interpolation 
  real(rp)                             , intent(in)    :: nodal_values(:)
  type(tensor_field_t)                 , intent(inout) :: quadrature_points_values(:)

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine quad_lagrangian_reference_fe_evaluate_fe_function_tensor

!==================================================================================================
function quad_lagrangian_reference_fe_check_compatibility_of_vefs                   &
     &                      (target_reference_fe,source_reference_fe, source_vef_id,target_vef_id)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)  :: target_reference_fe
  class(reference_fe_t)                , intent(in)  :: source_reference_fe
  integer(ip)                          , intent(in)  :: source_vef_id ! Local vef ID
  integer(ip)                          , intent(in)  :: target_vef_id ! Local vef ID
  logical :: quad_lagrangian_reference_fe_check_compatibility_of_vefs 

  select type(source_reference_fe)
     class is(quad_lagrangian_reference_fe_t)

        ! Get number nodes per dimension
        assert (target_reference_fe%order == source_reference_fe%order)
        assert (target_reference_fe%number_dimensions == source_reference_fe%number_dimensions)
        assert (target_reference_fe%get_vef_dimension(target_vef_id) == source_reference_fe%get_vef_dimension(source_vef_id))
        assert (target_reference_fe%get_vef_dimension(target_vef_id) < 3)
        assert (target_reference_fe%number_field_components == source_reference_fe%number_field_components)
        assert (target_reference_fe%get_number_own_nodes_vef(target_vef_id) == source_reference_fe%get_number_own_nodes_vef(source_vef_id))
        quad_lagrangian_reference_fe_check_compatibility_of_vefs = .true.
     class default
        quad_lagrangian_reference_fe_check_compatibility_of_vefs = .false.
  end select
 
end function quad_lagrangian_reference_fe_check_compatibility_of_vefs

!==================================================================================================
subroutine quad_lagrangian_reference_fe_fill_interior_points_permutation(this,&
                                                                         dimension,&
                                                                         number_interior_points,&
                                                                         interior_points_permutation )
  implicit none
  class(quad_lagrangian_reference_fe_t) , intent(inout) :: this 
  integer(ip)                           , intent(in)    :: dimension
  integer(ip)                           , intent(in)    :: number_interior_points
  integer(ip)      , allocatable        , intent(inout) :: interior_points_permutation(:,:)

  integer(ip) :: number_interior_points_x_dim
  integer(ip) :: number_of_possible_permutations
  
  if ( this%number_dimensions == 2 ) then
    assert ( dimension == 1 )
  else if ( this%number_dimensions == 3) then
    assert ( dimension == 1 .or. dimension == 2)
  else
    check(.false.)
  end if
  
  if ( allocated(interior_points_permutation) ) call memfree(interior_points_permutation,__FILE__,__LINE__)
  
  number_interior_points_x_dim = this%get_number_interior_points_x_dim(number_interior_points, &
                                                                       dimension )
  
  number_of_possible_permutations = this%number_rotations_per_dimension(dimension) * &
                                    this%number_orientations_per_dimension(dimension)
  
  call memalloc (number_interior_points,          &
                 number_of_possible_permutations, &
                 interior_points_permutation,     &
                 __FILE__,__LINE__)
  
  call this%fill_permutation_array(dimension,                    &
                                   number_interior_points_x_dim, &
                                   interior_points_permutation)
  
end subroutine quad_lagrangian_reference_fe_fill_interior_points_permutation

!=================================================================================================
function quad_lagrangian_reference_fe_get_number_interior_points_x_dim(this,n,dim)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: n, dim
  integer(ip) :: quad_lagrangian_reference_fe_get_number_interior_points_x_dim 
  quad_lagrangian_reference_fe_get_number_interior_points_x_dim = & 
     & int(real(n,rp)**(1.0_rp/real(dim,rp)),ip)
end function quad_lagrangian_reference_fe_get_number_interior_points_x_dim

!==================================================================================================
subroutine quad_lagrangian_reference_fe_fill (this)
  implicit none
  ! Parameters
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this
  integer(ip) :: c, i, j, dimension, number_interior_nodes, number_interior_nodes_scalar
  integer(ip) :: column, inode, idime, inode_scalar, num_columns
  
  call this%fill_scalar( )
  
  call memalloc (this%number_dimensions-1,this%number_rotations_per_dimension,__FILE__,__LINE__)
  call memalloc (this%number_dimensions-1,this%number_orientations_per_dimension,__FILE__,__LINE__)
  
  if ( this%continuity ) allocate(this%own_node_permutations(this%number_dimensions-1))
  
  do dimension = 1, this%number_dimensions-1

     if (dimension == 1) then
        this%number_rotations_per_dimension(dimension) = this%get_number_vertices_per_edge()
     elseif (dimension == 2) then 
        this%number_rotations_per_dimension(dimension) = this%get_number_vertices_per_face()
     end if
     this%number_orientations_per_dimension(dimension) = dimension
     
     if ( this%continuity ) then
       ! Compute the number of interior nodes X (edge or face)
       j = this%get_first_vef_id_of_dimension(dimension)
       number_interior_nodes = this%get_number_own_nodes_vef(j)
          
       call this%fill_interior_points_permutation(dimension,             &
                                                  number_interior_nodes, &
                                                  this%own_node_permutations(dimension)%a)
     end if
  end do
  
  if ( this%number_field_components /= 1 ) then
     call this%fill_field_components( )
     if ( this%continuity ) then
       do dimension = 1, this%number_dimensions-1
          ! Compute the number of interior nodes x edge or face
          j = this%get_first_vef_id_of_dimension(dimension)
          number_interior_nodes        = this%get_number_own_nodes_vef(j)
          number_interior_nodes_scalar = number_interior_nodes/this%number_field_components
          num_columns = this%number_rotations_per_dimension(dimension) * &
                        this%number_orientations_per_dimension(dimension) 
          call memrealloc ( number_interior_nodes, &
                            num_columns, &
                            this%own_node_permutations(dimension)%a, &
                            __FILE__, &
                            __LINE__  )
          do column = 1, num_columns
             ! Fill the rest of components
             inode = number_interior_nodes_scalar
             do idime = 2, this%number_field_components
                ! This is taking advantage of the face that we know how the DoF are ordered
                ! in case this ordering change, this will not work anymore.
                do inode_scalar = 1, number_interior_nodes_scalar
                   inode = inode + 1
                   this%own_node_permutations(dimension)%a(inode,column) = number_interior_nodes_scalar * &
                        (idime-1) +  this%own_node_permutations(dimension)%a(inode_scalar,column)
                end do
             end do
          end do
       end do
     end if
  else
     this%number_nodes_scalar = this%number_nodes
  end if
  
  call memalloc( this%number_nodes, 2, this%node_component_array, __FILE__, __LINE__ )
  call memalloc( this%number_nodes_scalar, this%number_field_components, this%node_array_component, __FILE__, __LINE__ )

  c = 1
  do i = 1, this%number_field_components
     do j = 1, this%number_nodes_scalar
        this%node_component_array(c,1) = j
        this%node_component_array(c,2) = i   
        this%node_array_component(j,i) = c
        c = c+1
     end do
  end do
  
end subroutine quad_lagrangian_reference_fe_fill
!==================================================================================================

!==================================================================================================
subroutine quad_lagrangian_reference_fe_fill_permutation_array(this,               &
                                                               dimension,          &
                                                               number_nodes_x_dim, &
                                                               permutation_array)
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this 
  integer(ip)                          , intent(in)    :: dimension
  integer(ip)                          , intent(in)    :: number_nodes_x_dim
  integer(ip)                          , intent(inout) :: permutation_array(:,:)
 
  integer(ip) :: irotation, iorientation, column

  column = 1
  do iorientation = 1, this%number_orientations_per_dimension(dimension)
     do irotation = 1, this%number_rotations_per_dimension(dimension)
        if (dimension == 1) then
           call permute_or_1d(permutation_array(:,column), &
                              number_nodes_x_dim, &
                              irotation)
        elseif (dimension == 2) then
           call this%permute_or_2d(permutation_array(:, column), &
                                   number_nodes_x_dim, &
                                   iorientation, &
                                   irotation)
        else 
           check (.false.)
        end if
        column = column + 1
     end do
  end do
  
end subroutine quad_lagrangian_reference_fe_fill_permutation_array
!==================================================================================================

subroutine quad_lagrangian_reference_fe_free ( this )
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this 
  
  ! quad_lagrangian_reference_fe_t variables
  if(allocated(this%node_component_array)) & 
       call memfree(this%node_component_array,__FILE__,__LINE__)
  if(allocated(this%node_array_component)) & 
       call memfree(this%node_array_component,__FILE__,__LINE__)
  this%number_nodes_scalar = 0
  call reference_fe_free ( this )
end subroutine quad_lagrangian_reference_fe_free

function quad_lagrangian_reference_fe_get_characteristic_length ( this )
  implicit none 
  class(quad_lagrangian_reference_fe_t), intent(in) :: this 
  real(rp)  :: quad_lagrangian_reference_fe_get_characteristic_length 

  quad_lagrangian_reference_fe_get_characteristic_length =  2.0_rp
end function quad_lagrangian_reference_fe_get_characteristic_length

subroutine quad_lagrangian_reference_fe_fill_field_components (this)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this
  call this%extend_list_components( this%nodes_vef)
  call this%extend_list_components( this%interior_nodes_vef)
  call this%extend_list_components( this%own_nodes_vef )
  call this%extend_list_components( this%face_integration_coupling_nodes_face )
  this%number_nodes_scalar = this%number_nodes
  this%number_nodes = this%number_nodes_scalar * this%number_field_components
end subroutine quad_lagrangian_reference_fe_fill_field_components

subroutine quad_lagrangian_reference_fe_set_nodal_quadrature (this)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this
  
  ! Create nodal quadrature
  call this%nodal_quadrature%create(this%number_dimensions,this%number_nodes_scalar)

  ! Fill nodal quadrature
  call this%fill_nodal_quadrature ( this%nodal_quadrature, this%order )
end subroutine quad_lagrangian_reference_fe_set_nodal_quadrature

subroutine quad_lagrangian_reference_fe_set_scalar_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values, unknown_component)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: code
  real(rp)                             , intent(in)    :: values(:)
  integer(ip)                          , intent(in)    :: nodal_codes(:)
  real(rp)                             , intent(inout) :: nodal_values(:)
  integer(ip), optional                , intent(in)    :: unknown_component
  integer(ip) :: i, icomp

  assert(size(nodal_values) == this%number_nodes)
  assert(size(values) == this%number_nodes_scalar)

  icomp = 1
  if(present(unknown_component)) icomp = unknown_component

  do i = 1, this%number_nodes_scalar
     if(nodal_codes(this%node_array_component(i,icomp)) == code) then
        nodal_values(this%node_array_component(i,icomp)) = values(i)
     end if
  end do
     
end subroutine quad_lagrangian_reference_fe_set_scalar_field_to_nodal_values

subroutine quad_lagrangian_reference_fe_set_vector_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: code
  type(vector_field_t)                 , intent(in)    :: values(:)
  integer(ip)                          , intent(in)    :: nodal_codes(:)
  real(rp)                             , intent(inout) :: nodal_values(:)
  integer(ip) :: i, icomp

  assert(size(nodal_values) == this%number_nodes)
  assert(size(values) == this%number_nodes_scalar)

  do icomp = 1, this%number_field_components
     do i = 1, this%number_nodes_scalar
        if(nodal_codes(this%node_array_component(i,icomp)) == code) then
           nodal_values(this%node_array_component(i,icomp)) = values(i)%get(icomp)
        end if
     end do
  end do
     
end subroutine quad_lagrangian_reference_fe_set_vector_field_to_nodal_values

subroutine quad_lagrangian_reference_fe_set_tensor_field_to_nodal_values (this, code, values, &
     &     nodal_codes, nodal_values)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: code
  type(tensor_field_t)                 , intent(in)    :: values(:)
  integer(ip)                          , intent(in)    :: nodal_codes(:)
  real(rp)                             , intent(inout) :: nodal_values(:)
  integer(ip) :: i, icomp, jcomp

  write(*,*) ' ERROR in: ',__FILE__,__LINE__
  write(*,*) ' Subroutine not implemented for tensor field unknowns '
  check( .false. )

end subroutine quad_lagrangian_reference_fe_set_tensor_field_to_nodal_values


subroutine quad_lagrangian_reference_fe_extend_list_components(this, list_1d)
  implicit none
  ! Parameters
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this
  type(list_t), intent(inout) :: list_1d
  type(list_t) :: list

  integer(ip) :: ngaus, order, i, j, k, c, node_1d, aux_1, aux_2

  call list%create(n=this%number_vefs+1)

  list%p(1) = 1
  do i = 2,this%number_vefs+2
     list%p(i) = list%p(i-1) + ( list_1d%p(i)-list_1d%p(i-1) ) * this%number_field_components
  end do

  call list%allocate_list_from_pointer()

  aux_1 = this%number_nodes
  do i = 1,this%number_vefs+1
     c = list%p(i)
     do k = 1,this%number_field_components
        aux_2 = aux_1*(k-1)
        do j = list_1d%p(i),list_1d%p(i+1)-1
           node_1d = list_1d%l(j)
           list%l(c) = node_1d + aux_2
           c = c + 1
        end do
     end do
  end do

  call memrealloc ( size(list%p), list_1d%p, __FILE__, __LINE__ )
  call memrealloc ( size(list%l), list_1d%l, __FILE__, __LINE__ )
  list_1d = list
  call list%free() 

end subroutine quad_lagrangian_reference_fe_extend_list_components

subroutine quad_lagrangian_reference_fe_fill_scalar (this)
  implicit none
  ! Parameters
  class(quad_lagrangian_reference_fe_t), intent(inout) :: this

  ! Local variables
  integer(ip)               :: nd,p
  integer(ip)               :: i,j,k,l,m
  integer(ip)               :: aux1,aux2,aux3,aux4
  integer(ip)               :: od,cd,kk,c
  integer(ip)               :: c2,c3,c4,c5,c6,co
  integer(ip)               :: no  ! #vefs in nd-quad
  integer(ip)               :: nn  ! #nodes in the nd-quad of order p
  integer(ip)               :: nt  ! sum of the #nodes (all, not only interior) of the vefs
  integer(ip)               :: nt2 ! sum of the #vefs (all, not only interior) of the vefs
  integer(ip)               :: nc  ! #corners x #{vefs delimited by each corner}
  integer(ip)               :: nod ! #corners in the quad. nod = 2^(nd)
  integer(ip), allocatable  :: auxt1(:,:),auxt2(:,:),auxt3(:,:),auxt4(:,:),auxt5(:,:), auxt6(:,:)
  integer(ip), allocatable  :: obdla(:,:),node2ob(:),ob2node(:)
  integer(ip), allocatable  :: aux(:),idm(:),fdm(:),ijk(:),ijk_g(:)
  type(list_iterator_t)     :: iterator

  !  ! Initilize values
  nd = this%number_dimensions
  p  = this%order

  call memalloc( nd, aux, __FILE__, __LINE__ )
  call memalloc( nd, idm, __FILE__, __LINE__ )
  call memalloc( nd, fdm, __FILE__, __LINE__ )
  call memalloc( nd, ijk, __FILE__, __LINE__ )
  call memalloc( nd, ijk_g, __FILE__, __LINE__ )

  no = 0
  nn = 0
  nt = 0
  nc = 0
  nt2 = 0
  nod = 0

  ! Initialize nvef_dim, nodes_vef
  !call memalloc(nd+2,nvef_dim,__FILE__,__LINE__)
  !call memalloc(nd+1,nodes_vef,__FILE__,__LINE__)
  this%number_vefs_dimension = 0
  this%number_vefs_dimension(1) = 1

  do k = 0,nd
     i = int(2**(nd-k)*bnm(nd,k)) ! #vefs of dimension k
     no = no + i                  ! compute #vefs
     nn = nn + int(i*((p-1)**k))  ! #nodes inside vefs of dimension k
     nt = nt + int(i*((p+1)**k))  ! nodes in the clousure of the vef
     nt2 = nt2 + int(i*((3)**k))! vefs in the clousure of the vef
     nc = nc + int(i*2**k)        ! corners delimiting vefs of dimension k
     nod = nod + bnm(nd,k)        ! #nodes/{displacement} (2^n = sum(bnm(n,k)), k=0,..,n)
     ! Pointer to obj id by dim. Local obj of dim k are nvef_dim(k):nvef_dim(k+1)
     this%number_vefs_dimension(k+2) = this%number_vefs_dimension(k+1) + i 
     ! #nodes in vefs of dimension k 
  end do

  ! Set constant values of reference_element
  this%number_vefs = no-1
  this%number_nodes = int((p+1)**nd) 

  ! Allocate arrays
  call this%orientation%create(no)
  call this%interior_nodes_vef%create(n=no)
  call this%nodes_vef%create(n=no)
  call this%vefs_vef%create(n=no)
  call this%vertices_vef%create(n=no)

  call memalloc(nod,nd+1,obdla,__FILE__,__LINE__)
  call memalloc(no, node2ob,__FILE__,__LINE__)        ! Auxiliar array
  call memalloc(no, ob2node,__FILE__,__LINE__)        ! Auxiliar array

  !Initialize pointers
  this%interior_nodes_vef%p(1) = 1
  this%nodes_vef%p(1) = 1
  this%vefs_vef%p(1) = 1
  this%vertices_vef%p(1) = 1
    
  !Loop over dimensions
  do k = 0,nd
     aux1 = int(((p-1)**k)) ! interior nodes for an vef of dim k
     aux3 = int(((p+1)**k)) ! Total nodes for an vef of dim k
     if ( p == -1 ) then    ! Void fe
        aux1 = 0
        aux3 = 0
     end if
     aux2 = int(2**k)       ! Corners for an vef of dim k
     aux4 = int((3**k)) ! Corners for an vef of dim k (idem p=2)

     ! Loop over vefs of dimension k
     do i = this%number_vefs_dimension(k+1),this%number_vefs_dimension(k+2)-1 
        this%interior_nodes_vef%p(i+1) = this%interior_nodes_vef%p(i) + aux1 ! assign pointers
        this%nodes_vef%p(i+1) = this%nodes_vef%p(i) + aux3 ! assign pointers
        this%vertices_vef%p(i+1) = this%vertices_vef%p(i) + aux2 ! assign pointers
        this%vefs_vef%p(i+1) = this%vefs_vef%p(i) + aux4 ! assign pointers 
     end do
  end do
  
  call this%interior_nodes_vef%allocate_list_from_pointer()
  call this%nodes_vef%allocate_list_from_pointer()
  call this%vertices_vef%allocate_list_from_pointer()
  call this%vefs_vef%allocate_list_from_pointer()

  ! Initialize auxiliar values
  k = 0
  i = 0
  idm = 0
  j = 2

  ! Construction of obdla matrix
  ! For each vef, up to a displacement, we have an identifier id={1..nod}
  ! obdla(id,1) = dimension of the vef
  ! obdla(id,2:obdla(id,1)+1) = gives the directions that define the vef
  obdla = -1
  obdla(1,1) = 0
  do od = 0,nd
     if (od > 0) then
        call r_dim(j,idm(1:od),k,i,nd,od,obdla,nod)
     end if
  end do

  ! Initialize auxiliar values
  idm = 0
  fdm = 0
  cd  = 0
  c2  = 0 ! ndxob%p counter
  c3  = 0 ! crxob%p counter
  c4  = 0 ! ntxob%p counter
  c5  = 0 ! obxob%p counter
  c6  = 0 ! ob2node   counter
  co  = 0 ! counter of vefs

  ! Loop over vefs dimensions
  do od = 0,nd
     ! Create ijk tables (od)
     ! Compute auxt1 the local numbering of the corners of an vef of dimension nd-od
     ! It allows to know how many translations for each paralel set of vefs
     if (od < nd) then
        call memalloc(nd-od,2**(nd-od),auxt1,__FILE__,__LINE__)
        auxt1 = 0
        kk    = 0
        aux1  = 1
        ijk   = 0
        call Q_r_ijk(kk,aux1,ijk,nd-od,auxt1,0,1)
     end if
     ! Compute auxt2 the local numbering of the corners in an vef of dim od
     if (od >0) then
        call memalloc(od,2**(od),auxt2,__FILE__,__LINE__)
        auxt2 = 0
        kk    = 0
        aux1  = 1
        ijk   = 0
        call Q_r_ijk(kk,aux1,ijk,od,auxt2,0,1)

        if (p > 1) then
           ! Compute auxt3 the local numbering of the interior nodes in an vef of dim od
           call memalloc(od,(p-1)**(od),auxt3,__FILE__,__LINE__)
           auxt3 = 0
           kk    = 0
           aux1  = 1
           ijk   = 0
           call Q_r_ijk(kk,aux1,ijk,od,auxt3,1,p-1)
        end if

        ! Compute auxt4 the local numbering of all nodes in an vef of dim od
        call memalloc(od,(p+1)**(od),auxt4,__FILE__,__LINE__)
        auxt4 = 0
        kk    = 0
        aux1  = 1
        ijk   = 0
        call Q_r_ijk(kk,aux1,ijk,od,auxt4,0,p)

        ! Compute auxt5 the local numbering of all nodes in an vef of dim od
        call memalloc(od,(2+1)**(od),auxt5,__FILE__,__LINE__)
        auxt5 = 0
        kk    = 0
        aux1  = 1
        ijk   = 0
        call Q_r_ijk(kk,aux1,ijk,od,auxt5,0,2)

        ! Compute auxt6 the local numbering of the interior vefs in an vef of dim od
        call memalloc(od,(2-1)**(od),auxt6,__FILE__,__LINE__)
        auxt6 = 0
        kk    = 0
        aux1  = 1
        ijk   = 0
        call Q_r_ijk(kk,aux1,ijk,od,auxt6,1,2-1)

     end if


     ! For each dimension, there are bnm(nd,od) vefs up to translation
     do j = 1,bnm(nd,od)
        idm = -1 ! positions in which the nodes variates
        fdm = -1 ! Positions corresponding to the translation between paralel vefs
        aux = -1 ! auxiliar vector to construct fdm from idm
        cd = cd+1

        ! Take the position that will vary inside the vef
        do k = 1,od
           idm(k) = obdla(cd,k+1) 
        end do

        !Mark the positions already taken by idm

        aux = 0
        do k=1,od
           aux(idm(k)+1) = 1
        end do

        !Construct the array of orthogonal space wrt idm. 
        !It gives the translations for each paralel vef
        c = 1
        do k=1,nd
           if (aux(k) == 0) then
              fdm(c) = k-1
              c = c+1
           end if
        end do

        ! Corner numbering
        ! Loop over the translations
        do l = 1,2**(nd-od) 

           ! Set orientation of the vef
           co = co +1
           call Q_orientation_vef(this%orientation%a(co),fdm(1:nd-od),od,nd,l)

           !ijk_g(jdm) will contain the translations from one vef to another
           !ijk_g(idm) will contain the variations inside the vef
           do k = 1,nd-od
              ijk_g(fdm(k)+1) = auxt1(k,l)
           end do

           ! Loop over the corners inside the vef
           do m = 1,2**od
              do k = 1,od
                 ijk_g(idm(k)+1) = auxt2(k,m)
              end do
              c2 = c2+1
              this%vertices_vef%l(c2) = Q_gijk(ijk_g,nd,1) !store the vef numbering of the corner 
           end do
        end do

        ! Interior node numbering
        ! Loop over the translations
        if ( p > 0 ) then ! Do nothing for void fe
        do l = 1,2**(nd-od)
           !ijk_g(jdm) will contain the translations from 1 vef to another; must be scaled by p
           !ijk_g(idm) will contain the variations inside the vef
           do k = 1,nd-od
              ijk_g(fdm(k)+1) = auxt1(k,l)*p
           end do

           ! Loop over the interior nodes of the vef
           do m = 1,(p-1)**(od)
              do k = 1,od
                 ijk_g(idm(k)+1) = auxt3(k,m)
              end do
              c3 = c3+1
              this%interior_nodes_vef%l(c3) = Q_gijk(ijk_g,nd,p) ! Store the local numbering in ndxob%l
           end do
        end do

        ! All node numbering
        !Loop over the translations
        do l = 1,2**(nd-od)
           !ijk_g(jdm) will contain the translations from 1 vef to another; must be scaled by p
           !ijk_g(idm) will contain the variations inside the vef
           do k = 1,nd-od
              ijk_g(fdm(k)+1) = auxt1(k,l)*p
           end do

           ! Loop over the interior nodes of the vef
           do m = 1,(p+1)**(od)
              do k = 1,od
                 ijk_g(idm(k)+1) = auxt4(k,m)
              end do
              c4 = c4+1
              this%nodes_vef%l(c4) = Q_gijk(ijk_g,nd,p) ! Store the local numbering in ntxob%l
           end do
        end do
        end if

        ! obxob array and auxiliar ob2node array 

        ! Interior node numbering
        ! Loop over the translations
        do l = 1,2**(nd-od)
           !ijk_g(jdm) will contain the translations from 1 vef to another; must be scaled by p
           !ijk_g(idm) will contain the variations inside the vef
           do k = 1,nd-od
              ijk_g(fdm(k)+1) = auxt1(k,l)*2
           end do

           ! Loop over the interior nodes of the vef
           do m = 1,(2-1)**(od)
              do k = 1,od
                 ijk_g(idm(k)+1) = auxt6(k,m)
              end do
              c6 = c6+1
              ob2node(c6) = Q_gijk(ijk_g,nd,2) ! Store the local numbering in ndxob%l
           end do
        end do


        do l = 1,2**(nd-od)

           ! Fixed values for the vef
           do k = 1,nd-od
              ijk_g(fdm(k)+1) = auxt1(k,l)*2
           end do

           ! Fill obxob (equivalent to ntxob for p=2)
           do m = 1,3**od
              do k = 1,od
                 ijk_g(idm(k)+1) = auxt5(k,m)
              end do
              c5 = c5 +1
              this%vefs_vef%l(c5) = Q_gijk(ijk_g,nd,2)
           end do

           ! Define ijk_g for the node in the center of the vef
           do k = 1,od
              ijk_g(idm(k)+1) = 1
           end do

           ! Find the generic node numbering
           m = Q_gijk(ijk_g,nd,2)

           ! Fill ob2node array
           !ob2node(m) = co
        end do

     end do

     !Deallocate auxiliar arrays
     if (od < nd) call memfree(auxt1,__FILE__,__LINE__)
     if (od >0) then
        call memfree(auxt2,__FILE__,__LINE__)
        if (p > 1) call memfree(auxt3,__FILE__,__LINE__)
        call memfree(auxt4,__FILE__,__LINE__)
        call memfree(auxt5,__FILE__,__LINE__)
        call memfree(auxt6,__FILE__,__LINE__)
     end if
  end do

  do i=1,no
     node2ob(ob2node(i)) = i
  end do

  ! Modify the identifiers of the nodes by the ids of the vef in obxob
  do c5 = 1, nt2
     this%vefs_vef%l(c5) = node2ob(this%vefs_vef%l(c5))
  end do
  
  ! Create face_integration_coupling_nodes_vef
  if ( this%continuity ) then
     this%own_nodes_vef = this%interior_nodes_vef
     ! Create a void face_integration_coupling_nodes_face type(list_t)
     call this%face_integration_coupling_nodes_face%create(n=no)
     call this%face_integration_coupling_nodes_face%calculate_header()
     call this%face_integration_coupling_nodes_face%allocate_list_from_pointer()
  else
     call this%own_nodes_vef%create(n=no)
     call this%own_nodes_vef%sum_to_pointer_index(this%own_nodes_vef%get_num_pointers(), this%number_nodes)
     call this%own_nodes_vef%calculate_header()
     call this%own_nodes_vef%allocate_list_from_pointer()
     
     iterator = this%own_nodes_vef%create_iterator()
     i=1
     do while(.not. iterator%is_upper_bound())
        call iterator%set_current(i)
        call iterator%next()
        i = i + 1 
    enddo
     
     if ( this%conformity ) then
       ! Create a void face_integration_coupling_nodes_face type(list_t)
       call this%face_integration_coupling_nodes_face%create(n=no)
       call this%face_integration_coupling_nodes_face%calculate_header()
       call this%face_integration_coupling_nodes_face%allocate_list_from_pointer()
     else
        this%face_integration_coupling_nodes_face = this%nodes_vef
     end if
  end if

  call memfree(obdla,__FILE__,__LINE__)
  call memfree(ob2node,__FILE__,__LINE__)
  call memfree(node2ob,__FILE__,__LINE__)


  call memfree( aux, __FILE__, __LINE__ )
  call memfree( idm, __FILE__, __LINE__ )
  call memfree( fdm, __FILE__, __LINE__ )
  call memfree( ijk, __FILE__, __LINE__ )
  call memfree( ijk_g, __FILE__, __LINE__ )

end subroutine quad_lagrangian_reference_fe_fill_scalar

!=================================================================================================
! BNM(A,B)=A!/((A-B)!B!) computes the binomial coefficient of (A,B), A>B
integer (ip) function bnm(a,b)
  implicit none
  integer(ip) :: a,b
  if (a >= b) then
     bnm = int(fc(a)/(fc(b)*fc(a-b)))
  else
     write(*,*) 'ERROR: no binomial coef for b > a'
     check(.false.)
  end if
end function bnm
!==================================================================================================
! Given the dimension nd of the quad and the positions p0,...,p1 we want to consider is going
! to take values. The routine Q_R_IJK returns the number of nodes (co) and a matrix auxt1 that 
! for the nth node of the quad it gives the ijk position that it corresponds to
!         | p0 p0   ... p0 p0   ... p1 |
! auxt1 = | p0 p0   ... p0 p0+1 ... p1 |
!         | p0 p0+1 ... p1 p0   ... p1 |
recursive subroutine Q_r_ijk(co,d,ijk,nd,auxt1,p0,p1)
  implicit none
  ! Parameters
  integer(ip), intent(in)    :: d,nd,p0,p1
  integer(ip), intent(inout) :: ijk(nd),co              !#nodes
  integer(ip), intent(inout) :: auxt1(nd,(p1+1-p0)**nd) ! ode ijk position matrix

  ! Local variables
  integer(ip)                :: dp,i,ipp

  do ipp = p0,p1
     if (d>nd) exit
     ijk(nd-d+1) = ipp 
     if (d < nd) call Q_r_ijk(co,d+1,ijk,nd,auxt1,p0,p1)
     if (d == nd) then
        co = co + 1
        do i = 1,nd
           auxt1(i,co) = ijk(i)
        end do
     end if
  end do
end subroutine Q_r_ijk


!==================================================================================================
! Q_GIJK(i,nd,p) returns the generic identifier of a node with coordinates i in an elem(nd,p)
!Given the coordinates ijk (in i) and the dimension nd and the order p of the 
!quad, it returns the local numbering of the node: Q_gijk=i+j*(p+1)+k*(p+1)^2
integer(ip) function Q_gijk(i,nd,p)
  implicit none
  integer(ip) :: nd,i(nd),p,k
  Q_gijk = 1
  do k = 1,nd
     Q_gijk = Q_gijk + i(k)*((p+1)**(k-1))
  end do
end function  Q_gijk


!==================================================================================================
subroutine Q_orientation_vef(o,fdm,od,nd,l)
  implicit none
  ! Parameters
  integer(ip), intent(out) :: o
  integer(ip), intent(in)  :: fdm(:)  ! fdm gives the orthogonal directions to the vef
  integer(ip), intent(in)  :: od,nd,l ! l=translation ordering

  if (nd == 2 .and. od == 1) then
     o = modulo(l+fdm(1),2)
  elseif (nd == 3 .and. od == 2) then
     o = modulo(l+fdm(1),2)
  elseif (nd>3) then
     write(*,*) __FILE__,__LINE__,'WARNING!! the orientation is not defined for dimension >3'
  else
     o = 0
  end if
end subroutine Q_orientation_vef

!==================================================================================================
! R_DIM construct OBDLA matrix
! For each vef, up to a displacement, we have an identifier id={1..nod}
! obdla(id,1) = dimension of the vef
! obdla(id,2:obdla(id,1)+1) = gives the directions that define the vef
recursive subroutine r_dim(co,idm,ko,i,nd,od,obdla,nod)
  implicit none
  integer(ip), intent(in)    :: ko !space position we begin to count from (ij=>i<j)
  integer(ip), intent(in)    :: i  !i=local space position we are currently modifying (i=0..od)
  integer(ip), intent(in)    :: nd,od,nod
  integer(ip), intent(inout) :: obdla(nod,nd+1)
  integer(ip), intent(inout) :: idm(od) 
  integer(ip), intent(inout) :: co      ! Pointer to the position of the vef
  integer(ip)                :: aux,ijk_c(nd),j,cd,kn,s

  !Given dimension od of the vef
  do kn = ko,nd-od+i
     idm(i+1) = kn 
     if (i+1 < od) then
        call r_dim(co,idm,kn+1,i+1,nd,od,obdla,nod)
     else
        obdla(co,1) = od
        do j = 1,od
           obdla(co,j+1) = idm(j)
        end do
        co = co + 1
     end if
  end do
end subroutine r_dim

!==================================================================================================
! FC(k)=k! computes the factorial of k 
integer(ip) function fc(i)
  implicit none
  integer(ip) :: i, k
  fc = 1
  do k=2,i
     fc = fc*k
  end do
end function fc

!-----------------------------------------------------------------------
subroutine quad_lagrangian_reference_fe_fill_quadrature ( this, quadrature ) 
  !-----------------------------------------------------------------------
  !
  !     This routine sets up the integration constants of open
  !     integration rules for brick elements:
  ! 
  !          NDIME = 1             NDIME = 2             NDIME = 3
  ! 
  !      NGAUS  EXACT POL.     NGAUS  EXACT POL.     NGAUS  EXACT POL. 
  !      -----  ----------     -----  ----------     -----  ----------
  !        1      q1           1 x 1     q1          1x1x1     q1	
  !        2      q3           2 x 2     q3          2x2x2     q3   
  !        3      q5           3 x 3     q5          3x3x3     q5
  !        4      q7           4 x 4     q7          4x4x4     q7
  !        5      q9           5 x 5     q9          5x5x5     q9
  !        6      q11          6 x 6     q11         6x6x6     q11
  !        7      q13          7 x 7     q13         7x7x7     q13
  !        8      q15          8 x 8     q15         8x8x8     q15
  !       16      q31         16 x 16    q31        16x16x16   q31
  ! 
  !-----------------------------------------------------------------------
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t), intent(inout) :: quadrature
  real(rp)                          :: posgl(20),weigl(20)
  integer(ip)                       :: nlocs,qpoin,ilocs,jlocs,klocs,ndime,ngaus

  ndime = quadrature%number_dimensions
  ngaus = quadrature%number_quadrature_points

  if(ndime==1) then
     nlocs=ngaus
  else if(ndime==2) then
     nlocs=nint(sqrt(real(ngaus,rp)))
  else
     nlocs=nint(real(ngaus,rp)**(1.0_rp/3.0_rp))
  end if

  if(nlocs==1) then
     posgl(1)=0.0_rp
     weigl(1)=2.0_rp
  else if(nlocs==2) then
     posgl(1)=-0.577350269189626_rp
     posgl(2)= 0.577350269189626_rp
     weigl(1)= 1.0_rp
     weigl(2)= 1.0_rp
  else if(nlocs==3) then
     posgl(1)=-0.774596669241483_rp
     posgl(2)= 0.0_rp
     posgl(3)= 0.774596669241483_rp
     weigl(1)= 0.555555555555556_rp
     weigl(2)= 0.888888888888889_rp
     weigl(3)= 0.555555555555556_rp
  else if(nlocs==4)  then
     posgl(1)=-0.861136311594053_rp
     posgl(2)=-0.339981043584856_rp
     posgl(3)= 0.339981043584856_rp
     posgl(4)= 0.861136311594053_rp
     weigl(1)= 0.347854845137454_rp
     weigl(2)= 0.652145154862546_rp
     weigl(3)= 0.652145154862546_rp
     weigl(4)= 0.347854845137454_rp
  else if(nlocs==5)  then
     posgl(1) = -0.906179845938664_rp
     posgl(2) = -0.538469310105683_rp
     posgl(3) =  0.0_rp
     posgl(4) =  0.538469310105683_rp
     posgl(5) =  0.906179845938664_rp
     weigl(1) =  0.236926885056189_rp
     weigl(2) =  0.478628670499366_rp
     weigl(3) =  0.568888888888889_rp
     weigl(4) =  0.478628670499366_rp
     weigl(5) =  0.236926885056189_rp
  else if(nlocs==6)  then
     posgl(1) = -0.932469514203152_rp
     posgl(2) = -0.661209386466265_rp
     posgl(3) = -0.238619186083197_rp
     posgl(4) =  0.238619186083197_rp
     posgl(5) =  0.661209386466265_rp
     posgl(6) =  0.932469514203152_rp
     weigl(1) =  0.171324492379170_rp
     weigl(2) =  0.360761573048139_rp
     weigl(3) =  0.467913934572691_rp
     weigl(4) =  0.467913934572691_rp
     weigl(5) =  0.360761573048139_rp
     weigl(6) =  0.171324492379170_rp
  else if(nlocs==7)  then
     posgl(1) = -0.949107912342759_rp
     posgl(2) = -0.741531185599394_rp
     posgl(3) = -0.405845151377397_rp
     posgl(4) =  0.0_rp
     posgl(5) =  0.405845151377397_rp
     posgl(6) =  0.741531185599394_rp
     posgl(7) =  0.949107912342759_rp
     weigl(1) =  0.129484966168870_rp
     weigl(2) =  0.279705391489277_rp
     weigl(3) =  0.381830050505119_rp
     weigl(4) =  0.417959183673469_rp
     weigl(5) =  0.381830050505119_rp
     weigl(6) =  0.279705391489277_rp
     weigl(7) =  0.129484966168870_rp
  else if(nlocs==8)  then
     posgl(1) = -0.960289856497536_rp
     posgl(2) = -0.796666477413627_rp
     posgl(3) = -0.525532409916329_rp
     posgl(4) = -0.183434642495650_rp
     posgl(5) =  0.183434642495650_rp
     posgl(6) =  0.525532409916329_rp
     posgl(7) =  0.796666477413627_rp
     posgl(8) =  0.960289856497536_rp

     weigl(1) =  0.101228536290376_rp
     weigl(2) =  0.222381034453374_rp
     weigl(3) =  0.313706645877887_rp
     weigl(4) =  0.362683783378362_rp
     weigl(5) =  0.362683783378362_rp
     weigl(6) =  0.313706645877887_rp
     weigl(7) =  0.222381034453374_rp
     weigl(8) =  0.101228536290376_rp
  else if(nlocs== 9 )  then 
     posgl( 1 ) = 0.968160239507626_rp 
     posgl( 2 ) = 0.836031107326636_rp 
     posgl( 3 ) = 0.613371432700590_rp 
     posgl( 4 ) = 0.324253423403809_rp 
     posgl( 5 ) = 0.000000000000000_rp 
     posgl( 6 ) = -0.324253423403809_rp 
     posgl( 7 ) = -0.613371432700590_rp 
     posgl( 8 ) = -0.836031107326636_rp 
     posgl( 9 ) = -0.968160239507626_rp 

     weigl( 1 ) = 0.081274388361575_rp 
     weigl( 2 ) = 0.180648160694857_rp 
     weigl( 3 ) = 0.260610696402936_rp 
     weigl( 4 ) = 0.312347077040003_rp 
     weigl( 5 ) = 0.330239355001260_rp 
     weigl( 6 ) = 0.312347077040003_rp 
     weigl( 7 ) = 0.260610696402936_rp 
     weigl( 8 ) = 0.180648160694857_rp 
     weigl( 9 ) = 0.081274388361575_rp 
  else if(nlocs== 10 )  then 
     posgl( 1 ) = 0.973906528517172_rp 
     posgl( 2 ) = 0.865063366688985_rp 
     posgl( 3 ) = 0.679409568299024_rp 
     posgl( 4 ) = 0.433395394129247_rp 
     posgl( 5 ) = 0.148874338981631_rp 
     posgl( 6 ) = -0.148874338981631_rp 
     posgl( 7 ) = -0.433395394129247_rp 
     posgl( 8 ) = -0.679409568299024_rp 
     posgl( 9 ) = -0.865063366688985_rp 
     posgl( 10 ) = -0.973906528517172_rp 

     weigl( 1 ) = 0.066671344308688_rp 
     weigl( 2 ) = 0.149451349150581_rp 
     weigl( 3 ) = 0.219086362515982_rp 
     weigl( 4 ) = 0.269266719309996_rp 
     weigl( 5 ) = 0.295524224714753_rp 
     weigl( 6 ) = 0.295524224714753_rp 
     weigl( 7 ) = 0.269266719309996_rp 
     weigl( 8 ) = 0.219086362515982_rp 
     weigl( 9 ) = 0.149451349150581_rp 
     weigl( 10 ) = 0.066671344308688_rp 
  else if(nlocs== 11 )  then 
     posgl( 1 ) = 0.978228658146057_rp 
     posgl( 2 ) = 0.887062599768095_rp 
     posgl( 3 ) = 0.730152005574049_rp 
     posgl( 4 ) = 0.519096129206812_rp 
     posgl( 5 ) = 0.269543155952345_rp 
     posgl( 6 ) = 0.000000000000000_rp 
     posgl( 7 ) = -0.269543155952345_rp 
     posgl( 8 ) = -0.519096129206812_rp 
     posgl( 9 ) = -0.730152005574049_rp 
     posgl( 10 ) = -0.887062599768095_rp 
     posgl( 11 ) = -0.978228658146057_rp 

     weigl( 1 ) = 0.055668567116174_rp 
     weigl( 2 ) = 0.125580369464904_rp 
     weigl( 3 ) = 0.186290210927734_rp 
     weigl( 4 ) = 0.233193764591990_rp 
     weigl( 5 ) = 0.262804544510247_rp 
     weigl( 6 ) = 0.272925086777901_rp 
     weigl( 7 ) = 0.262804544510247_rp 
     weigl( 8 ) = 0.233193764591990_rp 
     weigl( 9 ) = 0.186290210927734_rp 
     weigl( 10 ) = 0.125580369464904_rp 
     weigl( 11 ) = 0.055668567116174_rp 
  else if(nlocs== 12 )  then 
     posgl( 1 ) = 0.981560634246719_rp 
     posgl( 2 ) = 0.904117256370475_rp 
     posgl( 3 ) = 0.769902674194305_rp 
     posgl( 4 ) = 0.587317954286617_rp 
     posgl( 5 ) = 0.367831498998180_rp 
     posgl( 6 ) = 0.125233408511469_rp 
     posgl( 7 ) = -0.125233408511469_rp 
     posgl( 8 ) = -0.367831498998180_rp 
     posgl( 9 ) = -0.587317954286617_rp 
     posgl( 10 ) = -0.769902674194305_rp 
     posgl( 11 ) = -0.904117256370475_rp 
     posgl( 12 ) = -0.981560634246719_rp 

     weigl( 1 ) = 0.047175336386512_rp 
     weigl( 2 ) = 0.106939325995318_rp 
     weigl( 3 ) = 0.160078328543346_rp 
     weigl( 4 ) = 0.203167426723066_rp 
     weigl( 5 ) = 0.233492536538355_rp 
     weigl( 6 ) = 0.249147045813403_rp 
     weigl( 7 ) = 0.249147045813403_rp 
     weigl( 8 ) = 0.233492536538355_rp 
     weigl( 9 ) = 0.203167426723066_rp 
     weigl( 10 ) = 0.160078328543346_rp 
     weigl( 11 ) = 0.106939325995318_rp 
     weigl( 12 ) = 0.047175336386512_rp 
  else if(nlocs== 13 )  then 
     posgl( 1 ) = 0.984183054718588_rp 
     posgl( 2 ) = 0.917598399222978_rp 
     posgl( 3 ) = 0.801578090733310_rp 
     posgl( 4 ) = 0.642349339440340_rp 
     posgl( 5 ) = 0.448492751036447_rp 
     posgl( 6 ) = 0.230458315955135_rp 
     posgl( 7 ) = 0.000000000000000_rp 
     posgl( 8 ) = -0.230458315955135_rp 
     posgl( 9 ) = -0.448492751036447_rp 
     posgl( 10 ) = -0.642349339440340_rp 
     posgl( 11 ) = -0.801578090733310_rp 
     posgl( 12 ) = -0.917598399222978_rp 
     posgl( 13 ) = -0.984183054718588_rp 

     weigl( 1 ) = 0.040484004765316_rp 
     weigl( 2 ) = 0.092121499837728_rp 
     weigl( 3 ) = 0.138873510219787_rp 
     weigl( 4 ) = 0.178145980761946_rp 
     weigl( 5 ) = 0.207816047536888_rp 
     weigl( 6 ) = 0.226283180262897_rp 
     weigl( 7 ) = 0.232551553230874_rp 
     weigl( 8 ) = 0.226283180262897_rp 
     weigl( 9 ) = 0.207816047536888_rp 
     weigl( 10 ) = 0.178145980761946_rp 
     weigl( 11 ) = 0.138873510219787_rp 
     weigl( 12 ) = 0.092121499837728_rp 
     weigl( 13 ) = 0.040484004765316_rp 
  else if(nlocs== 14 )  then 
     posgl( 1 ) = 0.986283808696812_rp 
     posgl( 2 ) = 0.928434883663574_rp 
     posgl( 3 ) = 0.827201315069765_rp 
     posgl( 4 ) = 0.687292904811685_rp 
     posgl( 5 ) = 0.515248636358154_rp 
     posgl( 6 ) = 0.319112368927890_rp 
     posgl( 7 ) = 0.108054948707344_rp 
     posgl( 8 ) = -0.108054948707344_rp 
     posgl( 9 ) = -0.319112368927890_rp 
     posgl( 10 ) = -0.515248636358154_rp 
     posgl( 11 ) = -0.687292904811685_rp 
     posgl( 12 ) = -0.827201315069765_rp 
     posgl( 13 ) = -0.928434883663574_rp 
     posgl( 14 ) = -0.986283808696812_rp 

     weigl( 1 ) = 0.035119460331752_rp 
     weigl( 2 ) = 0.080158087159760_rp 
     weigl( 3 ) = 0.121518570687903_rp 
     weigl( 4 ) = 0.157203167158194_rp 
     weigl( 5 ) = 0.185538397477938_rp 
     weigl( 6 ) = 0.205198463721296_rp 
     weigl( 7 ) = 0.215263853463158_rp 
     weigl( 8 ) = 0.215263853463158_rp 
     weigl( 9 ) = 0.205198463721296_rp 
     weigl( 10 ) = 0.185538397477938_rp 
     weigl( 11 ) = 0.157203167158194_rp 
     weigl( 12 ) = 0.121518570687903_rp 
     weigl( 13 ) = 0.080158087159760_rp 
     weigl( 14 ) = 0.035119460331752_rp 
  else if(nlocs== 15 )  then 
     posgl( 1 ) = 0.987992518020485_rp 
     posgl( 2 ) = 0.937273392400706_rp 
     posgl( 3 ) = 0.848206583410427_rp 
     posgl( 4 ) = 0.724417731360170_rp 
     posgl( 5 ) = 0.570972172608539_rp 
     posgl( 6 ) = 0.394151347077563_rp 
     posgl( 7 ) = 0.201194093997435_rp 
     posgl( 8 ) = 0.000000000000000_rp 
     posgl( 9 ) = -0.201194093997435_rp 
     posgl( 10 ) = -0.394151347077563_rp 
     posgl( 11 ) = -0.570972172608539_rp 
     posgl( 12 ) = -0.724417731360170_rp 
     posgl( 13 ) = -0.848206583410427_rp 
     posgl( 14 ) = -0.937273392400706_rp 
     posgl( 15 ) = -0.987992518020485_rp 

     weigl( 1 ) = 0.030753241996117_rp 
     weigl( 2 ) = 0.070366047488108_rp 
     weigl( 3 ) = 0.107159220467172_rp 
     weigl( 4 ) = 0.139570677926154_rp 
     weigl( 5 ) = 0.166269205816994_rp 
     weigl( 6 ) = 0.186161000015562_rp 
     weigl( 7 ) = 0.198431485327112_rp 
     weigl( 8 ) = 0.202578241925561_rp 
     weigl( 9 ) = 0.198431485327112_rp 
     weigl( 10 ) = 0.186161000015562_rp 
     weigl( 11 ) = 0.166269205816994_rp 
     weigl( 12 ) = 0.139570677926154_rp 
     weigl( 13 ) = 0.107159220467172_rp 
     weigl( 14 ) = 0.070366047488108_rp 
     weigl( 15 ) = 0.030753241996117_rp 
  else if(nlocs==16)  then
     posgl( 1) =-0.98940093499165_rp
     posgl( 2) =-0.94457502307323_rp
     posgl( 3) =-0.86563120238783_rp
     posgl( 4) =-0.75540440835500_rp
     posgl( 5) =-0.61787624440264_rp
     posgl( 6) =-0.45801677765723_rp
     posgl( 7) =-0.28160355077926_rp
     posgl( 8) =-0.09501250983764_rp
     posgl( 9) = 0.09501250983764_rp
     posgl(10) = 0.28160355077926_rp
     posgl(11) = 0.45801677765723_rp
     posgl(12) = 0.61787624440264_rp
     posgl(13) = 0.75540440835500_rp
     posgl(14) = 0.86563120238783_rp
     posgl(15) = 0.94457502307323_rp
     posgl(16) = 0.98940093499165_rp

     weigl( 1) =  0.02715245941175_rp
     weigl( 2) =  0.06225352393865_rp
     weigl( 3) =  0.09515851168249_rp
     weigl( 4) =  0.12462897125553_rp
     weigl( 5) =  0.14959598881658_rp
     weigl( 6) =  0.16915651939500_rp
     weigl( 7) =  0.18260341504492_rp
     weigl( 8) =  0.18945061045507_rp
     weigl( 9) =  0.18945061045507_rp
     weigl(10) =  0.18260341504492_rp
     weigl(11) =  0.16915651939500_rp
     weigl(12) =  0.14959598881658_rp
     weigl(13) =  0.12462897125553_rp
     weigl(14) =  0.09515851168249_rp
     weigl(15) =  0.06225352393865_rp
     weigl(16) =  0.02715245941175_rp
  else if(nlocs== 17 )  then 
     posgl( 1 ) = 0.990575475314417_rp 
     posgl( 2 ) = 0.950675521768768_rp 
     posgl( 3 ) = 0.880239153726986_rp 
     posgl( 4 ) = 0.781514003896801_rp 
     posgl( 5 ) = 0.657671159216691_rp 
     posgl( 6 ) = 0.512690537086477_rp 
     posgl( 7 ) = 0.351231763453876_rp 
     posgl( 8 ) = 0.178484181495848_rp 
     posgl( 9 ) = 0.000000000000000_rp 
     posgl( 10 ) = -0.178484181495848_rp 
     posgl( 11 ) = -0.351231763453876_rp 
     posgl( 12 ) = -0.512690537086477_rp 
     posgl( 13 ) = -0.657671159216691_rp 
     posgl( 14 ) = -0.781514003896801_rp 
     posgl( 15 ) = -0.880239153726986_rp 
     posgl( 16 ) = -0.950675521768768_rp 
     posgl( 17 ) = -0.990575475314417_rp 

     weigl( 1 ) = 0.024148302868548_rp 
     weigl( 2 ) = 0.055459529373987_rp 
     weigl( 3 ) = 0.085036148317179_rp 
     weigl( 4 ) = 0.111883847193404_rp 
     weigl( 5 ) = 0.135136368468525_rp 
     weigl( 6 ) = 0.154045761076810_rp 
     weigl( 7 ) = 0.168004102156450_rp 
     weigl( 8 ) = 0.176562705366993_rp 
     weigl( 9 ) = 0.179446470356207_rp 
     weigl( 10 ) = 0.176562705366993_rp 
     weigl( 11 ) = 0.168004102156450_rp 
     weigl( 12 ) = 0.154045761076810_rp 
     weigl( 13 ) = 0.135136368468525_rp 
     weigl( 14 ) = 0.111883847193404_rp 
     weigl( 15 ) = 0.085036148317179_rp 
     weigl( 16 ) = 0.055459529373987_rp 
     weigl( 17 ) = 0.024148302868548_rp 
  else if(nlocs== 18 )  then 
     posgl( 1 ) = 0.991565168420931_rp 
     posgl( 2 ) = 0.955823949571398_rp 
     posgl( 3 ) = 0.892602466497556_rp 
     posgl( 4 ) = 0.803704958972523_rp 
     posgl( 5 ) = 0.691687043060353_rp 
     posgl( 6 ) = 0.559770831073948_rp 
     posgl( 7 ) = 0.411751161462843_rp 
     posgl( 8 ) = 0.251886225691506_rp 
     posgl( 9 ) = 0.084775013041735_rp 
     posgl( 10 ) = -0.084775013041735_rp 
     posgl( 11 ) = -0.251886225691506_rp 
     posgl( 12 ) = -0.411751161462843_rp 
     posgl( 13 ) = -0.559770831073948_rp 
     posgl( 14 ) = -0.691687043060353_rp 
     posgl( 15 ) = -0.803704958972523_rp 
     posgl( 16 ) = -0.892602466497556_rp 
     posgl( 17 ) = -0.955823949571398_rp 
     posgl( 18 ) = -0.991565168420931_rp 

     weigl( 1 ) = 0.021616013526483_rp 
     weigl( 2 ) = 0.049714548894969_rp 
     weigl( 3 ) = 0.076425730254889_rp 
     weigl( 4 ) = 0.100942044106287_rp 
     weigl( 5 ) = 0.122555206711478_rp 
     weigl( 6 ) = 0.140642914670651_rp 
     weigl( 7 ) = 0.154684675126265_rp 
     weigl( 8 ) = 0.164276483745833_rp 
     weigl( 9 ) = 0.169142382963144_rp 
     weigl( 10 ) = 0.169142382963144_rp 
     weigl( 11 ) = 0.164276483745833_rp 
     weigl( 12 ) = 0.154684675126265_rp 
     weigl( 13 ) = 0.140642914670651_rp 
     weigl( 14 ) = 0.122555206711478_rp 
     weigl( 15 ) = 0.100942044106287_rp 
     weigl( 16 ) = 0.076425730254889_rp 
     weigl( 17 ) = 0.049714548894969_rp 
     weigl( 18 ) = 0.021616013526483_rp 
  else if(nlocs== 19 )  then 
     posgl( 1 ) = 0.992406843843584_rp 
     posgl( 2 ) = 0.960208152134830_rp 
     posgl( 3 ) = 0.903155903614818_rp 
     posgl( 4 ) = 0.822714656537143_rp 
     posgl( 5 ) = 0.720966177335229_rp 
     posgl( 6 ) = 0.600545304661681_rp 
     posgl( 7 ) = 0.464570741375961_rp 
     posgl( 8 ) = 0.316564099963630_rp 
     posgl( 9 ) = 0.160358645640225_rp 
     posgl( 10 ) = 0.000000000000000_rp 
     posgl( 11 ) = -0.160358645640225_rp 
     posgl( 12 ) = -0.316564099963630_rp 
     posgl( 13 ) = -0.464570741375961_rp 
     posgl( 14 ) = -0.600545304661681_rp 
     posgl( 15 ) = -0.720966177335229_rp 
     posgl( 16 ) = -0.822714656537143_rp 
     posgl( 17 ) = -0.903155903614818_rp 
     posgl( 18 ) = -0.960208152134830_rp 
     posgl( 19 ) = -0.992406843843584_rp 

     weigl( 1 ) = 0.019461788229726_rp 
     weigl( 2 ) = 0.044814226765699_rp 
     weigl( 3 ) = 0.069044542737641_rp 
     weigl( 4 ) = 0.091490021622450_rp 
     weigl( 5 ) = 0.111566645547334_rp 
     weigl( 6 ) = 0.128753962539336_rp 
     weigl( 7 ) = 0.142606702173607_rp 
     weigl( 8 ) = 0.152766042065860_rp 
     weigl( 9 ) = 0.158968843393954_rp 
     weigl( 10 ) = 0.161054449848784_rp 
     weigl( 11 ) = 0.158968843393954_rp 
     weigl( 12 ) = 0.152766042065860_rp 
     weigl( 13 ) = 0.142606702173607_rp 
     weigl( 14 ) = 0.128753962539336_rp 
     weigl( 15 ) = 0.111566645547334_rp 
     weigl( 16 ) = 0.091490021622450_rp 
     weigl( 17 ) = 0.069044542737641_rp 
     weigl( 18 ) = 0.044814226765699_rp 
     weigl( 19 ) = 0.019461788229726_rp 
  else if(nlocs== 20 )  then 
     posgl( 1 ) = 0.993128599185095_rp 
     posgl( 2 ) = 0.963971927277914_rp 
     posgl( 3 ) = 0.912234428251326_rp 
     posgl( 4 ) = 0.839116971822219_rp 
     posgl( 5 ) = 0.746331906460151_rp 
     posgl( 6 ) = 0.636053680726515_rp 
     posgl( 7 ) = 0.510867001950827_rp 
     posgl( 8 ) = 0.373706088715420_rp 
     posgl( 9 ) = 0.227785851141645_rp 
     posgl( 10 ) = 0.076526521133497_rp 
     posgl( 11 ) = -0.076526521133497_rp 
     posgl( 12 ) = -0.227785851141645_rp 
     posgl( 13 ) = -0.373706088715420_rp 
     posgl( 14 ) = -0.510867001950827_rp 
     posgl( 15 ) = -0.636053680726515_rp 
     posgl( 16 ) = -0.746331906460151_rp 
     posgl( 17 ) = -0.839116971822219_rp 
     posgl( 18 ) = -0.912234428251326_rp 
     posgl( 19 ) = -0.963971927277914_rp 
     posgl( 20 ) = -0.993128599185095_rp 

     weigl( 1 ) = 0.017614007139152_rp 
     weigl( 2 ) = 0.040601429800387_rp 
     weigl( 3 ) = 0.062672048334109_rp 
     weigl( 4 ) = 0.083276741576705_rp 
     weigl( 5 ) = 0.101930119817240_rp 
     weigl( 6 ) = 0.118194531961518_rp 
     weigl( 7 ) = 0.131688638449177_rp 
     weigl( 8 ) = 0.142096109318382_rp 
     weigl( 9 ) = 0.149172986472604_rp 
     weigl( 10 ) = 0.152753387130726_rp 
     weigl( 11 ) = 0.152753387130726_rp 
     weigl( 12 ) = 0.149172986472604_rp 
     weigl( 13 ) = 0.142096109318382_rp 
     weigl( 14 ) = 0.131688638449177_rp 
     weigl( 15 ) = 0.118194531961518_rp 
     weigl( 16 ) = 0.101930119817240_rp 
     weigl( 17 ) = 0.083276741576705_rp 
     weigl( 18 ) = 0.062672048334109_rp 
     weigl( 19 ) = 0.040601429800387_rp 
     weigl( 20 ) = 0.017614007139152_rp 
  else
     write(*,*) __FILE__,__LINE__,'ERROR:: Quadrature not defined',nlocs
     stop
  end if

  if(ndime==1) then
     qpoin=0
     do ilocs=1,nlocs
        qpoin=qpoin+1
        quadrature%weight(  qpoin)=weigl(ilocs)
        quadrature%coordinates(1,qpoin)=posgl(ilocs)
     end do
  else if(ndime==2) then
     qpoin=0
     do jlocs=1,nlocs
        do ilocs=1,nlocs
           qpoin=qpoin+1
           quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)
           quadrature%coordinates(1,qpoin)=posgl(ilocs)
           quadrature%coordinates(2,qpoin)=posgl(jlocs)
        end do
     end do
  else if(ndime==3) then
     qpoin=0
     do klocs=1,nlocs
        do jlocs=1,nlocs
           do ilocs=1,nlocs
              qpoin=qpoin+1
              quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)*weigl(klocs)
              quadrature%coordinates(1,qpoin)=posgl(ilocs)
              quadrature%coordinates(2,qpoin)=posgl(jlocs)
              quadrature%coordinates(3,qpoin)=posgl(klocs)
           end do
        end do
     end do
  end if

end subroutine quad_lagrangian_reference_fe_fill_quadrature

!-----------------------------------------------------------------------
subroutine quad_lagrangian_reference_fe_fill_nodal_quadrature ( this, quadrature, order ) 
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  type(quadrature_t)                   , intent(inout) :: quadrature
  integer(ip)                          , intent(in)    :: order
  real(rp)    :: posgl(20),weigl(20)
  integer(ip) :: nlocs,qpoin,ilocs,jlocs,klocs,ndime,nquad

  ndime = quadrature%number_dimensions
  nquad = quadrature%number_quadrature_points

  if(ndime==1) then
     nlocs=nquad
  else if(ndime==2) then
     nlocs=nint(sqrt(real(nquad,rp)))
  else
     nlocs=nint(real(nquad,rp)**(1.0_rp/3.0_rp))
  end if

  posgl(1) = -1.0_rp
  do ilocs=1,nlocs-1
     posgl(ilocs+1) = -1.0_rp + ilocs*2.0_rp/(nlocs-1)
  end do
  weigl = 1.0_rp

  if(ndime==1) then
     qpoin=0
     do ilocs=1,nlocs
        qpoin=qpoin+1
        quadrature%weight(  qpoin)=weigl(ilocs)
        quadrature%coordinates(1,qpoin)=posgl(ilocs)
     end do
  else if(ndime==2) then
     qpoin=0
     do jlocs=1,nlocs
        do ilocs=1,nlocs
           qpoin=qpoin+1
           quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)
           quadrature%coordinates(1,qpoin)=posgl(ilocs)
           quadrature%coordinates(2,qpoin)=posgl(jlocs)
        end do
     end do
  else if(ndime==3) then
     qpoin=0
     do klocs=1,nlocs
        do jlocs=1,nlocs
           do ilocs=1,nlocs
              qpoin=qpoin+1
              quadrature%weight(  qpoin)=weigl(ilocs)*weigl(jlocs)*weigl(klocs)
              quadrature%coordinates(1,qpoin)=posgl(ilocs)
              quadrature%coordinates(2,qpoin)=posgl(jlocs)
              quadrature%coordinates(3,qpoin)=posgl(klocs)
           end do
        end do
     end do
  end if

end subroutine quad_lagrangian_reference_fe_fill_nodal_quadrature

subroutine quad_lagrangian_reference_fe_fill_interpolation ( this, interpolation, order, coord_ip )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this   
  type(interpolation_t)                , intent(inout) :: interpolation
  integer(ip)                          , intent(in)    :: order
  real(rp)                             , intent(in)    :: coord_ip(:,:)

  logical                  :: khes
  integer(ip)              :: nlocs
  real(rp)   , allocatable :: coord(:),shpe1(:,:),shpd1(:,:),shph1(:,:)

  khes = .false.
  if ( allocated( interpolation%hessian ) ) then 
     khes = .true.
  end if
  
  nlocs = int(real(interpolation%number_quadrature_points)**(1.0_rp/real(interpolation%number_dimensions)))
  
  ! Allocate auxiliary variables
  call memalloc(order+1,coord,__FILE__,__LINE__)
  call memalloc(order+1,nlocs,shpe1,__FILE__,__LINE__)
  call memalloc(order+1,nlocs,shpd1,__FILE__,__LINE__)
  call memalloc(order+1,nlocs,shph1,__FILE__,__LINE__)
  
  ! Set the coordenades of the nodal points
  call Q_coord_1d(coord,order+1)
  ! Compute the 1d shape function on the gauss points
  call shape1(coord_ip(1,:),order,nlocs,coord,shpe1,shpd1,shph1,khes)

  ! Compute the nd shape functions as the tensor product of 1d shape functions
  if ( allocated( interpolation%hessian ) )  then 
     call shapen(interpolation%shape_functions,interpolation%shape_derivatives, &
               & shpe1,shpd1,shph1,interpolation%number_dimensions,order,nlocs, &
               & interpolation%number_entries_symmetric_tensor,khes,interpolation%hessian)
  else
     call shapen(interpolation%shape_functions,interpolation%shape_derivatives, &
               & shpe1,shpd1,shph1,interpolation%number_dimensions,order,nlocs, & 
               & interpolation%number_entries_symmetric_tensor,khes)
  end if
  
  ! Deallocate auxiliary variables
  call memfree(coord,__FILE__,__LINE__)
  call memfree(shpe1,__FILE__,__LINE__)
  call memfree(shpd1,__FILE__,__LINE__)
  call memfree(shph1,__FILE__,__LINE__)
  
end subroutine quad_lagrangian_reference_fe_fill_interpolation

!==================================================================================================
subroutine quad_lagrangian_reference_fe_reference_coordinates(coordinates, num_dimensions,        &
     &                                                        order, number_nodes)
  implicit none
  ! Parameters
  integer(ip), intent(in)    :: num_dimensions,order,number_nodes
  real(rp),    intent(inout) :: coordinates(num_dimensions,number_nodes)
  ! Local variables
  integer(ip) :: ijk(num_dimensions),i,d
  real(rp)    :: c1d(order+1)

  call Q_coord_1d(c1d,order+1)

  do i=1,number_nodes

     call Q_ijkg(ijk,i,num_dimensions,order)
     do d=1,num_dimensions
        coordinates(d,i) = c1d(ijk(d)+1)
     end do
  end do
end subroutine quad_lagrangian_reference_fe_reference_coordinates

!==================================================================================================
subroutine Q_coord_1d (x,n)
  implicit none
  ! Parameters
  integer(ip), intent(in)  :: n
  real(rp)   , intent(out) :: x(n)

  ! Local variables
  integer(ip)              :: i

  do i = 0,n-1
     x(i+1) = 2*real(i)/(real(n)-1)-1
  end do
end subroutine Q_coord_1d

! ===================================================================================================
! Compute the shape function and its derivative
subroutine shape1(xg,p,ng,xn,shpe1,shpd1,shph1,khes)
  implicit none
  integer(ip), intent(in)  :: p,ng
  logical, intent(in)      :: khes
  real(rp),    intent(in)  :: xn(p+1),xg(ng)
  real(rp),    intent(out) :: shpe1(p+1,ng),shpd1(p+1,ng),shph1(p+1,ng)
  integer(ip)              :: i,j,k,m,ig
  real(rp)                 :: aux, aux2, aux3, auxv(ng),auxv2(ng),auxv3(ng)

  shpe1 = 1.0_rp
  shpd1 = 0.0_rp
  shph1 = 0.0_rp
  do i = 1,p+1
     do j = 1,p+1
        if (j /= i) then
           aux = 1/(xn(i)-xn(j)) 
           auxv = 1/(xn(i)-xn(j))
           if (khes ) auxv3 = 0
           do k = 1,p+1
              if (k /= j .and. k /= i) then
                 aux2 = 1/(xn(i)-xn(k))
                 if (khes ) auxv2 = 1/(xn(i)-xn(k))
                 do ig = 1,ng
                    auxv(ig) = auxv(ig)*(xg(ig)-xn(k))*aux2
                 end do
                 if (khes ) then
                    do m = 1, p+1
                       if (m/=k .and. m/= j .and. m /= i) then
                          aux3 = 1/(xn(i)-xn(m))
                          do ig = 1,ng
                             auxv2(ig) = auxv2(ig)*(xg(ig)-xn(m))*aux3
                          end do
                       end if
                    end do
                 end if
                 auxv3 = auxv3+auxv2
              end if
           end do
           do ig = 1,ng
              shpe1(i,ig) = shpe1(i,ig)*(xg(ig)-xn(j))*aux
              shpd1(i,ig) = shpd1(i,ig) + auxv(ig)
              shph1(i,ig) = shph1(i,ig) + auxv3(ig)*aux
           end do
        end if
     end do
  end do
end subroutine shape1


!==================================================================================================
subroutine shapen (shape,deriv,s1,sd1,sdd1,nd,p,ng,nt,khes,hessi)
  implicit none
  ! Parameters
  integer(ip)       , intent(in)  :: nd,p,ng,nt
  logical, intent(in)      :: khes
  real(rp)          , intent(in)  :: s1(p+1,ng),sd1(p+1,ng),sdd1(p+1,ng)
  !real(rp)          , intent(out) :: shape((p+1)**nd,ng**nd)
  !real(rp)          , intent(out) :: deriv(nd,(p+1)**nd,ng**nd)
  !real(rp), optional, intent(out) :: hessi(nt,(p+1)**nd,ng**nd)
  real(rp)          , intent(inout) :: shape(:,:)
  real(rp)          , intent(inout) :: deriv(:,:,:)
  real(rp), optional, intent(inout) :: hessi(:,:,:)


  ! Local variables
  integer(ip)              :: i,ig,d,d2,d3,it
  integer(ip)              :: ijk(nd),ijkg(nd),permu(nt)

  ! The presumed order of the varibles in the hessian is not the one obtained by generation
  if (nd == 2) then
     permu = (/ 1, 3, 2 /)
  elseif (nd == 3) then
     permu = (/ 1, 4, 5, 2, 6, 3/)
  end if

  ! Initialize values
  shape = 0.0_rp
  deriv = 0.0_rp
  if ( khes ) hessi = 0.0_rp

  ! Initialize nodal coordinates vector
  ijk = 0; ijk(1) = -1
  do i = 1,(p+1)**nd

     ! Set coordinates of node i 
     call Q_ijkg(ijk,i,nd,p)

     ! Initialize Gauss point coordinates vector
     ijkg = 0; ijkg(1) = -1
     do ig = 1,ng**nd

        ! Set coordinates of Gauss point ig 
        call Q_ijkg(ijkg,ig,nd,ng-1)

        ! Initialize shape
        shape(i,ig) = 1.0_rp
        it = 0
        do d = 1,nd
           ! Shape is the tensor product 1d shape: s_ijk(x,y,z) = s_i(x)*s_j(y)*s_k(z)
           shape(i,ig) = shape(i,ig)*s1(ijk(d)+1,ijkg(d)+1)

           ! Initialize deriv and hessi
           deriv(d,i,ig) = 1.0_rp
           it = it+1
           if (khes ) hessi(permu(it),i,ig)= 1.0_rp

           ! Deriv: d(s_ijk)/dx (x,y,z) = s'_i(x)*s_j(y)*s_k(z)
           ! Hessi: d2(s_ijk)/dx2 (x,y,z) = s''_i(x)*s_j(y)*s_k(z)
           do d2 = 1,nd
              if (d2 /= d) then
                 deriv( d,i,ig) = deriv( d,i,ig)*s1(ijk(d2)+1,ijkg(d2)+1)
                 if ( khes ) hessi(permu(it),i,ig)=hessi(permu(it),i,ig)*s1(ijk(d2)+1,ijkg(d2)+1)
              else
                 deriv( d,i,ig) = deriv( d,i,ig)* sd1(ijk(d)+1,ijkg(d)+1)  
                 if (khes ) hessi(permu(it),i,ig)=hessi(permu(it),i,ig)*sdd1(ijk(d)+1,ijkg(d)+1)             
              end if
           end do

           if ( khes ) then
              ! Hessi: d2(s_ijk)/dxdy (x,y,z) = s'_i(x)*s'_j(y)*s_k(z)
              do d2 = d+1,nd
                 it = it+1
                 hessi(permu(it),i,ig) = 1.0_rp
                 do d3 = 1,nd
                    if (d3 /= d .and. d3 /= d2) then
                       hessi(permu(it),i,ig) = hessi(permu(it),i,ig)*s1(ijk(d3)+1,ijkg(d3)+1)
                    else
                       hessi(permu(it),i,ig) = hessi(permu(it),i,ig)*sd1(ijk(d3)+1,ijkg(d3)+1)             
                    end if
                 end do
              end do
           end if

        end do
     end do
  end do
end subroutine shapen

!==================================================================================================
! Q_IJKG(i,g,nd,p) returns coordinates of the g-th node in an elem(nd,p)
subroutine Q_ijkg(i,g,nd,p)
  implicit none
  integer(ip), intent(in)  :: nd,g,p
  integer(ip), intent(out) :: i(nd)

  integer(ip)              :: k,g2

  g2 = g-1
  do k=1,nd
     i(k) = int(mod(g2,(p+1)**k)/(p+1)**(k-1))
     g2 = g2 - i(k)*(p+1)**(k-1)
  end do
end subroutine Q_ijkg

!=================================================================================================
subroutine permute_or_1d( o2n,p,r )
  implicit none
  integer(ip), intent(in)    :: p,r
  integer(ip), intent(inout) :: o2n(p)

  ! Local variables
  integer(ip) :: i

  ! Generic loop+rotation identifier  
  if (r==1) then
     o2n = (/(i,i=1,p)/)
  elseif (r==2) then
     o2n = (/(p-i,i=0,p-1)/)
  else
     write(*,*) __FILE__,__LINE__,'permute_or_1d:: ERROR! Delay cannot be >1 for edges'
  end if
end subroutine permute_or_1d

!==================================================================================================
subroutine quad_lagrangian_reference_fe_permute_or_2d( this,o2n,p,o,r )
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  integer(ip)                          , intent(in)    :: p,o,r
  integer(ip)                          , intent(inout) :: o2n(p**2)

  ! Local variables
  integer(ip) :: o_r,i,j,ij_q(4) ! ij_q = (i,j,p-i,p-j)
  integer(ip) :: ij_n(2),go
  integer(ip) :: ij_perm_quad(2,8) = reshape((/ 1, 2, 2, 3, 4, 1, 3, 4, 2, 1, 3, 2, 1, 4, 4, 3/), &
       &                                     (/2,8/))

  ! Generic loop+rotation identifier
  o_r = 4*(o-1)+r
  do j = 0,p-1
     ij_q(2) = j
     ij_q(4) = p-1-j
     do i = 0,p-1
        ij_q(1) = i
        ij_q(3) = p-1-i
        ! Get the global numbering of node (i,j)
        go = Q_gijk(ij_q(1:2),2,p-1)
        ! i,j coordinates for the o_r permutation
        ij_n(1:2) = ij_q(ij_perm_quad(1:2,o_r)) 
        ! Get the global numbering of node ij_n
        o2n(go) = Q_gijk(ij_n,2,p-1)
     end do
  end do
  
end subroutine quad_lagrangian_reference_fe_permute_or_2d

!==================================================================================================
subroutine quad_lagrangian_reference_fe_fill_face_interpolation (this,face_interpolation,local_quadrature,local_face_id)
  implicit none
  class(quad_lagrangian_reference_fe_t), intent(in)    :: this
  type(interpolation_t)                , intent(inout) :: face_interpolation
  type(quadrature_t)                   , intent(in)    :: local_quadrature
  integer(ip)                          , intent(in)    :: local_face_id

  type(interpolation_t)                :: interp_1D_corners, local_interpolation
  type(quadrature_t)                   :: nodal_coordinates_1D
  integer(ip)                          :: order_of_approximation
  type(quad_lagrangian_reference_fe_t) :: face_reference_fe, reference_fe_1D

  write(*,*) __FILE__,__LINE__,'Creation of 2 reference_FE!!'

  ! Create a 1D interpolation evaluated on the corners
  call nodal_coordinates_1D%create(1,2)
  nodal_coordinates_1D%coordinates(1,1) = -1.0_rp
  nodal_coordinates_1D%coordinates(1,2) =  1.0_rp
  call reference_fe_1D%create(1,this%order,this%field_type,this%continuity)
  call reference_fe_1D%create_interpolation(nodal_coordinates_1D,interp_1D_corners)

  ! Create a ndime-1 interpolation on the local Gauss points in each face
  call face_reference_fe%create(this%number_dimensions-1,this%order,this%field_type,this%continuity)
  call face_reference_fe%create_interpolation(local_quadrature,local_interpolation)

  order_of_approximation = this%order
  ! Create the interpolation
  call face_shapen(face_interpolation%shape_functions,face_interpolation%shape_derivatives,    &
       &           local_interpolation%shape_functions,local_interpolation%shape_derivatives,  &
       &           interp_1D_corners%shape_functions,interp_1D_corners%shape_derivatives,      &
       &           face_interpolation%number_dimensions,order_of_approximation,                &
       &           face_interpolation%number_quadrature_points,local_face_id)

  call face_reference_fe%free()
  call reference_fe_1D%free
  call local_interpolation%free()
  call interp_1D_corners%free()
  call nodal_coordinates_1D%free()

end subroutine quad_lagrangian_reference_fe_fill_face_interpolation

!==================================================================================================
subroutine face_shapen(shapf,derif,shp,drv,sh1,dr1,nd,p,ng,local_face_id)
  implicit none
  ! Parameters
  integer(ip)           , intent(in)  :: nd,p,ng, local_face_id
  real(rp)              , intent(in)  :: shp((p+1)**(nd-1),ng),drv(nd-1,(p+1)**(nd-1),ng) ! Face interpolation
  real(rp)              , intent(in)  :: sh1(p+1,2),dr1(1,p+1,2)
  real(rp)              , intent(out) :: shapf(   (p+1)**nd,ng)
  real(rp)              , intent(out) :: derif(nd,(p+1)**nd,ng)

  ! Local variable
  integer(ip) :: ifc, id, j, ijk(nd), ij(nd-1), d, inode, jnode, ig, d2
  integer(ip) :: ig0, ign

  ! Initialize
  shapf = 1.0_rp
  derif = 1.0_rp

  do inode = 1, (p+1)**nd ! node identifier

     ! Set coordinates of node i
     call Q_ijkg(ijk,inode,nd,p)

     ifc = 0
     do id = nd,1,-1   ! face normal direction

        ! Set node coordinate in the face
        j = 1
        do d = 1,nd
           if (d .ne. id) then
              ij(j) = ijk(d)
              j = j+1
           end if
        end do
        jnode = Q_gijk(ij,nd-1,p)

        do j = 1,2        ! 1 ---> -, 2 ---> +
           ifc = ifc + 1  ! face identifier
         
           if (ifc == local_face_id) then
              ig0 = 0
              ign = ng
           else
              cycle
           end if
           
           do ig = 1, ign  ! Loop over face Gauss Points    
              shapf(inode,ig0 + ig) = sh1(ijk(id)+1,j)*shp(jnode,ig)

              d2 = 0
              do d =1, nd
                 if (d == id) then
                    derif(d,inode,ig0 + ig) = dr1(1,ijk(id)+1,j)*shp(jnode,ig)
                 else
                    d2 = d2+1
                    derif(d,inode,ig0 + ig) = sh1(ijk(id)+1,j)*drv(d2,jnode,ig)
                 end if
              end do
           end do
        end do
     end do
  end do

end subroutine face_shapen

!==============================================================================
  subroutine quad_lagrangian_reference_fe_apply_femap_to_interpolation(this,map,ref,phy)
    implicit none
    class(quad_lagrangian_reference_fe_t), intent(in)    :: this 
    type(fe_map_t)                       , intent(in)    :: map
    type(interpolation_t)                , intent(in)    :: ref
    type(interpolation_t)                , intent(inout) :: phy
    real(rp), allocatable :: wmat1(:,:,:)
    real(rp), allocatable :: wmat2(:,:,:), wvec1(:)
    integer(ip) :: ndime,nnode,nlocs,ntens
    integer(ip) :: ilocs,idime,jdime,kdime,ldime,inode,itens
    logical :: khes


    khes = .false.
    if ( allocated( ref%hessian ) ) then 
       khes = .true.
    end if

    ndime = ref%number_dimensions
    ntens = ref%number_entries_symmetric_tensor
    nlocs = ref%number_quadrature_points
    !nnode = ref%number_shape_functions
    nnode = size(ref%shape_functions,1)

    ! Shape functions do not change
    !phy%shape_functions = ref%shape_functions 

    ! First derivatives do
    !if(phy%kder==1) then
    phy%shape_derivatives=0.0_rp
    do ilocs=1,phy%number_quadrature_points
       do inode=1,size(phy%shape_functions,1)!phy%number_shape_functions
          do idime=1,ndime
             do jdime=1,ndime
                phy%shape_derivatives(idime,inode,ilocs) = phy%shape_derivatives(idime,inode,ilocs) &
                     + map%inv_jacobian(jdime,idime,ilocs)*ref%shape_derivatives(jdime,inode,ilocs)
             end do
          end do
       end do
    end do
    !end if

    ! Second derivatives are
    !
    !    d^2 N / d x_i d x_j
    !       = (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j)
    !       + (d N / d s_k) (d^2 s_k / d x_i d x_j) 
    !
    if( khes ) then
       call memalloc(ndime,ndime,nnode,wmat1,__FILE__,__LINE__)
       call memalloc(ndime,ndime,nnode,wmat2,__FILE__,__LINE__)
       do ilocs=1,nlocs
          if( khes ) then
             ! Transforms the array HESSI to a symmetric matrix WMAT1
             do inode=1,nnode
                do itens = 1, ntens
                   wvec1(itens) = ref%hessian(itens,inode,ilocs)
                end do
                call vetoma(wvec1,wmat1(1,1,inode),ndime,ntens)
             end do
             ! Computes (d^2 N / d s_k d s_l) (d s_k/ d x_i)(d s_l/ d x_j) for each node
             do inode=1,nnode
                call btdbma(wmat2(1,1,inode),wmat1(1,1,inode),map%inv_jacobian(:,:,ilocs), &
                     &        ndime,ndime)
             end do
          end if
          if( khes ) then
             ! Add second cartesian derivatives of the map times 
             ! first derivatives of shape functions
             do inode=1,nnode
                do idime=1,ndime
                   do jdime=1,ndime
                      do kdime=1,ndime
                         wmat2(idime,jdime,inode)=wmat2(idime,jdime,inode) &
                              & + ref%shape_derivatives(kdime,inode,ilocs) &
                              &   * map%d2sdx(kdime,idime,jdime,ilocs)
                      end do
                   end do
                end do
             end do
          end if

          ! Writes the Hessian matrix as an array
          do inode=1,nnode
             do itens = 1, ntens
                wvec1(itens) = phy%hessian(itens,inode,ilocs)
             end do
             call matove(wmat2(1,1,inode),wvec1,ndime,ntens)
          end do
       end do
       call memfree(wmat1,__FILE__,__LINE__)
       call memfree(wmat2,__FILE__,__LINE__)
    end if
  end subroutine quad_lagrangian_reference_fe_apply_femap_to_interpolation

!==================================================================================================
  subroutine matove(xmatr,vecto,ndime,ntens)
    !-----------------------------------------------------------------------
    !                                      
    ! This routine stores a symmetric matrix XMATR into a vector VECTO
    !
    !-----------------------------------------------------------------------
    implicit none
    integer(ip), intent(in)  :: ndime,ntens
    real(rp)   , intent(in)  :: xmatr(ndime,ndime)
    real(rp)   , intent(out) :: vecto(ntens)

    if(ndime.eq.2) then
       vecto(1)=xmatr(1,1)
       vecto(3)=xmatr(1,2)
       vecto(2)=xmatr(2,2)
    else
       vecto(1)=xmatr(1,1)
       vecto(4)=xmatr(1,2)
       vecto(2)=xmatr(2,2)
       vecto(5)=xmatr(1,3)
       vecto(6)=xmatr(2,3)
       vecto(3)=xmatr(3,3)
    end if

  end subroutine matove

!==================================================================================================
  subroutine quad_lagrangian_reference_fe_get_subelements_connectivity(this, connectivity)
    implicit none
    class(quad_lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip),                           intent(inout) :: connectivity(:, :)
    integer(ip)                                          :: num_subelems
    integer(ip)                                          :: subelem
    integer(ip)                                          :: geo_nnodes
    integer(ip)                                          :: local_node
    integer(ip)                                          :: first_coord(this%number_dimensions)
    integer(ip)                                          :: local_coord(this%number_dimensions)
    integer(ip)                                          :: global_coord(this%number_dimensions)
   
    num_subelems = this%get_number_subelements()
    geo_nnodes = this%get_number_vertices()
    assert(size(connectivity,1) == geo_nnodes)
    assert(size(connectivity,2) == num_subelems)

    do subelem = 1, num_subelems
      call Q_ijkg(first_coord,subelem,this%number_dimensions,this%order-1)
      do local_node = 1, geo_nnodes
        call Q_ijkg(local_coord,local_node,this%number_dimensions,1)
        global_coord = first_coord + local_coord
        connectivity(local_node, subelem) = Q_gijk(global_coord,this%number_dimensions,this%order)
      end do
    end do
  end subroutine quad_lagrangian_reference_fe_get_subelements_connectivity

!==================================================================================================
  function quad_lagrangian_reference_fe_get_number_subelements(this) result(number_subelements)
    implicit none
    class(quad_lagrangian_reference_fe_t), intent(in)    :: this
    integer(ip)                                          :: number_subelements

    number_subelements = this%order**this%number_dimensions
  end function quad_lagrangian_reference_fe_get_number_subelements
  
