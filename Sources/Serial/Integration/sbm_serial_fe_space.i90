! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine serial_fe_space_create( this, &
     triangulation, &
     boundary_conditions, &
     reference_fe_phy, &
     field_blocks, &
     field_coupling )
  implicit none
  class(serial_fe_space_t)        , intent(inout) :: this
  type(triangulation_t)   , target, intent(in)    :: triangulation
  type(conditions_t)              , intent(in)    :: boundary_conditions
  type(p_reference_fe_t)  , target, intent(in)    :: reference_fe_phy(:)
  integer(ip)           , optional, intent(in)    :: field_blocks(:)
  logical               , optional, intent(in)    :: field_coupling(:,:)

  integer(ip) :: i, istat, jfe_space, ife_space

  call this%free()

  this%number_fe_spaces = size(reference_fe_phy)
  call memalloc( this%number_fe_spaces, this%field_blocks, __FILE__, __LINE__)
  call memalloc( this%number_fe_spaces, this%number_fe_spaces, this%field_coupling, __FILE__, __LINE__)
  if ( present(field_blocks) ) then
     assert( size(field_blocks) == this%number_fe_spaces )
     assert( size(field_coupling,1) == this%number_fe_spaces )
     assert( size(field_coupling,2) == this%number_fe_spaces )
     this%field_blocks   = field_blocks
     this%field_coupling = field_coupling
  else
     this%field_blocks = 1
     this%field_coupling = .true.
  end if
  this%number_blocks = maxval(this%field_blocks)

  call memalloc ( this%number_blocks, this%number_blocks, this%blocks_coupling, __FILE__, __LINE__)
  this%blocks_coupling = .false.
  do jfe_space=1,this%number_fe_spaces
     do ife_space=1,this%number_fe_spaces
        this%blocks_coupling(this%field_blocks(ife_space), this%field_blocks(jfe_space)) =  this%field_coupling(ife_space,jfe_space)
     end do
  end do

  this%triangulation => triangulation

  ! Assuming only one geometrical reference FE for the moment  SB.alert
  ! assuming we are going to use faces of 1 type
  allocate( this%quadrature(1), stat=istat )
  allocate( this%fe_map(1), stat=istat )
  allocate( character(len=5)::this%fe_space_type(this%number_fe_spaces), stat=istat)

  allocate( this%volume_integrator(this%number_fe_spaces), stat=istat )
  allocate( this%reference_fe_phy_list(this%number_fe_spaces), stat=istat )

  call this%quadrature(1)%allocate()
  call this%fe_map(1)%allocate()
  do i  = 1, this%number_fe_spaces
     this%reference_fe_phy_list(i) = reference_fe_phy(i)
     call this%volume_integrator(i)%allocate()
     if ( reference_fe_phy(i)%p%get_continuity() ) then
        this%fe_space_type = fe_space_type_cg
     else if ( reference_fe_phy(i)%p%get_conformity() ) then
        this%fe_space_type = fe_space_type_dg_conforming
     else
        this%fe_space_type = fe_space_type_dg
     end if
  end do

  allocate(this%fe_array(this%triangulation%num_elems))
  do i = 1, this%triangulation%num_elems
     call this%fe_array(i)%create (this%triangulation%elems(i),&
          this%number_fe_spaces,&
          this%reference_fe_phy_list, &
          this%quadrature(1)%p,&
          this%fe_map(1)%p,&
          this%volume_integrator,&
          this%number_blocks,&
          this%field_blocks,&
          boundary_conditions)
  end do

  call set_up_boundary_conditions( this, boundary_conditions )

end subroutine serial_fe_space_create

subroutine set_up_boundary_conditions( this, boundary_conditions )
  implicit none
  class(serial_fe_space_t)        , intent(inout) :: this
  type(conditions_t)              , intent(in)    :: boundary_conditions

  integer(ip) :: c, j, ielem, ivef, vef_gid, inode, jnode, component, offset_component
  type(finite_element_t), pointer :: fe

  ! For every fe_space_component, we go through FEs (ON THE BOUNDARY) and
  ! look for strong Dirichlet data nodes
  c = 0  
  offset_component = 0

  ! The way this function is implemented is inefficient, extracting the same fe many times...
  do j = 1, this%number_fe_spaces
     do ielem = 1, this%get_number_elements()
        fe => this%get_finite_element(ielem)
        do ivef = 1,fe%cell%num_vefs
           vef_gid = fe%cell%vefs(ivef)
           if (vef_gid /= -1) then
              do inode = 1, fe%reference_fe_phy(j)%p%get_number_own_nodes_vef(ivef)
                 jnode = fe%reference_fe_phy(j)%p%get_own_node_vef(inode,ivef)
                 component = offset_component+ fe%reference_fe_phy(j)%p%get_bc_component_node(jnode)
                 if ( boundary_conditions%code(component,vef_gid) /= 0 ) then 
                    c = c+1 
                    fe%elem2dof(j)%p(inode) = -1*c
                 end if
              end do
           end if
        end do
     end do
     offset_component = offset_component + fe%reference_fe_phy(j)%p%get_number_field_components()
  end do

  call memalloc ( c, this%strong_dirichlet_data, __FILE__, __LINE__ ) ! One for all blocks / unknowns

end subroutine set_up_boundary_conditions




subroutine serial_fe_space_fill_dof_info( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip) :: fe_space_id

  call memalloc( this%number_blocks, this%number_dofs_per_block, __FILE__, __LINE__ )
  call memalloc( this%number_fe_spaces, this%number_dofs_per_field, __FILE__, __LINE__ )

  this%number_dofs_per_block = 0
  this%number_dofs_per_field = 0
  do fe_space_id = 1, this%number_fe_spaces
     call this%fill_elem2dof_and_count_dofs( fe_space_id )
  end do
end subroutine serial_fe_space_fill_dof_info

subroutine serial_fe_space_fill_elem2dof_and_count_dofs( this, fe_space_id ) 
  implicit none
  ! Parameters
  class(serial_fe_space_t), intent(inout) :: this 
  integer(ip)                , intent(in) :: fe_space_id

  ! Local variables
  integer(ip) :: ivef, vef_id, ielem
  integer(ip) :: iblock, init_dof_block, current_dof_block

  integer(ip), allocatable :: visited_vef_to_elem_map(:,:)

  iblock            = this%field_blocks(fe_space_id)
  init_dof_block    = this%number_dofs_per_block(iblock)
  current_dof_block = init_dof_block

  call memalloc ( 2, this%triangulation%num_vefs, visited_vef_to_elem_map,  __FILE__, __LINE__ )
  visited_vef_to_elem_map = -1

  if ( this%fe_space_type(fe_space_id) == fe_space_type_cg ) then
     do ielem = 1, this%get_number_elements()
        ! Deal with dofs on the boundary of the element 
        call this%fe_array(ielem)%fill_own_dofs ( fe_space_id, current_dof_block )
        do ivef = 1, this%fe_array(ielem)%cell%num_vefs
           vef_id = this%fe_array(ielem)%cell%vefs(ivef)
           if ( visited_vef_to_elem_map ( 1, vef_id ) == -1 ) then
              visited_vef_to_elem_map ( 1, vef_id ) = ielem
              visited_vef_to_elem_map ( 2, vef_id ) = ivef
              call this%fe_array(ielem)%fill_own_dofs_on_vef ( ivef, fe_space_id, current_dof_block  ) 
           else 
              call this%fe_array(ielem)%fill_own_dofs_on_vef_from_source_element ( ivef, &
                   this%fe_array(visited_vef_to_elem_map(1,vef_id)), &
                   visited_vef_to_elem_map(2,vef_id), &
                   fe_space_id) 
           end if
        end do
     end do
  else 
     do ielem = 1, this%get_number_elements()
        call this%fe_array(ielem)%fill_own_dofs ( fe_space_id, current_dof_block )
     end do
  end if

  call memfree ( visited_vef_to_elem_map,  __FILE__, __LINE__ )  
  this%number_dofs_per_field(fe_space_id) = current_dof_block - init_dof_block
  this%number_dofs_per_block(iblock) = this%number_dofs_per_block(iblock) + &
       this%number_dofs_per_field(fe_space_id)     
end subroutine serial_fe_space_fill_elem2dof_and_count_dofs

subroutine serial_fe_space_free( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this

  integer(ip) :: iblock, i, j, number_nodes, istat, iobje, obje_g, inode, jnode

  ! Assuming only one reference FE for the moment  SB.alert
  ! Assuming order 1 for geometry SB.alert
  if ( allocated(this%fe_array) ) then
     call this%quadrature(1)%free()
     deallocate( this%quadrature )

     call this%fe_map(1)%free()
     deallocate( this%fe_map )

     do i  = 1, this%number_fe_spaces
        call this%volume_integrator(i)%free()
     end do
     deallocate( this%volume_integrator )
     deallocate( this%reference_fe_phy_list )

     do i = 1, this%get_number_elements()
        call this%fe_array(i)%free()
     end do
     deallocate(this%fe_array)
     
     if (allocated(this%strong_dirichlet_data)) then 
       deallocate ( this%strong_dirichlet_data, stat = istat )
       check(istat==0)
    end if
     
  end if

  ! Free memory related to face (assuming one only face_integrator
  if (allocated(this%face_integrator)) then
     do j = 1, 2 * this%number_fe_spaces
        call this%face_integrator(j)%p%free
     end do
     deallocate( this%face_integrator )
  end if

  if (allocated(this%face_array)) then
     do i = 1, this%triangulation%number_interior_faces + this%triangulation%number_boundary_faces
        call this%face_array(i)%free()
     end do
     deallocate(this%face_array)

     call this%face_quadrature(1)%free()
     deallocate(this%face_quadrature)

     call this%face_map(1)%free()
     call this%face_map(2)%free()
     deallocate(this%face_map)
  end if

  if (allocated(this%number_dofs_per_block)) call memfree( this%number_dofs_per_block, __FILE__, __LINE__ )
  if (allocated(this%number_dofs_per_field)) call memfree( this%number_dofs_per_field, __FILE__, __LINE__ )
  this%number_fe_spaces = 0
  this%number_blocks = 0
  if (allocated(this%field_blocks)) call memfree( this%field_blocks, __FILE__, __LINE__)
  if (allocated(this%field_coupling)) call memfree( this%field_coupling, __FILE__, __LINE__)
  if (allocated(this%blocks_coupling)) call memfree ( this%blocks_coupling, __FILE__, __LINE__)
  nullify(this%triangulation)
end subroutine serial_fe_space_free

subroutine serial_fe_space_print ( this )
  class(serial_fe_space_t), intent(in)                 :: this 

  integer(ip) :: i,j

  write(*,*) '********* number_dofs_per_field',this%number_dofs_per_field,'********'
  write(*,*) '********* number_dofs_per_block',this%number_dofs_per_block,'********'

  do i  = 1, this%triangulation%num_elems
     write(*,*) '********* ELEMENT: ',i,'********'
     write(*,*) '********* ELEMENT 2 DOF********'
     do j = 1, this%number_fe_spaces
        write(*,*) '********* FE COMPONENT: ',j,'********'
        write(*,*) this%fe_array(i)%elem2dof(j)%p
     end do
  end do

  do i  = 1, this%triangulation%number_interior_faces
     write(*,*) '--------------------- Face: ',i,'-------------------------'
     write(*,*) '-- Elem 1 --'
     write(*,*) this%face_array(i)%neighbour_fe(1)%p%elem2dof(1)%p
     write(*,*) '-- Elem 2 --'
     write(*,*) this%face_array(i)%neighbour_fe(2)%p%elem2dof(1)%p
  end do

end subroutine serial_fe_space_print

subroutine serial_fe_space_initialize_integration( this, max_order )
  implicit none
  ! Parameters
  class(serial_fe_space_t), intent(inout) :: this  
  integer(ip), optional, intent(in)  :: max_order
  call this%initialize_quadrature(max_order)
  call this%initialize_fe_map()
  call this%initialize_volume_integrator()
end subroutine serial_fe_space_initialize_integration

subroutine serial_fe_space_initialize_quadrature( this, max_order )
  implicit none
  ! Parameters
  class(serial_fe_space_t), intent(inout) :: this  
  integer(ip), optional, intent(in)  :: max_order
  integer(ip) :: i, max_order_

  if ( present(max_order) ) then
     max_order_ = max_order
  else
     max_order_ = 0
     do i = 1, this%number_fe_spaces
        max_order_ = max( max_order_, this%reference_fe_phy_list(i)%p%get_order() )
     end do
  end if
  do i = 1, size(this%quadrature)
     call this%reference_fe_phy_list(i)%p%create_quadrature( this%quadrature(i)%p, max_order_ )
  end do
end subroutine serial_fe_space_initialize_quadrature

subroutine serial_fe_space_initialize_volume_integrator( this )
  implicit none
  class(serial_fe_space_t), intent(inout) :: this
  integer(ip) :: i
  do i = 1, this%number_fe_spaces
     call this%volume_integrator(i)%p%create( this%quadrature(1)%p, & 
          this%reference_fe_phy_list(i)%p )
  end do
end subroutine serial_fe_space_initialize_volume_integrator

subroutine serial_fe_space_initialize_fe_map(this)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this  
  integer(ip) :: i
  do i = 1, size(this%fe_map)
     call this%fe_map(i)%p%create( this%quadrature(i)%p, &
          this%triangulation%reference_fe_geo_list(1)%p )
  end do
end subroutine serial_fe_space_initialize_fe_map

function serial_fe_space_create_assembler(this, &
     diagonal_blocks_symmetric_storage,&
     diagonal_blocks_symmetric, & 
     diagonal_blocks_sign)
  implicit none
  class(serial_fe_space_t)          , intent(in) :: this
  logical                           , intent(in) :: diagonal_blocks_symmetric_storage(:)
  logical                           , intent(in) :: diagonal_blocks_symmetric(:)
  integer(ip)                       , intent(in) :: diagonal_blocks_sign(:)
  class(matrix_array_assembler_t)   , pointer    :: serial_fe_space_create_assembler

  ! Locals
  class(matrix_t), pointer :: matrix
  class(array_t) , pointer :: array
  integer(ip)          :: ife_space, jfe_space
  integer(ip)          :: iblock, jblock

  if (this%number_blocks == 1) then
     allocate ( sparse_matrix_array_assembler_t :: serial_fe_space_create_assembler )
     allocate ( sparse_matrix_t :: matrix )
     allocate ( serial_scalar_array_t  :: array )
     select type(matrix)
        class is(sparse_matrix_t)
        call matrix%create(this%number_dofs_per_block(1), &
             diagonal_blocks_symmetric_storage(1),&
             diagonal_blocks_symmetric(1),&
             diagonal_blocks_sign(1))
        class default
        check(.false.)
     end select
     select type(array)
        class is(serial_scalar_array_t)
        call array%create(this%number_dofs_per_block(1))
        class default
        check(.false.)
     end select
  else
     allocate ( block_sparse_matrix_array_assembler_t :: serial_fe_space_create_assembler )
     allocate ( block_sparse_matrix_t :: matrix )
     allocate ( serial_block_array_t  :: array )
     select type(matrix)
        class is (block_sparse_matrix_t)
        call matrix%create(this%number_blocks, &
             this%number_dofs_per_block,&
             this%number_dofs_per_block,&
             diagonal_blocks_symmetric_storage,&
             diagonal_blocks_symmetric,&
             diagonal_blocks_sign)

        do jblock=1,this%number_blocks
           do iblock=1,this%number_blocks
              if (.not. this%blocks_coupling(iblock,jblock) ) then
                 call matrix%set_block_to_zero(iblock,jblock)
              end if
           end do
        end do
        class default
        check(.false.)
     end select
     select type(array)
        class is(serial_block_array_t)
        call array%create(this%number_blocks,this%number_dofs_per_block)
        class default
        check(.false.)
     end select
  end if
  call serial_fe_space_create_assembler%set_matrix(matrix)
  call serial_fe_space_create_assembler%set_array(array)
end function serial_fe_space_create_assembler


subroutine serial_fe_space_symbolic_setup_assembler(this,matrix_array_assembler)
  implicit none
  class(serial_fe_space_t)        , intent(in)    :: this
  class(matrix_array_assembler_t) , intent(inout) :: matrix_array_assembler
  ! Polymorphic matrix 
  class(matrix_t), pointer :: matrix

  matrix => matrix_array_assembler%get_matrix()
  select type(matrix)
     class is(sparse_matrix_t)
     class is(block_sparse_matrix_t)
     class default
     check(.false.)
  end select
end subroutine serial_fe_space_symbolic_setup_assembler

function serial_fe_space_get_number_elements ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)                 :: serial_fe_space_get_number_elements
  serial_fe_space_get_number_elements = this%triangulation%num_elems
end function serial_fe_space_get_number_elements

function serial_fe_space_get_number_interior_faces ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)                 :: serial_fe_space_get_number_interior_faces
  serial_fe_space_get_number_interior_faces = this%triangulation%number_interior_faces
end function serial_fe_space_get_number_interior_faces

function serial_fe_space_get_number_boundary_faces ( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this
  integer(ip)                 :: serial_fe_space_get_number_boundary_faces
  serial_fe_space_get_number_boundary_faces = this%triangulation%number_boundary_faces
end function serial_fe_space_get_number_boundary_faces

function serial_fe_space_get_number_fe_spaces( this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_number_fe_spaces
  serial_fe_space_get_number_fe_spaces = this%number_fe_spaces
end function serial_fe_space_get_number_fe_spaces

function serial_fe_space_get_finite_element( this, ielem )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip)                     , intent(in) :: ielem
  type(finite_element_t), pointer :: serial_fe_space_get_finite_element
  serial_fe_space_get_finite_element => this%fe_array(ielem)
end function serial_fe_space_get_finite_element

function serial_fe_space_get_finite_face( this, i )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip) :: i
  class(finite_face_t), pointer :: serial_fe_space_get_finite_face
  serial_fe_space_get_finite_face => this%face_array(i)
end function serial_fe_space_get_finite_face

function serial_fe_space_get_number_blocks( this)
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_number_blocks
  serial_fe_space_get_number_blocks = this%number_blocks ! SB.alert 
end function serial_fe_space_get_number_blocks

function serial_fe_space_get_field_blocks( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  integer(ip), pointer :: serial_fe_space_get_field_blocks(:)
  serial_fe_space_get_field_blocks => this%field_blocks
end function serial_fe_space_get_field_blocks

function serial_fe_space_get_field_coupling( this )
  implicit none
  class(serial_fe_space_t), target, intent(in) :: this
  logical, pointer :: serial_fe_space_get_field_coupling(:,:)
  serial_fe_space_get_field_coupling => this%field_coupling
end function serial_fe_space_get_field_coupling

function serial_fe_space_get_max_number_nodes_field( this, ifield )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip)                , intent(in) :: ifield
  integer(ip) :: serial_fe_space_get_max_number_nodes_field, ielem
  assert(ifield <= this%number_fe_spaces)
  serial_fe_space_get_max_number_nodes_field = 0
  do ielem = 1, this%get_number_elements()
     serial_fe_space_get_max_number_nodes_field = max(this%fe_array(ielem)%reference_fe_phy(ifield)%p%get_number_nodes(), &
          serial_fe_space_get_max_number_nodes_field)
  end do
end function serial_fe_space_get_max_number_nodes_field

function serial_fe_space_get_max_number_nodes_fe_space( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_number_nodes_fe_space, ielem, ifield
  serial_fe_space_get_max_number_nodes_fe_space = 0
  do ielem = 1, this%get_number_elements()
     do ifield = 1, this%number_fe_spaces
        serial_fe_space_get_max_number_nodes_fe_space = max(this%fe_array(ielem)%reference_fe_phy(ifield)%p%get_number_nodes(), &
             serial_fe_space_get_max_number_nodes_fe_space)
     end do
  end do
end function serial_fe_space_get_max_number_nodes_fe_space

function serial_fe_space_get_max_number_quadrature_points( this )
  implicit none
  class(serial_fe_space_t), intent(in) :: this 
  integer(ip) :: serial_fe_space_get_max_number_quadrature_points, iquad
  serial_fe_space_get_max_number_quadrature_points = 0
  do iquad = 1, size(this%quadrature)

     serial_fe_space_get_max_number_quadrature_points = max(this%quadrature(iquad)%p%get_number_quadrature_points(), &
          serial_fe_space_get_max_number_quadrature_points)
  end do
end function serial_fe_space_get_max_number_quadrature_points

subroutine update_bc_value_scalar( this, analytical_function, bc_code, fe_space_component, time, unknown_component)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  type(scalar_function_t) , intent(in)    :: analytical_function
  integer(ip)             , intent(in)    :: bc_code
  integer(ip)             , intent(in)    :: fe_space_component
  real(rp)   , optional   , intent(in)    :: time
  integer(ip), optional   , intent(in)    :: unknown_component
  ! Locals
  integer(ip) :: ielem, inode, istat
  integer(ip) :: number_quadrature_points, number_vertices
  real(rp)    :: time_(1)
  real(rp), allocatable       :: values(:,:)
  type(fe_map_t)              :: fe_map
  type(quadrature_t), pointer :: nodal_quadrature
  type(point_t), pointer      :: nodal_coordinates(:)
  type(point_t), pointer      :: vertex_coordinates(:)

  ! Getters
  nodal_quadrature         => this%reference_fe_phy_list(fe_space_component)%p%get_nodal_quadrature()
  number_vertices          =  this%reference_fe_phy_list(fe_space_component)%p%get_number_vertices()
  number_quadrature_points =  nodal_quadrature%get_number_quadrature_points()

  ! Auxiliar time as an array of dimension 1
  if (present(time)) time_(1) = time 

  ! Allocate nodal coordinates
  call memalloc(number_quadrature_points,1,values,__FILE__,__LINE__)

  ! Create FE map
  call fe_map%create(nodal_quadrature, this%triangulation%reference_fe_geo_list(1)%p)

  ! Loop over elements
  do ielem = 1, this%triangulation%num_elems

     ! Interpolate coordinates
     vertex_coordinates => fe_map%get_coordinates()
     call this%fe_array(ielem)%cell%get_coordinates(vertex_coordinates)
     call fe_map%compute_quadrature_coordinates()
     nodal_coordinates => fe_map%get_quadrature_coordinates()

     ! Evaluate function
     if(present(time)) then
        call analytical_function%get_values_set_space_time(nodal_coordinates,time_,values)
     else
        call analytical_function%get_values_set_space(nodal_coordinates,values(:,1))
     end if

     ! Set nodal bc_values from the analytical function evaluation
     call this%reference_fe_phy_list(fe_space_component)%p%set_scalar_field_to_nodal_values(bc_code, &
          & values(:,1),this%fe_array(ielem)%bc_code(fe_space_component)%p,                          &
          & this%fe_array(ielem)%bc_value(fe_space_component)%p, unknown_component)
  end do

  call memfree(values,__FILE__,__LINE__)

  ! Free FE map
  call fe_map%free()

end subroutine update_bc_value_scalar

subroutine update_bc_value_vector( this, analytical_function, bc_code, fe_space_component, time)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  type(vector_function_t) , intent(in)    :: analytical_function
  integer(ip)             , intent(in)    :: bc_code
  integer(ip)             , intent(in)    :: fe_space_component
  real(rp)   , optional   , intent(in)    :: time
  ! Locals
  integer(ip) :: ielem, qpoin, istat
  integer(ip) :: number_quadrature_points, number_vertices
  real(rp)    :: time_(1)
  character(:), allocatable         :: field_type
  type(fe_map_t)                    :: fe_map
  type(quadrature_t)  , pointer     :: nodal_quadrature
  type(point_t)       , pointer     :: nodal_coordinates(:)
  type(point_t)       , pointer     :: vertex_coordinates(:)
  type(vector_field_t), allocatable :: values(:,:)

  ! Getters
  field_type               =  this%reference_fe_phy_list(fe_space_component)%p%get_field_type()
  nodal_quadrature         => this%reference_fe_phy_list(fe_space_component)%p%get_nodal_quadrature()
  number_vertices          =  this%reference_fe_phy_list(fe_space_component)%p%get_number_vertices()
  number_quadrature_points =  nodal_quadrature%get_number_quadrature_points()
  assert( field_type == field_type_vector )

  ! Auxiliar time as an array of dimension 1
  if (present(time)) time_(1) = time 

  ! Allocate nodal coordinates
  allocate(values(number_quadrature_points,1), stat=istat); check(istat==0)

  ! Create FE map
  call fe_map%create(nodal_quadrature, this%triangulation%reference_fe_geo_list(1)%p)

  ! Loop over elements
  do ielem = 1, this%triangulation%num_elems

     ! Interpolate coordinates
     vertex_coordinates => fe_map%get_coordinates()
     call this%fe_array(ielem)%cell%get_coordinates(vertex_coordinates)
     call fe_map%compute_quadrature_coordinates()
     nodal_coordinates => fe_map%get_quadrature_coordinates()

     ! Evaluate function
     if(present(time)) then
        call analytical_function%get_values_set_space_time(nodal_coordinates,time_,values)
     else
        call analytical_function%get_values_set_space(nodal_coordinates,values(:,1))
     end if

     ! Set nodal bc_values from the analytical function evaluation
     call this%reference_fe_phy_list(fe_space_component)%p%set_field_to_nodal_values(bc_code, &
          & values(:,1),this%fe_array(ielem)%bc_code(fe_space_component)%p,                   &
          & this%fe_array(ielem)%bc_value(fe_space_component)%p)

  end do

  deallocate(values)

  ! Free FE map
  call fe_map%free()

end subroutine update_bc_value_vector

subroutine update_bc_value_tensor( this, analytical_function, bc_code, fe_space_component, time)
  implicit none
  class(serial_fe_space_t), intent(inout) :: this 
  type(tensor_function_t) , intent(in)    :: analytical_function
  integer(ip)             , intent(in)    :: bc_code
  integer(ip)             , intent(in)    :: fe_space_component
  real(rp)   , optional   , intent(in)    :: time
  ! Locals
  integer(ip) :: ielem, qpoin, istat
  integer(ip) :: number_quadrature_points, number_vertices
  real(rp)    :: time_(1)
  character(:), allocatable   :: field_type
  type(fe_map_t)              :: fe_map
  type(quadrature_t), pointer :: nodal_quadrature
  type(point_t), pointer      :: nodal_coordinates(:)
  type(point_t), pointer      :: vertex_coordinates(:)
  type(tensor_field_t), allocatable :: values(:,:)

  ! Getters
  field_type               =  this%reference_fe_phy_list(fe_space_component)%p%get_field_type()
  nodal_quadrature         => this%reference_fe_phy_list(fe_space_component)%p%get_nodal_quadrature()
  number_vertices          =  this%reference_fe_phy_list(fe_space_component)%p%get_number_vertices()
  number_quadrature_points =  nodal_quadrature%get_number_quadrature_points()
  assert( field_type == field_type_tensor )

  ! Auxiliar time as an array of dimension 1
  if (present(time)) time_(1) = time 

  ! Allocate nodal coordinates
  allocate(values(number_quadrature_points,1), stat=istat); check(istat==0)

  ! Create FE map
  call fe_map%create(nodal_quadrature, this%triangulation%reference_fe_geo_list(1)%p)

  ! Loop over elements
  do ielem = 1, this%triangulation%num_elems

     ! Interpolate coordinates
     vertex_coordinates => fe_map%get_coordinates()
     call this%fe_array(ielem)%cell%get_coordinates(vertex_coordinates)
     call fe_map%compute_quadrature_coordinates()
     nodal_coordinates => fe_map%get_quadrature_coordinates()

     ! Evaluate function
     if(present(time)) then
        call analytical_function%get_values_set_space_time(nodal_coordinates,time_,values)
     else
        call analytical_function%get_values_set_space(nodal_coordinates,values(:,1))
     end if

     ! Set nodal bc_values from the analytical function evaluation
     call this%reference_fe_phy_list(fe_space_component)%p%set_field_to_nodal_values(bc_code, &
          & values(:,1),this%fe_array(ielem)%bc_code(fe_space_component)%p,                   &
          & this%fe_array(ielem)%bc_value(fe_space_component)%p)

  end do

  deallocate(values)

  ! Free FE map
  call fe_map%free()

end subroutine update_bc_value_tensor


