subroutine interpolation_create( this, &
                                 number_dimensions, &
                                 number_shape_functions, &
                                 number_evaluation_points, & 
                                 number_entries_symmetric_tensor, &
                                 compute_hessian )
  implicit none
  class(interpolation_t), intent(inout) :: this
  integer(ip)              , intent(in)    :: number_dimensions, & 
                                              number_shape_functions, & 
                                              number_evaluation_points
  integer(ip)              , intent(in)    :: number_entries_symmetric_tensor
  logical, optional        , intent(in)    :: compute_hessian

  call this%free()
  
  this%number_dimensions = number_dimensions
  this%number_shape_functions = number_shape_functions
  this%number_evaluation_points = number_evaluation_points
  this%number_entries_symmetric_tensor = number_entries_symmetric_tensor
  call memalloc(number_shape_functions, &
                number_evaluation_points, &
                this%shape_functions,__FILE__,__LINE__)
  call memalloc(number_dimensions, &
                number_shape_functions, &
                number_evaluation_points, &
                this%shape_derivatives, __FILE__, __LINE__)
  if ( present(compute_hessian) ) then
     if ( compute_hessian ) then 
        call memalloc(number_entries_symmetric_tensor,&
                      number_shape_functions,&
                      number_evaluation_points, &
                      this%hessian,__FILE__,__LINE__) 
     end if
  end if
end subroutine interpolation_create

subroutine interpolation_free( this)
  implicit none
  class(interpolation_t), intent(inout) :: this
  this%number_dimensions = 0
  this%number_shape_functions = 0
  this%number_evaluation_points = 0
  this%number_entries_symmetric_tensor = 0
  if(allocated(this%shape_functions)) call memfree(this%shape_functions,__FILE__,__LINE__)
  if(allocated(this%shape_derivatives)) call memfree(this%shape_derivatives,   __FILE__,__LINE__)
  if(allocated(this%hessian)) call memfree(this%hessian,   __FILE__,__LINE__)
end subroutine interpolation_free

subroutine interpolation_copy(this, source_interpolation)
  implicit none
  class(interpolation_t), intent(inout) :: this
		type(interpolation_t), intent(in)     :: source_interpolation

		call this%free()
  this%number_dimensions = source_interpolation%number_dimensions
  this%number_shape_functions = source_interpolation%number_shape_functions
  this%number_evaluation_points = source_interpolation%number_evaluation_points
  this%number_entries_symmetric_tensor = source_interpolation%number_entries_symmetric_tensor
  call memalloc(this%number_shape_functions,this%number_evaluation_points, &
																this%shape_functions,__FILE__,__LINE__)
  call memalloc(this%number_dimensions,this%number_shape_functions,&
																this%number_evaluation_points,this%shape_derivatives,   __FILE__,__LINE__)
  this%shape_functions(:,:) = source_interpolation%shape_functions(:,:)
  this%shape_derivatives(:,:,:) = source_interpolation%shape_derivatives(:,:,:)
  if ( allocated(source_interpolation%hessian) ) then
    call memalloc(this%number_entries_symmetric_tensor,this%number_shape_functions,&
																		this%number_evaluation_points,this%hessian,   __FILE__,__LINE__) 
				this%hessian(:,:,:) = source_interpolation%hessian(:,:,:)
  end if

end subroutine interpolation_copy

subroutine interpolation_print ( this )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip) :: i,j,k
  write(*,*) 'number_dimensions: ', this%number_dimensions
  write(*,*) 'number_shape_functions: ', this%number_shape_functions
  write(*,*) 'number_evaluation_points: ', this%number_evaluation_points
  write(*,*) 'number_entries_symmetric_tensor: ', this%number_entries_symmetric_tensor
  write(*,*) '*************** SHAPE FUNCTIONS ******************'
  do i = 1, size(this%shape_functions,1)
     do j = 1, size(this%shape_functions,2)
        write(*,*) 'shape function phi^',i,'(gp=',j,')= ',this%shape_functions(i,j)
     end do
  end do

  write(*,*) '*************** SHAPE DERIVATIVES ******************'                      

  do i = 1, size(this%shape_derivatives,1)                                                             
     do j = 1, size(this%shape_derivatives,2)                                                         
        do k = 1, size(this%shape_derivatives,3)                                                        
           write(*,*) 'shape derivative D_',i,'phi^',j,'(gp=',k,')= ',this%shape_derivatives(i,j,k)
        end do
     end do
  end do
  write(*,*) 'shape_derivatives: ', this%shape_derivatives
  if ( allocated( this%hessian ) ) then
     write(*,*) 'hessian: ', this%hessian
  else
     write(*,*) 'hessian not computed '
  end if
end subroutine interpolation_print

function interpolation_get_number_dimensions( this )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip) :: interpolation_get_number_dimensions
  interpolation_get_number_dimensions = this%number_dimensions
end function interpolation_get_number_dimensions

function interpolation_get_number_shape_functions( this )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip) :: interpolation_get_number_shape_functions
  interpolation_get_number_shape_functions = this%number_shape_functions
end function interpolation_get_number_shape_functions

function interpolation_get_number_evaluation_points( this )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip) :: interpolation_get_number_evaluation_points
  interpolation_get_number_evaluation_points = this%number_evaluation_points
end function interpolation_get_number_evaluation_points

function interpolation_get_number_entries_symmetric_tensor( this )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip) :: interpolation_get_number_entries_symmetric_tensor
  interpolation_get_number_entries_symmetric_tensor = this%number_entries_symmetric_tensor
end function interpolation_get_number_entries_symmetric_tensor

function interpolation_get_shape_function ( this, i, j )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip), intent(in) :: i, j
  real(rp) :: interpolation_get_shape_function
  interpolation_get_shape_function = this%shape_functions(i,j)
end function interpolation_get_shape_function

function interpolation_get_shape_derivative ( this, i, j, k )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip), intent(in) :: i, j, k
  real(rp) :: interpolation_get_shape_derivative
  interpolation_get_shape_derivative = this%shape_derivatives(i,j,k)
end function interpolation_get_shape_derivative

function interpolation_get_hessian ( this, i, j, k )
  implicit none
  class(interpolation_t), intent(in) :: this
  integer(ip), intent(in) :: i, j, k
  real(rp) :: interpolation_get_hessian
  interpolation_get_hessian = this%hessian(i,j,k)
end function interpolation_get_hessian

! function interpolation_get_pointer_shape_functions ( this )
!   implicit none
!   class(interpolation_t), target, intent(in) :: this
!   real(rp), pointer :: interpolation_get_pointer_shape_functions(:,:)
!   interpolation_get_pointer_shape_functions => this%shape_functions
! end function interpolation_get_pointer_shape_functions

! function interpolation_get_pointer_shape_derivatives ( this )
!   implicit none
!   class(interpolation_t), target, intent(in) :: this
!   real(rp), pointer :: interpolation_get_pointer_shape_derivatives(:,:,:)
!   interpolation_get_pointer_shape_derivatives => this%shape_derivatives
! end function interpolation_get_pointer_shape_derivatives

! function interpolation_get_pointer_hessian ( this )
!   implicit none
!   class(interpolation_t), target, intent(in) :: this
!   real(rp), pointer :: interpolation_get_pointer_hessian(:,:,:)
!   if ( allocated( this%hessian ) ) then
!      interpolation_get_pointer_hessian => this%hessian
!   else
!      nullify(get_pointer_hessian)
!   end if
! end function interpolation_get_pointer_hessian
