! Templated implementation of a plain element set and its iterator. 
! Templates are not natively supported by fortran.
! They are emulated using the preprocessor by including this file in a module 
! AFTER the contains statement and after a definition of:
!
! template_element_t
! plain_template_element_set_t
! plain_template_element_iterator_t
!
  !=============================================================================
  subroutine create_template_element_iterator(this,iterator)
    implicit none
    class(plain_template_element_set_t), target     , intent(in)  :: this
    class(template_element_iterator_t) , allocatable, intent(out) :: iterator
    integer(ip) :: istat
    allocate(plain_template_element_iterator_t :: iterator, stat=istat)
    check(istat==0)
    select type(iterator)
    class is(plain_template_element_iterator_t)
       iterator%plain_template_element_set => this
    end select
  end subroutine create_template_element_iterator

  !=============================================================================
  subroutine free_template_element_iterator(this,iterator)
    implicit none
    class(plain_template_element_set_t)            , intent(in)    :: this
    class(template_element_iterator_t), allocatable, intent(inout) :: iterator
    ! No internal memory for this simple iterator.
    deallocate(iterator)
  end subroutine free_template_element_iterator

  !=============================================================================
  function plain_template_element_iterator_next (this) result(p)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    class(template_element_t)               , pointer       :: p
    this%ielem = this%ielem + 1
    assert( this%ielem <= this%plain_template_element_set%elements_array_len )
    p => this%plain_template_element_set%elements(this%ielem)
  end function plain_template_element_iterator_next

  !=============================================================================
  function plain_template_element_iterator_has_next(this) result(res)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    logical :: res
    res = ( this%ielem < this%plain_template_element_set%num_elements )
    if(.not.res) this%ielem=0 ! Reset iterator for the next loop
  end function plain_template_element_iterator_has_next
