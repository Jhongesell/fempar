! Templated implementation of a plain element set and its iterator. 
! Templates are not natively supported by fortran.
! They are emulated using the preprocessor by including this file in a module 
! AFTER the contains statement and after a definition of:
!
! template_element_t
! plain_template_element_set_t
! plain_template_element_iterator_t
!
  !=============================================================================
  subroutine create_plain_set(this,size,mold)
    implicit none
    class(plain_template_element_set_t), intent(inout) :: this
    integer(ip)                        , intent(in)    :: size
    class(template_element_t)          , intent(in)    :: mold
    integer(ip) :: istat
    ! Create set
    this%num_elements = size
    allocate(this%elements(this%num_elements), mold=mold, stat=istat)
    check(istat==0)
  end subroutine create_plain_set

  !=============================================================================
  subroutine free_plain_set(this)
    implicit none
    class(plain_template_element_set_t), intent(inout)  :: this
    integer(ip) :: istat
    this%num_elements = -1
    deallocate(this%elements, stat=istat)
    check(istat==0)
  end subroutine free_plain_set

  !=============================================================================
  subroutine create_plain_iterator(this,iterator)
    implicit none
    class(plain_template_element_set_t), target     , intent(in)  :: this
    class(template_element_iterator_t) , allocatable, intent(out) :: iterator
    integer(ip) :: istat
    allocate(plain_template_element_iterator_t :: iterator, stat=istat)
    check(istat==0)
    select type(iterator)
    class is(plain_template_element_iterator_t)
       iterator%plain_template_element_set => this
    end select
  end subroutine create_plain_iterator
  !=============================================================================
  subroutine free_plain_iterator(this,iterator)
    implicit none
    class(plain_template_element_set_t)            , intent(in)    :: this
    class(template_element_iterator_t), allocatable, intent(inout) :: iterator
    ! No internal memory for this simple iterator.
    deallocate(iterator)
  end subroutine free_plain_iterator

  !=============================================================================
  function plain_iterator_next (this) result(p)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    class(template_element_t)               , pointer       :: p
    this%ielem = this%ielem + 1
    assert( this%ielem <= this%plain_template_element_set%num_elements )
    p => this%plain_template_element_set%elements(this%ielem)
  end function plain_iterator_next

  !=============================================================================
  function plain_iterator_has_next(this) result(res)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    logical :: res
    res = ( this%ielem < this%plain_template_element_set%num_elements )
    if(.not.res) this%ielem=0 ! Reset iterator for the next loop
  end function plain_iterator_has_next

  !=============================================================================
  subroutine plain_iterator_current_id(this,res)
    implicit none
    class(plain_template_element_iterator_t), intent(in)    :: this
    class(element_id_t)        , allocatable, intent(inout) :: res
    if(allocated(res)) deallocate(res)
    allocate(ip_element_id_t :: res)
    call res%set_index(this%ielem)
  end subroutine plain_iterator_current_id

