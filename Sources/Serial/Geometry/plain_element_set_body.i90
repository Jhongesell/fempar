! Templated implementation of a plain element set and its iterator. 
! Templates are not natively supported by fortran.
! They are emulated using the preprocessor by including this file in a module 
! AFTER the contains statement and after a definition of:
!
! template_element_t
! plain_template_element_set_t
! plain_template_element_iterator_t
!
  !=============================================================================
  !=============================================================================
  !=============================================================================
  !=============================================================================
  subroutine create_plain_set(this,size,mold)
    implicit none
    class(plain_template_element_set_t), intent(inout) :: this
    integer(ip)                        , intent(in)    :: size
    class(template_element_t)          , intent(in)    :: mold
    integer(ip) :: istat
    ! Create set
    this%num_elements = size
    allocate(this%elements(this%num_elements), mold=mold, stat=istat)
    check(istat==0)
  end subroutine create_plain_set

  !=============================================================================
  subroutine free_plain_set(this)
    implicit none
    class(plain_template_element_set_t), intent(inout)  :: this
    integer(ip) :: istat
    this%num_elements = -1
    deallocate(this%elements, stat=istat)
    check(istat==0)
  end subroutine free_plain_set

  !=============================================================================
  !=============================================================================
  !=============================================================================
  !=============================================================================
  subroutine create_plain_iterator(this,iterator)
    implicit none
    class(plain_template_element_set_t), target     , intent(in)  :: this
    class(template_element_iterator_t) , allocatable, intent(out) :: iterator
    integer(ip) :: istat
    allocate(plain_template_element_iterator_t :: iterator, stat=istat)
    check(istat==0)
    select type(iterator)
    class is(plain_template_element_iterator_t)
       iterator%plain_template_element_set => this
       iterator%first=1
       iterator%last=this%num_elements
    end select
  end subroutine create_plain_iterator
  !=============================================================================
  subroutine free_plain_iterator(this,iterator)
    implicit none
    class(plain_template_element_set_t)            , intent(in)    :: this
    class(template_element_iterator_t), allocatable, intent(inout) :: iterator
    ! No internal memory for this simple iterator.
    deallocate(iterator)
  end subroutine free_plain_iterator

  !=============================================================================
  !=============================================================================
  !=============================================================================
  !=============================================================================
  subroutine plain_iterator_set_first(this, first)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    integer(ip)                             , intent(in)    :: first
    this%first=first
  end subroutine plain_iterator_set_first

  !=============================================================================
  subroutine plain_iterator_set_last(this, last)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    integer(ip)                             , intent(in)    :: last
    this%last=last
  end subroutine plain_iterator_set_last

  !=============================================================================
  subroutine plain_iterator_begin(this)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    this%ielem=1
  end subroutine plain_iterator_begin
  !=============================================================================
  function plain_iterator_finished(this) result(res)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    logical :: res
    res = ( this%ielem > this%plain_template_element_set%num_elements )
  end function plain_iterator_finished
  !=============================================================================
  subroutine plain_iterator_next(this)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    this%ielem = this%ielem + 1
  end subroutine plain_iterator_next
  !=============================================================================
  function plain_iterator_current (this) result(p)
    implicit none
    class(plain_template_element_iterator_t), intent(inout) :: this
    class(template_element_t)               , pointer       :: p
    assert( this%ielem <= this%plain_template_element_set%num_elements )
    p => this%plain_template_element_set%elements(this%ielem)
  end function plain_iterator_current

  !=============================================================================
  subroutine plain_iterator_create_id(this,res)
    implicit none
    class(plain_template_element_iterator_t), intent(in)    :: this
    class(element_id_t)        , allocatable, intent(inout) :: res
    if(allocated(res)) deallocate(res)
    allocate(ip_element_id_t :: res)
  end subroutine plain_iterator_create_id
  !=============================================================================
  subroutine plain_iterator_free_id(this,res)
    implicit none
    class(plain_template_element_iterator_t), intent(in)    :: this
    class(element_id_t)        , allocatable, intent(inout) :: res
    if(allocated(res)) deallocate(res)
  end subroutine plain_iterator_free_id
  !=============================================================================
  subroutine plain_iterator_get_id(this,res)
    implicit none
    class(plain_template_element_iterator_t), intent(in)    :: this
    class(element_id_t)                     , intent(inout) :: res
    call res%set_index(this%ielem)
  end subroutine plain_iterator_get_id
  !=============================================================================
  function plain_iterator_get (this,id) result(p)
    implicit none
    class(plain_template_element_iterator_t), intent(in) :: this
    class(element_id_t)                     , intent(in) :: id
    class(template_element_t)               , pointer    :: p
    assert( id%get_index() <= this%plain_template_element_set%num_elements )
    p => this%plain_template_element_set%elements(id%get_index())
  end function plain_iterator_get
