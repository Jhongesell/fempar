! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************************
!***********************************************************************
! Templated implementation of a hash table based element set, extension of 
! the abstract element_set defined in element_set.i90. The code is similar 
! but has some differences with respect to standard hash_tables used elsewhere
! in FEMPAR. An iterator over the table is also defined.
!
! Templates are not natively supported by fortran.
! They are emulated using the preprocessor by including this file in a module 
! AFTER the contains statement and after a definition of:
!
! template_element_t
! hash_template_element_set_t
! hash_template_element_iterator_t
!  
!====================================================================
! node functions
!
recursive subroutine put_hash_node(list,key,mold,stat)
  class(hash_node), target , intent(inout) :: list
  type (template_key_t)    , intent(in)    :: key
  class(template_element_t), intent(in)    :: mold
  integer(ip)              , intent(out)   :: stat
  class(hash_node)         , pointer       :: newel => null()

  if( greater(key,list%key) ) then
     if(associated(list%child) ) then
        ! Keep going
        call put_hash_node(list%child,key,mold,stat)
     else
        ! We are at the end of the list
        ! Allocate a new child
        allocate(list%child)
        list%child%parent => list
        ! WARNING: we need assignment working (both in key and val)!
        list%child%key = list%key ! the default value
        ! Fill the value 
        list%key = key
        allocate(list%val, mold=mold)
     end if
  else if( equal(key,list%key) ) then
     ! Already stored
     stat = was_stored
  else if( smaller(key,list%key) ) then
     ! ! Insert an element just behind
     !
     ! Insert an element just after this one,
     ! copy list keyval and store keyval in list.
     ! allocate(newel)
     ! newel%child => list%child
     ! newel%parent => list
     ! newel%key = list%key
     ! newel%val = list%val
     ! if(associated(list%child)) list%child%parent => newel
     ! list%child => newel
     ! list%key = key
     ! list%val = val
     ! stat = now_stored
     !
     newel => list%child        ! keep the reference to old child
     allocate(list%child)       ! Allocate a new child
     ! WARNING: we need assignment working (both in key and val)!
     list%child%key = list%key  ! New child fields (copy list keyval)
     list%child%val = list%val
     list%child%parent => list
     list%child%child => newel
     list%child%child%parent => list%child ! Regenerate link
     list%key = key                        ! Store keyval in list
     allocate(list%val, mold=mold)
     stat = now_stored
  end if
end subroutine put_hash_node

recursive subroutine del_hash_node(list,key,stat)
  class(hash_node)   , target, intent(inout) :: list
  type(template_key_t)       , intent(in)    :: key
  integer(ip)                , intent(out)   :: stat
  class(hash_node)           , pointer       :: tmp => null()

  if( equal(key,list%key) ) then
     !if(associated(list%parent)) then ! this is not the first element
     !   tmp => list
     !   list%parent%child => list%child
     !   list%child%parent => list%parent
     !else                             ! this is the first element (copy and dealloc the second)
     !   tmp => list%child
     if(.not.associated(list%child)) then
        write(*,*) 'Error in migratory_element hash table'
        stat = error
        return
     end if
     ! WARNING: we need assignment working (both in key and val)!
     list%key = list%child%key
     list%val = list%child%val
     if(associated(list%child%child)) list%child%child%parent => list
     tmp => list%child%child
     call list%child%val%free()
     deallocate(list%child)
     list%child => tmp
     stat = deleted
  else if(associated(list%child)) then ! keep going
     call del_hash_node(list%child,key,stat)
  else
     stat = key_not_found
  end if
  return

end subroutine del_hash_node

recursive subroutine get_hash_node(list,key,val,stat)
  class(hash_node)     , target     , intent(in)    :: list
  type(template_key_t)              , intent(in)    :: key
  class(template_element_t), pointer, intent(out)   :: val
  integer(ip)                       , intent(inout) :: stat

  if( equal(key,list%key) ) then
     val => list%val
     stat = key_found
  else if(associated(list%child)) then ! keep going
     call get_hash_node(list%child,key,val,stat)
  else
     stat = key_not_found
  end if
  return

end subroutine get_hash_node

recursive subroutine free_hash_node(list)
  implicit none
  class(hash_node), intent(inout) :: list
  if (associated(list%child)) then
     call free_hash_node(list%child)
     deallocate(list%child)
  end if
  call list%val%free()
  list%child => null()
end subroutine free_hash_node

! To get the next node in the list
subroutine get_next_hash_node(list,next,stat)
  class(hash_node)        , intent(in)    :: list
  type(hash_node), pointer, intent(out)   :: next
  integer(ip)             , intent(inout) :: stat
  if(associated(list%child)) then
     next => list%child
     stat = key_found
  else
     stat = key_not_found
  end if
end subroutine get_next_hash_node

! To get the first element in the list
subroutine get_first_hash_node(list,first,stat)
  class(hash_node), target, intent(in)    :: list
  type(hash_node), pointer, intent(out)   :: first
  integer(ip)             , intent(inout) :: stat

  if(associated(list%child)) then
     first => list
     stat = key_found
  else
     stat = key_not_found
  end if

end subroutine get_first_hash_node

!====================================================================
! tbl functions
!
subroutine create_hash_template_element_set_t(this,size,mold)
  class(hash_template_element_set_t), intent(inout) :: this
  integer(ip)                       , intent(in)    :: size
  class(template_element_t)         , intent(in)    :: mold
  this%vec_len = size
  if (allocated(this%vec)) deallocate(this%vec)
  !allocate(this%vec(this%vec_len),mold=mold)
  allocate(this%vec(this%vec_len))
end subroutine create_hash_template_element_set_t

subroutine put_hash_template_element_set_t(tbl,key,mold,stat)
  class(template_element_t)           , intent(in)    :: mold
  class(hash_template_element_set_t)  , intent(inout) :: tbl
  type(template_key_t)                , intent(in)    :: key
  integer(ip)                         , intent(out)   :: stat
  integer(ip)                        :: hash
  hash = mod( convert_to_int(key) ,tbl%vec_len)
  assert ( (hash>=1).and.(hash<=tbl%vec_len))
!$OMP CRITICAL (hash_template_element_set_t_lock)
  call tbl%vec(hash)%put(key=key,mold=mold,stat=stat)
!$OMP END CRITICAL (hash_template_element_set_t_lock)
end subroutine put_hash_template_element_set_t

subroutine get_hash_template_element_set_t(tbl,key,val,stat)
  class(hash_template_element_set_t)  , intent(in)    :: tbl
  type(template_key_t)                , intent(in)    :: key
  class(template_element_t), pointer  , intent(out)   :: val
  integer(ip)             , optional  , intent(out)   :: stat
  integer(ip)                                         :: hash
  hash = mod( convert_to_int(key) ,tbl%vec_len)
  assert ( (hash>=1).and.(hash<=tbl%vec_len))
  call tbl%vec(hash)%get(key=key,val=val,stat=stat)
end subroutine get_hash_template_element_set_t

subroutine get_next_hash_template_element_set_t(tbl,current,next,stat)
  class(hash_template_element_set_t)  , intent(in)  :: tbl
  type(hash_node)                     , intent(in)  :: current
  type(hash_node)            ,pointer , intent(out) :: next
  integer(ip)                         , intent(out) :: stat
  integer(ip)                                       :: hash
  next => null()
  call current%get_next(next,stat)
  if(stat == key_not_found ) then
     hash = mod( convert_to_int(current%key),tbl%vec_len)
     assert ( (hash>=1).and.(hash<=tbl%vec_len))
     do while(hash<=tbl%vec_len .and. stat == key_not_found )
        hash=hash+1
        call tbl%vec(hash)%get_first(next,stat)
     end do
  end if
end subroutine get_next_hash_template_element_set_t

subroutine del_hash_template_element_set_t(tbl,key,stat)
  class(hash_template_element_set_t), intent(inout) :: tbl
  type(template_key_t)              , intent(in)    :: key
  integer(ip)                       , intent(out)   :: stat
  integer(ip)                                       :: hash

  hash = mod( convert_to_int(key) ,tbl%vec_len)
  assert ( (hash>=1).and.(hash<=tbl%vec_len))
!$OMP CRITICAL (hash_template_element_set_t_lock)
  call tbl%vec(hash)%del(key=key,stat=stat)
!$OMP END CRITICAL (hash_template_element_set_t_lock)
end subroutine del_hash_template_element_set_t

subroutine free_hash_template_element_set_t(this)
  class(hash_template_element_set_t), intent(inout) :: this    
  integer(ip) :: i
  if (allocated(this%vec)) then
     do i=1,this%vec_len
        call this%vec(i)%free()
     end do
     deallocate(this%vec)
  end if
  this%is_init = .false.
end subroutine free_hash_template_element_set_t

!=============================================================================
! Simplest iterator
  subroutine create_hash_template_element_iterator(this,iterator)
    implicit none
    class(hash_template_element_set_t) , target     , intent(in)  :: this
    class(template_element_iterator_t) , allocatable, intent(out) :: iterator
    integer(ip) :: istat
    allocate(hash_template_element_iterator_t :: iterator, stat=istat)
    check(istat==0)
    select type(iterator)
    class is(hash_template_element_iterator_t)
       iterator%hash_template_element_set => this
    end select
  end subroutine create_hash_template_element_iterator

  !=============================================================================
  subroutine free_hash_template_element_iterator(this,iterator)
    implicit none
    class(hash_template_element_set_t)             , intent(in)    :: this
    class(template_element_iterator_t), allocatable, intent(inout) :: iterator
    ! No internal memory for this simple iterator.
    deallocate(iterator)
  end subroutine free_hash_template_element_iterator

  !=============================================================================
  !=============================================================================
  subroutine hash_template_element_iterator_begin (this)
    implicit none
    class(hash_template_element_iterator_t), intent(inout) :: this
    type(hash_node), pointer :: first 
    integer(ip) :: stat
    first => this%hash_template_element_set%vec(1)
    call this%hash_template_element_set%get_next(first,this%current_node,stat)
    call this%hash_template_element_set%get_next(this%current_node,this%next_node,stat)
  end subroutine hash_template_element_iterator_begin

  !=============================================================================
  function hash_template_element_iterator_finished(this) result(res)
    implicit none
    class(hash_template_element_iterator_t), intent(inout) :: this
    logical :: res
    res = associated(this%next_node)
  end function hash_template_element_iterator_finished

  !=============================================================================
  subroutine hash_template_element_iterator_next (this)
    implicit none
    class(hash_template_element_iterator_t), intent(inout) :: this
    integer(ip) :: stat
    this%current_node => this%next_node
    call this%hash_template_element_set%get_next(this%current_node,this%next_node,stat)
  end subroutine hash_template_element_iterator_next
  !=============================================================================
  function hash_template_element_iterator_current (this) result(p)
    implicit none
    class(hash_template_element_iterator_t), intent(inout) :: this
    class(template_element_t)              , pointer       :: p
    p => this%current_node%val
  end function hash_template_element_iterator_current

  !=============================================================================
  subroutine hash_template_element_iterator_create_id(this,res)
    implicit none
    class(hash_template_element_iterator_t), intent(in)    :: this
    class(element_id_t)       , allocatable, intent(inout) :: res
    if(allocated(res)) deallocate(res)
    allocate(forest_element_id_t :: res)
  end subroutine hash_template_element_iterator_create_id
  !=============================================================================
  subroutine hash_template_element_iterator_free_id(this,res)
    implicit none
    class(hash_template_element_iterator_t), intent(in)    :: this
    class(element_id_t)       , allocatable, intent(inout) :: res
    if(allocated(res)) deallocate(res)
  end subroutine hash_template_element_iterator_free_id
  !=============================================================================
  subroutine hash_template_element_iterator_get_id(this,res)
    implicit none
    class(hash_template_element_iterator_t), intent(in)    :: this
    class(element_id_t)                    , intent(inout) :: res
    ! The following line gives an error using IFC 16. For this
    ! reason it is substituted by the select type below, even though
    ! the assignment of the abstract type is correct.
    !res = this%current_node%key
    select type(res)
    class is(forest_element_id_t)
       res = this%current_node%key
    class default
       write(*,*) 'Error calling hash_element_set%get_id'
       write(*,*) 'the id must be of type forest_element_id_t'
       check(.false.)
    end select
  end subroutine hash_template_element_iterator_get_id
  !=============================================================================
  function hash_template_element_iterator_get (this,id) result(p)
    implicit none
    class(hash_template_element_iterator_t), intent(in) :: this
    class(element_id_t)                    , intent(in) :: id
    class(template_element_t)              , pointer    :: p
    integer(ip) :: stat
    select type(id)
    class is(forest_element_id_t)
       call this%hash_template_element_set%get(id,p,stat)
       assert(stat==key_found)
    class default
       write(*,*) 'Error calling hash_element_iterator%get'
       write(*,*) 'the id must be of type forest_element_id_t'
       check(.false.)
    end select
  end function hash_template_element_iterator_get
