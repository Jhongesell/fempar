! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine fine_triangulation_generate_vefs(this,order,boundary,boundary_geometry,boundary_set)
  implicit none
  ! This routine assumes a triangulation with vertices and ghost elements
  ! Parameters
  class(fine_triangulation_t), intent(inout) :: this
  type(list_t), optional, intent(in) :: boundary
  integer(ip) , optional, intent(in) :: boundary_geometry(:)
  integer(ip) , optional, intent(in) :: boundary_set(:)
  integer(ip)                        :: order

  integer(ip)          , allocatable :: ptr_vertices(:)
  integer(ip)          , allocatable :: lst_vertices(:)
  type(cell_iterator_t)              :: cell_iterator
  type(cell_accessor_t)              :: icell
  type(cell_accessor_t)              :: jcell
  type(vef_accessor_t)               :: ivef_accessor

  type(position_hash_table_t) :: pos_ref_fe

  type(list_t), pointer    :: vertices_ivef
  type(list_t), pointer    :: vertices_jvef
  logical     :: equal
  integer(ip) :: istat, count, iboun, ivert, jvert, nnodb
  integer(ip) :: ielem, ivef, ielem_type, ielem_num_vertices
  integer(ip) :: ielem_num_vefs, ielem_first_vef_id, ielem_num_vef_verts
  integer(ip) :: vertex_of_ivef(4)
  integer(ip) :: jelpo, jelem, jvef, jelem_type, jelem_num_vertices
  integer(ip) :: jelem_num_vefs, jelem_first_vef_id, jelem_num_vef_verts
  integer(ip) :: vertex_of_jvef(4)
  type(list_iterator_t) :: vertices_ivef_iterator
  type(list_iterator_t) :: vertices_jvef_iterator
  type(list_iterator_t) :: boundary_iterator

  ! Get vertices from triangulation
  call memmovealloc(this%ptr_vefs_per_cell,ptr_vertices,__FILE__,__LINE__)
  call memmovealloc(this%lst_vefs_lids,lst_vertices,__FILE__,__LINE__)

  ! Build reference_fe_geo index and list:
  ! A scalar reference fe is used for the geometry as it is always interpolated
  ! using a Lagrangian type fe and nodal values are stored into a point_t array.
  call pos_ref_fe%init(max_num_elem_types)

  cell_iterator = this%create_cell_iterator()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(icell)
     ielem = icell%get_lid()
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     if ( istat == new_index ) then
        if(this%num_dimensions==2) then
           if(ielem_num_vertices==3) then ! Triangle
              this%reference_fe_geo_list(ielem_type) = &
                   &    make_reference_fe ( topology = topology_tet, fe_type = fe_type_lagrangian, &
                   &                        number_dimensions = this%num_dimensions, order = order, &
                   &                        field_type = field_type_scalar, continuity = .true. )
           else ! Quadrilateral
              this%reference_fe_geo_list(ielem_type) = &
                   &    make_reference_fe ( topology = topology_hex, fe_type = fe_type_lagrangian, &
                   &                        number_dimensions = this%num_dimensions, order = order, &
                   &                        field_type = field_type_scalar, continuity = .true. )
           end if
        else
           if(ielem_num_vertices==4) then ! Tetrahedra
              assert(.false.)
           else if(ielem_num_vertices==6) then ! Prism
              assert(.false.)
           else if(ielem_num_vertices==8) then ! Hexahedra
              assert(.false.)
           end if
        end if
     end if
     call cell_iterator%next()
  end do
  !write(*,*) 'Ref fe list done'
  !call this%reference_fe_geo_list(1)%p%print()

  ! Compute this%ptr_vefs_per_cell and allocate this%lst_vefs_lids
  call memalloc(this%num_local_cells + this%num_ghost_cells+1, this%ptr_vefs_per_cell, __FILE__, __LINE__ )
  !call memalloc(this%num_local_cells + this%num_ghost_cells+1, this%ptr_nodes_per_cell, __FILE__, __LINE__ )
  this%ptr_vefs_per_cell(1)=1
  !this%ptr_nodes_per_cell(1)=1
  call cell_iterator%init()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(icell)
     ielem = icell%get_lid()
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     assert(istat==old_index)
     this%ptr_vefs_per_cell(ielem+1)  = this%ptr_vefs_per_cell(ielem)  + this%reference_fe_geo_list(ielem_type)%p%get_number_vefs()
     !this%ptr_nodes_per_cell(ielem+1) = this%ptr_nodes_per_cell(ielem) + this%reference_fe_geo_list(ielem_type)%p%get_number_nodes()
     call cell_iterator%next()
  end do
  call memalloc(this%ptr_vefs_per_cell(this%num_local_cells + this%num_ghost_cells+1)-1, this%lst_vefs_lids , __FILE__, __LINE__ )
  this%lst_vefs_lids=0
  !write(*,*) 'ptr_vefs_per_cell done'
  !write(*,*) this%ptr_vefs_per_cell
  
  ! Fill vertices (dim 0 vefs)
  call cell_iterator%init()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(icell)
     ielem = icell%get_lid()
     !write(*,*) 'Element i:',ielem
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     assert(istat==old_index)
     ! Fill vefs (only vertices)
     this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem):this%ptr_vefs_per_cell(ielem)+ielem_num_vertices-1) = &
          & lst_vertices(ptr_vertices(ielem):ptr_vertices(ielem+1)-1)
     call cell_iterator%next()
  end do
  !write(*,*) 'Vertices filled'
  
  ! Fill dim 1 vefs (this%num_vefs = number of vertices at this point)
  ! they only have two vertices
  call cell_iterator%init()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(icell)
     ielem = icell%get_lid()
     !write(*,*) 'Element i:',ielem
     ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     assert(istat==old_index)
     ielem_num_vefs     = this%reference_fe_geo_list(ielem_type)%p%get_number_vefs_of_dimension(1)
     ielem_first_vef_id = this%reference_fe_geo_list(ielem_type)%p%get_first_vef_id_of_dimension(1)
     vertices_ivef => this%reference_fe_geo_list(ielem_type)%p%get_vertices_vef()
     !write(*,*) 'num edges, first edge',ielem_num_vefs,ielem_first_vef_id
     do ivef=1,ielem_num_vefs
        if(this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)==0) then ! Not filled yet
           ! Fill vef
           this%num_vefs=this%num_vefs+1                                                                ! Count it
           this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)=this%num_vefs  ! Fill it
           vertices_ivef_iterator = vertices_ivef%create_iterator(ielem_first_vef_id+ivef-1)
           vertex_of_ivef(1) = lst_vertices(ptr_vertices(ielem)-1+vertices_ivef_iterator%reach_from_current(0))
           vertex_of_ivef(2) = lst_vertices(ptr_vertices(ielem)-1+vertices_ivef_iterator%reach_from_current(1))
           !write(*,*) 'vertices of vef:',vertex_of_ivef(1:2)
           !write(*,*) 'Creating vef accessor for local vertex',vertex_of_ivef(1)
           !ivef_accessor = icell%get_vef(vertex_of_ivef(1))
           call ivef_accessor%create(vertex_of_ivef(1),this)
           !write(*,*) 'Created with ID:',ivef_accessor%lid
           !write(*,*) 'Num_cells_around:',ivef_accessor%get_num_cells_around()
           do jelpo = 1, ivef_accessor%get_num_cells_around()
              !write(*,*) 'Cell_around:',jelpo
              call ivef_accessor%get_cell_around(jelpo, jcell)
              !write(*,*) 'Calling get_lid'
              jelem = jcell%get_lid()
              !write(*,*) 'Element around i:',jelem
              if(jelem>ielem) then
                 jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
                 call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
                 assert(istat==old_index)
                 jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_vefs_of_dimension(1)
                 jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_vef_id_of_dimension(1)
                 vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_vef()
                 do jvef=1,jelem_num_vefs
                    vertices_jvef_iterator = vertices_ivef%create_iterator(jelem_first_vef_id+jvef-1)
                    vertex_of_jvef(1) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(0))
                    vertex_of_jvef(2) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(1))
                    !write(*,*) 'vertices of j:',vertex_of_jvef
                    ! Compare, here we are using that edges have two vertices, hard coded
                    equal = (vertex_of_ivef(1)==vertex_of_jvef(1).and.vertex_of_ivef(2)==vertex_of_jvef(2)).or. &
                         &  (vertex_of_ivef(1)==vertex_of_jvef(2).and.vertex_of_ivef(2)==vertex_of_jvef(1))
                    !write(*,*) 'Are equal:',equal
                    if(equal) then 
                       ! Fill vertices
                       this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)=this%num_vefs
                       exit
                    end if
                 end do
              end if
           end do
        end if
     end do
     call cell_iterator%next()
  end do

  ! These numbers (num_faces and num_edges) might not be necessary
  if(this%num_dimensions==2) then
     this%num_edges = 0
     this%num_faces=this%num_vefs-this%num_vertices
     !write(*,*) '2D faces filled',this%num_faces
  else if(this%num_dimensions==3) then
     this%num_edges=this%num_vefs-this%num_vertices
     !write(*,*) '3D edges filled',this%num_edges

     ! Fill dim 2 vefs (the code is similar to that of dim 1 vefs,
     ! except for the number of vertices of each vef, that is variable)
     call cell_iterator%init()
     do while ( .not. cell_iterator%has_finished() )
        call cell_iterator%current(icell)
        ielem = icell%get_lid()
        !write(*,*) 'Element i:',ielem
        ielem_num_vertices = ptr_vertices(ielem+1)-ptr_vertices(ielem)
        call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
        assert(istat==old_index)
        ielem_num_vefs      = this%reference_fe_geo_list(ielem_type)%p%get_number_vefs_of_dimension(2)
        ielem_first_vef_id  = this%reference_fe_geo_list(ielem_type)%p%get_first_vef_id_of_dimension(2)
        do ivef=1,ielem_num_vefs
           if(this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)==0) then ! Not filled yet
              this%num_vefs=this%num_vefs+1                                       ! Count it
              this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem)-1+ielem_first_vef_id-1+ivef)=this%num_vefs ! Fill it
              ielem_num_vef_verts = this%reference_fe_geo_list(ielem_type)%p%get_number_vertices_vef(ielem_first_vef_id+ivef-1)
              vertices_ivef => this%reference_fe_geo_list(ielem_type)%p%get_vertices_vef()
              vertices_ivef_iterator = vertices_ivef%create_iterator(ielem_first_vef_id+ivef-1)
              vertex_of_ivef = 0
              do ivert=1,ielem_num_vef_verts
                 vertex_of_ivef(ivert)=lst_vertices( ptr_vertices(ielem)-1+vertices_ivef_iterator%get_current())
                 call vertices_ivef_iterator%next()
              end do
              !ivef_accessor = icell%get_vef(vertex_of_ivef(1))
              call ivef_accessor%create(vertex_of_ivef(1),this)
              do jelpo = 1, ivef_accessor%get_num_cells_around()
                 call ivef_accessor%get_cell_around(jelpo, jcell)
                 jelem = jcell%get_lid()
                 if(jelem>ielem) then
                    jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
                    call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
                    assert(istat==old_index)
                    jelem_num_vefs      = this%reference_fe_geo_list(jelem_type)%p%get_number_vefs_of_dimension(2)
                    jelem_first_vef_id  = this%reference_fe_geo_list(jelem_type)%p%get_first_vef_id_of_dimension(2)
                    vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_vef()
                    do jvef=1,jelem_num_vefs
                       jelem_num_vef_verts = this%reference_fe_geo_list(jelem_type)%p%get_number_vertices_vef(jelem_first_vef_id+jvef-1)
                       if(jelem_num_vef_verts==ielem_num_vef_verts) then
                          vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                          vertex_of_jvef = 0
                          do jvert=1,jelem_num_vef_verts
                             vertex_of_jvef(jvert)=lst_vertices( ptr_vertices(jelem)-1+vertices_jvef_iterator%get_current())
                             call vertices_jvef_iterator%next()
                          end do
                          count=0
                          do ivert=1,ielem_num_vef_verts
                             do jvert=1,jelem_num_vef_verts
                                if(vertex_of_ivef(ivert)==vertex_of_jvef(jvert)) then
                                   count=count+1
                                   exit
                                end if
                             end do
                          end do
                          equal=(count==ielem_num_vef_verts)
                          if(equal) then ! Fill it
                             this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)=this%num_vefs
                             exit
                          end if
                       end if
                    end do
                 end if
              end do
           end if
        end do
        call cell_iterator%next()
     end do
     this%num_faces=this%num_vefs-this%num_vertices-this%num_edges
  end if
  !write(*,*) this%lst_vefs_lids

  if(present(boundary)) then
     assert(present(boundary_geometry))
     assert(present(boundary_set))
     !write(*,*) boundary%get_size(), boundary%get_num_pointers()
     assert(size(boundary_geometry)==boundary%get_num_pointers())
     assert(size(boundary_set)==boundary%get_num_pointers())

     ! Identify boundary faces and assign set and geometry to vefs
     call memalloc(this%num_vefs, this%vefs_geometry, __FILE__, __LINE__ )
     call memalloc(this%num_vefs, this%vefs_set, __FILE__, __LINE__ )
     this%vefs_geometry=0
     this%vefs_set=0

     do iboun=1,boundary%get_num_pointers()
        boundary_iterator = boundary%create_iterator(iboun)
        nnodb=boundary%get_sublist_size(iboun)
        !write(*,*) iboun,nnodb
        if(nnodb==1) then      ! Vertex
           ivert=boundary_iterator%reach_from_current(0)
           this%vefs_geometry(ivert)=boundary_geometry(iboun)
           this%vefs_set(ivert)=boundary_set(iboun)
        else if(nnodb==2) then ! Edge
           vertex_of_ivef(1) = boundary_iterator%reach_from_current(0)
           vertex_of_ivef(2) = boundary_iterator%reach_from_current(1)
           call ivef_accessor%create(vertex_of_ivef(1),this)
           elems1: do jelpo = 1, ivef_accessor%get_num_cells_around()
              call ivef_accessor%get_cell_around(jelpo, jcell)
              jelem = jcell%get_lid()
              jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
              call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
              assert(istat==old_index)
              jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_vefs_of_dimension(1)
              jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_vef_id_of_dimension(1)
              vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_vef()
              do jvef=1,jelem_num_vefs
                 vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                 vertex_of_jvef(1) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(0))
                 vertex_of_jvef(2) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(1))
                 ! Compare, here we are using that edges have two vertices, hard coded
                 equal = (vertex_of_ivef(1)==vertex_of_jvef(1).and.vertex_of_ivef(2)==vertex_of_jvef(2)).or. &
                      &  (vertex_of_ivef(1)==vertex_of_jvef(2).and.vertex_of_ivef(2)==vertex_of_jvef(1))
                 if(equal) then ! Fill it
                    this%vefs_geometry( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = boundary_geometry(iboun)
                    this%vefs_set( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = boundary_set(iboun)
                    exit elems1
                 end if
              end do
           end do elems1
        else                   ! Face
           ivert=boundary_iterator%reach_from_current(0)
           vertex_of_ivef = 0
           do ivert=1,nnodb
              vertex_of_ivef(ivert)= boundary_iterator%get_current()
              call boundary_iterator%next()
           end do
           call ivef_accessor%create(vertex_of_ivef(1),this)
           elems2: do jelpo = 1, ivef_accessor%get_num_cells_around()
              call ivef_accessor%get_cell_around(jelpo, jcell)
              jelem = jcell%get_lid()
              jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
              call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
              assert(istat==old_index)
              jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_vefs_of_dimension(2)
              jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_vef_id_of_dimension(2)
              vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_vef()
              do jvef=1,jelem_num_vefs
                 jelem_num_vef_verts = this%reference_fe_geo_list(jelem_type)%p%get_number_vertices_vef(jelem_first_vef_id+jvef-1)
                 vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                 if(jelem_num_vef_verts==nnodb) then
                    vertex_of_jvef = 0
                    do jvert=1,jelem_num_vef_verts
                       vertex_of_jvef(jvert)=lst_vertices( ptr_vertices(jelem)-1+vertices_jvef_iterator%get_current())
                       call vertices_jvef_iterator%next()
                    end do
                    count=0
                    do ivert=1,ielem_num_vef_verts
                       do jvert=1,jelem_num_vef_verts
                          if(vertex_of_ivef(ivert)==vertex_of_jvef(jvert)) then
                             count=count+1
                             exit
                          end if
                       end do
                    end do
                    equal=(count==ielem_num_vef_verts)
                    if(equal) then ! Fill it
                       this%vefs_geometry( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = boundary_geometry(iboun)
                       this%vefs_set( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = boundary_set(iboun)
                       exit elems2
                    end if
                 end if
              end do
           end do elems2
        end if
     end do
     !write(*,*) this%vefs_geometry,this%vefs_set
  end if

  ! Generate the ref fe position hash table using the number of vefs (instead of vertices) as keys
  call  this%reference_fe_geo_index%init(max_num_elem_types)
  if(this%num_dimensions==3) then
     ! Tetrahedra
     ielem_num_vertices=4
     ielem_num_vefs=16
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=ielem_type,stat=istat)
        assert(istat==now_stored)
     end if
     ! Prisms
     ielem_num_vertices=6
     ielem_num_vefs=20
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=ielem_type,stat=istat)
        assert(istat==now_stored)
     end if
     ! Hexahedra
     ielem_num_vertices=8
     ielem_num_vefs=22
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=ielem_type,stat=istat)
        assert(istat==now_stored)
     end if
  else if(this%num_dimensions==2) then
     ! Triangle
     ielem_num_vertices=3
     ielem_num_vefs =6
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=ielem_type,stat=istat)
        assert(istat==now_stored)
     end if
     ! Quad
     ielem_num_vertices=4
     ielem_num_vefs =8
     call pos_ref_fe%get(key=ielem_num_vertices,val=ielem_type,stat=istat)
     if(istat==old_index) then
        call this%reference_fe_geo_index%put(key=ielem_num_vefs,val=ielem_type,stat=istat)
        assert(istat==now_stored)
     end if
  end if

end subroutine fine_triangulation_generate_vefs

subroutine fine_triangulation_allocate_and_fill_geometry_and_set(this,given_vefs,vefs_geometry,vefs_set)
  implicit none
  ! This routine assumes a triangulation with vertices and ghost elements
  ! Parameters
  class(fine_triangulation_t), intent(inout) :: this
  type(list_t), intent(in) :: given_vefs
  integer(ip) , intent(in) :: vefs_geometry(:)
  integer(ip) , intent(in) :: vefs_set(:)
  integer(ip)                        :: order

  type(cell_iterator_t)              :: cell_iterator
  type(cell_accessor_t)              :: icell
  type(cell_accessor_t)              :: jcell
  type(vef_accessor_t)               :: ivef_accessor

  type(list_t), pointer    :: vertices_ivef
  type(list_t), pointer    :: vertices_jvef
  logical     :: equal
  integer(ip) :: istat, count, iboun, ivert, jvert, nnodb
  integer(ip) :: ielem, ivef, ielem_type, ielem_num_vertices
  integer(ip) :: ielem_num_vefs, ielem_first_vef_id, ielem_num_vef_verts
  integer(ip) :: vertex_of_ivef(4)
  integer(ip) :: jelpo, jelem, jvef, jelem_type, jelem_num_vertices
  integer(ip) :: jelem_num_vefs, jelem_first_vef_id, jelem_num_vef_verts
  integer(ip) :: vertex_of_jvef(4)
  type(list_iterator_t) :: vertices_ivef_iterator
  type(list_iterator_t) :: vertices_jvef_iterator
  type(list_iterator_t) :: given_vefs_iterator

     assert(size(vefs_geometry)==given_vefs%get_num_pointers())
     assert(size(vefs_set)==given_vefs%get_num_pointers())

     call this%free_geometry_and_set()

     ! Identify boundary faces and assign set and geometry to vefs
     call memalloc(this%num_vefs, this%vefs_geometry, __FILE__, __LINE__ )
     call memalloc(this%num_vefs, this%vefs_set, __FILE__, __LINE__ )
     this%vefs_geometry=0
     this%vefs_set=0

     do iboun=1,given_vefs%get_num_pointers()
        given_vefs_iterator = given_vefs%create_iterator(iboun)
        nnodb=given_vefs%get_sublist_size(iboun)
        !write(*,*) iboun,nnodb
        if(nnodb==1) then      ! Vertex
           ivert=given_vefs_iterator%reach_from_current(0)
           this%vefs_geometry(ivert)=vefs_geometry(iboun)
           this%vefs_set(ivert)=vefs_set(iboun)
        else if(nnodb==2) then ! Edge
           vertex_of_ivef(1) = given_vefs_iterator%reach_from_current(0)
           vertex_of_ivef(2) = given_vefs_iterator%reach_from_current(1)
           call ivef_accessor%create(vertex_of_ivef(1),this)
           elems1: do jelpo = 1, ivef_accessor%get_num_cells_around()
              call ivef_accessor%get_cell_around(jelpo, jcell)
              jelem = jcell%get_lid()
              !jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
              !call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
              !assert(istat==old_index)
              call this%reference_fe_geo_index%get(key=jcell%get_num_vefs(),val=jelem_type,stat=istat)
              assert(istat==key_found)
              jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_vefs_of_dimension(1)
              jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_vef_id_of_dimension(1)
              vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_vef()
              do jvef=1,jelem_num_vefs
                 vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                 !vertex_of_jvef(1) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(0))
                 !vertex_of_jvef(2) = lst_vertices(ptr_vertices(jelem)-1+vertices_jvef_iterator%reach_from_current(1))
                 vertex_of_jvef(1) = this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+vertices_jvef_iterator%reach_from_current(0))
                 vertex_of_jvef(2) = this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+vertices_jvef_iterator%reach_from_current(1))
                 ! Compare, here we are using that edges have two vertices, hard coded
                 equal = (vertex_of_ivef(1)==vertex_of_jvef(1).and.vertex_of_ivef(2)==vertex_of_jvef(2)).or. &
                      &  (vertex_of_ivef(1)==vertex_of_jvef(2).and.vertex_of_ivef(2)==vertex_of_jvef(1))
                 if(equal) then ! Fill it
                    this%vefs_geometry( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_geometry(iboun)
                    this%vefs_set( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_set(iboun)
                    exit elems1
                 end if
              end do
           end do elems1
        else                   ! Face
           ivert=given_vefs_iterator%reach_from_current(0)
           vertex_of_ivef = 0
           do ivert=1,nnodb
              vertex_of_ivef(ivert)= given_vefs_iterator%get_current()
              call given_vefs_iterator%next()
           end do
           call ivef_accessor%create(vertex_of_ivef(1),this)
           elems2: do jelpo = 1, ivef_accessor%get_num_cells_around()
              call ivef_accessor%get_cell_around(jelpo, jcell)
              jelem = jcell%get_lid()
              !jelem_num_vertices=ptr_vertices(jelem+1)-ptr_vertices(jelem)
              !call pos_ref_fe%get(key=jelem_num_vertices,val=jelem_type,stat=istat)
              !assert(istat==old_index)
              call this%reference_fe_geo_index%get(key=jcell%get_num_vefs(),val=jelem_type,stat=istat)
              assert(istat==key_found)
              jelem_num_vefs     = this%reference_fe_geo_list(jelem_type)%p%get_number_vefs_of_dimension(2)
              jelem_first_vef_id = this%reference_fe_geo_list(jelem_type)%p%get_first_vef_id_of_dimension(2)
              vertices_jvef => this%reference_fe_geo_list(jelem_type)%p%get_vertices_vef()
              do jvef=1,jelem_num_vefs
                 jelem_num_vef_verts = this%reference_fe_geo_list(jelem_type)%p%get_number_vertices_vef(jelem_first_vef_id+jvef-1)
                 vertices_jvef_iterator = vertices_jvef%create_iterator(jelem_first_vef_id+jvef-1)
                 if(jelem_num_vef_verts==nnodb) then
                    vertex_of_jvef = 0
                    do jvert=1,jelem_num_vef_verts
                       vertex_of_jvef(jvert)=this%lst_vefs_lids( this%ptr_vefs_per_cell(jelem)-1+vertices_jvef_iterator%get_current())
                       call vertices_jvef_iterator%next()
                    end do
                    count=0
                    do ivert=1,ielem_num_vef_verts
                       do jvert=1,jelem_num_vef_verts
                          if(vertex_of_ivef(ivert)==vertex_of_jvef(jvert)) then
                             count=count+1
                             exit
                          end if
                       end do
                    end do
                    equal=(count==ielem_num_vef_verts)
                    if(equal) then ! Fill it
                       this%vefs_geometry( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_geometry(iboun)
                       this%vefs_set( this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem)-1+jelem_first_vef_id-1+jvef)  ) = vefs_set(iboun)
                       exit elems2
                    end if
                 end if
              end do
           end do elems2
        end if
     end do
     !write(*,*) this%vefs_geometry,this%vefs_set

     
     
end subroutine fine_triangulation_allocate_and_fill_geometry_and_set

subroutine fine_triangulation_free_geometry_and_set( this )
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  if (allocated(this%vefs_geometry)) call memfree(this%vefs_geometry,__FILE__,__LINE__)
  if (allocated(this%vefs_set))      call memfree(this%vefs_set,__FILE__,__LINE__)
end subroutine fine_triangulation_free_geometry_and_set

subroutine fine_triangulation_allocate_and_fill_vef_type (this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)           :: ivef, icell ! , vef_lid, cell_num_vertices, cell_num_edges, cell_num_vefs
  integer(ip)           :: cell_type, istat
  type(cell_accessor_t) :: cell
  type(vef_iterator_t)  :: vef_iterator
  type(vef_accessor_t)  :: vef, vef_of_vef
  type(list_t), pointer :: vefs_of_vef
  type(list_iterator_t) :: vefs_of_vef_iterator
  class(reference_fe_t), pointer :: reference_fe_geo
  
  integer(ip) :: ivef_pos_in_cell, vef_of_vef_pos_in_cell, cell_num_vefs_of_dim0, cell_num_vefs_of_dim1
  logical     :: vef_is_local, vef_is_ghost

  assert ( this%num_vefs >= 0 )
  call this%free_vefs_type()
  call memalloc(this%num_vefs, this%vefs_type,__FILE__,__LINE__) 

  this%num_itfc_vefs = 0
  vef_iterator = this%create_vef_iterator()
  do while ( .not. vef_iterator%has_finished() )
     call vef_iterator%current(vef)
     ivef = vef%get_lid()
     vef_is_local = .true.
     vef_is_ghost = .true.

     call vef%get_cell_around(1,cell) ! There is always one cell around
     call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=cell_type,stat=istat)
     assert(istat==key_found)
     reference_fe_geo => this%reference_fe_geo_list(cell_type)%p

     cell_num_vefs_of_dim0   = reference_fe_geo%get_number_vefs_of_dimension(0)
     cell_num_vefs_of_dim1   = reference_fe_geo%get_number_vefs_of_dimension(1)
     ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
     if(ivef_pos_in_cell<=cell_num_vefs_of_dim0) then
        call vef%set_dimension(0)
     else if(ivef_pos_in_cell<=cell_num_vefs_of_dim0+cell_num_vefs_of_dim1) then
        call vef%set_dimension(1)
     else
        call vef%set_dimension(2)
     end if
     
     if(cell%is_ghost()) then
        vef_is_local = .false.
     else if(cell%is_local()) then
        vef_is_ghost = .false.
     end if

     if(vef%get_num_cells_around()==1) then ! vef is on the boundary
        if( vef%get_dimension() == this%num_dimensions-1 ) then ! It is a face
           call vef%set_it_at_boundary()
           vefs_of_vef => reference_fe_geo%get_vefs_vef()
           ! They are also at the boundary, regardless of the number of cells they have around
           vefs_of_vef_iterator = vefs_of_vef%create_iterator(ivef_pos_in_cell)
           do while( .not. vefs_of_vef_iterator%is_upper_bound() )
              vef_of_vef_pos_in_cell = vefs_of_vef_iterator%get_current()
              call cell%get_vef(vef_of_vef_pos_in_cell, vef_of_vef)
              call vef_of_vef%set_it_at_boundary()
              call vefs_of_vef_iterator%next()
           end do
        end if
     else
        do icell = 1, vef%get_num_cells_around()
           call vef%get_cell_around(icell,cell)
           if(cell%is_ghost()) then
              vef_is_local = .false.
           else if(cell%is_local()) then
              vef_is_ghost = .false.
           end if
        end do
     end if
     if(vef_is_local) then
        call vef%set_it_as_local()
     else if(vef_is_ghost) then
        call vef%set_it_as_ghost()
     else
        this%num_itfc_vefs = this%num_itfc_vefs + 1
        call vef%set_it_at_interface()
     end if
     call vef_iterator%next()
  end do

end subroutine fine_triangulation_allocate_and_fill_vef_type

subroutine fine_triangulation_find_vefs_at_boundary (this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)           :: ivef 
  integer(ip)           :: cell_type, istat
  type(cell_accessor_t) :: cell
  type(vef_iterator_t)  :: vef_iterator
  type(vef_accessor_t)  :: vef, vef_of_vef
  type(list_t), pointer :: vefs_of_vef
  type(list_iterator_t) :: vefs_of_vef_iterator
  class(reference_fe_t), pointer :: reference_fe_geo
  
  integer(ip) :: ivef_pos_in_cell, vef_of_vef_pos_in_cell, vef_set_id, vef_geom_id

  assert ( this%num_vefs >= 0 )
  assert ( allocated(this%vefs_type))

  vef_iterator = this%create_vef_iterator()
  do while ( .not. vef_iterator%has_finished() )
     call vef_iterator%current(vef)
     ivef = vef%get_lid()

     call vef%get_cell_around(1,cell) ! There is always one cell around
     call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=cell_type,stat=istat)
     assert(istat==key_found)
     reference_fe_geo => this%reference_fe_geo_list(cell_type)%p

     ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
     
     if(vef%get_num_cells_around()==1) then ! vef is on the boundary
        if( vef%get_dimension() == this%num_dimensions-1 ) then ! It is a face
           call vef%set_it_at_boundary()
           vef_set_id = vef%get_set_id()
           !vef_geom_id = vef%get_geom_id()
           vefs_of_vef => reference_fe_geo%get_vefs_vef()
           ! They are also at the boundary, regardless of the number of cells they have around
           vefs_of_vef_iterator = vefs_of_vef%create_iterator(ivef_pos_in_cell)
           do while( .not. vefs_of_vef_iterator%is_upper_bound() )
              vef_of_vef_pos_in_cell = vefs_of_vef_iterator%get_current()
              call cell%get_vef(vef_of_vef_pos_in_cell, vef_of_vef)
              call vef_of_vef%set_it_at_boundary()
              !write(*,*) 'Boundary face', vef%get_lid(), vef_set_id, 'vef', vef_of_vef%get_lid(), vef_of_vef%get_set_id()
              if( vef_of_vef%get_set_id() == 0) then
                 call vef_of_vef%set_set_id(vef_set_id)
                 !call vef_of_vef%set_geom_id(vef_geom_id)
              end if
              call vefs_of_vef_iterator%next()
           end do
        end if
     end if
     call vef_iterator%next()
  end do

end subroutine fine_triangulation_find_vefs_at_boundary

subroutine fine_triangulation_compute_vefs_dimension (this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)           :: ivef
  integer(ip)           :: cell_type, istat
  type(cell_accessor_t) :: cell
  type(vef_iterator_t)  :: vef_iterator
  type(vef_accessor_t)  :: vef
  class(reference_fe_t), pointer :: reference_fe_geo
  
  integer(ip) :: ivef_pos_in_cell, cell_num_vefs_of_dim0, cell_num_vefs_of_dim1

  assert ( this%num_vefs >= 0 )
  call this%free_vefs_type()
  call memalloc(this%num_vefs, this%vefs_type,__FILE__,__LINE__) 
  this%vefs_type = 0

  vef_iterator = this%create_vef_iterator()
  do while ( .not. vef_iterator%has_finished() )
     call vef_iterator%current(vef)
     ivef = vef%get_lid()

     call vef%get_cell_around(1,cell) ! There is always one cell around
     call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=cell_type,stat=istat)
     assert(istat==key_found)
     reference_fe_geo => this%reference_fe_geo_list(cell_type)%p

     cell_num_vefs_of_dim0   = reference_fe_geo%get_number_vefs_of_dimension(0)
     cell_num_vefs_of_dim1   = reference_fe_geo%get_number_vefs_of_dimension(1)
     ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
     if(ivef_pos_in_cell<=cell_num_vefs_of_dim0) then
        call vef%set_dimension(0)
     else if(ivef_pos_in_cell<=cell_num_vefs_of_dim0+cell_num_vefs_of_dim1) then
        call vef%set_dimension(1)
     else
        call vef%set_dimension(2)
     end if
     call vef_iterator%next()
  end do

end subroutine fine_triangulation_compute_vefs_dimension

subroutine fine_triangulation_allocate_and_fill_nodes(this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  integer(ip)           :: icell 
  integer(ip)           :: cell_type, istat
  type(cell_accessor_t) :: cell
  type(cell_iterator_t) :: cell_iterator
  type(vef_iterator_t)  :: vef_iterator
  type(vef_accessor_t)  :: vef
  class(reference_fe_t), pointer :: reference_fe_geo

  integer(ip) :: ivef, ielem, jelem, jelem_type, ivef_pos_in_cell, jvef_pos_in_cell, cell_num_vertices

  ! Compute header and allocate array
  call this%free_nodes()
  call memalloc(this%num_local_cells + this%num_ghost_cells+1, this%ptr_nodes_per_cell, __FILE__, __LINE__ )

  this%ptr_nodes_per_cell(1)=1
  cell_iterator = this%create_cell_iterator()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(cell)
     call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=cell_type,stat=istat)
     assert(istat==key_found)
     ielem = cell%get_lid()
     this%ptr_nodes_per_cell(ielem+1) = this%ptr_nodes_per_cell(ielem) + this%reference_fe_geo_list(cell_type)%p%get_number_nodes()
     call cell_iterator%next()
  end do
  call memalloc(this%ptr_nodes_per_cell(this%num_local_cells + this%num_ghost_cells+1)-1, this%lst_nodes , __FILE__, __LINE__ )
  this%lst_nodes=0
  !write(*,*) 'Heade ptr_nodes_per_cell computed:'
  !write(*,*) this%ptr_nodes_per_cell

  ! Set nodes on vertices (with id = id of the vertex)
  call cell_iterator%init()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(cell)
     if ( cell%is_local() ) then
       call cell%fill_nodes_on_vertices()
     end if  
     call cell_iterator%next()
  end do
  this%num_nodes=this%num_vertices
  
  vef_iterator = this%create_vef_iterator()
  do while ( .not. vef_iterator%has_finished() )
     call vef_iterator%current(vef)
     if( (vef%get_dimension()>0) .and. (.not.vef%is_ghost()) ) then
        ivef = vef%get_lid()

        call vef%get_cell_around(1,cell) ! There is always one cell around
        
        ! The first cell around a local or interface vef is always local provided
        ! that we first enumerate local, followed by ghost cells, and how the dual
        ! mesh is computed (from 1st to last cell).
        assert ( cell%is_local() )
        
        ielem = cell%get_lid()
        call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=cell_type,stat=istat)
        assert(istat==key_found)
        reference_fe_geo => this%reference_fe_geo_list(cell_type)%p
        ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
        ! Fill vef nodes (new numbers)
        call fill_new_nodes_on_vef(reference_fe_geo, &
             &                     ivef_pos_in_cell, &
             &                     this%lst_nodes(this%ptr_nodes_per_cell(ielem):this%ptr_nodes_per_cell(ielem+1)-1),&
             &                     this%num_nodes)

        do icell = 2, vef%get_num_cells_around()
           call vef%get_cell_around(icell,cell)
           if ( cell%is_local() ) then
             jelem = cell%get_lid()
             call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=jelem_type,stat=istat)
             assert(istat==key_found)
             jvef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
             call fill_nodes_on_vef_from_source_element ( &
                  ! Source
                  & reference_fe_geo, &
                  & ivef_pos_in_cell, &
                  & this%lst_vefs_lids(this%ptr_vefs_per_cell(ielem) :this%ptr_vefs_per_cell(ielem+1)-1), &
                  & this%lst_nodes    (this%ptr_nodes_per_cell(ielem):this%ptr_nodes_per_cell(ielem+1)-1), &
                  ! Target
                  & this%reference_fe_geo_list(jelem_type)%p, &
                  & jvef_pos_in_cell, &
                  & this%lst_vefs_lids(this%ptr_vefs_per_cell(jelem) :this%ptr_vefs_per_cell(jelem+1)-1), &
                  & this%lst_nodes    (this%ptr_nodes_per_cell(jelem):this%ptr_nodes_per_cell(jelem+1)-1))
           end if 
        end do
     end if
     call vef_iterator%next()
  end do

  ! Fill nodes on volume
  call cell_iterator%init()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(cell)
     if ( cell%is_local() ) then
       call this%reference_fe_geo_index%get(key=cell%get_num_vefs(),val=cell_type,stat=istat)
       assert(istat==key_found)
       ielem = cell%get_lid()
       !write(*,*) 'Element i:',ielem
       ! Fill interior nodes (new numbers)
       call fill_internal_new_nodes(this%reference_fe_geo_list(cell_type)%p, &
            &                       this%lst_nodes(this%ptr_nodes_per_cell(ielem):this%ptr_nodes_per_cell(ielem+1)-1),&
            &                       this%num_nodes)
      end if 
      call cell_iterator%next()  
  end do

  !write(*,*) this%num_nodes

end subroutine fine_triangulation_allocate_and_fill_nodes

subroutine fine_triangulation_free_nodes (this)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  if (allocated (this%ptr_nodes_per_cell)) call memfree ( this%ptr_nodes_per_cell, __FILE__, __LINE__ )
  if (allocated (this%lst_nodes)) call memfree ( this%lst_nodes, __FILE__, __LINE__ )
end subroutine fine_triangulation_free_nodes

subroutine fill_internal_new_nodes(reference_fe,node_list,node_count)
  implicit none
  ! Parameters
  class(reference_fe_t)  , intent(in)    :: reference_fe
  integer(ip)           , intent(inout) :: node_list(:)
  integer(ip)           , intent(inout) :: node_count
  
  ! Local variables
  integer(ip) :: inode, l_node, ivef
  
  ivef = reference_fe%get_number_vefs()+1 ! volume
  do inode = 1, reference_fe%get_number_own_nodes_vef(ivef)
     l_node = reference_fe%get_own_node_vef(inode,ivef)
     node_count = node_count +1
     node_list(l_node) = node_count
  end do

end subroutine fill_internal_new_nodes

subroutine fill_new_nodes_on_vef (reference_fe,vef_local_id, node_list, node_count )
  implicit none
  ! Parameters
  class(reference_fe_t) , intent(in)    :: reference_fe
  integer(ip)           , intent(in)    :: vef_local_id
  integer(ip)           , intent(inout) :: node_list(:)
  integer(ip)           , intent(inout) :: node_count

  ! Local variables
  integer(ip) :: inode, l_node

  !write(*,*) vef_local_id, reference_fe%get_number_own_nodes_vef(vef_local_id)
  !write(*,*) node_list

  do inode = 1,reference_fe%get_number_own_nodes_vef(vef_local_id)
    l_node = reference_fe%get_own_node_vef(inode,vef_local_id)
    !write(*,*) l_node
    assert ( node_list(l_node) <= 0 )
    if ( node_list(l_node) == 0 ) then
      node_count = node_count + 1
      node_list(l_node) = node_count
    end	if
  end do
end subroutine fill_new_nodes_on_vef

subroutine fill_nodes_on_vertices (reference_fe, vertex_list, node_list)
  implicit none
  ! Parameters
  class(reference_fe_t) , intent(in)    :: reference_fe
  integer(ip)           , intent(in)    :: vertex_list(:)
  integer(ip)           , intent(inout) :: node_list(:)
  type(vef_accessor_t) :: vef

  ! Local variables
  integer(ip) :: ivef, inode, l_node, node_count, ndime

  ndime = reference_fe%get_number_dimensions()
  do ivef=1,reference_fe%get_number_vefs_of_dimension(0)
     assert(reference_fe%get_number_own_nodes_vef(ivef)==1)

     l_node = reference_fe%get_own_node_vef(1,ivef)
     node_list(l_node) = vertex_list(ivef)
  end do

end subroutine fill_nodes_on_vertices

subroutine fill_nodes_on_vef_from_source_element ( source_ref_fe,    &
                                                   source_vef_lid,   &
                                                   source_vefs,      &
                                                   source_node_list, &
                                                   target_ref_fe,    &  
                                                   target_vef_lid,   &
                                                   target_vefs,      &
                                                   target_node_list)
  implicit none
  ! Parameters
  class(reference_fe_t) , intent(in)    :: source_ref_fe
  integer(ip)           , intent(in)    :: source_vef_lid
  integer(ip)           , intent(in)    :: source_vefs(:)
  integer(ip)           , intent(in)    :: source_node_list(:)

  class(reference_fe_t) , intent(in)    :: target_ref_fe
  integer(ip)           , intent(in)    :: target_vef_lid
  integer(ip)           , intent(in)    :: target_vefs(:) 
  integer(ip)           , intent(inout) :: target_node_list(:)

  ! Local variables
  integer(ip) :: own_inode, l_node, own_nnode, inode_source, inode_target
  integer(ip) :: relative_orientation, relative_rotation


  assert(size(source_vefs)==source_ref_fe%get_number_vefs())
  assert(size(target_vefs)==target_ref_fe%get_number_vefs())

  own_nnode = source_ref_fe%get_number_own_nodes_vef(source_vef_lid)

  if ( own_nnode > 0 ) then

     check (target_ref_fe%check_compatibility_of_vefs(source_ref_fe,source_vef_lid,target_vef_lid))
     relative_rotation = target_ref_fe%compute_relative_rotation( source_ref_fe,                  &
          &                                        source_vef_lid,                                &
          &                                        target_vef_lid,                                &
          &                                        source_vefs,                                   &
          &                                        target_vefs)

     relative_orientation = target_ref_fe%compute_relative_orientation( source_ref_fe,            &
          &                                           source_vef_lid,                             &
          &                                           target_vef_lid)
     
     do own_inode = 1, own_nnode
        inode_source = source_ref_fe%get_own_node_vef(own_inode,source_vef_lid)
        inode_target = target_ref_fe%get_permuted_own_node_vef(own_inode,               &
             &                          target_vef_lid, relative_orientation,relative_rotation)
        assert ( target_node_list(inode_target) <= 0 )
        if ( target_node_list(inode_target) == 0 ) then
          target_node_list(inode_target) = source_node_list(inode_source)
        end if
    end do 
 end if
 
end subroutine fill_nodes_on_vef_from_source_element

subroutine fine_triangulation_allocate_and_fill_coordinates(this,vertices_coordinates)
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  real(rp)                          , intent(in)    :: vertices_coordinates(:,:)
  type(cell_iterator_t)     :: cell_iterator
  type(cell_accessor_t)     :: cell
  type(vertex_iterator_t) :: vertices_iterator
  type(edge_iterator_t)    :: edges_iterator
  type(face_iterator_t)    :: faces_iterator
  type(vef_accessor_t)      :: vef
  type(line_t), pointer     :: line
  type(list_t), pointer     :: vertices_of_vefs
  integer(ip)   :: istat, inode, l_node, order
  integer(ip)   :: vertex1, vertex2, ivef_pos_in_cell, ivef 
  integer(ip)   :: cell_num_vefs, cell_num_nodes, cell_type
  integer(ip)   :: face_num_nodes
  type(point_t) :: point1,point2
  real(rp)      :: u_param1, u_param2, param, u_param
  type(point_t), allocatable :: coordinates(:)
  type(list_iterator_t) :: vertices_of_vefs_iterator
  
  call this%free_coordinates()
  call memalloc(this%num_nodes,this%coordinates,__FILE__,__LINE__)
  
  ! Store coordinates of vertices
  vertices_iterator = this%create_vertex_iterator()
  do while ( .not. vertices_iterator%has_finished() )
     call vertices_iterator%current(vef)
     ivef = vef%get_lid()
     call this%coordinates(ivef)%init(vertices_coordinates(:,ivef))
     call vertices_iterator%next()
  end do
  
  ! In the case of a linear (i.e., order == 1) interpolation of the
  ! geometry, skip the rest of steps where the this%geometry member
  ! variable is involved
  order = this%reference_fe_geo_list(1)%p%get_order() 
  if (order == 1) return

   ! High order interpolation is only working in 2D
   assert(this%num_dimensions==2) 

  ! Allocate local coordinates for faces
  call memalloc(order+1, coordinates, __FILE__,__LINE__)
   
  !write(*,*) 'Starting face loop'
  faces_iterator = this%create_face_iterator()
  do while ( .not. faces_iterator%has_finished() )
     call faces_iterator%current(vef)
     if ( .not. vef%is_ghost() ) then
        ivef = vef%get_lid()

        call vef%get_cell_around (1, cell) ! there is always one element around
        ivef_pos_in_cell = cell%find_lpos_vef_lid(ivef)
        cell_num_vefs = cell%get_num_vefs()
        call this%reference_fe_geo_index%get(key=cell_num_vefs,val=cell_type,stat=istat)
        assert(istat==key_found)
        vertices_of_vefs => this%reference_fe_geo_list(cell_type)%p%get_vertices_vef()
        face_num_nodes = this%reference_fe_geo_list(cell_type)%p%get_number_own_nodes_vef(ivef_pos_in_cell)
        call memrealloc( face_num_nodes, coordinates, __FILE__,__LINE__)
        ! assert(face_num_nodes<=10) ! see declaration of points above

        vertices_of_vefs_iterator = vertices_of_vefs%create_iterator(ivef_pos_in_cell)
        vertex1 = cell%get_vef_lid(  vertices_of_vefs_iterator%reach_from_current(0) )
        vertex2 = cell%get_vef_lid(  vertices_of_vefs_iterator%reach_from_current(1) )
        !write(*,*) 'vertices of vef', ivef, vvertex1, vertex2

        point1 = this%coordinates(vertex1)
        point2 = this%coordinates(vertex2)

        if(this%vefs_geometry(ivef)>0) then
           ! Put nodes according to geometry
           line => this%geometry%get_line( this%vefs_geometry(ivef) )
           u_param1 = line%get_parameter(point1,1.0e-8_rp)
           u_param2 = line%get_parameter(point2,1.0e-8_rp)
           do inode = 1,face_num_nodes
              param = real(inode,rp)/(face_num_nodes+1)
              u_param = u_param1 * (1.0_rp - param) + &
                   &            u_param2 * param 
              call line%evaluate(u_param,coordinates(inode))
           end do
        else
           ! Put nodes by linear interpolation
           do inode = 1,face_num_nodes
              u_param = real(inode,rp)/(face_num_nodes+1)
              coordinates(inode) = point1*(1.0_rp -u_param) + &
                   &               point2*u_param
           end do
        end if
        ! write(*,*) 'Vef points:' ,ivef ,vertex1, vertex2, num_points, this%vefs_geometry(ivef)
        ! write(*,*) point1%get_value(),u_param1
        ! write(*,*) point2%get_value(),u_param2
        ! write(*,*) points(1)%get_value()
        ! write(*,*) points(2)%get_value()
        ! write(*,*) points(3)%get_value()

        do inode=1,face_num_nodes
           l_node = cell%get_node_lid( this%reference_fe_geo_list(cell_type)%p%get_own_node_vef(inode,ivef_pos_in_cell) )
           this%coordinates(l_node) = coordinates(inode)
        end do
     end if      
     call faces_iterator%next()
  end do

  ! Fill internal nodes
  write(*,*) 'Fill internal nodes'
  cell_iterator = this%create_cell_iterator()
  do while ( .not. cell_iterator%has_finished() )
     call cell_iterator%current(cell)
     if ( cell%is_local() ) then
       ! Reallocate coordinates (if needed) and get them from cell
       cell_num_nodes = cell%get_num_nodes()
       call memrealloc( cell_num_nodes, coordinates, __FILE__,__LINE__)
       call cell%get_coordinates(coordinates)

       ! Call reference_fe to make the blending
       !write(*,*) 'Calling blending:'
       cell_num_vefs = cell%get_num_vefs()
       call this%reference_fe_geo_index%get(key=cell_num_vefs,val=cell_type,stat=istat)
       assert(istat==key_found)
       call this%reference_fe_geo_list(cell_type)%p%blending(coordinates)

       ! Store coordinates
       call cell%set_coordinates(coordinates)
     end if
     call cell_iterator%next()
  end do

end subroutine fine_triangulation_allocate_and_fill_coordinates
  
subroutine fine_triangulation_free_coordinates( this )
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  if (allocated(this%coordinates)) call memfree(this%coordinates,__FILE__,__LINE__)
end subroutine fine_triangulation_free_coordinates

subroutine fine_triangulation_free ( this )
  implicit none
  class(fine_triangulation_t), intent(inout) :: this
  call this%free_geometry_and_set()
  call this%free_nodes()
  call this%free_coordinates()
  call this%base_static_triangulation_t%free()  
end subroutine fine_triangulation_free
