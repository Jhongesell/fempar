! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!====================================================================================================
subroutine initialize_from_cli(this,cli,group)
  implicit none
  class(nsi_iss_oss_discrete_integration_t), intent(inout) :: this
  type(Type_Command_Line_Interface)        , intent(inout) :: cli
  character(len=:), allocatable            , intent(in)    :: group
  ! Locals
  integer(ip) :: istat

  ! Getters
  call cli%get(group=trim(group),switch='-nu'   ,val=this%viscosity,error=istat); check(istat==0)
  call cli%get(group=trim(group),switch='-c1'   ,val=this%c1       ,error=istat); check(istat==0)
  call cli%get(group=trim(group),switch='-c2'   ,val=this%c2       ,error=istat); check(istat==0)
  call cli%get(group=trim(group),switch='-cc'   ,val=this%cc       ,error=istat); check(istat==0)
  call cli%get(group=trim(group),switch='-h_flg',val=this%elemental_length_flag,error=istat)
  check(istat==0)
  call cli%get(group=trim(group),switch='-cnv'  ,val=this%convection_activated ,error=istat)
  check(istat==0)

end subroutine initialize_from_cli

!====================================================================================================
subroutine integrate(this,fe_space,assembler)
  implicit none
  class(nsi_iss_oss_discrete_integration_t), intent(in)    :: this
  class(serial_fe_space_t)                 , intent(inout) :: fe_space
  class(assembler_t)                       , intent(inout) :: assembler
  ! Integers
  integer(ip)              :: number_fe_spaces, number_nodes, number_elements
  integer(ip)              :: number_dimensions, velocity_order
  integer(ip)              :: ngaus
  integer(ip)              :: ielem,igaus,inode,jnode
  integer(ip)              :: ioffset,joffset
  integer(ip), pointer     :: field_blocks(:)
  integer(ip), allocatable :: number_nodes_per_field(:)
  ! Reals
  real(rp)              :: velocity_gp
  real(rp)              :: test_scalar, trial_scalar
  real(rp)              :: dvolume
  real(rp), allocatable :: tau_m(:), tau_c(:)
  real(rp), allocatable :: elmat(:,:)
  real(rp), allocatable :: elvec(:)
  ! Logicals
  logical, pointer :: field_coupling(:,:)
  ! Types
  type(vector_field_t)               :: test_vector, trial_vector
  type(vector_field_t)               :: advection_vector
  type(vector_field_t)               :: source_vector
  type(vector_field_t)               :: grad_test_scalar, grad_trial_scalar
  type(tensor_field_t)               :: grad_test_vector, grad_trial_vector
  type(fe_function_vector_t)         :: fe_velocity
  type(finite_element_t)   , pointer :: fe
  type(quadrature_t)       , pointer :: quad
  type(fe_map_t)           , pointer :: fe_map
  type(volume_integrator_t), pointer :: vol_int_velocity_fe
  type(volume_integrator_t), pointer :: vol_int_pressure_fe
  type(volume_integrator_t), pointer :: vol_int_projection_fe
  type(i1p_t)              , pointer :: elem2dof(:)
  type(i1p_t)              , pointer :: bc_code(:)
  type(r1p_t)              , pointer :: bc_value(:)
  class(vector_t)          , pointer :: vector_dof_values
  
  ! Getters
  fe                => fe_space%get_finite_element(1)
  field_blocks      => fe_space%get_field_blocks()
  field_coupling    => fe_space%get_field_coupling()
  number_fe_spaces  =  fe_space%get_number_fe_spaces()
  number_nodes      =  fe%get_number_nodes()
  velocity_order    =  fe%get_order(1)
  number_elements   =  fe_space%get_number_elements()
  quad              => fe%get_quadrature()
  ngaus             =  quad%get_number_quadrature_points()
  number_dimensions =  quad%get_number_dimensions()
  call memalloc(number_fe_spaces,number_nodes_per_field,__FILE__,__LINE__)
  call fe%get_number_nodes_per_field(number_nodes_per_field)

  ! Asserts
  assert(number_fe_spaces == 3) ! Velocity + Pressure + Projection

  ! Allocate elemental matrix and vector (same for all elements)
  call memalloc(number_nodes,number_nodes,elmat,__FILE__,__LINE__)
  call memalloc(number_nodes,elvec,__FILE__,__LINE__)

  ! Initialize integration
  call fe_space%initialize_integration()
  call fe_space%create_fe_function(1,fe_velocity)
  call source_vector%init(0.0_rp)
  vector_dof_values => this%dof_values
  
  ! Initialize discrete integration structures
  call allocate_stabilization_parameters(ngaus,tau_m,tau_c)

  ! Loop over elements
  element: do ielem = 1, number_elements

     ! Initialize matrix and vector
     elmat = 0.0_rp
     elvec = 0.0_rp

     ! Update finite element structures
     fe => fe_space%get_finite_element(ielem)
     call fe%update_integration()
     call fe%update_values(fe_velocity, vector_dof_values)
     
     ! Elemental getters
     fe_map                => fe%get_fe_map()
     vol_int_velocity_fe   => fe%get_volume_integrator(1)
     vol_int_pressure_fe   => fe%get_volume_integrator(2)
     vol_int_projection_fe => fe%get_volume_integrator(3)
     elem2dof              => fe%get_elem2dof()
     bc_code               => fe%get_bc_code()
     bc_value              => fe%get_bc_value()

     ! Update discrete integration structures
     call this%compute_stabilization_parameters(fe_map,fe_velocity,ngaus,number_nodes_per_field(1), & 
     &                                          number_dimensions,velocity_order,tau_m,tau_c)
     
     ! Loop over Gauss points
     gaus: do igaus = 1, ngaus
        
        ! |J]*wg
        dvolume = fe_map%get_det_jacobian(igaus) * quad%get_weight(igaus)

        ! Velocity at Gauss point
        call fe_velocity%get_value(igaus,advection_vector)
        
        !-----------!
        ! BLOCK V-U !
        !-----------!
        ! Diffusive term: (nu*grad(v),grad(u))
        do inode = 1, number_nodes_per_field(1) 
           call vol_int_velocity_fe%get_gradient(inode,igaus,grad_test_vector)  
           do jnode = 1, number_nodes_per_field(1)
              call vol_int_velocity_fe%get_gradient(jnode,igaus,grad_trial_vector)  
              elmat(inode,jnode) = elmat(inode,jnode) + this%viscosity * dvolume * &
                   &               double_contract(grad_test_vector,grad_trial_vector)
           end do
        end do
        
        ! Convective term: (v,u*grad(u))
        if(this%convection_activated) then
           do jnode = 1, number_nodes_per_field(1) 
              call vol_int_velocity_fe%get_gradient(jnode,igaus,grad_trial_vector)  
              trial_vector = advection_vector * grad_trial_vector
              do inode = 1, number_nodes_per_field(1) 
                 call vol_int_velocity_fe%get_value(inode,igaus,test_vector)
                 elmat(inode,jnode) = elmat(inode,jnode) + dvolume * test_vector * trial_vector
              end do
           end do
        end if

        ! Grad-div term: (tau_c*div(v),div(u))
        do inode = 1, number_nodes_per_field(1) 
           call vol_int_velocity_fe%get_divergence(inode,igaus,test_scalar)
           do jnode = 1, number_nodes_per_field(1) 
              call vol_int_velocity_fe%get_divergence(jnode,igaus,trial_scalar)
              elmat(inode,jnode) = elmat(inode,jnode) + tau_c(igaus) * dvolume * test_scalar * trial_scalar
           end do
        end do            
        
        !-----------!
        ! BLOCK V-P !
        !-----------!
        ! Pressure gradient term: -(div(v),p)
        do inode = 1, number_nodes_per_field(1) 
           call vol_int_velocity_fe%get_divergence(inode,igaus,test_scalar)
           do jnode = 1, number_nodes_per_field(2)
              call vol_int_pressure_fe%get_value(jnode,igaus,trial_scalar)
              joffset = number_nodes_per_field(1)+jnode
              elmat(inode,joffset) = elmat(inode,joffset) - dvolume * test_scalar * trial_scalar
           end do
        end do

        !-----------!
        ! BLOCK V-X !
        !-----------!
        ! Projection term: -(tau_m*u*grad(v),xi)
        if(this%convection_activated) then
           do inode = 1, number_nodes_per_field(1) 
              call vol_int_velocity_fe%get_gradient(inode,igaus,grad_test_vector)  
              test_vector = advection_vector * grad_test_vector
              do jnode = 1, number_nodes_per_field(3) 
                 call vol_int_projection_fe%get_value(jnode,igaus,trial_vector)
                 joffset = number_nodes_per_field(1 )+ number_nodes_per_field(2) + jnode
                 elmat(inode,joffset) = elmat(inode,joffset) - tau_m(igaus) * dvolume * test_vector * trial_vector
              end do
           end do
        end if

        !-----------!
        ! BLOCK Q-U !
        !-----------!
        ! Velocity divergence term: (q,div(u))
        do inode = 1, number_nodes_per_field(2)
           call vol_int_pressure_fe%get_value(inode,igaus,test_scalar)
           ioffset = number_nodes_per_field(1)+inode
           do jnode = 1, number_nodes_per_field(1) 
              call vol_int_velocity_fe%get_divergence(jnode,igaus,trial_scalar)
              elmat(ioffset,jnode) = elmat(ioffset,jnode) + dvolume * test_scalar * trial_scalar
           end do
        end do

        !-----------!
        ! BLOCK E-U !
        !-----------!
        ! Velocity gradient projection term: (tau_m*eta,u*grad(u))
        if(this%convection_activated) then
           do inode = 1, number_nodes_per_field(3) 
              ioffset = number_nodes_per_field(1 )+ number_nodes_per_field(2) + inode
              call vol_int_projection_fe%get_value(inode,igaus,test_vector)
              do jnode = 1, number_nodes_per_field(1) 
                 call vol_int_velocity_fe%get_gradient(jnode,igaus,grad_trial_vector)  
                 trial_vector = advection_vector * grad_trial_vector
                 elmat(ioffset,jnode) = elmat(ioffset,jnode) + tau_m(igaus) * dvolume * test_vector * trial_vector
              end do
           end do          
        end if
                
        !-----------!
        ! BLOCK E-X !
        !-----------!
        ! Projection mass term: -(tau_m*eta,xi)
        do inode = 1, number_nodes_per_field(3) 
           ioffset = number_nodes_per_field(1 )+ number_nodes_per_field(2) + inode
           call vol_int_projection_fe%get_value(inode,igaus,test_vector)
           do jnode = 1, number_nodes_per_field(3) 
              joffset = number_nodes_per_field(1 )+ number_nodes_per_field(2) + jnode
              call vol_int_projection_fe%get_value(jnode,igaus,trial_vector)
              elmat(ioffset,joffset) = elmat(ioffset,joffset) - tau_m(igaus) * dvolume * test_vector * trial_vector
           end do
        end do
        
        !-----------!
        ! BLOCK U   !
        !-----------!
        ! Source term: (v,f)    
        do inode = 1, number_nodes_per_field(1) 
           call vol_int_velocity_fe%get_value(inode,igaus,test_vector)
           elvec(inode) = elvec(inode) + dvolume * test_vector * source_vector
        end do
        
     end do gaus
    
     call this%impose_strong_dirichlet_data(elmat,elvec,bc_code,bc_value,number_nodes_per_field,number_fe_spaces)
     call assembler%assembly(number_fe_spaces,number_nodes_per_field,elem2dof,field_blocks,field_coupling,elmat,elvec)  
     
  end do element

  ! Deallocate
  call memfree(number_nodes_per_field,__FILE__,__LINE__)
  call memfree(elmat,__FILE__,__LINE__)
  call memfree(elvec,__FILE__,__LINE__)
  
  ! Finalize discrete integration structures
  call deallocate_stabilization_parameters(tau_m,tau_c)
  
end subroutine integrate

!====================================================================================================
subroutine allocate_stabilization_parameters(ngaus,tau_m,tau_c)
  implicit none
  integer(ip)          , intent(in)  :: ngaus
  real(rp), allocatable, intent(out) :: tau_m(:)
  real(rp), allocatable, intent(out) :: tau_c(:)

  ! Allocate $\tau_m$ and $\tau_c$
  call memalloc(ngaus,tau_m,__FILE__,__LINE__)
  call memalloc(ngaus,tau_c,__FILE__,__LINE__)

end subroutine allocate_stabilization_parameters

!====================================================================================================
subroutine deallocate_stabilization_parameters(tau_m,tau_c)
  implicit none
  real(rp), allocatable, intent(inout) :: tau_m(:)
  real(rp), allocatable, intent(inout) :: tau_c(:)

  ! Dellocate $\tau_m$ and $\tau_c$
  call memfree(tau_m,__FILE__,__LINE__)
  call memfree(tau_c,__FILE__,__LINE__)

end subroutine deallocate_stabilization_parameters

!====================================================================================================
subroutine compute_stabilization_parameters(this,fe_map,fe_velocity,ngaus,number_velocity_nodes, & 
     &                                      number_components,velocity_order,tau_m,tau_c)
  implicit none
  class(nsi_iss_oss_discrete_integration_t), intent(in)    :: this
  type(fe_map_t)                           , intent(in)    :: fe_map
  type(fe_function_vector_t)               , intent(in)    :: fe_velocity
  integer(ip)                              , intent(in)    :: ngaus
  integer(ip)                              , intent(in)    :: number_velocity_nodes
  integer(ip)                              , intent(in)    :: number_components
  integer(ip)                              , intent(in)    :: velocity_order
  real(rp)                                 , intent(inout) :: tau_m(ngaus)
  real(rp)                                 , intent(inout) :: tau_c(ngaus)
  ! Locals
  integer(ip) :: igaus
  real(rp)    :: gp_velocity
  real(rp)    :: h_vol,h_flow
  real(rp)    :: ch_velocity(number_components,2)
  real(rp)    :: inv_tau_m
  type(vector_field_t) :: advection_vector

  ! Initiealize
  tau_m = 0.0_rp
  tau_c = 0.0_rp

  ! Loop over Gauss points
  do igaus = 1, ngaus

     ! Velocity norm at Gauss point
     call fe_velocity%get_value(igaus,advection_vector)
     gp_velocity = advection_vector*advection_vector
     gp_velocity = sqrt(gp_velocity)

     ! Characteristic element length
     call this%compute_characteristic_length(fe_map,fe_velocity,number_velocity_nodes,number_components, &
     &                                       velocity_order,igaus,ch_velocity,h_vol,h_flow)

     ! $\tau_m$
     inv_tau_m = this%c1*this%viscosity/(h_vol**2) + this%c2*gp_velocity/h_flow
     if(inv_tau_m.ge.1.0e-8_rp) tau_m(igaus) = 1.0_rp/inv_tau_m
     
     ! $\tau_c$
     if(this%c1.ge.1.0e-8_rp) tau_c(igaus) = this%cc*(this%viscosity + this%c2/this%c1*gp_velocity*h_vol)
     
  end do  

end subroutine compute_stabilization_parameters

!====================================================================================================
subroutine compute_characteristic_length(this,fe_map,fe_velocity,number_velocity_nodes,            &
     &                                   number_components,velocity_order,igaus,ch_velocity,h_vol, &
     &                                   h_flow)
  implicit none
  class(nsi_iss_oss_discrete_integration_t), intent(in)  :: this
  type(fe_map_t)                           , intent(in)  :: fe_map
  type(fe_function_vector_t)               , intent(in)  :: fe_velocity
  integer(ip)                              , intent(in)  :: number_velocity_nodes
  integer(ip)                              , intent(in)  :: number_components
  integer(ip)                              , intent(in)  :: velocity_order
  integer(ip)                              , intent(in)  :: igaus
  real(rp)                                 , intent(out) :: ch_velocity(number_components,2)
  real(rp)                                 , intent(out) :: h_vol,h_flow
  ! Locals
  real(rp)          :: h_min,h_max,h_reference
  real(rp)          :: v1_norm,v2_norm
  real(rp), pointer :: elemental_velocity(:)
  real(rp), pointer :: inv_jacobian(:,:,:)
  integer(ip)       :: number_velocity_nodes_scalar
  integer(ip)       :: idime,jdime,inode,counter

  ! Get elemental lengths
  h_vol = fe_map%compute_h(igaus)          ! Volumetric
  h_min = fe_map%compute_h_min(igaus)      ! Minimum
  h_max = fe_map%compute_h_max(igaus)      ! Maximum
  h_reference  =  fe_map%get_reference_h() ! Reference
  inv_jacobian => fe_map%get_inv_jacobian()

  ! Number of physical elemental nodes 
  number_velocity_nodes_scalar = number_velocity_nodes/number_components

  ! Length in the flow direction
  if(this%convection_activated) then

     ! Characteristic element velocity
     elemental_velocity => fe_velocity%get_nodal_values()
     ch_velocity = 0.0_rp
     counter = 0
     do idime = 1, number_components
        do inode = 1, number_velocity_nodes_scalar
           counter = counter + 1
           ch_velocity(idime,1) = ch_velocity(idime,1) + elemental_velocity(counter)
        end do
        ch_velocity(idime,1) = ch_velocity(idime,1)/real(number_velocity_nodes_scalar)
     end do
     do idime = 1, number_components
        ch_velocity(idime,2) = 0.0_rp
        do jdime = 1, number_components
           ch_velocity(idime,2) = ch_velocity(idime,2) + inv_jacobian(idime,jdime,igaus)* &
                &                                        ch_velocity(jdime,1)
        end do
     end do
     v1_norm = 0.0_rp
     v2_norm = 0.0_rp
     do idime = 1, number_components
        v1_norm = v1_norm + ch_velocity(idime,1)*ch_velocity(idime,1)
        v2_norm = v2_norm + ch_velocity(idime,2)*ch_velocity(idime,2)
     end do
     v1_norm = sqrt(v1_norm)
     v2_norm = sqrt(v2_norm)
     if(v2_norm>1.0e-16) then
        h_flow = h_reference*v1_norm/v2_norm
     else
        h_flow = h_vol    
     end if
  else
     h_flow = h_vol
  end if

  ! Restrictions
  if(this%elemental_length_flag == minimum_elemental_length) then
     h_vol  = h_min
     h_flow = h_min
  elseif(this%elemental_length_flag == maximum_elemental_length) then
     h_vol  = h_max
     h_flow = h_min
  end if

  ! Divide by p**2
  h_vol = h_vol/real(velocity_order**2)
  h_vol = h_vol/real(velocity_order**2)  
  
end subroutine compute_characteristic_length
