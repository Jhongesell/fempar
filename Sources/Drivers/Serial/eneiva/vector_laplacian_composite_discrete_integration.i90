! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module vector_laplacian_composite_discrete_integration_names
  use serial_names

  implicit none
# include "debug.i90"
  private
  type, extends(discrete_integration_t) :: vector_laplacian_composite_discrete_integration_t
     integer(ip)              :: number_neumann_faces
     integer(ip), allocatable :: neumann_faces(:)
   contains
     procedure :: integrate
  end type vector_laplacian_composite_discrete_integration_t

  public :: vector_laplacian_composite_discrete_integration_t

contains
  subroutine integrate ( this, fe_space, assembler )
    implicit none
    class(vector_laplacian_composite_discrete_integration_t), intent(in)    :: this
    class(serial_fe_space_t)                                , intent(inout) :: fe_space
    class(assembler_t)                                      , intent(inout) :: assembler
    ! Finite objects
    type(finite_element_t)    , pointer     :: fe
    type(finite_face_t)       , pointer     :: face
    ! Integrators
    type(volume_integrator_t) , pointer     :: vol_int_first_fe, vol_int_second_fe
    type(face_integrator_t)   , pointer     :: face_int_first_fe, face_int_second_fe
    ! Elemental arrays
    real(rp)                  , allocatable :: elmat(:,:), elvec(:)
    real(rp)                  , allocatable :: facemat(:,:,:,:), facevec(:,:)
    ! Coordinate maps
    type(fe_map_t)            , pointer     :: fe_map
    type(face_map_t)          , pointer     :: face_map
    ! Element to dofs maps
    type(i1p_t)               , pointer     :: elem2dof(:)
    ! Quadrature
    type(quadrature_t)        , pointer     :: quad
    ! Test functions
    real(rp)                                :: shape_trial
    type(vector_field_t)                    :: grad_test, grad_trial
    ! Other locals
    integer(ip)                             :: ioffset, joffset
    integer(ip)                             :: qpoint, inode, jnode, npoint
    real(rp)                                :: space_factor
    integer(ip)               , allocatable :: number_nodes_per_field(:)
    integer(ip)                             :: number_fe_spaces
    integer(ip)               , pointer     :: field_blocks(:)
    logical                   , pointer     :: field_coupling(:,:)
    integer(ip)                             :: ielem, number_nodes
    integer(ip)                             :: iface, neighbour_id

    ! Getters
    number_fe_spaces =  fe_space%get_number_fe_spaces()
    
    field_blocks     => fe_space%get_field_blocks()
    field_coupling   => fe_space%get_field_coupling()
    
    fe               => fe_space%get_finite_element(1)
    number_nodes     =  fe%get_number_nodes()
    
    quad             => fe%get_quadrature()
  
    call memalloc ( number_fe_spaces, number_nodes_per_field, __FILE__, __LINE__ )
    call fe%get_number_nodes_per_field( number_nodes_per_field )
    
    ! Allocate memory for elemental arrays
    call memalloc ( number_nodes, number_nodes, elmat, __FILE__, __LINE__ )
    call memalloc ( number_nodes, elvec, __FILE__, __LINE__ )
    call memalloc ( number_nodes, number_nodes, 2, 2, facemat, __FILE__, __LINE__ )
    call memalloc ( number_nodes, 2, facevec, __FILE__, __LINE__ )
    
    ! Initialize integration
    call fe_space%initialize_integration()
    npoint = quad%get_number_quadrature_points()
    
    ! LOOP OVER ELEMENTS
    elements: do ielem = 1, fe_space%get_number_elements()
    
       ! Get element and integrate if it is in the computational domain
       fe => fe_space%get_finite_element(ielem)
    
       ! Initialize arrays
       elmat = 0.0_rp
       elvec = 0.0_rp
       
       ! Elemental getters
       fe_map   => fe%get_fe_map()
       vol_int_first_fe  => fe%get_volume_integrator(1)
       vol_int_second_fe => fe%get_volume_integrator(2)
       elem2dof => fe%get_elem2dof()      
       
       ! Update finite element structures
       call fe%update_integration()
       
       ! Loop over quadrature points
       do qpoint = 1,npoint
          
          ! |J]*wg
          space_factor  = fe_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)
          
          ! Diffusive term: - div ( k(u^{n+theta}) grad(u^{n+theta}) )
          do inode = 1, number_nodes_per_field(1)
             call vol_int_first_fe%get_gradient(inode,qpoint,grad_trial)
             do jnode = 1, number_nodes_per_field(1)
                call vol_int_first_fe%get_gradient(jnode,qpoint,grad_test)
                elmat(inode,jnode) = elmat(inode,jnode) + space_factor * grad_test * grad_trial 
             end do
          end do

          do inode = 1, number_nodes_per_field(2)
             ioffset = number_nodes_per_field(1) + inode
             call vol_int_second_fe%get_gradient(inode,qpoint,grad_trial)
             do jnode = 1, number_nodes_per_field(2)
                joffset = number_nodes_per_field(1) + jnode
                call vol_int_second_fe%get_gradient(jnode,qpoint,grad_test)
                elmat(ioffset,joffset) = elmat(ioffset,joffset) + space_factor * grad_test * grad_trial 
             end do
          end do
          
       end do
       
       ! Apply strong Dirichlet conditions and assemble elemental arrays
       call fe%impose_strong_dirichlet_bcs( elmat, elvec )
       call assembler%assembly( number_fe_spaces, number_nodes_per_field, elem2dof, field_blocks,  field_coupling, elmat, elvec )
       
    end do elements

    neumann_faces: do iface = 1, this%number_neumann_faces
    
       ! Face getters
       face => fe_space%get_finite_face(this%neumann_faces(iface))
       neighbour_id = 1
                         
       ! Initialize arrays
       facemat = 0.0_rp
       facevec = 0.0_rp

       face_map => face%get_map()
       face_int_first_fe  => face%get_face_integrator(1)
       face_int_second_fe => face%get_face_integrator(2)
       
       quad     => face%get_quadrature()
       npoint = quad%get_number_quadrature_points()

       ! Update finite face structures
       call face%update_integration()
       
       ! Loop over quadrature points
       do qpoint = 1, npoint
       
          ! |J]*wg
          space_factor = face_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)
          
          ! Integrate Neumann Boundary Condition
          do inode = 1, number_nodes_per_field(1)
             call face_int_first_fe%get_value(inode,qpoint,neighbour_id,shape_trial)
             facevec(inode,neighbour_id) = facevec(inode,neighbour_id) + space_factor * shape_trial
          end do
          
          do inode = 1, number_nodes_per_field(2)
             ioffset = number_nodes_per_field(1) + inode
             call face_int_second_fe%get_value(inode,qpoint,neighbour_id,shape_trial)
             facevec(ioffset,neighbour_id) = facevec(ioffset,neighbour_id) + space_factor * shape_trial
          end do
          
       end do
       
       ! Assemble elemental arrays. RMK: Apply strong Dirichlet bcs?
       elem2dof => face%get_elem2dof(neighbour_id)
       call assembler%face_assembly(number_fe_spaces,number_nodes_per_field, number_nodes_per_field,  &
                                    &  elem2dof,elem2dof,field_blocks,field_coupling,                 &
                                    &  facemat(:,:,neighbour_id,neighbour_id), facevec(:,neighbour_id) )   
    
    end do neumann_faces
 
    ! Release memory
    call memfree ( elmat, __FILE__, __LINE__ )
    call memfree ( elvec, __FILE__, __LINE__ )
    call memfree ( facemat, __FILE__, __LINE__ )
    call memfree ( facevec, __FILE__, __LINE__ )
    call memfree ( number_nodes_per_field, __FILE__, __LINE__ )
  end subroutine integrate

end module vector_laplacian_composite_discrete_integration_names
