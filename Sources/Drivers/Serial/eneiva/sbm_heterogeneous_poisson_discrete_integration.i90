module heterogeneous_poisson_discrete_integration_names
  use field_names
  use assembler_names
  use serial_fe_space_names
  use discrete_integration_names
  use reference_fe_names
  use types_names
  use memor_names
  use vector_names
  
  implicit none
# include "debug.i90"
  private

  type, extends(discrete_integration_t) :: heterogeneous_poisson_discrete_integration_t
     ! User-defined table
     integer(ip)                :: nvalu
     real(rp), allocatable      :: data_points(:)
     real(rp), allocatable      :: property_values(:)
     class(vector_t), pointer   :: dof_values => NULL()                    
   contains
     procedure                  :: integrate
     procedure, non_overridable :: interpolate_property
     procedure, non_overridable :: search_interval
  end type heterogeneous_poisson_discrete_integration_t
  
  public :: heterogeneous_poisson_discrete_integration_t
  
contains
  
  !===============================================================================================
  subroutine integrate ( this, fe_space, assembler )
    implicit none
    class(heterogeneous_poisson_discrete_integration_t), intent(in)    :: this
    class(serial_fe_space_t)                        , intent(inout) :: fe_space
    class(assembler_t)                              , intent(inout) :: assembler
    ! Locals
    type(finite_element_t), pointer    :: fe
    type(volume_integrator_t), pointer :: vol_int_first_fe, vol_int_second_fe
    real(rp), allocatable                 :: elmat(:,:), elvec(:)
    type(fe_map_t), pointer               :: fe_map
    type(quadrature_t), pointer        :: quad

    integer(ip)                           :: igaus,inode,jnode,ioffset,joffset,ngaus
    real(rp)                              :: factor

    type(vector_field_t)                  :: grad_test_scalar, grad_trial_scalar
    type(tensor_field_t)                  :: grad_test_vector, grad_trial_vector

    integer(ip)                           :: number_fe_spaces

    integer(ip), pointer                  :: field_blocks(:)
    logical, pointer                      :: field_coupling(:,:)

    integer(ip)                           :: ielem, number_nodes
    type(i1p_t), pointer                  :: elem2dof(:)
    type(i1p_t), pointer                  :: bc_code(:)
    type(r1p_t), pointer                  :: bc_value(:)
    integer(ip), allocatable              :: number_nodes_per_field(:)
    
    type(fe_function_scalar_t)            :: fe_unknown_scalar
    real(rp)                              :: igaus_value_scalar
    
    type(fe_function_vector_t)            :: fe_unknown_vector
    type(vector_field_t)                  :: igaus_value_vector
    
    real(rp)                              :: viscosity_scalar
    type(tensor_field_t)                  :: viscosity_matrix

    class(vector_t), pointer              :: vector_dof_values
				
    number_fe_spaces = fe_space%get_number_fe_spaces()
    field_blocks    => fe_space%get_field_blocks()
    field_coupling  => fe_space%get_field_coupling()

    fe => fe_space%get_finite_element(1)
    number_nodes = fe%get_number_nodes()
    call memalloc ( number_nodes, number_nodes, elmat, __FILE__, __LINE__ )
    call memalloc ( number_nodes, elvec, __FILE__, __LINE__ )
    call memalloc ( number_fe_spaces, number_nodes_per_field, __FILE__, __LINE__ )
    call fe%get_number_nodes_per_field( number_nodes_per_field )

    call fe_space%initialize_integration()
    
    quad => fe%get_quadrature()
    ngaus = quad%get_number_evaluation_points()
    
    call fe_space%create_fe_function(1,fe_unknown_scalar)
    call fe_space%create_fe_function(2,fe_unknown_vector)
    
    vector_dof_values => this%dof_values
    
    do ielem = 1, fe_space%get_number_elements()
       elmat = 0.0_rp
       elvec = 0.0_rp

       fe => fe_space%get_finite_element(ielem)
       call fe%update_integration()
       
       fe_map            => fe%get_fe_map()
       vol_int_first_fe  => fe%get_volume_integrator(1)
       vol_int_second_fe => fe%get_volume_integrator(2)
       elem2dof          => fe%get_elem2dof()
       bc_code           => fe%get_bc_code()
       bc_value          => fe%get_bc_value()
						
       call fe%update_values(fe_unknown_scalar, vector_dof_values)
       call fe%update_values(fe_unknown_vector, vector_dof_values)
       
       do igaus = 1,ngaus
          factor = fe_map%get_det_jacobian(igaus) * quad%get_weight(igaus)
          
          call fe_unknown_scalar%get_value(igaus, igaus_value_scalar)
          viscosity_scalar = this%interpolate_property(igaus_value_scalar)
          
          do inode = 1, number_nodes_per_field(1)
             call vol_int_first_fe%get_gradient(inode,igaus,grad_trial_scalar)
             do jnode = 1, number_nodes_per_field(1)
                call vol_int_first_fe%get_gradient(jnode,igaus,grad_test_scalar)
                elmat(inode,jnode) = elmat(inode,jnode) + & 
                   & factor * viscosity_scalar * grad_test_scalar * grad_trial_scalar
             end do
          end do
          
          call fe_unknown_vector%get_value(igaus, igaus_value_vector)
          
          call viscosity_matrix%init(0.0_rp)
          call viscosity_matrix%set(1,1,this%interpolate_property(igaus_value_vector%get(1)))
          call viscosity_matrix%set(2,2,this%interpolate_property(igaus_value_vector%get(2)))
          
          do inode = 1, number_nodes_per_field(2)
             ioffset = number_nodes_per_field(1) + inode
             call vol_int_second_fe%get_gradient(inode,igaus,grad_trial_vector)
             do jnode = 1, number_nodes_per_field(2)
                joffset = number_nodes_per_field(1) + jnode
                call vol_int_second_fe%get_gradient(jnode,igaus,grad_test_vector)
                elmat(ioffset,joffset) = elmat(ioffset,joffset) + & 
                   & factor * double_contract(grad_test_vector,viscosity_matrix*grad_trial_vector)
             end do
          end do
          
       end do
       
       ! Apply boundary conditions
       call this%impose_strong_dirichlet_data( elmat, elvec, bc_code, bc_value, number_nodes_per_field, number_fe_spaces )
       call assembler%assembly( number_fe_spaces, number_nodes_per_field, elem2dof, field_blocks,  field_coupling, elmat, elvec )
    end do
    
    call fe_unknown_scalar%free()
    call fe_unknown_vector%free()
    call memfree ( number_nodes_per_field, __FILE__, __LINE__ )
    call memfree ( elmat, __FILE__, __LINE__ )
    call memfree ( elvec, __FILE__, __LINE__ )
  end subroutine integrate
 
  !===============================================================================================
  function interpolate_property ( this, point ) result ( value )
     implicit none
     class(heterogeneous_poisson_discrete_integration_t), intent(in) :: this
     real(rp), intent(in) :: point
     real(rp)             :: value
     ! Locals
     integer(ip)          :: ileft, iright
     real(rp)             :: slope
     
     ileft = 1; iright = this%nvalu
     if (point <= this%data_points(ileft)) then
        value = this%property_values(ileft)
     else if (point >= this%property_values(iright)) then
        value = this%property_values(iright)
     else
        call this%search_interval( point, ileft, iright )
     endif
     
     slope = (this%property_values(iright)-this%property_values(ileft))/ &
             &  (this%data_points(iright)-this%data_points(ileft))
     
     value = slope*(point-this%data_points(ileft)) + this%property_values(ileft)
     
  end function interpolate_property
  
  !===============================================================================================
  recursive subroutine search_interval ( this, point, ileft, iright )
     implicit none
     class(heterogeneous_poisson_discrete_integration_t), intent(in) :: this
     real(rp)   , intent(in)    :: point
     integer(ip), intent(inout) :: ileft, iright
     ! Locals
     integer(ip)                :: imid
     
     if (iright - ileft > 1) then
        imid = (ileft + iright)/2
        if (this%data_points(imid) < point) then
           ileft = imid
           call this%search_interval( point, ileft, iright )
        else
           iright = imid
           call this%search_interval( point, ileft, iright )
        endif 
     endif
     
  end subroutine search_interval
  
end module heterogeneous_poisson_discrete_integration_names
