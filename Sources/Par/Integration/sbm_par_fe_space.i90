! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine par_fe_space_create( this, &
                                par_triangulation, &
                                par_boundary_conditions, &
                                reference_fe_phy, &
                                field_blocks, &
                                field_coupling )
  implicit none
  class(par_fe_space_t)           , intent(inout) :: this
  type(par_triangulation_t),target, intent(in)    :: par_triangulation
  type(par_conditions_t)          , intent(in)    :: par_boundary_conditions
  type(p_reference_fe_t)  , target, intent(in)    :: reference_fe_phy(:)
  integer(ip)           , optional, intent(in)    :: field_blocks(:)
  logical               , optional, intent(in)    :: field_coupling(:,:)
 
  integer(ip) :: i
  integer(ip) :: num_elems, num_ghosts
 
  call this%free()
  
  this%par_triangulation => par_triangulation
  if ( par_triangulation%p_env%p_context%iam >= 0 ) then
    call this%serial_fe_space_t%create( par_triangulation%f_trian, &
                                        par_boundary_conditions%f_conditions, &
                                        reference_fe_phy, &
                                        field_blocks, &
                                        field_coupling )       
    
    num_elems  = par_triangulation%num_elems
    num_ghosts = par_triangulation%num_ghosts
    
    allocate(this%ghost_fe_array(num_ghosts))
    do i=1, num_ghosts
       call this%ghost_fe_array(i)%create (this%triangulation%elems(num_elems+i),&
                                           this%number_fe_spaces,&
                                           this%reference_fe_phy_list, &
                                           this%quadrature(1)%p,&
                                           this%fe_map(1)%p,&
                                           this%volume_integrator,&
                                           this%number_blocks,&
                                           this%field_blocks,&
                                           par_boundary_conditions%f_conditions)
    end do
  end if
  
end subroutine par_fe_space_create

subroutine par_fe_space_free( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip) :: i
 
  if ( associated (this%par_triangulation) ) then
    if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
      do i=1, this%par_triangulation%num_ghosts
        call this%ghost_fe_array(i)%free()
      end do
      deallocate(this%ghost_fe_array)
      do i=1, this%number_blocks
        call this%blocks_dof_import(i)%free()
      end do
      deallocate(this%blocks_dof_import) 
      call this%serial_fe_space_t%free()
    end if
    nullify(this%par_triangulation)
  end if
  
end subroutine par_fe_space_free

function par_fe_space_get_finite_element( this, ielem )
  implicit none
  class(par_fe_space_t), target, intent(inout) :: this
  integer(ip)                  , intent(in)    :: ielem
  type(finite_element_t), pointer              :: par_fe_space_get_finite_element
  integer(ip) :: num_local_elems
  
  assert ( associated (this%par_triangulation) )
  nullify (par_fe_space_get_finite_element)
  
  if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
    num_local_elems = this%par_triangulation%num_elems  
    if ( ielem <= num_local_elems ) then
     par_fe_space_get_finite_element => this%fe_array(ielem)
    else
     par_fe_space_get_finite_element => this%ghost_fe_array(ielem-num_local_elems)
    end if
  end if  
end function par_fe_space_get_finite_element


subroutine par_fe_space_print ( this )
  class(par_fe_space_t), intent(in) :: this 
  integer(ip) :: i,j
  
  if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
    call this%serial_fe_space_t%print()
    do i = 1, this%par_triangulation%num_ghosts
     write(*,*) '********* GHOST ELEMENT: ',i,'********'
     write(*,*) '********* ELEMENT 2 DOF********'
     do j = 1, this%number_fe_spaces
        write(*,*) '********* FE COMPONENT: ',j,'********'
        write(*,*) this%ghost_fe_array(i)%elem2dof(j)%p
     end do
    end do
  end if
  
  !do i  = 1, this%triangulation%number_interior_faces
  !   write(*,*) '--------------------- Face: ',i,'-------------------------'
  !   write(*,*) '-- Elem 1 --'
  !   write(*,*) this%face_array(i)%neighbour_fe(1)%p%elem2dof(1)%p
  !   write(*,*) '-- Elem 2 --'
  !   write(*,*) this%face_array(i)%neighbour_fe(2)%p%elem2dof(1)%p
  !end do

end subroutine par_fe_space_print


subroutine par_fe_space_fill_dof_info( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock, fe_space_id
  
  assert ( associated (this%par_triangulation) )
  if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
    call this%serial_fe_space_t%fill_dof_info()
    do fe_space_id = 1, this%number_fe_spaces
      call this%par_fe_space_fill_elem2dof_and_count_dofs( fe_space_id )
    end do
    call this%par_fe_space_compute_blocks_dof_import()
  end if
  
end subroutine par_fe_space_fill_dof_info

subroutine par_fe_space_fill_elem2dof_and_count_dofs( this, fe_space_id ) 
  implicit none
  ! Parameters
  class(par_fe_space_t)      , intent(inout) :: this 
  integer(ip)                , intent(in)    :: fe_space_id
  
  ! Local variables
  integer(ip) :: ivef, vef_lid, ighost, ielem, elem_id, ivef_in_elem_id
  integer(ip) :: num_elems, num_ghosts
  integer(ip) :: first_face_id, num_faces
  integer(ip) :: iblock, init_dof_block, current_dof_block
  integer(ip), allocatable :: s2t_perm_for_interior_nodes_vef(:)

  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )
  
  iblock            = this%field_blocks(fe_space_id)
  init_dof_block    = this%number_dofs_per_block(iblock)
  current_dof_block = init_dof_block

  call memalloc ( this%get_max_number_nodes(), s2t_perm_for_interior_nodes_vef, __FILE__, __LINE__ )
  do ighost = 1, this%par_triangulation%num_ghosts
     if ( this%ghost_fe_array(ighost)%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
       ! Fill elem2dof on ghost elements from the elem2dof 
       ! already computed on neighbouring local elements
       do ivef = 1, this%ghost_fe_array(ighost)%cell%num_vefs
          vef_lid = this%ghost_fe_array(ighost)%cell%vefs(ivef)
          if ( vef_lid /= -1 ) then
            ! Find local element around vef_lid in elem_id
            do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
              elem_id = this%triangulation%vefs(vef_lid)%elems_around(ielem)
              ! Is elem_id a local element ?
              if ( elem_id <= this%triangulation%num_elems ) exit
            end do
            
            ! Find local position of vef_lid in elem_id            
            ivef_in_elem_id = this%fe_array(elem_id)%cell%find_local_pos_from_vef_id(vef_lid)
            
            call this%ghost_fe_array(ighost)%fill_interior_dofs_on_vef_from_source_element ( ivef, &
                                                                                             this%fe_array(elem_id), &
                                                                                             ivef_in_elem_id, &
                                                                                             fe_space_id, &
                                                                                             s2t_perm_for_interior_nodes_vef )
          end if
       end do 
     else
       ! Fill elem2dof on ghost elements by assigning new dof identifiers
       ! to all DoFs placed on local faces
       first_face_id = this%ghost_fe_array(ighost)%cell%reference_fe_geo%get_first_face_id()
       num_faces     = this%ghost_fe_array(ighost)%cell%reference_fe_geo%get_number_faces()
       do ivef = first_face_id, first_face_id+num_faces-1
         vef_lid = this%ghost_fe_array(ighost)%cell%vefs(ivef)
         if ( vef_lid /= -1 ) then
         call this%ghost_fe_array(ighost)%fill_dofs_on_vef ( ivef, &
                                                             fe_space_id, &
                                                             current_dof_block )
         end if
       end do
     end if
  end do   
  call memfree ( s2t_perm_for_interior_nodes_vef, __FILE__, __LINE__ )

  this%number_dofs_per_field(fe_space_id) = this%number_dofs_per_field(fe_space_id) + & 
                                            (current_dof_block - init_dof_block)
  this%number_dofs_per_block(iblock) = this%number_dofs_per_block(iblock) + &
                                       (current_dof_block - init_dof_block) 
end subroutine par_fe_space_fill_elem2dof_and_count_dofs

subroutine par_fe_space_compute_blocks_dof_import ( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)                          :: iblock
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )     
  allocate ( this%blocks_dof_import(this%number_blocks) )
  do iblock=1, this%number_blocks
     call this%par_fe_space_compute_dof_import(iblock)
  end do
end subroutine par_fe_space_compute_blocks_dof_import


subroutine par_fe_space_compute_dof_import ( this, iblock )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: iblock
  
  ! Local raw data
  integer(igp), allocatable :: raw_interface_data(:,:)
  integer(ip) , allocatable :: dofs_lid(:)
  integer(ip)               :: total_ubound_num_itfc_couplings
  integer(ip)               :: total_num_itfc_couplings
  integer(ip), allocatable  :: ubound_num_itfc_couplings(:)
  integer(ip)               :: num_fe_spaces_in_iblock
  integer(ip)               :: i, fe_space_id
  
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )
  assert ( iblock >= 1 .and. iblock <= this%number_blocks )
  
  num_fe_spaces_in_iblock = 0
  do fe_space_id = 1, this%number_fe_spaces
    if ( this%field_blocks(fe_space_id) == iblock ) then
       num_fe_spaces_in_iblock = num_fe_spaces_in_iblock + 1
    end if
  end do
  
  call memalloc ( num_fe_spaces_in_iblock, ubound_num_itfc_couplings, __FILE__, __LINE__ )
  total_ubound_num_itfc_couplings = 0 
  i = 1
  do fe_space_id = 1, this%number_fe_spaces
    if ( this%field_blocks(fe_space_id) == iblock ) then
      if ( this%reference_fe_phy_list(fe_space_id)%p%get_continuity() ) then
         ubound_num_itfc_couplings (i) = this%par_fe_space_compute_ubound_num_itfc_couplings_by_continuity(fe_space_id)
      else
         ubound_num_itfc_couplings (i) = this%par_fe_space_compute_ubound_num_itfc_couplings_by_face_integ(fe_space_id)
      end if
      total_ubound_num_itfc_couplings = total_ubound_num_itfc_couplings + ubound_num_itfc_couplings (i)
      i=i+1                                  
    end if
  end do
  
  call memalloc ( num_rows_raw_interface_data, &
                  total_ubound_num_itfc_couplings, &
                  raw_interface_data, __FILE__, __LINE__ )
                  
  call memalloc ( total_ubound_num_itfc_couplings, dofs_lid, __FILE__, __LINE__)

  total_num_itfc_couplings = 0
  i = 1
  do fe_space_id = 1, this%number_fe_spaces
    if ( this%field_blocks(fe_space_id) == iblock ) then
    
      if ( this%reference_fe_phy_list(fe_space_id)%p%get_continuity() ) then
       total_num_itfc_couplings = total_num_itfc_couplings + & 
                                  this%par_fe_space_compute_raw_interface_data_by_continuity(fe_space_id, &
                                                                               ubound_num_itfc_couplings(i),&
                                                                               dofs_lid(total_num_itfc_couplings+1),&
                                                                               raw_interface_data(1,total_num_itfc_couplings+1) )
      else
      total_num_itfc_couplings = total_num_itfc_couplings + & 
                                  this%par_fe_space_compute_raw_interface_data_by_face_integ(fe_space_id, &
                                                                                             ubound_num_itfc_couplings(i),&
                                                                                             dofs_lid(total_num_itfc_couplings+1),&
                                                                                             raw_interface_data(1,total_num_itfc_couplings+1) )      
      end if
                                                                               
      i=i+1                                  
    end if
  end do
  
  call this%blocks_dof_import(iblock)%create(this%par_triangulation%p_env%p_context%iam+1, &
                                             this%par_triangulation%p_env%p_context%np, &
                                             total_num_itfc_couplings, &
                                             dofs_lid, &
                                             raw_interface_data )
                  
  call memfree ( ubound_num_itfc_couplings, __FILE__, __LINE__ )                
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  call memfree ( dofs_lid, __FILE__, __LINE__ )
end subroutine par_fe_space_compute_dof_import

function par_fe_space_compute_ubound_num_itfc_couplings_by_continuity( this, fe_space_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)                          :: par_fe_space_compute_ubound_num_itfc_couplings_by_continuity
  
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: elem_lid
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  type(finite_element_t), pointer :: finite_element
  
  integer(ip) :: result
  
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )
  
  mypart_id = this%par_triangulation%p_env%p_context%iam + 1 
  
  result = 0 
  ! Traverse vefs on the interface
  do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
    vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)  
    do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
      elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
      part_id = this%par_triangulation%elems(elem_lid)%mypart
      if ( part_id /= mypart_id ) then
        finite_element => this%par_fe_space_get_finite_element(elem_lid)
        ivef = finite_element%cell%find_local_pos_from_vef_id(vef_lid)
        result = result + finite_element%reference_fe_phy(fe_space_id)%p%get_number_interior_nodes_vef(ivef)
      end if  
    end do
  end do
  par_fe_space_compute_ubound_num_itfc_couplings_by_continuity = result
end function par_fe_space_compute_ubound_num_itfc_couplings_by_continuity


function par_fe_space_compute_ubound_num_itfc_couplings_by_face_integ( this, fe_space_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)                          :: par_fe_space_compute_ubound_num_itfc_couplings_by_face_integ
  
  integer(ip)  :: elem_lid
  integer(ip)  :: ivef_itfc, ielem, vef_lid
  type(finite_element_t), pointer :: finite_element
  
  integer(ip) :: result
  
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )
    
  result = 0 
  ! Traverse vefs on the interface
  do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
    vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)
    ! Is current vef_lid a face ?
    if ( this%triangulation%vefs(vef_lid)%dimension == this%triangulation%num_dims-1 ) then
      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
        elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
        finite_element => this%par_fe_space_get_finite_element(elem_lid)
        result = result + finite_element%reference_fe_phy(fe_space_id)%p%get_number_nodes_per_face()
      end do
    end if  
    par_fe_space_compute_ubound_num_itfc_couplings_by_face_integ = result
  end do  
  
end function par_fe_space_compute_ubound_num_itfc_couplings_by_face_integ

function par_fe_space_compute_raw_interface_data_by_continuity (  this, &
                                                    fe_space_id, &
                                                    ubound_num_itfc_couplings, &
                                                    dofs_lid, &
                                                    raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_lid(ubound_num_itfc_couplings)
  integer(igp)         , intent(inout) :: raw_interface_data(num_rows_raw_interface_data, ubound_num_itfc_couplings)
  integer(ip)                          :: num_itfc_couplings
 
  ! Locals
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id, elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_interior, dof_lid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: col, init_col, current_col
  integer(ip)  :: num_parts

  
  integer(igp), allocatable :: max_elem_gid(:)
  integer(ip) , allocatable :: max_part_id(:)
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  logical     , allocatable :: part_visited(:)
  integer(ip) , allocatable :: dofs_max_part_id(:)
  type(finite_element_t), pointer :: finite_element
  
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( this%number_dofs_per_field(fe_space_id), max_elem_gid, __FILE__, __LINE__ )
  call memalloc ( this%number_dofs_per_field(fe_space_id), max_part_id, __FILE__, __LINE__ )
  call memalloc ( this%number_dofs_per_field(fe_space_id), local_idof, __FILE__, __LINE__ )
  call memalloc ( this%number_dofs_per_field(fe_space_id), lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( this%par_triangulation%p_env%p_context%np, part_visited, __FILE__, __LINE__ )
  
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, __FILE__, __LINE__ )
  
  mypart_id = this%par_triangulation%p_env%p_context%iam + 1 
  
  max_elem_gid = 0
  max_part_id  = 0
  part_visited = .false.
  current_col  = 1
  
  ! Traverse vefs on the interface
  do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
    vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)
    
    num_dofs_current_vef = 0
    ! Identify the total set of dofs in current vef
    do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
      elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
      elem_gid = this%par_triangulation%elems(elem_lid)%globalID
      part_id = this%par_triangulation%elems(elem_lid)%mypart
      finite_element => this%par_fe_space_get_finite_element(elem_lid)
      ivef = finite_element%cell%find_local_pos_from_vef_id(vef_lid)
      do idof_interior=1, finite_element%reference_fe_phy(fe_space_id)%p%get_number_interior_nodes_vef(ivef)
        idof = finite_element%reference_fe_phy(fe_space_id)%p%get_interior_node_vef(idof_interior,ivef)
        dof_lid = finite_element%elem2dof(fe_space_id)%p(idof)
        if ( dof_lid == 0 ) cycle
        if ( max_elem_gid(dof_lid) == 0 ) then
           num_dofs_current_vef = num_dofs_current_vef + 1    
           lst_dofs_current_vef (num_dofs_current_vef) = dof_lid
        end if
        if ( elem_gid > max_elem_gid(dof_lid) ) then
          max_elem_gid(dof_lid) = elem_gid
          local_idof(dof_lid) = idof
        end if
        max_part_id(dof_lid) = max(part_id, max_part_id(dof_lid) )
      end do
    end do  
    
    init_col = current_col
    do idof=1, num_dofs_current_vef
      dof_lid = lst_dofs_current_vef(idof)
      num_parts = 1
      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
         part_id = this%par_triangulation%elems(elem_lid)%mypart
         if ( part_id /= mypart_id .and. .not. part_visited(part_id) ) then 
            ! .and. finite_element%is_dof_present(dof_lid) ) then 
            ! This third condition will be required for situations where we have
            ! interface coupling among different physical problems, e.g., FSI
            dofs_lid ( current_col ) = dof_lid 
            dofs_max_part_id ( current_col ) = max_part_id(dof_lid)
            raw_interface_data(neighbour_part_id, current_col) = part_id
            raw_interface_data(max_egid, current_col) = max_elem_gid(dof_lid)
            raw_interface_data(lpos_dof_max_egid, current_col) = local_idof(dof_lid)
            part_visited(part_id) = .true.
            num_parts = num_parts + 1
            current_col = current_col + 1
         end if
      end do
      
      max_elem_gid(dof_lid) = 0
      max_part_id(dof_lid) = 0
      
      do col = init_col, current_col-1
       raw_interface_data(owner_flag,col) = num_parts
       ! Undo part_visited
       part_visited ( raw_interface_data(neighbour_part_id,col) ) = .false.
      end do
    end do
  end do
  
    
 ! Free touch arrays
  call memfree ( max_elem_gid, __FILE__, __LINE__ )
  call memfree ( max_part_id, __FILE__, __LINE__ )
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( part_visited, __FILE__, __LINE__ )
  
  call this%par_fe_space_raw_interface_data_by_continuity_decide_owner (current_col-1, &
                                                                       raw_interface_data,&
                                                                       dofs_max_part_id,&
                                                                       dofs_lid)
  
  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )
  
  num_itfc_couplings = current_col-1 
end function par_fe_space_compute_raw_interface_data_by_continuity

subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner ( this, &
                                                                       num_cols, &
                                                                       raw_interface_data, &
                                                                       dofs_max_part_id,  &
                                                                       dofs_lid)
  implicit none
  class(par_fe_space_t), intent(in)    :: this
  integer(ip)          , intent(in)    :: num_cols
  integer(igp)         , intent(inout) :: raw_interface_data(num_rows_raw_interface_data,num_cols)
  integer(ip)          , intent(inout) :: dofs_max_part_id(num_cols)
  integer(ip)          , intent(inout) :: dofs_lid(num_cols)
  
  
  integer(igp)               :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)
  integer(ip) , allocatable  :: perm(:)
  integer(ip) , allocatable  :: aux(:)
  integer(ip)                :: start_col, end_col, col, mypart_id, ipart_max, j, size
  
  do col=1,num_cols
    write(*,"(10i10)") col, dofs_lid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  end do 
  
  write(*,*) '============================================================================='
  
  call memalloc ( num_cols, aux, __FILE__, __LINE__ )
  call memalloc ( num_cols, perm, __FILE__, __LINE__ )
  do col=1, num_cols
    perm(col) = col
  end do
  
  ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
                                       num_rows_raw_interface_data, &
                                       num_cols, &
                                       raw_interface_data, &
                                       perm, &
                                       l1, &
                                       l2)
  
  aux = dofs_max_part_id
  do col=1, num_cols
    dofs_max_part_id(col) = aux(perm(col))
  end do
  
  aux = dofs_lid
  do col=1, num_cols
    dofs_lid(col) = aux(perm(col))
  end do
  
  call memfree ( perm, __FILE__, __LINE__ )
  call memfree ( aux, __FILE__, __LINE__ )
  
  mypart_id = this%par_triangulation%p_env%p_context%iam + 1
  
  col = 1
  do while ( col <= num_cols ) 
      if ( raw_interface_data ( owner_flag, col ) == 2 ) then
        start_col = col
        do while  (raw_interface_data ( owner_flag, col ) == 2)
          col = col + 1
          if ( col > num_cols ) exit
        end do
        end_col = col - 1
        
        ipart_max = dofs_max_part_id(start_col)
                
        size = end_col - start_col + 1
        do j= start_col, start_col + size/2 -1
          if ( mypart_id == ipart_max ) then
            raw_interface_data ( owner_flag, j) = owner
          else 
            raw_interface_data ( owner_flag, j) = non_owner
          end if
        end do
        
        do j= start_col + size/2,  end_col
          if ( mypart_id /= ipart_max ) then
            raw_interface_data ( owner_flag, j) = owner
          else 
            raw_interface_data ( owner_flag, j) = non_owner
          end if
        end do
        
      else
        if ( mypart_id == dofs_max_part_id(col) ) then
           raw_interface_data ( owner_flag, col) = owner
        else
           if ( raw_interface_data ( neighbour_part_id, col) == dofs_max_part_id(col) ) then
             raw_interface_data ( owner_flag, col) = non_owner
           else
             raw_interface_data ( owner_flag, col) = uncoupled
           end if  
        end if
        col = col +1
      end if
      
  end do

  do col=1,num_cols
    write(*,"(10i10)") col, dofs_lid(col), dofs_max_part_id(col), raw_interface_data(:,col)
  end do 
  
end subroutine par_fe_space_raw_interface_data_by_continuity_decide_owner

function par_fe_space_compute_raw_interface_data_by_face_integ (  this, &
                                                                  fe_space_id, &
                                                                  ubound_num_itfc_couplings, &
                                                                  dofs_lid, &
                                                                  raw_interface_data ) result(num_itfc_couplings)
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)          , intent(in)    :: ubound_num_itfc_couplings
  integer(ip)          , intent(inout) :: dofs_lid(ubound_num_itfc_couplings)
  integer(igp)         , intent(inout) :: raw_interface_data(num_rows_raw_interface_data, ubound_num_itfc_couplings)
  integer(ip)                          :: num_itfc_couplings
 
  ! Locals
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_face, dof_lid
  integer(ip)  :: current_col
  integer(igp)               :: l1(num_rows_raw_interface_data), l2(num_rows_raw_interface_data)

  
  type(finite_element_t), pointer :: finite_element
  
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )
  
  mypart_id = this%par_triangulation%p_env%p_context%iam + 1 
  current_col = 1
  
  ! Traverse vefs on the interface
  do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
    vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)
    
    ! Is current vef_lid a face ?
    if ( this%triangulation%vefs(vef_lid)%dimension == this%triangulation%num_dims-1 ) then
       do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
        elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
        if ( this%par_triangulation%elems(elem_lid)%mypart /= mypart_id ) then
          part_id = this%par_triangulation%elems(elem_lid)%mypart
        end if
       end do
       
       do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
        elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
        elem_gid = this%par_triangulation%elems(elem_lid)%globalID
        finite_element => this%par_fe_space_get_finite_element(elem_lid)
        ivef = finite_element%cell%find_local_pos_from_vef_id(vef_lid)
        do idof_face=1, finite_element%reference_fe_phy(fe_space_id)%p%get_number_nodes_vef(ivef)
          idof = finite_element%reference_fe_phy(fe_space_id)%p%get_node_vef(idof_face,ivef)
          dof_lid = finite_element%elem2dof(fe_space_id)%p(idof)
          dofs_lid ( current_col ) = dof_lid 
          raw_interface_data(neighbour_part_id, current_col) = part_id
          raw_interface_data(max_egid, current_col) = elem_gid
          raw_interface_data(lpos_dof_max_egid, current_col) = idof
          if ( mypart_id == this%par_triangulation%elems(elem_lid)%mypart ) then
            raw_interface_data(owner_flag,current_col) = owner
          else
            raw_interface_data(owner_flag,current_col) = non_owner
          end if
          current_col = current_col + 1
        end do 
       end do  
    end if
  end do
  
  num_itfc_couplings = current_col-1
  
  
  ! Re-number interface DoF couplings in increasing order by neighbour part id, the
  ! number of neighbour parts around, and e_max + local_pos_dof_in_emax
  call sort_array_cols_by_row_section( num_rows_raw_interface_data, &
                                       num_rows_raw_interface_data, &
                                       num_itfc_couplings, &
                                       raw_interface_data, &
                                       dofs_lid, &
                                       l1, &
                                       l2)
  do current_col=1,num_itfc_couplings 
    write(*,"(10i10)") current_col, dofs_lid(current_col), raw_interface_data(:,current_col)
  end do 
  
end function par_fe_space_compute_raw_interface_data_by_face_integ


!function serial_fe_space_create_assembler(this, &
!                          diagonal_blocks_symmetric_storage,&
!                          diagonal_blocks_symmetric, & 
!                          diagonal_blocks_sign)
!  implicit none
!  class(serial_fe_space_t)          , intent(in) :: this
!  logical                           , intent(in) :: diagonal_blocks_symmetric_storage(this%number_blocks)
!  logical                           , intent(in) :: diagonal_blocks_symmetric(this%number_blocks)
!  integer(ip)                       , intent(in) :: diagonal_blocks_sign(this%number_blocks)
!  class(matrix_array_assembler_t)   , pointer    :: serial_fe_space_create_assembler
!  
!  ! Locals
!  class(matrix_t), pointer :: matrix
!  class(array_t) , pointer :: array
!		logical, allocatable :: blocks_coupling(:,:)
!		integer(ip)          :: ife_space, jfe_space
!		integer(ip)          :: iblock, jblock

!  if (this%number_blocks == 1) then
!     allocate ( sparse_matrix_array_assembler_t :: serial_fe_space_create_assembler )
!     allocate ( sparse_matrix_t :: matrix )
!     allocate ( serial_scalar_array_t  :: array )
!     select type(matrix)
!        class is(sparse_matrix_t)
!        call matrix%create(this%number_dofs(1), &
!                           diagonal_blocks_symmetric_storage(1),&
!                           diagonal_blocks_symmetric(1),&
!                           diagonal_blocks_sign(1))
!        class default
!        check(.false.)
!     end select
!     select type(array)
!        class is(serial_scalar_array_t)
!        call array%create(this%number_dofs(1))
!        class default
!        check(.false.)
!     end select
!  else
!     allocate ( block_sparse_matrix_array_assembler_t :: serial_fe_space_create_assembler )
!     allocate ( block_sparse_matrix_t :: matrix )
!     allocate ( serial_block_array_t  :: array )
!     select type(matrix)
!        class is (block_sparse_matrix_t)
!        call matrix%create(this%number_blocks,this%number_dofs,this%number_dofs,&
!             &             diagonal_blocks_symmetric_storage,diagonal_blocks_symmetric,diagonal_blocks_sign)

!	call memalloc ( this%number_blocks, this%number_blocks, blocks_coupling, __FILE__, __LINE__)
!	blocks_coupling = .false.
!	do jfe_space=1,this%number_fe_spaces
!	   do ife_space=1,this%number_fe_spaces
!		 blocks_coupling(this%field_blocks(ife_space), this%field_blocks(jfe_space)) =  this%field_coupling(ife_space,jfe_space)
!           end do
!	end do
!								
!	do jblock=1,this%number_blocks
!               do iblock=1,this%number_blocks
!            if (.not. blocks_coupling(iblock,jblock) ) then
!		  call matrix%set_block_to_zero(iblock,jblock)
!	    end if
!	      end do
!	end do				

!	call memfree ( blocks_coupling, __FILE__, __LINE__)
!        
!      class default
!        check(.false.)
!     end select
!     select type(array)
!        class is(serial_block_array_t)
!        call array%create(this%number_blocks,this%number_dofs)
!        class default
!        check(.false.)
!     end select
!  end if
!  call serial_fe_space_create_assembler%set_matrix(matrix)
!  call serial_fe_space_create_assembler%set_array(array)
!end function serial_fe_space_create_assembler

!subroutine serial_fe_space_symbolic_setup_assembler(this,matrix_array_assembler)
!  implicit none
!  class(serial_fe_space_t)        , intent(in)    :: this
!  class(matrix_array_assembler_t) , intent(inout) :: matrix_array_assembler
!  ! Polymorphic matrix 
!  class(matrix_t), pointer :: matrix

!  matrix => matrix_array_assembler%get_matrix()
!  select type(matrix)
!     class is(sparse_matrix_t)
!     class is(block_sparse_matrix_t)
!     class default
!     check(.false.)
!  end select
!end subroutine serial_fe_space_symbolic_setup_assembler

