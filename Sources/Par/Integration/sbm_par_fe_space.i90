! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine par_fe_space_create( this, &
                                par_triangulation, &
                                par_boundary_conditions, &
                                reference_fe_phy, &
                                field_blocks, &
                                field_coupling )
  implicit none
  class(par_fe_space_t)           , intent(inout) :: this
  type(par_triangulation_t),target, intent(in)    :: par_triangulation
  type(par_conditions_t)          , intent(in)    :: par_boundary_conditions
  type(p_reference_fe_t)  , target, intent(in)    :: reference_fe_phy(:)
  integer(ip)           , optional, intent(in)    :: field_blocks(:)
  logical               , optional, intent(in)    :: field_coupling(:,:)
 
  integer(ip) :: i
  integer(ip) :: num_elems, num_ghosts
 
  call this%free()
  
  this%par_triangulation => par_triangulation
  if ( par_triangulation%p_env%p_context%iam >= 0 ) then
    call this%serial_fe_space_t%create( par_triangulation%f_trian, &
                                        par_boundary_conditions%f_conditions, &
                                        reference_fe_phy, &
                                        field_blocks, &
                                        field_coupling )       
    
    num_elems  = par_triangulation%num_elems
    num_ghosts = par_triangulation%num_ghosts
    
    allocate(this%ghost_fe_array(num_ghosts))
    do i=1, num_ghosts
       call this%ghost_fe_array(i)%create (this%triangulation%elems(num_elems+i),&
                                           this%number_fe_spaces,&
                                           this%reference_fe_phy_list, &
                                           this%quadrature(1)%p,&
                                           this%fe_map(1)%p,&
                                           this%volume_integrator,&
                                           this%number_blocks,&
                                           this%field_blocks,&
                                           par_boundary_conditions%f_conditions)
    end do
  end if
  
end subroutine par_fe_space_create

subroutine par_fe_space_free( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip) :: i
 
  if ( associated (this%par_triangulation) ) then
    if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
      call this%serial_fe_space_t%free()
      do i=1, this%par_triangulation%num_ghosts
        call this%ghost_fe_array(i)%free()
      end do
      deallocate(this%ghost_fe_array)
    end if
    nullify(this%par_triangulation)
  end if
  
end subroutine par_fe_space_free

function par_fe_space_get_finite_element( this, ielem )
  implicit none
  class(par_fe_space_t), target, intent(inout) :: this
  integer(ip)                  , intent(in)    :: ielem
  type(finite_element_t), pointer              :: par_fe_space_get_finite_element
  integer(ip) :: num_local_elems
  
  assert ( associated (this%par_triangulation) )
  nullify (par_fe_space_get_finite_element)
  
  if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
    num_local_elems = this%par_triangulation%num_elems  
    if ( ielem <= num_local_elems ) then
     par_fe_space_get_finite_element => this%fe_array(ielem)
    else
     par_fe_space_get_finite_element => this%ghost_fe_array(ielem-num_local_elems)
    end if
  end if  
end function par_fe_space_get_finite_element


subroutine par_fe_space_print ( this )
  class(par_fe_space_t), intent(in) :: this 
  integer(ip) :: i,j
  
  if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
    call this%serial_fe_space_t%print()
    do i = 1, this%par_triangulation%num_ghosts
     write(*,*) '********* GHOST ELEMENT: ',i,'********'
     write(*,*) '********* ELEMENT 2 DOF********'
     do j = 1, this%number_fe_spaces
        write(*,*) '********* FE COMPONENT: ',j,'********'
        write(*,*) this%ghost_fe_array(i)%elem2dof(j)%p
     end do
    end do
  end if
  
  !do i  = 1, this%triangulation%number_interior_faces
  !   write(*,*) '--------------------- Face: ',i,'-------------------------'
  !   write(*,*) '-- Elem 1 --'
  !   write(*,*) this%face_array(i)%neighbour_fe(1)%p%elem2dof(1)%p
  !   write(*,*) '-- Elem 2 --'
  !   write(*,*) this%face_array(i)%neighbour_fe(2)%p%elem2dof(1)%p
  !end do

end subroutine par_fe_space_print


subroutine par_fe_space_fill_dof_info( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this 
  integer(ip) :: iblock, fe_space_id
  
  assert ( associated (this%par_triangulation) )
  if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
    call this%serial_fe_space_t%fill_dof_info()
    do fe_space_id = 1, this%number_fe_spaces
      call this%par_fe_space_fill_elem2dof_and_count_dofs( fe_space_id )
    end do
  end if
  
end subroutine par_fe_space_fill_dof_info

subroutine par_fe_space_fill_elem2dof_and_count_dofs( this, fe_space_id ) 
  implicit none
  ! Parameters
  class(par_fe_space_t)      , intent(inout) :: this 
  integer(ip)                , intent(in)    :: fe_space_id
  
  ! Local variables
  integer(ip) :: ivef, vef_lid, ighost, ielem, elem_id, ivef_in_elem_id
  integer(ip) :: num_elems, num_ghosts
  integer(ip) :: first_face_id, num_faces
  integer(ip) :: iblock, init_dof_block, current_dof_block
  integer(ip), allocatable :: s2t_perm_for_interior_nodes_vef(:)

  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )
  
  iblock            = this%field_blocks(fe_space_id)
  init_dof_block    = this%number_dofs_per_block(iblock)
  current_dof_block = init_dof_block

  call memalloc ( this%get_max_number_nodes(), s2t_perm_for_interior_nodes_vef, __FILE__, __LINE__ )
  do ighost = 1, this%par_triangulation%num_ghosts
     if ( this%ghost_fe_array(ighost)%reference_fe_phy(fe_space_id)%p%get_continuity() ) then
       ! Fill elem2dof on ghost elements from the elem2dof 
       ! already computed on neighbouring local elements
       do ivef = 1, this%ghost_fe_array(ighost)%cell%num_vefs
          vef_lid = this%ghost_fe_array(ighost)%cell%vefs(ivef)
          if ( vef_lid /= -1 ) then
            ! Find local element around vef_lid in elem_id
            do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
              elem_id = this%triangulation%vefs(vef_lid)%elems_around(ielem)
              ! Is elem_id a local element ?
              if ( elem_id <= this%triangulation%num_elems ) exit
            end do
            
            ! Find local position of vef_lid in elem_id            
            ivef_in_elem_id = this%fe_array(elem_id)%cell%find_local_pos_from_vef_id(vef_lid)
            
            call this%ghost_fe_array(ighost)%fill_interior_dofs_on_vef_from_source_element ( ivef, &
                                                                                             this%fe_array(elem_id), &
                                                                                             ivef_in_elem_id, &
                                                                                             fe_space_id, &
                                                                                             s2t_perm_for_interior_nodes_vef )
          end if
       end do 
     else
       ! Fill elem2dof on ghost elements by assigning new dof identifiers
       ! to all DoFs placed on local faces
       first_face_id = this%ghost_fe_array(ighost)%cell%reference_fe_geo%get_first_face_id()
       num_faces     = this%ghost_fe_array(ighost)%cell%reference_fe_geo%get_number_faces()
       do ivef = first_face_id, first_face_id+num_faces-1
         vef_lid = this%ghost_fe_array(ighost)%cell%vefs(ivef)
         if ( vef_lid /= -1 ) then
         call this%ghost_fe_array(ighost)%fill_dofs_on_vef ( ivef, &
                                                             fe_space_id, &
                                                             current_dof_block )
         end if
       end do
     end if
  end do   
  call memfree ( s2t_perm_for_interior_nodes_vef, __FILE__, __LINE__ )

  this%number_dofs_per_field(fe_space_id) = this%number_dofs_per_field(fe_space_id) + & 
                                            (current_dof_block - init_dof_block)
  this%number_dofs_per_block(iblock) = this%number_dofs_per_block(iblock) + &
                                       (current_dof_block - init_dof_block) 
end subroutine par_fe_space_fill_elem2dof_and_count_dofs

subroutine par_fe_space_compute_dof_import( this )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  
  assert ( associated (this%par_triangulation) )
  if ( this%par_triangulation%p_env%p_context%iam >= 0 ) then
     call this%par_fe_space_compute_raw_interface_data(1)
  end if
  
end subroutine par_fe_space_compute_dof_import

function par_fe_space_compute_ubound_number_interface_couplings( this, fe_space_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
  integer(ip)                          :: par_fe_space_compute_ubound_number_interface_couplings
  
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: elem_lid
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(ip)  :: idof, idof_interior, dof_lid
  type(finite_element_t), pointer :: finite_element
  
  integer(ip) :: result
  
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )
  
  mypart_id = this%par_triangulation%p_env%p_context%iam + 1 
  
  result = 0 
  ! Traverse vefs on the interface
  do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
    vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)  
    do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
      elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
      part_id = this%par_triangulation%elems(elem_lid)%mypart
      if ( part_id /= mypart_id ) then
        finite_element => this%par_fe_space_get_finite_element(elem_lid)
        ivef = finite_element%cell%find_local_pos_from_vef_id(vef_lid)
        result = result + finite_element%reference_fe_phy(fe_space_id)%p%get_number_interior_nodes_vef(ivef)
      end if  
    end do
  end do
  par_fe_space_compute_ubound_number_interface_couplings = result
end function par_fe_space_compute_ubound_number_interface_couplings

subroutine par_fe_space_compute_raw_interface_data (  this, fe_space_id )
  implicit none
  class(par_fe_space_t), intent(inout) :: this
  integer(ip)          , intent(in)    :: fe_space_id
 
  ! Locals
  integer(ip)  :: ivef, ivef_itfc, ielem, vef_lid
  integer(igp) :: elem_gid
  integer(ip)  :: mypart_id, part_id
  integer(ip)  :: ivef_in_elem_id, elem_lid, max_elem_lid
  integer(ip)  :: idof, idof_interior, dof_lid
  integer(ip)  :: num_dofs_current_vef
  integer(ip)  :: row, init_row, current_row
  integer(ip)  :: num_parts
  integer(ip)  :: ubound_num_itfc_couplings

  
  integer(igp), allocatable :: max_elem_gid(:)
  integer(ip) , allocatable :: max_part_id(:)
  integer(ip) , allocatable :: local_idof(:)  
  integer(ip) , allocatable :: lst_dofs_current_vef(:)
  logical     , allocatable :: part_visited(:)
  
  integer(igp), allocatable :: dofs_max_part_id(:)
  integer(igp), allocatable :: dofs_lid(:)
  integer(igp), allocatable :: raw_interface_data(:,:)
    
  type(finite_element_t), pointer :: finite_element
  
  assert ( associated (this%par_triangulation) )
  assert ( this%par_triangulation%p_env%p_context%iam >= 0 )

  ! Allocate touch arrays (we could reduce memory consumption by using hash tables here)
  call memalloc ( this%number_dofs_per_field(fe_space_id), max_elem_gid, __FILE__, __LINE__ )
  call memalloc ( this%number_dofs_per_field(fe_space_id), max_part_id, __FILE__, __LINE__ )
  call memalloc ( this%number_dofs_per_field(fe_space_id), local_idof, __FILE__, __LINE__ )
  call memalloc ( this%number_dofs_per_field(fe_space_id), lst_dofs_current_vef, __FILE__, __LINE__ )
  call memalloc ( this%par_triangulation%p_env%p_context%np, part_visited, __FILE__, __LINE__ )

  ubound_num_itfc_couplings = this%par_fe_space_compute_ubound_number_interface_couplings(fe_space_id)
  
  call memalloc ( ubound_num_itfc_couplings, dofs_max_part_id, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, dofs_lid, __FILE__, __LINE__ )
  call memalloc ( ubound_num_itfc_couplings, 4, raw_interface_data, __FILE__, __LINE__ )
  
  mypart_id = this%par_triangulation%p_env%p_context%iam + 1 
  
  max_elem_gid = 0
  max_part_id  = 0
  part_visited = .false.
  current_row  = 1
  
  ! Traverse vefs on the interface
  do ivef_itfc = 1, this%par_triangulation%num_itfc_vefs
    vef_lid = this%par_triangulation%lst_itfc_vefs(ivef_itfc)
    
    num_dofs_current_vef = 0
    ! Identify the total set of dofs in current vef
    do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
      elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
      elem_gid = this%par_triangulation%elems(elem_lid)%globalID
      part_id = this%par_triangulation%elems(elem_lid)%mypart
      finite_element => this%par_fe_space_get_finite_element(elem_lid)
      ivef = finite_element%cell%find_local_pos_from_vef_id(vef_lid)
      do idof_interior=1, finite_element%reference_fe_phy(fe_space_id)%p%get_number_interior_nodes_vef(ivef)
        idof = finite_element%reference_fe_phy(fe_space_id)%p%get_interior_node_vef(idof_interior,ivef)
        dof_lid = finite_element%elem2dof(fe_space_id)%p(idof)
        if ( dof_lid == 0 ) cycle
        if ( max_elem_gid(dof_lid) == 0 ) then
           num_dofs_current_vef = num_dofs_current_vef + 1    
           lst_dofs_current_vef (num_dofs_current_vef) = dof_lid
        end if
        if ( elem_gid > max_elem_gid(dof_lid) ) then
          max_elem_gid(dof_lid) = elem_gid
          local_idof(dof_lid) = idof
        end if
        max_part_id(dof_lid) = max(part_id, max_part_id(dof_lid) )
      end do
    end do  
    
    init_row = current_row
    do idof=1, num_dofs_current_vef
      dof_lid = lst_dofs_current_vef(idof)
      num_parts = 1
      do ielem=1, this%triangulation%vefs(vef_lid)%num_elems_around
         elem_lid = this%triangulation%vefs(vef_lid)%elems_around(ielem)
         part_id = this%par_triangulation%elems(elem_lid)%mypart
         if ( part_id /= mypart_id .and. .not. part_visited(part_id) ) then 
            ! .and. finite_element%is_dof_present(dof_lid) ) then 
            ! This third condition will be required for situations where we have
            ! interface coupling among different physical problems, e.g., FSI
            dofs_lid ( current_row ) = dof_lid 
            dofs_max_part_id ( current_row ) = max_part_id(dof_lid)
            raw_interface_data(current_row, neighbour_part_id) = part_id
            raw_interface_data(current_row, max_egid) = max_elem_gid(dof_lid)
            raw_interface_data(current_row, lpos_dof_max_egid) = local_idof(dof_lid)
            part_visited(part_id) = .true.
            num_parts = num_parts + 1
            current_row = current_row + 1
         end if
      end do
      
      max_elem_gid(dof_lid) = 0
      max_part_id(dof_lid) = 0
      
      do row = init_row, current_row-1
       raw_interface_data(row, owner_flag) = num_parts
       ! Undo part_visited
       part_visited ( raw_interface_data(row, neighbour_part_id) ) = .false.
      end do
    end do
  end do
  
  do row=1,current_row-1
    write(*,*) row, dofs_lid(row), dofs_max_part_id(row), raw_interface_data(row,:)
  end do 
    
 ! Free touch arrays
  call memfree ( max_elem_gid, __FILE__, __LINE__ )
  call memfree ( max_part_id, __FILE__, __LINE__ )
  call memfree ( local_idof, __FILE__, __LINE__ )
  call memfree ( lst_dofs_current_vef, __FILE__, __LINE__ )
  call memfree ( part_visited, __FILE__, __LINE__ )
  call memfree ( dofs_max_part_id, __FILE__, __LINE__ )
  call memfree ( dofs_lid, __FILE__, __LINE__ )
  call memfree ( raw_interface_data, __FILE__, __LINE__ )
  
end subroutine par_fe_space_compute_raw_interface_data

!function serial_fe_space_create_assembler(this, &
!                          diagonal_blocks_symmetric_storage,&
!                          diagonal_blocks_symmetric, & 
!                          diagonal_blocks_sign)
!  implicit none
!  class(serial_fe_space_t)          , intent(in) :: this
!  logical                           , intent(in) :: diagonal_blocks_symmetric_storage(this%number_blocks)
!  logical                           , intent(in) :: diagonal_blocks_symmetric(this%number_blocks)
!  integer(ip)                       , intent(in) :: diagonal_blocks_sign(this%number_blocks)
!  class(matrix_array_assembler_t)   , pointer    :: serial_fe_space_create_assembler
!  
!  ! Locals
!  class(matrix_t), pointer :: matrix
!  class(array_t) , pointer :: array
!		logical, allocatable :: blocks_coupling(:,:)
!		integer(ip)          :: ife_space, jfe_space
!		integer(ip)          :: iblock, jblock

!  if (this%number_blocks == 1) then
!     allocate ( sparse_matrix_array_assembler_t :: serial_fe_space_create_assembler )
!     allocate ( sparse_matrix_t :: matrix )
!     allocate ( serial_scalar_array_t  :: array )
!     select type(matrix)
!        class is(sparse_matrix_t)
!        call matrix%create(this%number_dofs(1), &
!                           diagonal_blocks_symmetric_storage(1),&
!                           diagonal_blocks_symmetric(1),&
!                           diagonal_blocks_sign(1))
!        class default
!        check(.false.)
!     end select
!     select type(array)
!        class is(serial_scalar_array_t)
!        call array%create(this%number_dofs(1))
!        class default
!        check(.false.)
!     end select
!  else
!     allocate ( block_sparse_matrix_array_assembler_t :: serial_fe_space_create_assembler )
!     allocate ( block_sparse_matrix_t :: matrix )
!     allocate ( serial_block_array_t  :: array )
!     select type(matrix)
!        class is (block_sparse_matrix_t)
!        call matrix%create(this%number_blocks,this%number_dofs,this%number_dofs,&
!             &             diagonal_blocks_symmetric_storage,diagonal_blocks_symmetric,diagonal_blocks_sign)

!	call memalloc ( this%number_blocks, this%number_blocks, blocks_coupling, __FILE__, __LINE__)
!	blocks_coupling = .false.
!	do jfe_space=1,this%number_fe_spaces
!	   do ife_space=1,this%number_fe_spaces
!		 blocks_coupling(this%field_blocks(ife_space), this%field_blocks(jfe_space)) =  this%field_coupling(ife_space,jfe_space)
!           end do
!	end do
!								
!	do jblock=1,this%number_blocks
!               do iblock=1,this%number_blocks
!            if (.not. blocks_coupling(iblock,jblock) ) then
!		  call matrix%set_block_to_zero(iblock,jblock)
!	    end if
!	      end do
!	end do				

!	call memfree ( blocks_coupling, __FILE__, __LINE__)
!        
!      class default
!        check(.false.)
!     end select
!     select type(array)
!        class is(serial_block_array_t)
!        call array%create(this%number_blocks,this%number_dofs)
!        class default
!        check(.false.)
!     end select
!  end if
!  call serial_fe_space_create_assembler%set_matrix(matrix)
!  call serial_fe_space_create_assembler%set_array(array)
!end function serial_fe_space_create_assembler

!subroutine serial_fe_space_symbolic_setup_assembler(this,matrix_array_assembler)
!  implicit none
!  class(serial_fe_space_t)        , intent(in)    :: this
!  class(matrix_array_assembler_t) , intent(inout) :: matrix_array_assembler
!  ! Polymorphic matrix 
!  class(matrix_t), pointer :: matrix

!  matrix => matrix_array_assembler%get_matrix()
!  select type(matrix)
!     class is(sparse_matrix_t)
!     class is(block_sparse_matrix_t)
!     class default
!     check(.false.)
!  end select
!end subroutine serial_fe_space_symbolic_setup_assembler

