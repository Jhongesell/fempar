! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************************
!***********************************************************************
! Templated implementation of a hash table based element set, extension of 
! the abstract element_set defined in element_set.i90. The code is similar 
! but has some differences with respect to standard hash_tables used elsewhere
! in FEMPAR. An iterator over the table is also defined.
!
! Templates are not natively supported by fortran.
! They are emulated using the preprocessor by including this file in a module 
! AFTER the contains statement and after a definition of:
!
! template_element_t
! hash_template_element_set_t
! hash_template_element_iterator_t
!  
!====================================================================
! node functions
!
recursive subroutine put_hash_node(list,key,stat)
  class(hash_node), target , intent(inout) :: list
  key_type        , intent(in)    :: key
  integer(ip)              , intent(out)   :: stat
  class(hash_node)         , pointer       :: newel => null()

  if( key>list%key ) then
     if(associated(list%child) ) then
        ! Keep going
        call put_hash_node(list%child,key,stat)
     else
        ! We are at the end of the list
        ! Allocate a new child
        allocate(list%child)
        list%child%parent => list
        ! WARNING: we need assignment working (both in key and val)!
        list%child%key = list%key ! the default value
        ! Fill the value 
        list%key = key
        allocate(list%val)
     end if
  else if( key==list%key ) then
     ! Already stored
     stat = was_stored
  else if( key<list%key ) then
     ! ! Insert an element just behind
     !
     ! Insert an element just after this one,
     ! copy list keyval and store keyval in list.
     ! allocate(newel)
     ! newel%child => list%child
     ! newel%parent => list
     ! newel%key = list%key
     ! newel%val = list%val
     ! if(associated(list%child)) list%child%parent => newel
     ! list%child => newel
     ! list%key = key
     ! list%val = val
     ! stat = now_stored
     !
     newel => list%child        ! keep the reference to old child
     allocate(list%child)       ! Allocate a new child
     ! WARNING: we need assignment working (both in key and val)!
     list%child%key = list%key  ! New child fields (copy list keyval)
     list%child%val = list%val
     list%child%parent => list
     list%child%child => newel
     list%child%child%parent => list%child ! Regenerate link
     list%key = key                        ! Store keyval in list
     allocate( list%val)
     stat = now_stored
  end if
end subroutine put_hash_node

recursive subroutine del_hash_node(list,key,stat)
  class(hash_node)   , target, intent(inout) :: list
  key_type       , intent(in)    :: key
  integer(ip)                , intent(out)   :: stat
  class(hash_node)           , pointer       :: tmp => null()

  if( key==list%key ) then
     !if(associated(list%parent)) then ! this is not the first element
     !   tmp => list
     !   list%parent%child => list%child
     !   list%child%parent => list%parent
     !else                             ! this is the first element (copy and dealloc the second)
     !   tmp => list%child
     if(.not.associated(list%child)) then
        write(*,*) 'Error in migratory_element hash table'
        stat = error
        return
     end if
     ! WARNING: we need assignment working (both in key and val)!
     list%key = list%child%key
     list%val = list%child%val
     if(associated(list%child%child)) list%child%child%parent => list
     tmp => list%child%child
     call list%child%val%free()
     deallocate(list%child)
     list%child => tmp
     stat = deleted
  else if(associated(list%child)) then ! keep going
     call del_hash_node(list%child,key,stat)
  else
     stat = key_not_found
  end if
  return

end subroutine del_hash_node

recursive subroutine get_hash_node(list,key,val,stat)
  class(hash_node)     , target     , intent(in)    :: list
  key_type              , intent(in)    :: key
  type(template_element_t), pointer, intent(out)   :: val
  integer(ip)                       , intent(inout) :: stat

  if( key==list%key ) then
     val => list%val
     stat = key_found
  else if(associated(list%child)) then ! keep going
     call get_hash_node(list%child,key,val,stat)
  else
     stat = key_not_found
  end if
  return

end subroutine get_hash_node

recursive subroutine free_hash_node(list)
  implicit none
  class(hash_node), intent(inout) :: list
  if (associated(list%child)) then
     call free_hash_node(list%child)
     deallocate(list%child)
  end if
  call list%val%free()
  list%child => null()
end subroutine free_hash_node

! To get the next node in the list
subroutine get_next_hash_node(list,next,stat)
  class(hash_node)        , intent(in)    :: list
  type(hash_node), pointer, intent(out)   :: next
  integer(ip)             , intent(inout) :: stat
  if(associated(list%child)) then
     next => list%child
     stat = key_found
  else
     next => null()
     stat = key_not_found
  end if
end subroutine get_next_hash_node

! To get the first element in the list
subroutine get_first_hash_node(list,first,stat)
  class(hash_node), target, intent(in)    :: list
  type(hash_node), pointer, intent(out)   :: first
  integer(ip)             , intent(inout) :: stat

  if(associated(list%child)) then
     first => list
     stat = key_found
  else
     stat = key_not_found
  end if

end subroutine get_first_hash_node

!====================================================================
! Set (table) functions
!====================================================================
subroutine create_hash_template_element_set_t(this,size)
  class(hash_template_element_set_t), intent(inout) :: this
  integer(ip)                       , intent(in)    :: size
  !class(template_element_t)         , intent(in)    :: mold
  this%vec_len = size
  if (allocated(this%vec)) deallocate(this%vec)
  !allocate(this%vec(this%vec_len),mold=mold)
  allocate(this%vec(this%vec_len))
end subroutine create_hash_template_element_set_t

subroutine put_hash_template_element_set_t(tbl,key,stat)
  class(hash_template_element_set_t)  , intent(inout) :: tbl
  key_type                            , intent(in)    :: key
  integer(ip)                         , intent(out)   :: stat
  integer(ip)                        :: hash
  hash = mod( convert_to_int(key) ,tbl%vec_len)
  assert ( (hash>=1).and.(hash<=tbl%vec_len) )
  !$OMP CRITICAL (hash_template_element_set_t_lock)
  call tbl%vec(hash)%put(key=key,stat=stat)
  !$OMP END CRITICAL (hash_template_element_set_t_lock)
end subroutine put_hash_template_element_set_t

function get_hash_template_element_set_t(this,id,stat) result(p)
  class(hash_template_element_set_t),target, intent(in)    :: this
  key_type                , intent(in)    :: id
  type(template_element_t), pointer   :: p
  integer(ip)             , optional  , intent(out)   :: stat
  integer(ip)                                         :: hash
  hash = mod( convert_to_int(id) ,this%vec_len)
  assert ( (hash>=1).and.(hash<=this%vec_len) )
  call this%vec(hash)%get(key=id,val=p,stat=stat)
end function get_hash_template_element_set_t

function get_hash_abstract_element_set_t(this,id,stat) result(p)
  class(hash_template_element_set_t),target, intent(in)    :: this
  key_type                , intent(in)    :: id
  class(template_element_t), pointer      :: p
  integer(ip)             , optional  , intent(out)   :: stat
  integer(ip)                                         :: hash
  hash = mod( convert_to_int(id) ,this%vec_len)
  assert ( (hash>=1).and.(hash<=this%vec_len) )
  call this%vec(hash)%get(key=id,val=p,stat=stat)
end function get_hash_abstract_element_set_t

subroutine get_next_hash_template_element_set_t(tbl,current,next,stat)
  class(hash_template_element_set_t)  , intent(in)  :: tbl
  type(hash_node)                     , intent(in)  :: current
  type(hash_node)            ,pointer , intent(out) :: next
  integer(ip)                         , intent(out) :: stat
  integer(ip)                                       :: hash
  next => null()
  call current%get_next(next,stat)
  if(stat == key_not_found ) then
     hash = mod( convert_to_int(current%key),tbl%vec_len)
     assert ( (hash>=1).and.(hash<=tbl%vec_len) )
     do while(hash<=tbl%vec_len .and. stat == key_not_found )
        hash=hash+1
        call tbl%vec(hash)%get_first(next,stat)
     end do
  end if
end subroutine get_next_hash_template_element_set_t

subroutine del_hash_template_element_set_t(tbl,key,stat)
  class(hash_template_element_set_t), intent(inout) :: tbl
  key_type              , intent(in)    :: key
  integer(ip)                       , intent(out)   :: stat
  integer(ip)                                       :: hash

  hash = mod( convert_to_int(key) ,tbl%vec_len)
  assert ( (hash>=1).and.(hash<=tbl%vec_len) )
  !$OMP CRITICAL (hash_template_element_set_t_lock)
  call tbl%vec(hash)%del(key=key,stat=stat)
  !$OMP END CRITICAL (hash_template_element_set_t_lock)
end subroutine del_hash_template_element_set_t

subroutine free_hash_template_element_set_t(this)
  class(hash_template_element_set_t), intent(inout) :: this    
  integer(ip) :: i
  if (allocated(this%vec)) then
     do i=1,this%vec_len
        call this%vec(i)%free()
     end do
     deallocate(this%vec)
  end if
  this%is_init = .false.
end subroutine free_hash_template_element_set_t

!=============================================================================
subroutine create_hash_template_element_iterator(this,iterator)
  implicit none
  class(hash_template_element_set_t)          , target     , intent(in)  :: this
  class(abstract_template_element_iterator_t) , allocatable, intent(out) :: iterator
  integer(ip) :: istat
  allocate(hash_template_element_iterator_t :: iterator, stat=istat)
  check( istat==0 )
  select type(iterator)
     class is(hash_template_element_iterator_t)
     iterator%hash_template_element_set => this
  end select
end subroutine create_hash_template_element_iterator

!=============================================================================
subroutine free_hash_template_element_iterator(this,iterator)
  implicit none
  class(hash_template_element_set_t)             , intent(in)    :: this
  class(abstract_template_element_iterator_t), allocatable, intent(inout) :: iterator
  ! No internal memory for this simple iterator.
  deallocate(iterator)
end subroutine free_hash_template_element_iterator

!=============================================================================
! Iterator functions
!=============================================================================
subroutine hash_template_element_iterator_begin (this)
  implicit none
  class(hash_template_element_iterator_t), intent(inout) :: this
  type(hash_node), pointer :: first 
  integer(ip) :: stat
  first => this%hash_template_element_set%vec(1)
  call this%hash_template_element_set%get_next(first,this%current_node,stat)
  call this%hash_template_element_set%get_next(this%current_node,this%next_node,stat)
end subroutine hash_template_element_iterator_begin

!=============================================================================
function hash_template_element_iterator_finished(this) result(res)
  implicit none
  class(hash_template_element_iterator_t), intent(inout) :: this
  logical :: res
  res = associated(this%next_node)
end function hash_template_element_iterator_finished

!=============================================================================
subroutine hash_template_element_iterator_next (this)
  implicit none
  class(hash_template_element_iterator_t), intent(inout) :: this
  integer(ip) :: stat
  this%current_node => this%next_node
  call this%hash_template_element_set%get_next(this%current_node,this%next_node,stat)
end subroutine hash_template_element_iterator_next
!=============================================================================
function hash_template_element_iterator_current (this) result(p)
  implicit none
  class(hash_template_element_iterator_t), intent(inout) :: this
  type(template_element_t)  , pointer       :: p
  p => this%current_node%val
end function hash_template_element_iterator_current
!=============================================================================
#ifdef abstract_element_t
function hash_abstract_element_iterator_t (this) result(p)
  implicit none
  class(hash_template_element_iterator_t), intent(inout) :: this
  class(abstract_element_t)              , pointer       :: p
  p => this%current_node%val
end function hash_abstract_element_iterator_t
#endif
!=============================================================================
subroutine hash_template_element_iterator_get_local_id (this,id)
  implicit none
  class(hash_template_element_iterator_t), intent(in) :: this
  integer(ip)                            , intent(out) :: id
  id = this%current_node%key
end subroutine hash_template_element_iterator_get_local_id





