! Templated implementation of a static element set and its iterator. 
! Templates are not natively supported by fortran.
! They are emulated using the preprocessor by including this file in a module 
! AFTER the contains statement and after a definition of:
!
! template_element_t                 : the base data type of the set
! static_template_element_set_t      : 
! static_template_element_iterator_t : 
!
! abstract_element_t                 : if defined, it provides a parent type to 
!                                      define an iterator over abstract elements
! static_abstract_element_iterator_t : the type of the iterator over abstract
!                                      elements.
!
!=============================================================================
! Set functions
!=============================================================================
subroutine create_static_set(this,size)
  implicit none
  class(static_template_element_set_t), intent(inout) :: this
  integer(ip)                         , intent(in)    :: size
  integer(ip) :: istat
  ! Create set
  this%num_elements = size
  !allocate( template_element_t ::  this%elements(this%num_elements), stat=istat)
  allocate( this%elements(this%num_elements), stat=istat)
  check(istat==0)
end subroutine create_static_set
!=============================================================================
subroutine free_static_set(this)
  implicit none
  class(static_template_element_set_t), intent(inout)  :: this
  integer(ip) :: istat
  this%num_elements = -1
  deallocate(this%elements, stat=istat)
  check(istat==0)
end subroutine free_static_set
!=============================================================================
function get_element_pointer(this,id,stat) result(p)
  class(static_template_element_set_t), target, intent(in)  :: this
  integer(ip)                         , intent(in)  :: id
  integer(ip)             , optional  , intent(out) :: stat     
  type(template_element_t), pointer :: p
  if( id <= this%num_elements ) then
     p => this%elements(id)
     if(present(stat)) stat = key_found
  else if(present(stat)) then
     p => null()
     stat = key_not_found
  end if
end function get_element_pointer
!=============================================================================
function get_element_class_pointer(this,id,stat) result(p)
  class(static_template_element_set_t), target, intent(in)  :: this
  integer(ip)                         , intent(in)  :: id
  integer(ip)              , optional , intent(out) :: stat     
  class(template_element_t), pointer :: p
  if( id <= this%num_elements ) then
     p => this%elements(id)
     if(present(stat)) stat = key_found
  else if(present(stat)) then
     p => null()
     stat = key_not_found
  end if
end function get_element_class_pointer
!=============================================================================
subroutine create_static_iterator(this,iterator)
  implicit none
  class(static_template_element_set_t)        , target     , intent(in)  :: this
  class(abstract_template_element_iterator_t) , allocatable, intent(out) :: iterator
  integer(ip) :: istat
  allocate(static_template_element_iterator_t :: iterator, stat=istat)
  check(istat==0)
  select type(iterator)
     class is(static_template_element_iterator_t)
     iterator%static_template_element_set => this
     iterator%first=1
     iterator%last=this%num_elements
  end select
end subroutine create_static_iterator
!=============================================================================
subroutine free_static_iterator(this,iterator)
  implicit none
  class(static_template_element_set_t)                    , intent(in)    :: this
  class(abstract_template_element_iterator_t), allocatable, intent(inout) :: iterator
  ! No internal memory for this simple iterator.
  deallocate(iterator)
end subroutine free_static_iterator
!=============================================================================
! This function should be eliminated. It returns the array to reuse legacy code.
function get_elements_array(this) result(p)
  implicit none
  class(static_template_element_set_t), target, intent(inout)  :: this
  type(template_element_t)           , pointer :: p(:)
  p => this%elements
end function get_elements_array

!=============================================================================
! Iterator functions
!=============================================================================
subroutine static_iterator_set_first(this, first)
  implicit none
  class(static_template_element_iterator_t), intent(inout) :: this
  integer(ip)                             , intent(in)    :: first
  this%first=first
end subroutine static_iterator_set_first
!=============================================================================
subroutine static_iterator_set_last(this, last)
  implicit none
  class(static_template_element_iterator_t), intent(inout) :: this
  integer(ip)                             , intent(in)    :: last
  this%last=last
end subroutine static_iterator_set_last
!=============================================================================
subroutine static_iterator_begin(this)
  implicit none
  class(static_template_element_iterator_t), intent(inout) :: this
  this%ielem=1
end subroutine static_iterator_begin
!=============================================================================
function static_iterator_finished(this) result(res)
  implicit none
  class(static_template_element_iterator_t), intent(inout) :: this
  logical :: res
  res = ( this%ielem > this%static_template_element_set%num_elements )
end function static_iterator_finished
!=============================================================================
subroutine static_iterator_next(this)
  implicit none
  class(static_template_element_iterator_t), intent(inout) :: this
  this%ielem = this%ielem + 1
end subroutine static_iterator_next
!=============================================================================
function static_template_element_iterator_current (this) result(p)
  implicit none
  class(static_template_element_iterator_t), intent(inout) :: this
  type(template_element_t)                 , pointer       :: p
  assert( this%ielem <= this%static_template_element_set%num_elements )
  p => this%static_template_element_set%elements(this%ielem)
end function static_template_element_iterator_current
!=============================================================================
#ifdef abstract_element_t
function static_abstract_element_iterator_current (this) result(p)
  implicit none
  class(static_template_element_iterator_t), intent(inout) :: this
  class(abstract_element_t)                , pointer       :: p
  assert( this%ielem <= this%static_template_element_set%num_elements )
  p => this%static_template_element_set%elements(this%ielem)
end function static_abstract_element_iterator_current
#endif
!=============================================================================
subroutine static_iterator_get_local_id(this,id)
  implicit none
  class(static_template_element_iterator_t), intent(in)    :: this
  integer(ip), intent(out) :: id
  id = this%ielem
end subroutine static_iterator_get_local_id

