subroutine  mixed_u_p_discrete_integration_create(this,number_dimensions,analytical_functions)
  implicit none
  class(mixed_u_p_discrete_integration_t)       , intent(inout) :: this
  integer(ip)                                   , intent(in)    :: number_dimensions
  type(fempar_sm_analytical_functions_t), target, intent(in)    :: analytical_functions
  integer(ip) :: istat

  this%number_dimensions = number_dimensions
  this%number_fields     = 2
  this%number_components = number_dimensions+1
  allocate(this%fe_type(this%number_fields),stat=istat)  ; check(istat==0)
  allocate(this%field_type(this%number_fields),stat=istat); check(istat==0)
  allocate(this%field_name(this%number_fields),stat=istat); check(istat==0)
  call memalloc(this%number_fields,this%field_blocks,__FILE__,__LINE__)
  call memalloc(this%number_fields,this%number_fields,this%field_coupling,__FILE__,__LINE__)
  this%fe_type(1)          = fe_type_lagrangian
  this%fe_type(2)          = fe_type_lagrangian
  this%field_type(1)       = field_type_vector
  this%field_type(2)       = field_type_scalar
  this%field_name(1)       = 'displacement'
  this%field_name(2)       = 'pressure'
  this%field_blocks        = (/1,1/)
  this%field_coupling = reshape((/.true.,  .true.,  &
       &                     .true.,  .true.   /),(/2,2/)) 

  ! Could be done in the mother class
  this%analytical_functions => analytical_functions
  this%source_term => this%analytical_functions%get_source_term_u()
  
end subroutine mixed_u_p_discrete_integration_create

     function mixed_u_p_discrete_integration_is_symmetric(this)
       implicit none
       class(mixed_u_p_discrete_integration_t), intent(inout) :: this
       logical :: mixed_u_p_discrete_integration_is_symmetric
       mixed_u_p_discrete_integration_is_symmetric = .true.
     end function mixed_u_p_discrete_integration_is_symmetric
     
     function mixed_u_p_discrete_integration_is_coercive(this)
       implicit none
       class(mixed_u_p_discrete_integration_t), intent(inout) :: this
       logical :: mixed_u_p_discrete_integration_is_coercive
       mixed_u_p_discrete_integration_is_coercive = .false.
     end function mixed_u_p_discrete_integration_is_coercive

subroutine mixed_u_p_discrete_integration_integrate ( this, fe_space, matrix_array_assembler )
  implicit none
  class(mixed_u_p_discrete_integration_t), intent(in)    :: this
  class(serial_fe_space_t)               , intent(inout) :: fe_space
  class(matrix_array_assembler_t)        , intent(inout) :: matrix_array_assembler

  ! FE space traversal-related data types
  class(fe_iterator_t), allocatable :: fe

  ! FE integration-related data types
  type(fe_map_t)           , pointer :: fe_map
  type(quadrature_t)       , pointer :: quad
  type(point_t)            , pointer :: quad_coords(:)
  type(volume_integrator_t), pointer :: vol_int_u
  type(volume_integrator_t), pointer :: vol_int_p
  type(vector_field_t), allocatable  :: shape_p_gradients(:,:)
  real(rp)            , allocatable  :: shape_p_values(:,:)
  type(tensor_field_t), allocatable  :: shape_u_gradients(:,:)
  type(vector_field_t), allocatable  :: shape_u_values(:,:)

  ! Workspace (FE matrix and vector, assembly data), it could be allocated in the creation
  real(rp)   , allocatable :: elmat(:,:), elvec(:)
  type(i1p_t), allocatable :: elem2dof(:)
  integer(ip), allocatable :: num_dofs_per_field(:)  

  integer(ip)  :: istat
  integer(ip)  :: qpoint, num_quad_points
  integer(ip)  :: idof, jdof, idof_u, jdof_u, idof_p, jdof_p , num_dofs
  
  type(cell_fe_function_vector_t) :: cell_solution_u
  type(cell_fe_function_scalar_t) :: cell_solution_p
  type(tensor_field_t), pointer   :: solution_gradu(:) => null()
  real(rp)            , pointer   :: solution_p(:) => null()
  
  ! Problem variables
  type(vector_field_t) :: source_term_value
  type(tensor_field_t) :: s_u, epsd_v, epsd_u, Id
  real(rp)     :: dV, div_v, div_u
  real(rp), parameter :: one_third = 1.0_rp/3.0_rp

  assert (associated(this%source_term)) 

  call Id%init(0.0)
  call Id%set(1,1,1.0)
  call Id%set(2,2,1.0)
  call Id%set(3,3,1.0)  
  
  call fe_space%initialize_fe_integration()
  call fe_space%create_fe_iterator(fe)
  call cell_solution_u%create(fe_space,1)
  call cell_solution_p%create(fe_space,2)

  num_dofs = fe%get_number_dofs()
  call memalloc ( num_dofs, num_dofs, elmat, __FILE__, __LINE__ )
  call memalloc ( num_dofs, elvec, __FILE__, __LINE__ )
  call memalloc ( this%number_fields, num_dofs_per_field, __FILE__, __LINE__ )
  call fe%get_number_dofs_per_field(num_dofs_per_field)
  allocate( elem2dof(this%number_fields), stat=istat); check(istat==0);

  quad            => fe%get_quadrature()
  num_quad_points = quad%get_number_quadrature_points()
  fe_map          => fe%get_fe_map()
  vol_int_u => fe%get_volume_integrator(1)
  vol_int_p => fe%get_volume_integrator(2)
  
  do while ( .not. fe%has_finished())
     if ( fe%is_local() ) then
        ! Update FE-integration related data structures
        call fe%update_integration()
        call cell_solution_u%update(fe,this%solution)
        call cell_solution_p%update(fe,this%solution)
        solution_gradu => cell_solution_u%get_quadrature_points_gradients()
        solution_p     => cell_solution_p%get_quadrature_points_values()
        
        ! Get DoF numbering within current FE
        call fe%get_elem2dof(elem2dof)

        ! Get quadrature coordinates to evaluate source_term
        quad_coords => fe_map%get_quadrature_coordinates()

        ! Compute element matrix and vector
        elmat = 0.0_rp
        elvec = 0.0_rp

        call vol_int_u%get_gradients(shape_u_gradients)
        call vol_int_u%get_values(shape_u_values)
        call vol_int_p%get_gradients(shape_p_gradients)
        call vol_int_p%get_values(shape_p_values)

        do qpoint = 1, num_quad_points
           dV = fe_map%get_det_jacobian(qpoint) * quad%get_weight(qpoint)

           do idof_u = 1, num_dofs_per_field(1)
              idof = idof_u
              ! U-U
              epsd_v  = symmetric_part(shape_u_gradients(idof_u,qpoint)) 
              div_v = trace(epsd_v)
              epsd_v  = epsd_v - one_third*div_v*Id
              do jdof_u = 1, num_dofs_per_field(1)
                 jdof = jdof_u
                 epsd_u  = symmetric_part(shape_u_gradients(jdof_u,qpoint))
                 epsd_u  = epsd_u - one_third*trace(epsd_u)*Id
                 !s_u = 2*mu*epsd_u
                 elmat(idof,jdof) = elmat(idof,jdof) + dV * double_contract(epsd_v,2*mu*epsd_u)
              end do
              ! U-P
              do jdof_p = 1, num_dofs_per_field(2)
                 jdof = num_dofs_per_field(1)+jdof_p
                 elmat(idof,jdof) = elmat(idof,jdof) + dV * div_v * shape_p_values(jdof_p,qpoint)
              end do
           end do
           do idof_p = 1, num_dofs_per_field(2)
              idof = num_dofs_per_field(1)+idof_p
              ! P-U
              do jdof_u = 1, num_dofs_per_field(1)
                 div_u = trace(shape_u_gradients(jdof_u,qpoint))
                 jdof = jdof_u
                 elmat(idof,jdof) = elmat(idof,jdof) + dV * shape_p_values(idof_p,qpoint) * div_u
              end do
              ! P-P
              do jdof_p = 1, num_dofs_per_field(2)
                 jdof = num_dofs_per_field(1)+jdof_p
                 elmat(idof,jdof) = elmat(idof,jdof) - dV * inv_K * shape_p_values(idof_p,qpoint) * shape_p_values(jdof_p,qpoint)
              end do
           end do

           ! Residual
           call this%source_term%get_value_space(quad_coords(qpoint),source_term_value)
           epsd_u = symmetric_part(solution_gradu(qpoint))
           div_u  = trace(epsd_u)
           epsd_u = epsd_u - one_third*div_u*Id
           do idof_u = 1, num_dofs_per_field(1)
              idof = idof_u
              epsd_v  = symmetric_part(shape_u_gradients(idof_u,qpoint)) 
              div_v = trace(epsd_v)
              epsd_v  = epsd_v - one_third*div_v*Id
              elvec(idof) = elvec(idof) - dV * source_term_value * shape_u_values(idof_u,qpoint)
              elvec(idof) = elvec(idof) + dV * double_contract(epsd_v,2*mu*epsd_u)
              elvec(idof) = elvec(idof) + dV * div_v * solution_p(qpoint)
           end do
           do idof_p = 1, num_dofs_per_field(2)
              idof = num_dofs_per_field(1)+idof_p
              elvec(idof) = elvec(idof) + dV * shape_p_values(idof_p,qpoint) * div_u
              elvec(idof) = elvec(idof) - dV * inv_K * shape_p_values(idof_p,qpoint) * solution_p(qpoint)
           end do

        end do

        ! Apply boundary conditions
        !call fe%impose_strong_dirichlet_bcs( elmat, elvec )
        call matrix_array_assembler%assembly( this%number_fields, num_dofs_per_field, elem2dof, this%field_blocks, this%field_coupling, elmat, elvec )
     end if
     call fe%next()
  end do

  call cell_solution_u%free()
  call cell_solution_p%free()
  call fe_space%free_fe_iterator(fe)
  call memfree(shape_p_values, __FILE__, __LINE__)
  deallocate (shape_p_gradients, stat=istat); check(istat==0);
  deallocate (shape_u_values, stat=istat); check(istat==0);
  deallocate (shape_u_gradients, stat=istat); check(istat==0);
  deallocate (elem2dof, stat=istat); check(istat==0);
  call memfree ( num_dofs_per_field, __FILE__, __LINE__ )
  call memfree ( elmat, __FILE__, __LINE__ )
  call memfree ( elvec, __FILE__, __LINE__ )

end subroutine mixed_u_p_discrete_integration_integrate
