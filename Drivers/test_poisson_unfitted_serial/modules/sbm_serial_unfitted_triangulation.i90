 ! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Public TBP ------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_create(this, parameters, level_set_function)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)                         , intent(inout) :: parameters
  class(level_set_function_t),            target, intent(in)    :: level_set_function
  
  ! Allocate and fill data managed by the parent class
  call this%free()
  call this%serial_triangulation_t%create(parameters)
  
  ! Check that the triangulation fulfills the assumptions made by this class
  assert(this%fulfills_assumptions())
  
  ! Allocate and fill member variables which are managed by this derived data type
  this%level_set_function => level_set_function
  call this%mc_tables_create()
  call this%mc_runtime_info_create()

end subroutine serial_unfitted_triangulation_create

subroutine serial_unfitted_triangulation_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this

  ! Free memory managed by the parent class
  call this%serial_triangulation_t%free()

  ! Free memory managed by this class
  call this%mc_tables_free()
  call this%mc_runtime_info_free()

end subroutine serial_unfitted_triangulation_free

function serial_unfitted_triangulation_create_unfitted_cell_iterator ( this ) result (cell_iter)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  type(unfitted_cell_iterator_t) :: cell_iter
  call cell_iter%create(1, this)
end function serial_unfitted_triangulation_create_unfitted_cell_iterator

! Private TBP ------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_serial_triangulation_create ( this, parameters)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)             , intent(inout) :: parameters
  check(.false.)
end subroutine serial_unfitted_triangulation_serial_triangulation_create

function serial_unfitted_triangulation_fulfills_assumptions(this) result (fulfills)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in) :: this
  logical :: fulfills
  type(unfitted_cell_iterator_t)            :: cell_iter
  type(unfitted_cell_accessor_t)            :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  character(:),                 allocatable :: topology ! TODO Why allocatable and not pointer?
  integer(ip)                               :: num_dim, num_dim_tmp, p_order
  
  ! Hypothesis: All cells in the mesh are either qua4 or hex8
  fulfills = .true. 
  cell_iter = this%create_unfitted_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_dim  = reference_fe_geo%get_number_dimensions()
  if ( (num_dim .ne. 2) .and. (num_dim .ne. 3) ) fulfills = .false. 
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
      reference_fe_geo => cell%get_reference_fe_geo()
      num_dim_tmp  = reference_fe_geo%get_number_dimensions()
      if (num_dim .ne. num_dim_tmp) fulfills = .false.
      p_order  = reference_fe_geo%get_order()
      if (p_order .ne. 1_ip) fulfills = .false.
      topology = reference_fe_geo%get_topology()
      if (topology .ne. topology_hex) fulfills = .false.
      if (.not. fulfills) exit
      call cell_iter%next()      
  end do  
  
end function serial_unfitted_triangulation_fulfills_assumptions

subroutine serial_unfitted_triangulation_mc_tables_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  type(unfitted_cell_iterator_t)            :: cell_iter
  type(unfitted_cell_accessor_t)            :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: num_dim

  ! To be safe
  call this%mc_tables_free()
  
  ! Get element type
  cell_iter = this%create_unfitted_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_dim  = reference_fe_geo%get_number_dimensions()
  
  ! Fill in the sizes of the tables
  if (num_dim == 2_ip) then
    this%mc_table_num_cases         = MC_QUA4_NUM_CASES
    this%mc_table_max_num_subcells  = MC_QUA4_MAX_NUM_SUBCELLS
    this%mc_table_max_num_cut_edges = MC_QUA4_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_QUA4_NUM_NODES_PER_SUBCELL
  else
    this%mc_table_num_cases         = MC_HEX8_NUM_CASES
    this%mc_table_max_num_subcells  = MC_HEX8_MAX_NUM_SUBCELLS
    this%mc_table_max_num_cut_edges = MC_HEX8_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_HEX8_NUM_NODES_PER_SUBCELL
  end if

  ! Now, we know the sizes and can allocate
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_subcells_per_case    , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_num_nodes_subcell, this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__ )

  ! Fill tables for the selected element type
  if (num_dim == 2_ip) then
    this%mc_table_num_subcells_per_case      = MC_QUA4_NUM_SUBCELLS_PER_CASE
    this%mc_table_num_cut_edges_per_case     = MC_QUA4_NUM_CUT_EDGES_PER_CASE
    this%mc_table_inout_subcells_per_case    = MC_QUA4_INOUT_SUBCELLS_PER_CASE
    this%mc_table_subcell_node_ids_per_case  = MC_QUA4_SUBCELL_NODE_IDS_PER_CASE
  else
    this%mc_table_num_subcells_per_case      = MC_HEX8_NUM_SUBCELLS_PER_CASE
    this%mc_table_num_cut_edges_per_case     = MC_HEX8_NUM_CUT_EDGES_PER_CASE
    this%mc_table_inout_subcells_per_case    = MC_HEX8_INOUT_SUBCELLS_PER_CASE
    this%mc_table_subcell_node_ids_per_case  = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE
  endif

end subroutine serial_unfitted_triangulation_mc_tables_create

subroutine serial_unfitted_triangulation_mc_tables_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this

  if (allocated (this%mc_table_num_subcells_per_case    )) call memfree (this%mc_table_num_subcells_per_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_cut_edges_per_case   )) call memfree (this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__)
  if (allocated (this%mc_table_inout_subcells_per_case  )) call memfree (this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__)
  if (allocated (this%mc_table_subcell_node_ids_per_case)) call memfree (this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__)

end subroutine serial_unfitted_triangulation_mc_tables_free

subroutine serial_unfitted_triangulation_mc_runtime_info_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  
  type(unfitted_cell_iterator_t)            :: cell_iter
  type(unfitted_cell_accessor_t)            :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quadrature
  integer(ip), parameter :: x=1, y=2
  type(point_t), allocatable :: Xe_phys(:), Xe_ref(:)
  integer(ip), parameter :: edge_dim = 1
  integer(ip), allocatable :: edges2nodes(:,:)
  integer(ip) :: num_edge_nodes, num_edges, iedge, inode, num_nodes, num_dim
  integer(ip) :: num_cells, icell
  real(rp)    :: phi_node, phi_edge(2)
  integer(ip) :: icase
  integer(ip), parameter :: node2bit(8) = [1,2,4,8,16,32,64,128]

  ! To be safe
  call this%mc_runtime_info_free()  
  
  ! Get edges to nodes table on the reference element
  cell_iter = this%create_unfitted_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  call reference_fe_geo%get_nodes_of_all_n_faces_of_dim(edge_dim, edges2nodes, num_edge_nodes, num_edges) 
  assert(num_edge_nodes == 2_ip)  
  
  ! TODO. to be removed (print the table)
  write(*,*) "Edge to nodes table"
  do iedge = 1, num_edges
      write(*,*) edges2nodes(1,iedge), edges2nodes(2,iedge)
  end do  
  write(*,*) " "
 
  ! Get the nodal coordinates in the reference element
  nodal_quadrature => reference_fe_geo%get_nodal_quadrature()
  num_dim   = nodal_quadrature%get_number_dimensions()
  num_nodes = nodal_quadrature%get_number_quadrature_points()
  allocate ( Xe_ref(num_nodes) )
  call nodal_quadrature%get_coordinates_as_points(Xe_ref)
  
  write(*,*) "Coordinates at reference element"
  do inode = 1, num_nodes
      write(*,*) Xe_ref(inode)%get(x), Xe_ref(inode)%get(y)
  end do  
    write(*,*) " "
    
  ! Get number of cells  
  num_cells = this%get_num_local_cells() + this%get_num_ghost_cells()
  write(*,*) "num_cells ", num_cells
  
  call memalloc (num_cells, this%mc_case_per_cell, __FILE__, __LINE__ )
  
  ! Loop to determine the cases
  allocate ( Xe_phys(num_nodes) )
  icell = 1
  do while ( .not. cell_iter%has_finished() )

    call cell_iter%current(cell)
   
      write (*,*) "I am: ", cell%get_lid(), " lid"
      write (*,*) "Node coordinates (physical space)"
      reference_fe_geo => cell%get_reference_fe_geo()
      
      call cell%get_coordinates(Xe_phys)
      do inode = 1, num_nodes
        write (*,*) Xe_phys(inode)%get(x), Xe_phys(inode)%get(y)
      end do
      write(*,*) " "
      
      ! Evaluate level set and the case
      icase = 0_ip
      do inode = 1, num_nodes
        call this%level_set_function%get_value(Xe_phys(inode),phi_node)
        write (*,*) phi_node
        if (phi_node < 0.0_rp) icase = ior(icase,node2bit(inode))
      end do
      this%mc_case_per_cell(icell) = icase + 1
      write(*,*) "case ", icase
      write(*,*) " "
      
    icell = icell + 1 ! TODO a better way of doing this?? using the iterator?  
    call cell_iter%next()

  end do
  
  ! Loop for creating the intersection points pointers
  call memalloc (num_cells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  this%mc_ptr_to_intersections(1) = 1
  do icell = 1,num_cells
    this%mc_ptr_to_intersections(icell + 1) = this%mc_ptr_to_intersections(icell) & 
    + this%mc_table_num_cut_edges_per_case(this%mc_case_per_cell(icell))
  end do
  
  
  ! Loop for computing the intersection points
  icell = 1
  do while ( .not. cell_iter%has_finished() )

    call cell_iter%current(cell)
   
      write (*,*) "I am: ", cell%get_lid(), " lid"
      write (*,*) "Node coordinates (physical space)"
      reference_fe_geo => cell%get_reference_fe_geo()
      
      call cell%get_coordinates(Xe_phys)
      
      do iedge = 1, num_edges
       
      do inode = 1,2
         call this%level_set_function%get_value(Xe_phys(edges2nodes(inode,iedge)),phi_edge(inode))
      end do
       
      ! Compute and store the intersection
       
      end do
      
    icell = icell + 1 ! TODO a better way of doing this?? using the iterator?  
    call cell_iter%next()

  end do
  
  
  
  
  
  
  
  deallocate( Xe_ref ) 
  deallocate( Xe_phys )   
  call memfree (edges2nodes, __FILE__, __LINE__ ) ! TODO needed? allocated when it goes out of scope?
  
  

  !! Allocate and fill mc cases
  !num_lhcells = this%get_num_local_cells() + this%get_num_ghost_cells()
  !call memalloc (num_lhcells, this%mc_case_per_cell, __FILE__, __LINE__ )
  !do i_lhcell = 1, num_lhcells ! TODO use loop or use iterators?
  !  this%mc_case_per_cell(i_lhcell) = this%determine_mc_case(i_lhcell) ! TODO
  !end do

  !!Allocate and fill intersection points pointers
  !call memalloc (num_lhcells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  !assert ( allocated(this%mc_table_num_cut_edges_per_case) )
  !assert ( maxval(this%mc_case_per_cell) <= size(this%mc_table_num_cut_edges_per_case) )
  !co = 1_ip
  !this%mc_ptr_to_intersections(1) = co
  !max_num_cut_edges_per_cell = 0_ip
  !do i_lhcell = 1, num_lhcells ! TODO use loop or use iterators?
  !this_num_cut_edges = this%mc_table_num_cut_edges_per_case( this%mc_case_per_cell(i_lhcell) )
  !  max_num_cut_edges_per_cell = max( max_num_cut_edges_per_cell, this_num_cut_edges )
  !  co = co + this_num_cut_edges
  !  this%mc_ptr_to_intersections(i_lhcell+1) = co
  !end do

  !!Allocate and fill intersection points coordinates
  !num_cut_edges =  this%mc_ptr_to_intersections(num_lhcells+1) - this%mc_ptr_to_intersections(1)
  !call memalloc (num_cut_edges, this%mc_intersection_points, __FILE__, __LINE__ )
  !call memalloc (max_num_cut_edges_per_cell, points_tmp, __FILE__, __LINE__ )
  !do i_lhcell = 1, num_lhcells ! TODO use loop or use iterators?
  !  this_num_cut_edges = this%mc_table_num_cut_edges_per_case( this%mc_case_per_cell(i_lhcell) )
  !  call this%compute_mc_intersection_points(i_lhcell,points_tmp) ! TODO
  !  do i_point = 1, this_num_cut_edges
  !    i_ptr = this%mc_ptr_to_intersections(i_lhcell) + i_point - 1
  !    this%mc_intersection_points(i_ptr) = points_tmp(i_point)
  !  end do
  !end do
  !call memfree ( points_tmp, __FILE__, __LINE__ )


end subroutine serial_unfitted_triangulation_mc_runtime_info_create

subroutine serial_unfitted_triangulation_mc_runtime_info_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this

  if (allocated (this%mc_case_per_cell       )) call memfree ( this%mc_case_per_cell        , __FILE__, __LINE__ )
  if (allocated (this%mc_ptr_to_intersections)) call memfree ( this%mc_ptr_to_intersections , __FILE__, __LINE__ )
  if (allocated (this%mc_intersection_points )) call memfree ( this%mc_intersection_points  , __FILE__, __LINE__ )

end subroutine serial_unfitted_triangulation_mc_runtime_info_free


function serial_unfitted_triangulation_determine_mc_case(this,i_lhcell) result (i_case)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in) :: this
  integer(ip), intent(in) :: i_lhcell
  integer(ip) :: i_case
  ! TODO
end function serial_unfitted_triangulation_determine_mc_case



subroutine serial_unfitted_triangulation_compute_mc_intersection_points(this,i_lhcell,points_out)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in) :: this
  integer(ip), intent(in) :: i_lhcell
  type(point_t), allocatable, intent(out) :: points_out(:)
  ! TODO
end subroutine serial_unfitted_triangulation_compute_mc_intersection_points


