 ! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine serial_unfitted_triangulation_serial_triangulation_create ( this, parameters)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)             , intent(inout) :: parameters
  check(.false.)
end subroutine serial_unfitted_triangulation_serial_triangulation_create

subroutine serial_unfitted_triangulation_create(this, parameters, level_set_function)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)                      , intent(inout) :: parameters
  class(level_set_function_t)                , intent(in)    :: level_set_function

  ! Allocate and fill data managed by the parent class
  call this%free()
  call this%serial_triangulation_t%create(parameters)

  ! Allocate and fill member variables which are managed by this derived data type
  call this%mc_tables_create()
  call this%mc_runtime_info_create()


end subroutine serial_unfitted_triangulation_create

subroutine serial_unfitted_triangulation_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this

  ! Free memory managed by the parent class
  call this%serial_triangulation_t%free()

  ! Free memory managed by this class
  call this%mc_tables_free()
  !call this%free_marching_cube_cases()
  !call this%free_ptr_intersection_points()
  !call this%free_intersection_points_coor()

end subroutine serial_unfitted_triangulation_free

function serial_unfitted_triangulation_create_unfitted_cell_iterator ( this ) result (cell_iter)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  type(unfitted_cell_iterator_t) :: cell_iter
  call cell_iter%create(1, this)
end function serial_unfitted_triangulation_create_unfitted_cell_iterator

subroutine serial_unfitted_triangulation_mc_tables_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this

  ! TODO check that all the elements of the mesh are of the same type

  ! To be safe
  call this%mc_tables_free()

  ! TODO: Now we assume quads
  this%mc_table_num_cases         = MC_QUA4_NUM_CASES
  this%mc_table_max_num_subcells  = MC_QUA4_MAX_NUM_SUBCELLS
  this%mc_table_num_nodes_subcell = MC_QUA4_NUM_NODES_PER_SUBCELL

  ! Now, we know the sizes and can allocate
  call memalloc (                                                                 this%mc_table_num_cases, this%mc_table_num_subcells_per_case    , __FILE__, __LINE__ )
  call memalloc (                                                                 this%mc_table_num_cases, this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__ )
  call memalloc (                                 this%mc_table_max_num_subcells, this%mc_table_num_cases, this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__ )
  call memalloc (this%mc_table_num_nodes_subcell, this%mc_table_max_num_subcells, this%mc_table_num_cases, this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__ )

  ! Fill tables for the selected element type
  !TODO Now we assume this is only for quads
  this%mc_table_num_subcells_per_case      = MC_QUA4_NUM_SUBCELLS_PER_CASE
  this%mc_table_num_cut_edges_per_case     = MC_QUA4_NUM_CUT_EDGES_PER_CASE
  this%mc_table_inout_subcells_per_case    = MC_QUA4_INOUT_SUBCELLS_PER_CASE
  this%mc_table_subcell_node_ids_per_case  = MC_QUA4_SUBCELL_NODE_IDS_PER_CASE

end subroutine serial_unfitted_triangulation_mc_tables_create

subroutine serial_unfitted_triangulation_mc_tables_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this

  if (allocated (this%mc_table_num_subcells_per_case    )) call memfree ( this%mc_table_num_subcells_per_case    , __FILE__, __LINE__ )
  if (allocated (this%mc_table_num_cut_edges_per_case   )) call memfree ( this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__ )
  if (allocated (this%mc_table_inout_subcells_per_case  )) call memfree ( this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__ )
  if (allocated (this%mc_table_subcell_node_ids_per_case)) call memfree ( this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__ )

end subroutine serial_unfitted_triangulation_mc_tables_free

subroutine serial_unfitted_triangulation_mc_runtime_info_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  
  type(unfitted_cell_iterator_t)            :: cell_iter
  type(unfitted_cell_accessor_t)            :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quadrature
  integer(ip) :: nbcn, icn
  integer(ip), parameter :: x=1, y=2
  integer(ip) :: first_edge, last_edge, current_edge
  type(point_t), allocatable :: Xc(:)

  integer(ip) :: num_cut_edges, max_num_cut_edges_per_cell, this_num_cut_edges
  integer(ip) :: num_lhcells
  integer(ip) :: i_lhcell, co, i_point, i_ptr
  type(point_t), allocatable :: points_tmp(:)
  type(list_iterator_t) :: nodes_n_face_iterator

  ! To be safe
  call this%mc_runtime_info_free()
  
  ! Loop over all the cells
  cell_iter = this%create_unfitted_cell_iterator()

  do while ( .not. cell_iter%has_finished() )

    ! TODO. To be removed (learning how the loops work)
    call cell_iter%current(cell)
   
      write (*,*) "I am: ", cell%get_lid(), " lid"
      write (*,*) "Node coordinates (physical space)"
      ! This can be moved outside the poop if all elements are of the same type
      reference_fe_geo => cell%get_reference_fe_geo()
      nodal_quadrature => reference_fe_geo%get_nodal_quadrature()
      nbcn = reference_fe_geo%get_number_shape_functions()
      allocate ( Xc(nbcn) )
      call cell%get_coordinates(Xc)
      do icn = 1,nbcn
        write (*,*) Xc(icn)%get(x), Xc(icn)%get(y)
      end do
      write(*,*) " "
      call nodal_quadrature%get_coordinates_as_points(Xc);
      write (*,*) "Node coordinates (reference space)"
      do icn = 1,nbcn
        write (*,*) Xc(icn)%get(x), Xc(icn)%get(y)
      end do
      deallocate (Xc)
      write(*,*) " "
      
      first_edge = reference_fe_geo%get_number_n_faces_of_dimension(0) + 1
      last_edge  = first_edge + reference_fe_geo%get_number_n_faces_of_dimension(1) - 1
      
      write(*,*) "first_edge=", first_edge, " last_edge=", last_edge
      
      do current_edge = first_edge, last_edge 
      write (*,*) "current_edge = ", current_edge
        nodes_n_face_iterator = reference_fe_geo%create_nodes_n_face_iterator(current_edge)
        do while (.not. nodes_n_face_iterator%is_upper_bound())
           write(*,*) "edge=",  current_edge - first_edge, " node=", nodes_n_face_iterator%get_current()        
        call nodes_n_face_iterator%next()
        end do      
      end do
      
    call cell_iter%next()

  end do

  !! Allocate and fill mc cases
  !num_lhcells = this%get_num_local_cells() + this%get_num_ghost_cells()
  !call memalloc (num_lhcells, this%mc_case_per_cell, __FILE__, __LINE__ )
  !do i_lhcell = 1, num_lhcells ! TODO use loop or use iterators?
  !  this%mc_case_per_cell(i_lhcell) = this%determine_mc_case(i_lhcell) ! TODO
  !end do

  !!Allocate and fill intersection points pointers
  !call memalloc (num_lhcells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  !assert ( allocated(this%mc_table_num_cut_edges_per_case) )
  !assert ( maxval(this%mc_case_per_cell) <= size(this%mc_table_num_cut_edges_per_case) )
  !co = 1_ip
  !this%mc_ptr_to_intersections(1) = co
  !max_num_cut_edges_per_cell = 0_ip
  !do i_lhcell = 1, num_lhcells ! TODO use loop or use iterators?
  !this_num_cut_edges = this%mc_table_num_cut_edges_per_case( this%mc_case_per_cell(i_lhcell) )
  !  max_num_cut_edges_per_cell = max( max_num_cut_edges_per_cell, this_num_cut_edges )
  !  co = co + this_num_cut_edges
  !  this%mc_ptr_to_intersections(i_lhcell+1) = co
  !end do

  !!Allocate and fill intersection points coordinates
  !num_cut_edges =  this%mc_ptr_to_intersections(num_lhcells+1) - this%mc_ptr_to_intersections(1)
  !call memalloc (num_cut_edges, this%mc_intersection_points, __FILE__, __LINE__ )
  !call memalloc (max_num_cut_edges_per_cell, points_tmp, __FILE__, __LINE__ )
  !do i_lhcell = 1, num_lhcells ! TODO use loop or use iterators?
  !  this_num_cut_edges = this%mc_table_num_cut_edges_per_case( this%mc_case_per_cell(i_lhcell) )
  !  call this%compute_mc_intersection_points(i_lhcell,points_tmp) ! TODO
  !  do i_point = 1, this_num_cut_edges
  !    i_ptr = this%mc_ptr_to_intersections(i_lhcell) + i_point - 1
  !    this%mc_intersection_points(i_ptr) = points_tmp(i_point)
  !  end do
  !end do
  !call memfree ( points_tmp, __FILE__, __LINE__ )


end subroutine serial_unfitted_triangulation_mc_runtime_info_create

subroutine serial_unfitted_triangulation_mc_runtime_info_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this

  if (allocated (this%mc_case_per_cell       )) call memfree ( this%mc_case_per_cell        , __FILE__, __LINE__ )
  if (allocated (this%mc_ptr_to_intersections)) call memfree ( this%mc_ptr_to_intersections , __FILE__, __LINE__ )
  if (allocated (this%mc_intersection_points )) call memfree ( this%mc_intersection_points  , __FILE__, __LINE__ )

end subroutine serial_unfitted_triangulation_mc_runtime_info_free


function serial_unfitted_triangulation_determine_mc_case(this,i_lhcell) result (i_case)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in) :: this
  integer(ip), intent(in) :: i_lhcell
  integer(ip) :: i_case
  ! TODO
end function serial_unfitted_triangulation_determine_mc_case



subroutine serial_unfitted_triangulation_compute_mc_intersection_points(this,i_lhcell,points_out)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in) :: this
  integer(ip), intent(in) :: i_lhcell
  type(point_t), allocatable, intent(out) :: points_out(:)
  ! TODO
end subroutine serial_unfitted_triangulation_compute_mc_intersection_points


