 ! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Public TBP ------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_create(this, parameters, level_set_function)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)                         , intent(inout) :: parameters
  class(level_set_function_t),            target, intent(in)    :: level_set_function
  
  ! Allocate and fill data managed by the parent class
  call this%free()
  call this%serial_triangulation_t%create(parameters)
  
  ! Check that the triangulation fulfills the assumptions made by this class
  assert(this%fulfills_assumptions())
  
  ! Allocate and fill member variables which are managed by this derived data type
  this%level_set_function => level_set_function
  call this%mc_tables_create()
  call this%mc_runtime_info_create()

end subroutine serial_unfitted_triangulation_create

subroutine serial_unfitted_triangulation_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this

  ! Free memory managed by the parent class
  call this%serial_triangulation_t%free()

  ! Free memory managed by this class
  call this%mc_tables_free()
  call this%mc_runtime_info_free()

end subroutine serial_unfitted_triangulation_free

function serial_unfitted_triangulation_create_unfitted_cell_iterator ( this ) result (cell_iter)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  type(unfitted_cell_iterator_t) :: cell_iter
  call cell_iter%create(1, this)
end function serial_unfitted_triangulation_create_unfitted_cell_iterator


subroutine serial_unfitted_triangulation_print_to_vtk_file ( this )
  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  
  ! Used by VTKIO
  integer(ip) :: E_IO
  integer(ip) :: Nn 
  integer(ip) :: Ne
  integer(ip) :: the_cell_type
  integer(ip) :: the_subcell_type
  real(rp),    allocatable, dimension(:) :: x 
  real(rp),    allocatable, dimension(:) :: y
  real(rp),    allocatable, dimension(:) :: z
  integer(ip), allocatable, dimension(:) :: cell_type
  integer(ip), allocatable, dimension(:) :: offset 
  integer(ip), allocatable, dimension(:) :: connect
  integer(ip), allocatable, dimension(:) :: vc  
  
  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quadrature
  integer(ip) :: num_cell_nodes, num_cells, inode , num_dim, icell, ino, istat
  integer(ip) :: num_subcells, num_subcell_nodes, subcell
  type(point_t), allocatable :: Xe_phys(:)
  integer(ip), allocatable :: nodes_vtk2fempar(:), nodesids(:)
  
  !Get dimensions
  cell_iter = this%create_unfitted_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  nodal_quadrature => reference_fe_geo%get_nodal_quadrature()
  num_dim   = nodal_quadrature%get_number_dimensions()
  num_cell_nodes = nodal_quadrature%get_number_quadrature_points()
  num_cells = this%get_num_local_cells() + this%get_num_ghost_cells()
  num_subcell_nodes = cell%get_number_of_subcell_nodes()
  
  ! Get total number of subcells
  num_subcells = 0
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    num_subcells = num_subcells + cell%get_number_of_subcells() 
    call cell_iter%next()
  end do
    
  ! Fill Number of nodes and number of cells and cell type
  Ne = num_cells + num_subcells
  Nn = num_cell_nodes*num_cells  + num_subcell_nodes*num_subcells
  call memalloc (num_cell_nodes, nodes_vtk2fempar, __FILE__, __LINE__ )
  select case (num_dim)
    case(3)
      the_cell_type = 12_I1P
      the_subcell_type = 10_I1P
    case(2)
      the_cell_type = 9_I1P
      the_subcell_type = 5_I1P
      nodes_vtk2fempar(:) = [1, 2 , 4, 3]
    case default
    check(.false.)
  end select
  
  ! Allocate 
  call memalloc ( Nn, x, __FILE__, __LINE__ )
  call memalloc ( Nn, y, __FILE__, __LINE__ )
  call memalloc ( Nn, z, __FILE__, __LINE__ )
  call memalloc ( Ne, cell_type, __FILE__, __LINE__ )
  call memalloc ( Ne, offset   , __FILE__, __LINE__ )
  call memalloc ( Nn, connect  , __FILE__, __LINE__ )
  call memalloc ( Ne, vc       , __FILE__, __LINE__ )
  
  ! Fill coordinates (cells)
  allocate ( Xe_phys(1:num_cell_nodes), stat=istat ); check(istat == 0)
  inode = 1
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    call cell%get_coordinates(Xe_phys)
    do ino = 1, num_cell_nodes
      x(inode) = Xe_phys(ino)%get(1)
      y(inode) = Xe_phys(ino)%get(2)
      z(inode) = Xe_phys(ino)%get(3)
      inode = inode + 1
    end do   
    call cell_iter%next()
  end do
  deallocate ( Xe_phys , stat=istat ); check(istat == 0)  
  
  !! Fill coordinates (subcells)
  !allocate ( Xe_phys(1:num_subcell_nodes), stat=istat ); check(istat == 0)
  !call cell_iter%init()
  !do while ( .not. cell_iter%has_finished() )
  !  call cell_iter%current(cell)
  !  do subcell = 1, cell%get_number_of_subcells()
  !    call cell%get_phys_coords_of_subcell(subcell,Xe_phys)
  !    do ino = 1, num_subcell_nodes
  !       x(inode) = Xe_phys(ino)%get(1)
  !       y(inode) = Xe_phys(ino)%get(2)
  !       z(inode) = Xe_phys(ino)%get(3)
  !       inode = inode + 1
  !    end do 
  !  end do
  !  call cell_iter%next()
  !end do
  !deallocate ( Xe_phys , stat=istat ); check(istat == 0)
   
  if ( num_dim == 2 ) z(:) = 0
  
  ! Fill cell info  
  call memalloc (num_cell_nodes, nodesids        , __FILE__, __LINE__ )
  call cell_iter%init()
  inode = 1
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell) 
    icell = cell%get_lid()
    cell_type( icell ) = the_cell_type
    if ( cell%is_interior() ) then  
      vc( icell )  = -1
    else if ( cell%is_cut() ) then
      vc( icell )  = 0
    else 
      vc( icell )  = 1
    end if
    offset( icell) = inode + num_cell_nodes -1
    do ino = 1, num_cell_nodes
      nodesids(ino) = inode
      inode = inode + 1
    end do 
    do ino = 1, num_cell_nodes
      connect( nodesids(ino) ) = nodesids(nodes_vtk2fempar(ino)) - 1
    end do 
    call cell_iter%next()
  end do  
  call memfree ( nodes_vtk2fempar, __FILE__, __LINE__ )
  call memfree ( nodesids, __FILE__, __LINE__ )
  
  ! Fill sub cell info
  icell = num_cells + 1
  call cell_iter%init()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell) 
    do subcell = 1, cell%get_number_of_subcells()
      cell_type( icell ) = the_subcell_type
      vc( icell ) = -2
      offset( icell ) = inode + num_subcell_nodes -1
      do ino = 1, num_subcell_nodes
         connect( inode ) = inode - 1
         inode = inode + 1
      end do
      icell = icell + 1
    end do    
    call cell_iter%next()
  end do   
  
  E_IO = VTK_INI_XML(output_format = 'ascii', filename = 'serial_unfitted_triangulation.vtu', mesh_topology = 'UnstructuredGrid')
  E_IO = VTK_GEO_XML(NN = Nn, NC = Ne, X = x, Y = y, Z = z)
  E_IO = VTK_CON_XML(NC = Ne, connect = connect, offset = offset, cell_type = int(cell_type,I1P) ) 
  E_IO = VTK_DAT_XML(var_location = 'cell', var_block_action = 'opeN')
  E_IO = VTK_VAR_XML(NC_NN = Ne, varname = 'cell_scalars', var = vc)
  E_IO = VTK_DAT_XML(var_location = 'cell', var_block_action = 'CLOSE')
  E_IO = VTK_GEO_XML()
  E_IO = VTK_END_XML()
  
  call cell_iter%free() ! TODO: this is not obvious, and also not sufficient. The cell iter / accessor should not allocate data ...
  call memfree ( x        , __FILE__, __LINE__ )
  call memfree ( y        , __FILE__, __LINE__ )
  call memfree ( z        , __FILE__, __LINE__ )
  call memfree ( cell_type, __FILE__, __LINE__ )
  call memfree ( offset   , __FILE__, __LINE__ )
  call memfree ( connect  , __FILE__, __LINE__ )
  call memfree ( vc       , __FILE__, __LINE__ )
    
end


! Private TBP ------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_serial_triangulation_create ( this, parameters)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)             , intent(inout) :: parameters
  check(.false.)
end subroutine serial_unfitted_triangulation_serial_triangulation_create

function serial_unfitted_triangulation_fulfills_assumptions(this) result (fulfills)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in) :: this
  logical :: fulfills
  
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  character(:),                 allocatable :: topology 
  integer(ip)                               :: num_dim, num_dim_tmp, p_order
  
  ! Hypothesis: All cells in the mesh are either qua4 or hex8
  fulfills = .true. 
  cell_iter = this%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_dim  = reference_fe_geo%get_number_dimensions()
  if ( (num_dim .ne. 2) .and. (num_dim .ne. 3) ) fulfills = .false. 
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
      reference_fe_geo => cell%get_reference_fe_geo()
      num_dim_tmp  = reference_fe_geo%get_number_dimensions()
      if (num_dim .ne. num_dim_tmp) fulfills = .false.
      p_order  = reference_fe_geo%get_order()
      if (p_order .ne. 1_ip) fulfills = .false.
      topology = reference_fe_geo%get_topology()
      if (topology .ne. topology_hex) fulfills = .false.
      if (.not. fulfills) exit
      call cell_iter%next()      
  end do  
  
end function serial_unfitted_triangulation_fulfills_assumptions

subroutine serial_unfitted_triangulation_mc_tables_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: num_dim

  ! To be safe
  call this%mc_tables_free()
  
  ! Get element type
  cell_iter = this%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_dim  = reference_fe_geo%get_number_dimensions()
  
  ! Fill in the sizes of the tables
  if (num_dim == 2_ip) then
    this%mc_table_num_cases         = MC_QUA4_NUM_CASES
    this%mc_table_max_num_subcells  = MC_QUA4_MAX_NUM_SUBCELLS
    this%mc_table_max_num_cut_edges = MC_QUA4_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_QUA4_NUM_NODES_PER_SUBCELL
  else
    this%mc_table_num_cases         = MC_HEX8_NUM_CASES
    this%mc_table_max_num_subcells  = MC_HEX8_MAX_NUM_SUBCELLS
    this%mc_table_max_num_cut_edges = MC_HEX8_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_HEX8_NUM_NODES_PER_SUBCELL
  end if

  ! Now, we know the sizes and can allocate
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_subcells_per_case    , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_num_nodes_subcell, this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__ )

  ! Fill tables for the selected element type
  if (num_dim == 2_ip) then
    this%mc_table_num_subcells_per_case      = MC_QUA4_NUM_SUBCELLS_PER_CASE
    this%mc_table_num_cut_edges_per_case     = MC_QUA4_NUM_CUT_EDGES_PER_CASE
    this%mc_table_inout_subcells_per_case    = MC_QUA4_INOUT_SUBCELLS_PER_CASE
    this%mc_table_subcell_node_ids_per_case  = MC_QUA4_SUBCELL_NODE_IDS_PER_CASE
  else
    this%mc_table_num_subcells_per_case      = MC_HEX8_NUM_SUBCELLS_PER_CASE
    this%mc_table_num_cut_edges_per_case     = MC_HEX8_NUM_CUT_EDGES_PER_CASE
    this%mc_table_inout_subcells_per_case    = MC_HEX8_INOUT_SUBCELLS_PER_CASE
    this%mc_table_subcell_node_ids_per_case  = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE
  endif

end subroutine serial_unfitted_triangulation_mc_tables_create

subroutine serial_unfitted_triangulation_mc_tables_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this

  if (allocated (this%mc_table_num_subcells_per_case    )) call memfree (this%mc_table_num_subcells_per_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_cut_edges_per_case   )) call memfree (this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__)
  if (allocated (this%mc_table_inout_subcells_per_case  )) call memfree (this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__)
  if (allocated (this%mc_table_subcell_node_ids_per_case)) call memfree (this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__)

end subroutine serial_unfitted_triangulation_mc_tables_free

subroutine serial_unfitted_triangulation_mc_runtime_info_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quadrature
  integer(ip), parameter :: x=1, y=2
  type(point_t), allocatable :: Xe_phys(:), Xe_ref(:)
  integer(ip), parameter :: edge_dim = 1
  integer(ip), allocatable :: edges2nodes(:,:)
  integer(ip) :: num_edge_nodes, num_edges, iedge, inode, num_nodes, num_dim
  integer(ip) :: num_cells, icell, ipoin, num_int_points
  integer(ip) :: icase, istat
  integer(ip), parameter :: node2bit(8) = [1,2,4,8,16,32,64,128] ! enough for qua4 and hex8
  integer(ip), parameter :: num_nodes_in_edge = 2
  integer(ip) :: nodes_in_edge(num_nodes_in_edge)
  real(rp)    :: phi_node, phi_edge(num_nodes_in_edge)
  
  ! To be safe
  call this%mc_runtime_info_free()  
  
  ! Get edges to nodes table on the reference element
  cell_iter = this%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  write(*,*) "Is edges2nodes allocated? ", allocated(edges2nodes)  
  num_edges      = reference_fe_geo%get_number_n_faces_of_dimension(edge_dim)
  num_edge_nodes = reference_fe_geo%get_num_nodes_per_n_face_of_dim(edge_dim) 
  assert(num_edge_nodes == 2_ip)
  call memalloc (num_edge_nodes, num_edges, edges2nodes, __FILE__, __LINE__ )
  call reference_fe_geo%get_nodes_of_all_n_faces_of_dim( edge_dim, edges2nodes ) 
    
  
  ! TODO. to be removed (print the table)
  write(*,*) "Edge to nodes table"
  do iedge = 1, num_edges
      write(*,*) edges2nodes(1,iedge), edges2nodes(2,iedge)
  end do  
  write(*,*) " "
 
  ! Get the nodal coordinates in the reference element
  nodal_quadrature => reference_fe_geo%get_nodal_quadrature()
  num_dim   = nodal_quadrature%get_number_dimensions()
  num_nodes = nodal_quadrature%get_number_quadrature_points()
  allocate( Xe_ref(1:num_nodes), stat=istat )
  check(istat == 0)
  call nodal_quadrature%get_coordinates_as_points( Xe_ref )
  
  write(*,*) "Coordinates at reference element"
  do inode = 1, num_nodes
      write(*,*) Xe_ref(inode)%get(x), Xe_ref(inode)%get(y)
  end do  
    write(*,*) " "
    
  ! Get number of cells  
  num_cells = this%get_num_local_cells() + this%get_num_ghost_cells()
  write(*,*) "num_cells ", num_cells
  
  call memalloc (num_cells, this%mc_case_per_cell, __FILE__, __LINE__ )
  
  ! Loop to determine the cases
  allocate ( Xe_phys(num_nodes), stat=istat )
  check(istat == 0)
  icell = 1
  do while ( .not. cell_iter%has_finished() )

    call cell_iter%current(cell)
   
      write (*,*) "I am: ", cell%get_lid(), " lid"
      write (*,*) "Node coordinates (physical space)"
      reference_fe_geo => cell%get_reference_fe_geo()
      
      call cell%get_coordinates(Xe_phys)
      do inode = 1, num_nodes
        write (*,*) Xe_phys(inode)%get(x), Xe_phys(inode)%get(y)
      end do
      write(*,*) " "
      
      ! Evaluate level set and the case
      icase = 0_ip
      do inode = 1, num_nodes
        call this%level_set_function%get_value(Xe_phys(inode),phi_node)
        write (*,*) phi_node
        if (phi_node < 0.0_rp) icase = ior(icase,node2bit(inode))
      end do
      this%mc_case_per_cell(icell) = icase + 1
      write(*,*) "case ", icase
      write(*,*) " "
      
    icell = icell + 1 ! TODO a better way of doing this?? using the iterator?  Use lid? what happens to ghost cells?
    call cell_iter%next()

  end do
  
  ! Loop for creating the intersection points pointers
  call memalloc (num_cells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  this%mc_ptr_to_intersections(1) = 1
  do icell = 1,num_cells
    this%mc_ptr_to_intersections(icell + 1) = this%mc_ptr_to_intersections(icell) & 
    + this%mc_table_num_cut_edges_per_case(this%mc_case_per_cell(icell))
  end do
    
  ! Loop for computing the intersection points
  num_int_points = this%mc_ptr_to_intersections(num_cells + 1) - this%mc_ptr_to_intersections(1)
  allocate ( this%mc_intersection_points( num_int_points ), stat = istat )
  check(istat == 0)
  call cell_iter%init()
  icell = 1
  ipoin = 1
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
      call cell%get_coordinates(Xe_phys)
      write (*,*) "I am: ", cell%get_lid(), " lid"
      write (*,*) "Node coordinates (physical space)"
      do inode = 1, num_nodes
        write (*,*) Xe_phys(inode)%get(x), Xe_phys(inode)%get(y)
      end do
      write(*,*) " "
      do iedge = 1, num_edges
        nodes_in_edge(:) = edges2nodes(:,iedge)      
        do inode = 1,num_nodes_in_edge
          call this%level_set_function%get_value(Xe_phys(nodes_in_edge(inode)),phi_edge(inode))
        end do
        write(*,*) "Edge=", iedge, " ", phi_edge
        if ( (phi_edge(1) >= 0 .and. phi_edge(2) < 0) .or. (phi_edge(2) >= 0 .and. phi_edge(1) < 0)   ) then
          this%mc_intersection_points(ipoin) = Xe_ref(nodes_in_edge(1)) + &
          (abs(phi_edge(1))/(abs(phi_edge(1))+abs(phi_edge(2))))*( Xe_ref(nodes_in_edge(2)) - Xe_ref(nodes_in_edge(1)) ) 
          write(*,*) "Int ", this%mc_intersection_points(ipoin)%get(x), this%mc_intersection_points(ipoin)%get(y) 
          ipoin = ipoin + 1          
        end if
      end do      
    icell = icell + 1 ! TODO a better way of doing this?? using the iterator?  Use lid?  Use lid? what happens to ghost cells?
    call cell_iter%next()
    write(*,*) " "
 end do
  
  deallocate( Xe_ref, stat=istat )   ! TODO needed? allocated when it goes out of scope?
  check(istat == 0)
  deallocate( Xe_phys, stat=istat )    ! TODO needed? allocated when it goes out of scope?
  check(istat == 0)
  call memfree (edges2nodes, __FILE__, __LINE__ ) ! TODO needed? allocated when it goes out of scope?
  
end subroutine serial_unfitted_triangulation_mc_runtime_info_create

subroutine serial_unfitted_triangulation_mc_runtime_info_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  integer(ip) :: istat
  if (allocated (this%mc_case_per_cell       )) call memfree ( this%mc_case_per_cell        , __FILE__, __LINE__ )
  if (allocated (this%mc_ptr_to_intersections)) call memfree ( this%mc_ptr_to_intersections , __FILE__, __LINE__ )
  if (allocated (this%mc_intersection_points )) then
    deallocate( this%mc_intersection_points, stat=istat )
    check(istat==0)
  end if
end subroutine serial_unfitted_triangulation_mc_runtime_info_free


! TODO split previous function into several shorter ones

!function serial_unfitted_triangulation_determine_mc_case(this,i_lhcell) result (i_case)
!  implicit none
!  class(serial_unfitted_triangulation_t), intent(in) :: this
!  integer(ip), intent(in) :: i_lhcell
!  integer(ip) :: i_case
!  ! TODO
!end function serial_unfitted_triangulation_determine_mc_case



!subroutine serial_unfitted_triangulation_compute_mc_intersection_points(this,i_lhcell,points_out)
!  implicit none
!  class(serial_unfitted_triangulation_t), intent(in) :: this
!  integer(ip), intent(in) :: i_lhcell
!  type(point_t), allocatable, intent(out) :: points_out(:)
!  ! TODO
!end subroutine serial_unfitted_triangulation_compute_mc_intersection_points


