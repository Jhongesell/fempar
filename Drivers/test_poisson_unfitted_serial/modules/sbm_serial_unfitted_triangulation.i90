 ! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Public TBP ------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_create(this, parameters, level_set_function)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)                         , intent(inout) :: parameters
  class(level_set_function_t),            target, intent(in)    :: level_set_function
  
  ! Allocate and fill data managed by the parent class
  call this%free()
  call this%serial_triangulation_t%create(parameters)
  
  ! Check that the triangulation fulfills the assumptions made by this class
  assert(this%fulfills_assumptions())
  
  ! Allocate and fill member variables which are managed by this derived data type
  this%level_set_function => level_set_function
  call this%mc_tables_create()
  call this%mc_runtime_info_create()

end subroutine serial_unfitted_triangulation_create

!------------------------------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this

  ! Free memory managed by the parent class
  call this%serial_triangulation_t%free()

  ! Free memory managed by this class
  call this%mc_tables_free()
  call this%mc_runtime_info_free()

end subroutine serial_unfitted_triangulation_free

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_create_unfitted_cell_iterator ( this ) result (cell_iter)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  type(unfitted_cell_iterator_t) :: cell_iter
  call cell_iter%create(1, this)
end function serial_unfitted_triangulation_create_unfitted_cell_iterator

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_get_num_cut_cells( this ) result ( num_cut_cells )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this

  integer(ip) :: num_cut_cells
  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_cut_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_cut() ) then
      num_cut_cells = num_cut_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function serial_unfitted_triangulation_get_num_cut_cells

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_get_num_interior_cells( this ) result ( num_interior_cells )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  integer(ip) :: num_interior_cells

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_interior_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_interior() ) then
      num_interior_cells = num_interior_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function serial_unfitted_triangulation_get_num_interior_cells

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_get_num_exterior_cells( this ) result ( num_exterior_cells )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  integer(ip) :: num_exterior_cells

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_exterior_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_exterior() ) then
      num_exterior_cells = num_exterior_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function serial_unfitted_triangulation_get_num_exterior_cells

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_get_max_subcells_in_cell( this ) result ( max_subcells_in_cell )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  integer(ip) :: max_subcells_in_cell

  max_subcells_in_cell = this%mc_table_max_num_subcells

end function serial_unfitted_triangulation_get_max_subcells_in_cell

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_get_max_subnodes_in_cell( this ) result ( max_subnodes_in_cell )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  integer(ip) :: max_subnodes_in_cell

  max_subnodes_in_cell = this%get_max_number_shape_functions() + this%mc_table_max_num_cut_edges

end function serial_unfitted_triangulation_get_max_subnodes_in_cell

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_get_max_nodes_in_subcell( this ) result ( max_nodes_in_subcell )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  integer(ip) :: max_nodes_in_subcell

  max_nodes_in_subcell = this%mc_table_num_nodes_subcell

end function serial_unfitted_triangulation_get_max_nodes_in_subcell

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_get_total_num_of_subcells( this ) result ( total_num )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this
  integer(ip) :: total_num

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  total_num = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    total_num = total_num + cell%get_number_of_subcells()
    call cell_iter%next()
  end do
  call cell_iter%free()

end function serial_unfitted_triangulation_get_total_num_of_subcells

!------------------------------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_print ( this )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell
  type(point_t), allocatable, dimension(:) :: cell_coords, subcell_coords
  integer(ip) :: inode, isubcell

  ! Print basic info of triangulation
  write(*,*) " "
  write (*,'(a)') '**** print type(serial_unfitted_triangulation_t) [begin] ****'
  write(*,*) " "
  write (*,'(a,i10)') 'num_dimensions:           ', this%get_num_dimensions()
  write (*,'(a,i10)') 'num_cells:                ', this%get_num_cells()
  write (*,'(a,i10)') 'num_local_cells:          ', this%get_num_local_cells()
  write (*,'(a,i10)') 'num_ghost_cells:          ', this%get_num_ghost_cells()
  write (*,'(a,i10)') 'num_cut_cells:            ', this%get_num_cut_cells()
  write (*,'(a,i10)') 'num_interior_cells:       ', this%get_num_interior_cells()
  write (*,'(a,i10)') 'num_exterior_cells:       ', this%get_num_exterior_cells()
  write (*,'(a,i10)') 'max_num_nodes_in_cell:    ', this%get_max_number_shape_functions()
  write (*,'(a,i10)') 'max_num_subcells_in_cell: ', this%get_max_num_subcells_in_cell()
  write (*,'(a,i10)') 'max_num_subnodes_in_cell: ', this%get_max_num_subnodes_in_cell()
  write (*,'(a,i10)') 'max_num_nodes_in_subcell: ', this%get_max_num_nodes_in_subcell()
  write(*,*) " "

  ! Print basic info of cells
  cell_iter = this%create_unfitted_cell_iterator()
  write(*,'(7a20)') 'id', 'is_cut', 'is_interior', 'is_exterior', 'num_nodes' , 'num_subcells', 'num_nodes_subcell'
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    write(*,'(i20,3L20,3i20)') cell%get_lid(), cell%is_cut(), cell%is_interior(), cell%is_exterior(), &
                               cell%get_num_nodes(), cell%get_number_of_subcells(), cell%get_number_of_subcell_nodes()
    call cell_iter%next()
  end do
  write(*,*) " "

  call memalloc( this%get_max_number_shape_functions(), cell_coords   , __FILE__, __LINE__ ) !TODO can we use memalloc for derived data types?
  call memalloc( this%get_max_num_nodes_in_subcell()  , subcell_coords, __FILE__, __LINE__ )

  ! Print coordinates of cells and sub-cells
  write(*,'(2a7,7a11)') 'id', 'sbid', 'x1', 'y1', 'z1', 'x2', 'y2', 'z2', 'etc.'
  call cell_iter%init()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    call cell%get_coordinates( cell_coords )
    write (*,'(i7,a7,20(2x,e9.2))'  ) cell%get_lid(), ' ',(cell_coords(inode)%get_value(),inode=1,cell%get_num_nodes())
    do isubcell = 1, cell%get_number_of_subcells()
      call cell%get_phys_coords_of_subcell(isubcell,subcell_coords)
      write (*,'(a7,i7,20(2x,e9.2))'  ) ' ', isubcell, (subcell_coords(inode)%get_value(),inode=1,cell%get_number_of_subcell_nodes())
    end do
    call cell_iter%next()
  end do

  write(*,*) " "
  write (*,'(a)') '**** print type(serial_unfitted_triangulation_t) [end] ****'
  write(*,*) " "

 call memfree( cell_coords   , __FILE__, __LINE__ )
 call memfree( subcell_coords, __FILE__, __LINE__ )
 call cell_iter%free()

end subroutine serial_unfitted_triangulation_print

!------------------------------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_print_to_vtk_file ( this )

  implicit none
  class(serial_unfitted_triangulation_t), intent(in)    :: this

  integer(ip) :: num_cells, num_cell_nodes, num_subcells, num_subcell_nodes, num_dime
  integer(ip) :: istat, icell, inode, ino, isubcell
  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell
  type(point_t), allocatable, dimension(:) :: cell_coords, subcell_coords
  integer(ip) :: the_cell_type, the_subcell_type

  ! Used by VTKIO
  integer(ip) :: E_IO
  integer(ip) :: Nn
  integer(ip) :: Ne
  real(rp),    allocatable, dimension(:) :: x
  real(rp),    allocatable, dimension(:) :: y
  real(rp),    allocatable, dimension(:) :: z
  integer(ip), allocatable, dimension(:) :: cell_type
  integer(ip), allocatable, dimension(:) :: offset
  integer(ip), allocatable, dimension(:) :: connect
  integer(ip), allocatable, dimension(:) :: vc
  integer(ip), allocatable :: nodes_vtk2fempar(:), nodesids(:)

  assert( this%mc_runtime_init )
  
  write(*,*) "serial_unfitted_triangulation_t: Writing vtu file ..."

  cell_iter = this%create_unfitted_cell_iterator()
  call cell_iter%current(cell)

  num_dime = this%get_num_dimensions()
  num_cells = this%get_num_cells()
  num_cell_nodes = cell%get_num_nodes()
  num_subcells = this%get_total_num_of_subcells()
  num_subcell_nodes = this%get_max_num_nodes_in_subcell()
  Ne = num_cells + num_subcells
  Nn = num_cell_nodes*num_cells  + num_subcell_nodes*num_subcells

  call memalloc ( Nn, x, __FILE__, __LINE__ )
  call memalloc ( Nn, y, __FILE__, __LINE__ )
  call memalloc ( Nn, z, __FILE__, __LINE__ )
  call memalloc ( Ne, cell_type, __FILE__, __LINE__ )
  call memalloc ( Ne, offset   , __FILE__, __LINE__ )
  call memalloc ( Nn, connect  , __FILE__, __LINE__ )
  call memalloc ( Ne, vc       , __FILE__, __LINE__ )
  allocate ( cell_coords(1:num_cell_nodes), stat = istat ); check(istat == 0)
  allocate ( subcell_coords(1:num_subcell_nodes), stat = istat ); check(istat == 0)
  call memalloc ( num_cell_nodes, nodes_vtk2fempar, __FILE__, __LINE__ )
  call memalloc ( num_cell_nodes, nodesids        , __FILE__, __LINE__ )

  select case (num_dime)
    case(3)
      the_cell_type = 12_I1P
      the_subcell_type = 10_I1P
      nodes_vtk2fempar(:) = [1, 2 , 4, 3, 5, 6, 8, 7]
    case(2)
      the_cell_type = 9_I1P
      the_subcell_type = 5_I1P
      nodes_vtk2fempar(:) = [1, 2 , 4, 3]
    case default
    check(.false.)
  end select

  ! Fill date to be passed to vtkio
  call cell_iter%init()
  icell = 1
  inode = 1
  do while ( .not. cell_iter%has_finished() )

    call cell_iter%current(cell)
    call cell%get_coordinates( cell_coords )

    do ino = 1, num_cell_nodes !TODO is it possible to avoid loops like this one?
      x(inode) = cell_coords(ino)%get(1)
      y(inode) = cell_coords(ino)%get(2)
      z(inode) = cell_coords(ino)%get(3)
      nodesids(ino) = inode
      inode = inode + 1
    end do

    connect(nodesids(:)) = nodesids( nodes_vtk2fempar(:) ) - 1

    offset(icell)        = inode - 1
    cell_type(icell)     = the_cell_type

    if ( cell%is_interior() ) then
      vc( icell )  = -1
    else if ( cell%is_cut() ) then
      vc( icell )  = 0
    else
      vc( icell )  = 1
    end if

    icell = icell + 1

    do isubcell = 1, cell%get_number_of_subcells()
      call cell%get_phys_coords_of_subcell(isubcell,subcell_coords)

      do ino = 1, num_subcell_nodes
        x(inode) = subcell_coords(ino)%get(1)
        y(inode) = subcell_coords(ino)%get(2)
        z(inode) = subcell_coords(ino)%get(3)
        connect(inode) = inode - 1
        inode = inode + 1
      end do

      offset(icell)        = inode - 1
      cell_type(icell)     = the_subcell_type

      if ( cell%is_interior_subcell(isubcell) ) then
        vc( icell )  = -2
      else
        vc( icell )  = 2
      end if

      icell = icell + 1

    end do

    call cell_iter%next()
  end do


  if (num_dime == 2_ip) z(:) = 0

  ! Write mesh to .vtu file
  E_IO = VTK_INI_XML(output_format = 'ascii', filename = 'unfitted_triangulation.vtu', mesh_topology = 'UnstructuredGrid')
  E_IO = VTK_GEO_XML(NN = Nn, NC = Ne, X = x, Y = y, Z = z)
  E_IO = VTK_CON_XML(NC = Ne, connect = connect, offset = offset, cell_type = int(cell_type,I1P) ) 
  E_IO = VTK_DAT_XML(var_location = 'cell', var_block_action = 'opeN')
  E_IO = VTK_VAR_XML(NC_NN = Ne, varname = 'cell_scalars', var = vc)
  E_IO = VTK_DAT_XML(var_location = 'cell', var_block_action = 'CLOSE')
  E_IO = VTK_GEO_XML()
  E_IO = VTK_END_XML()

  call memfree ( x        , __FILE__, __LINE__ )
  call memfree ( y        , __FILE__, __LINE__ )
  call memfree ( z        , __FILE__, __LINE__ )
  call memfree ( cell_type, __FILE__, __LINE__ )
  call memfree ( offset   , __FILE__, __LINE__ )
  call memfree ( connect  , __FILE__, __LINE__ )
  call memfree ( vc       , __FILE__, __LINE__ )
  deallocate ( cell_coords, stat = istat ); check(istat == 0)
  deallocate ( subcell_coords, stat = istat ); check(istat == 0)
  call memfree ( nodes_vtk2fempar, __FILE__, __LINE__ )
  call memfree ( nodesids, __FILE__, __LINE__ )

  call cell_iter%free()
  
  write(*,*) "serial_unfitted_triangulation_t: Writing vtu file ... OK"

end subroutine serial_unfitted_triangulation_print_to_vtk_file


! Private TBP ------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_serial_triangulation_create ( this, parameters)
  implicit none
  class(serial_unfitted_triangulation_t), target, intent(inout) :: this
  type(ParameterList_t)             , intent(inout) :: parameters
  check(.false.)
end subroutine serial_unfitted_triangulation_serial_triangulation_create

!------------------------------------------------------------------------------------------------

function serial_unfitted_triangulation_fulfills_assumptions(this) result (fulfills)
  implicit none
  class(serial_unfitted_triangulation_t), intent(in) :: this
  logical :: fulfills
  
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  character(:),                 allocatable :: topology 
  integer(ip)                               :: num_dim, num_dim_tmp, p_order
  
  ! TODO: requires clean up using getters
  ! Hypothesis: All cells in the mesh are either qua4 or hex8
  fulfills = .true. 
  cell_iter = this%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_dim  = reference_fe_geo%get_number_dimensions()
  if ( (num_dim .ne. 2) .and. (num_dim .ne. 3) ) fulfills = .false. 
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
      reference_fe_geo => cell%get_reference_fe_geo()
      num_dim_tmp  = reference_fe_geo%get_number_dimensions()
      if (num_dim .ne. num_dim_tmp) fulfills = .false.
      p_order  = reference_fe_geo%get_order()
      if (p_order .ne. 1_ip) fulfills = .false.
      topology = reference_fe_geo%get_topology()
      if (topology .ne. topology_hex) fulfills = .false.
      if (.not. fulfills) exit
      call cell_iter%next()      
  end do  
  
end function serial_unfitted_triangulation_fulfills_assumptions

!------------------------------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_mc_tables_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: num_dim

  ! TODO: requires clean up using getters
  
  ! To be safe
  call this%mc_tables_free()
  
  ! Get element type
  cell_iter = this%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_dim  = reference_fe_geo%get_number_dimensions()
  
  ! Fill in the sizes of the tables
  if (num_dim == 2_ip) then
    this%mc_table_num_cases         = MC_QUA4_NUM_CASES
    this%mc_table_max_num_subcells  = MC_QUA4_MAX_NUM_SUBCELLS
    this%mc_table_max_num_cut_edges = MC_QUA4_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_QUA4_NUM_NODES_PER_SUBCELL
  else
    this%mc_table_num_cases         = MC_HEX8_NUM_CASES
    this%mc_table_max_num_subcells  = MC_HEX8_MAX_NUM_SUBCELLS
    this%mc_table_max_num_cut_edges = MC_HEX8_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_HEX8_NUM_NODES_PER_SUBCELL
  end if

  ! Now, we know the sizes and can allocate
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_subcells_per_case    , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__ )
  
  call memalloc (this%mc_table_num_nodes_subcell, this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__ )

  ! Fill tables for the selected element type
  if (num_dim == 2_ip) then
    this%mc_table_num_subcells_per_case      = MC_QUA4_NUM_SUBCELLS_PER_CASE
    this%mc_table_num_cut_edges_per_case     = MC_QUA4_NUM_CUT_EDGES_PER_CASE
    this%mc_table_inout_subcells_per_case    = MC_QUA4_INOUT_SUBCELLS_PER_CASE
    this%mc_table_subcell_node_ids_per_case  = MC_QUA4_SUBCELL_NODE_IDS_PER_CASE
  else
    this%mc_table_num_subcells_per_case      = MC_HEX8_NUM_SUBCELLS_PER_CASE
    this%mc_table_num_cut_edges_per_case     = MC_HEX8_NUM_CUT_EDGES_PER_CASE
    this%mc_table_inout_subcells_per_case    = MC_HEX8_INOUT_SUBCELLS_PER_CASE
    this%mc_table_subcell_node_ids_per_case  = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE
  endif

  this%mc_tables_init = .true.

end subroutine serial_unfitted_triangulation_mc_tables_create

subroutine serial_unfitted_triangulation_mc_tables_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this

  if (allocated (this%mc_table_num_subcells_per_case    )) call memfree (this%mc_table_num_subcells_per_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_cut_edges_per_case   )) call memfree (this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__)
  if (allocated (this%mc_table_inout_subcells_per_case  )) call memfree (this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__)
  if (allocated (this%mc_table_subcell_node_ids_per_case)) call memfree (this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__)

  this%mc_tables_init = .false.

end subroutine serial_unfitted_triangulation_mc_tables_free

subroutine serial_unfitted_triangulation_mc_runtime_info_create(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  type(quadrature_t), pointer :: nodal_quadrature
  integer(ip), parameter :: x=1, y=2, z=3
  type(point_t), allocatable :: Xe_phys(:), Xe_ref(:)
  integer(ip), parameter :: edge_dim = 1
  integer(ip), allocatable :: edges2nodes(:,:)
  integer(ip) :: num_edge_nodes, num_edges, iedge, inode, num_nodes, num_dim
  integer(ip) :: num_cells, icell, ipoin, num_int_points
  integer(ip) :: icase, istat
  integer(ip), parameter :: node2bit(8) = [1,2,4,8,16,32,64,128] ! enough for qua4 and hex8
  integer(ip), parameter :: num_nodes_in_edge = 2
  integer(ip) :: nodes_in_edge(num_nodes_in_edge)
  real(rp)    :: phi_node, phi_edge(num_nodes_in_edge)
  
  ! To be safe
  call this%mc_runtime_info_free()  
  
  ! Get edges to nodes table on the reference element.
  ! To this end I have created a new getter in reference FE. TODO: a better way of doing this?
  cell_iter = this%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_edges      = reference_fe_geo%get_number_n_faces_of_dimension(edge_dim)
  num_edge_nodes = reference_fe_geo%get_num_nodes_per_n_face_of_dim(edge_dim) 
  assert(num_edge_nodes == 2_ip)
  call memalloc (num_edge_nodes, num_edges, edges2nodes, __FILE__, __LINE__ )
  call reference_fe_geo%get_nodes_of_all_n_faces_of_dim( edge_dim, edges2nodes ) 
   
  !! TODO. to be removed (print the table)
  !write(*,*) "Edge to nodes table"
  !do iedge = 1, num_edges
  !    write(*,*) edges2nodes(1,iedge), edges2nodes(2,iedge)
  !end do  
  !write(*,*) " "
 
  ! Get the nodal coordinates in the reference element
  nodal_quadrature => reference_fe_geo%get_nodal_quadrature()
  num_dim   = nodal_quadrature%get_number_dimensions()
  num_nodes = nodal_quadrature%get_number_quadrature_points()
  allocate( Xe_ref(1:num_nodes), stat=istat )
  check(istat == 0)
  call nodal_quadrature%get_coordinates_as_points( Xe_ref )
  
  !write(*,*) "Coordinates at reference element"
  !do inode = 1, num_nodes
  !    write(*,*) Xe_ref(inode)%get(x), Xe_ref(inode)%get(y), Xe_ref(inode)%get(z)
  !end do  
  !  write(*,*) " "
    
  ! Get number of cells  
  num_cells = this%get_num_local_cells() + this%get_num_ghost_cells()
  !write(*,*) "num_cells ", num_cells
  
  call memalloc (num_cells, this%mc_case_per_cell, __FILE__, __LINE__ )
  
  ! Loop to determine the cases
  allocate ( Xe_phys(num_nodes), stat=istat )
  check(istat == 0)
  icell = 1
  do while ( .not. cell_iter%has_finished() )

    call cell_iter%current(cell)
   
      !write (*,*) "I am: ", cell%get_lid(), " lid"
      !write (*,*) "Node coordinates (physical space)"
      !reference_fe_geo => cell%get_reference_fe_geo()
      
      call cell%get_coordinates(Xe_phys)
      
      if ( num_dim == 2_ip ) then ! Only needed to use a sphere levelset in 2d. TODO: remove when using a generic levelset
        do inode = 1, num_nodes
          call Xe_phys(inode)%set(z,0.0_rp)
        end do
      end if
      
      !do inode = 1, num_nodes
      !  write (*,*) Xe_phys(inode)%get(x), Xe_phys(inode)%get(y)
      !end do
      !write(*,*) " "
      
      ! Evaluate level set and the case
      icase = 0_ip
      do inode = 1, num_nodes
        call this%level_set_function%get_value(Xe_phys(inode),phi_node)
        !write (*,*) phi_node
        if (phi_node < 0.0_rp) icase = ior(icase,node2bit(inode))
      end do
      this%mc_case_per_cell(icell) = icase + 1
      !write(*,*) "case ", icase
      !write(*,*) " "
      
    icell = icell + 1 ! TODO a better way of doing this?? using the iterator?  Use lid? what happens to ghost cells?
    call cell_iter%next()

  end do
  
  ! Loop for creating the intersection points pointers
  call memalloc (num_cells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  this%mc_ptr_to_intersections(1) = 1
  do icell = 1,num_cells
    this%mc_ptr_to_intersections(icell + 1) = this%mc_ptr_to_intersections(icell) & 
    + this%mc_table_num_cut_edges_per_case(this%mc_case_per_cell(icell))
  end do
    
  ! Loop for computing the intersection points
  num_int_points = this%mc_ptr_to_intersections(num_cells + 1) - this%mc_ptr_to_intersections(1)
  allocate ( this%mc_intersection_points( num_int_points ), stat = istat )
  check(istat == 0)
  call cell_iter%init()
  icell = 1
  ipoin = 1
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
      call cell%get_coordinates(Xe_phys)
      !write (*,*) "I am: ", cell%get_lid(), " lid"
      !write (*,*) "Node coordinates (physical space)"
      !do inode = 1, num_nodes
      !  write (*,*) Xe_phys(inode)%get(x), Xe_phys(inode)%get(y)
      !end do
      !write(*,*) " "
      do iedge = 1, num_edges
        nodes_in_edge(:) = edges2nodes(:,iedge)      
        do inode = 1,num_nodes_in_edge
          call this%level_set_function%get_value(Xe_phys(nodes_in_edge(inode)),phi_edge(inode))
        end do
        !write(*,*) "Edge=", iedge, " ", phi_edge
        if ( (phi_edge(1) >= 0 .and. phi_edge(2) < 0) .or. (phi_edge(2) >= 0 .and. phi_edge(1) < 0)   ) then
          this%mc_intersection_points(ipoin) = Xe_ref(nodes_in_edge(1)) + &
          (abs(phi_edge(1))/(abs(phi_edge(1))+abs(phi_edge(2))))*( Xe_ref(nodes_in_edge(2)) - Xe_ref(nodes_in_edge(1)) ) 
          !write(*,*) "Int ", this%mc_intersection_points(ipoin)%get(x), this%mc_intersection_points(ipoin)%get(y) 
          ipoin = ipoin + 1          
        end if
      end do      
    icell = icell + 1 ! TODO a better way of doing this?? using the iterator?  Use lid?  Use lid? what happens to ghost cells?
    call cell_iter%next()
   ! write(*,*) " "
 end do
  
  deallocate( Xe_ref, stat=istat )  
  check(istat == 0)
  deallocate( Xe_phys, stat=istat )    
  check(istat == 0)
  call memfree (edges2nodes, __FILE__, __LINE__ ) 

  this%mc_runtime_init = .true.
  
end subroutine serial_unfitted_triangulation_mc_runtime_info_create

!------------------------------------------------------------------------------------------------

subroutine serial_unfitted_triangulation_mc_runtime_info_free(this)
  implicit none
  class(serial_unfitted_triangulation_t), intent(inout) :: this
  integer(ip) :: istat, i
  if (allocated (this%mc_case_per_cell       )) call memfree ( this%mc_case_per_cell        , __FILE__, __LINE__ )
  if (allocated (this%mc_ptr_to_intersections)) call memfree ( this%mc_ptr_to_intersections , __FILE__, __LINE__ )
  if (allocated (this%mc_intersection_points)) then
    deallocate(this%mc_intersection_points, stat=istat); check(istat==0)
  end if
  this%mc_runtime_init = .false.
end subroutine serial_unfitted_triangulation_mc_runtime_info_free
