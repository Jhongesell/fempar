 ! Copyright (C) 2014 Santiago Badia, Alberto F. Mart√≠n and Javier Principe
!
! This file is part of FEMPAR (Finite Element Multiphysics PARallel library)
!
! FEMPAR is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! FEMPAR is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with FEMPAR. If not, see <http://www.gnu.org/licenses/>.
!
! Additional permission under GNU GPL version 3 section 7
!
! If you modify this Program, or any covered work, by linking or combining it 
! with the Intel Math Kernel Library and/or the Watson Sparse Matrix Package 
! and/or the HSL Mathematical Software Library (or a modified version of them), 
! containing parts covered by the terms of their respective licenses, the
! licensors of this Program grant you additional permission to convey the 
! resulting work. 
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!========================================================================================
subroutine marching_cubes_create(this, triangulation, level_set_function)
  implicit none
  class(marching_cubes_t),            target,  intent(inout)  :: this
  class(base_static_triangulation_t), pointer, intent(in)     :: triangulation
  class(level_set_function_t),        target,  intent(in)     :: level_set_function
  call this%free()
  this%triangulation => triangulation
  assert(this%fulfills_assumptions())
  this%level_set_function => level_set_function
  call this%mc_tables_create()
  call this%mc_runtime_info_create()
  call this%subnodes_data_create()
end subroutine marching_cubes_create

!========================================================================================
subroutine marching_cubes_free(this)
  implicit none
  class(marching_cubes_t), target, intent(inout) :: this
  this%triangulation => null()
  this%level_set_function => null()
  call this%mc_tables_free()
  call this%mc_runtime_info_free()
  call this%subnodes_data_free()
end subroutine marching_cubes_free

!========================================================================================
function marching_cubes_create_unfitted_cell_iterator ( this ) result (cell_iter)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  type(unfitted_cell_iterator_t) :: cell_iter
  call cell_iter%create(1, this)
end function marching_cubes_create_unfitted_cell_iterator

!========================================================================================
function marching_cubes_get_num_cut_cells( this ) result ( num_cut_cells )

  implicit none
  class(marching_cubes_t), intent(in)    :: this

  integer(ip) :: num_cut_cells
  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_cut_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_cut() ) then
      num_cut_cells = num_cut_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_num_cut_cells

!========================================================================================
function marching_cubes_get_num_interior_cells( this ) result ( num_interior_cells )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: num_interior_cells

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_interior_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_interior() ) then
      num_interior_cells = num_interior_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_num_interior_cells

!========================================================================================
function marching_cubes_get_num_exterior_cells( this ) result ( num_exterior_cells )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: num_exterior_cells

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  num_exterior_cells = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if ( cell%is_exterior() ) then
      num_exterior_cells = num_exterior_cells + 1_ip
    end if
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_num_exterior_cells

!========================================================================================
function marching_cubes_get_max_num_subcells_in_cell( this ) result ( max_subcells_in_cell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_subcells_in_cell
  max_subcells_in_cell = this%mc_table_max_num_subcells
end function marching_cubes_get_max_num_subcells_in_cell

!========================================================================================
function marching_cubes_get_max_num_nodes_in_subcell( this ) result ( max_nodes_in_subcell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_nodes_in_subcell
  max_nodes_in_subcell = this%mc_table_num_nodes_subcell
end function marching_cubes_get_max_num_nodes_in_subcell

!========================================================================================
function marching_cubes_get_total_num_of_subcells( this ) result ( total_num )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: total_num

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  total_num = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    call cell%update_sub_triangulation()
    total_num = total_num + cell%get_number_of_subcells()
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_total_num_of_subcells

!========================================================================================
function marching_cubes_get_max_num_subfaces_in_cell( this ) result ( max_subfaces_in_cell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_subfaces_in_cell
  max_subfaces_in_cell = this%mc_table_max_num_subfaces
end function marching_cubes_get_max_num_subfaces_in_cell

!========================================================================================
function marching_cubes_get_max_num_nodes_in_subface( this ) result ( max_nodes_in_subface)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_nodes_in_subface
  max_nodes_in_subface = this%mc_table_num_nodes_subface
end function marching_cubes_get_max_num_nodes_in_subface

!========================================================================================
function marching_cubes_get_total_num_of_subfaces( this ) result ( total_num )

  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: total_num

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell

  total_num = 0_ip
  cell_iter = this%create_unfitted_cell_iterator()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    call cell%update_sub_triangulation()
    total_num = total_num + cell%get_number_of_subfaces()
    call cell_iter%next()
  end do
  call cell_iter%free()

end function marching_cubes_get_total_num_of_subfaces

!========================================================================================
function marching_cubes_get_max_num_subnodes_in_cell( this ) result ( max_subnodes_in_cell )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: max_subnodes_in_cell
  max_subnodes_in_cell = this%triangulation%get_max_number_shape_functions() + this%mc_table_max_num_cut_edges
end function marching_cubes_get_max_num_subnodes_in_cell

!========================================================================================
function marching_cubes_get_num_mc_cases(this) result (mc_cases)
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  integer(ip) :: mc_cases
  mc_cases = this%mc_table_num_cases
end function marching_cubes_get_num_mc_cases

!========================================================================================
function marching_cubes_get_num_subcells_mc_case(this,mc_case) result (num_subcells)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip), intent(in) :: mc_case
  integer(ip) :: num_subcells
  num_subcells = this%mc_table_num_subcells_per_case(mc_case)
end function marching_cubes_get_num_subcells_mc_case

!========================================================================================
function marching_cubes_get_num_subfaces_mc_case(this,mc_case) result (num_subfaces)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  integer(ip), intent(in) :: mc_case
  integer(ip) :: num_subfaces
  num_subfaces = this%mc_table_num_subfaces_per_case(mc_case)
end function marching_cubes_get_num_subfaces_mc_case

!========================================================================================
subroutine marching_cubes_print ( this )

  implicit none
  class(marching_cubes_t), intent(in)    :: this

  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell
  type(point_t), allocatable, dimension(:) :: cell_coords, subcell_coords, subface_coords
  integer(ip) :: inode, isubcell, isubface

  ! Print basic info of triangulation
  write(*,*) " "
  write (*,'(a)') '**** print type(marching_cubes_t) [begin] ****'
  write(*,*) " "
  write (*,'(a,i10)') 'num_dimensions:           ', this%triangulation%get_num_dimensions()
  write (*,'(a,i10)') 'num_cells:                ', this%triangulation%get_num_cells()
  write (*,'(a,i10)') 'num_local_cells:          ', this%triangulation%get_num_local_cells()
  write (*,'(a,i10)') 'num_ghost_cells:          ', this%triangulation%get_num_ghost_cells()
  write (*,'(a,i10)') 'num_cut_cells:            ', this%get_num_cut_cells()
  write (*,'(a,i10)') 'num_interior_cells:       ', this%get_num_interior_cells()
  write (*,'(a,i10)') 'num_exterior_cells:       ', this%get_num_exterior_cells()
  write (*,'(a,i10)') 'max_num_nodes_in_cell:    ', this%triangulation%get_max_number_shape_functions()
  write (*,'(a,i10)') 'max_num_subcells_in_cell: ', this%get_max_num_subcells_in_cell()
  write (*,'(a,i10)') 'max_num_nodes_in_subcell: ', this%get_max_num_nodes_in_subcell()
  write (*,'(a,i10)') 'max_num_subfaces_in_cell: ', this%get_max_num_subfaces_in_cell()
  write (*,'(a,i10)') 'max_num_nodes_in_subface: ', this%get_max_num_nodes_in_subface()
  write (*,'(a,i10)') 'max_num_subnodes_in_cell: ', this%get_max_num_subnodes_in_cell()
  write(*,*) " "

  ! Print basic info of cells
  cell_iter = this%create_unfitted_cell_iterator()
  write(*,'(8a20)') 'id', 'is_cut', 'is_interior', 'is_exterior', 'is_active', 'num_nodes' , 'num_subcells', 'num_nodes_subcell'
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    write(*,'(i20,4L20,3i20)') cell%get_lid(), cell%is_cut(), cell%is_interior(), cell%is_exterior(), cell%is_active(), &
                               cell%get_num_nodes(), cell%get_number_of_subcells(), cell%get_number_of_subcell_nodes()
    call cell_iter%next()
  end do
  write(*,*) " "

  call memalloc( this%triangulation%get_max_number_shape_functions(), cell_coords   , __FILE__, __LINE__ )
  call memalloc( this%get_max_num_nodes_in_subcell()  , subcell_coords, __FILE__, __LINE__ )
  call memalloc( this%get_max_num_nodes_in_subface()  , subface_coords, __FILE__, __LINE__ )

  ! Print coordinates of cells and sub-cells
  write(*,'(3a7,7a11)') 'id', 'scid', 'sfid', 'x1', 'y1', 'z1', 'x2', 'y2', 'z2', 'etc.'
  call cell_iter%init()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    ! TODO where is the safe place to put this update?
    call cell%update_sub_triangulation()
    call cell%get_coordinates( cell_coords )
    write (*,'(i7,2a7,20(2x,e9.2))'  ) cell%get_lid(), ' ', ' ',(cell_coords(inode)%get_value(),inode=1,cell%get_num_nodes())
    do isubcell = 1, cell%get_number_of_subcells()
      call cell%get_phys_coords_of_subcell(isubcell,subcell_coords)
      write (*,'(a7,i7,a7,20(2x,e9.2))'  ) ' ', isubcell, ' ' ,(subcell_coords(inode)%get_value(),inode=1,cell%get_number_of_subcell_nodes())
    end do
    do isubface = 1, cell%get_number_of_subfaces()
      call cell%get_phys_coords_of_subface(isubface,subface_coords)
      write (*,'(2a7,i7,20(2x,e9.2))'  ) ' ', ' ' , isubface,(subface_coords(inode)%get_value(),inode=1,cell%get_number_of_subface_nodes())
    end do
    call cell_iter%next()
  end do

  write(*,*) " "
  write (*,'(a)') '**** print type(marching_cubes_t) [end] ****'
  write(*,*) " "

 call memfree( cell_coords   , __FILE__, __LINE__ )
 call memfree( subcell_coords, __FILE__, __LINE__ )
 call memfree( subface_coords, __FILE__, __LINE__ )
 call cell_iter%free()

end subroutine marching_cubes_print

!========================================================================================
subroutine marching_cubes_print_to_vtk_file ( this )
  implicit none
  class(marching_cubes_t), intent(in)    :: this
  write(*,*) "marching_cubes_t: Writing vtu file ..."
  call this%print_vtk_subcells()
  call this%print_vtk_subfaces()
  write(*,*) "marching_cubes_t: Writing vtu file ... OK"
end subroutine marching_cubes_print_to_vtk_file

! Private TBP

!========================================================================================
function marching_cubes_fulfills_assumptions(this) result (fulfills)
  implicit none
  class(marching_cubes_t), intent(in) :: this
  logical :: fulfills

  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  character(:),                 allocatable :: topology
  integer(ip)                               :: num_dim, num_dim_tmp, p_order

  ! Hypothesis: All cells in the mesh are either bi-linear qua or tri-linear hex
  fulfills = .true.
  cell_iter= this%triangulation%create_cell_iterator()
  num_dim  = this%triangulation%get_num_dimensions()
  if ( (num_dim .ne. 2) .and. (num_dim .ne. 3) ) fulfills = .false.
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
      reference_fe_geo => cell%get_reference_fe_geo()
      num_dim_tmp  = reference_fe_geo%get_number_dimensions()
      if (num_dim .ne. num_dim_tmp) fulfills = .false.
      p_order  = reference_fe_geo%get_order()
      if (p_order .ne. 1_ip) fulfills = .false.
      topology = reference_fe_geo%get_topology()
      if (topology .ne. topology_hex) fulfills = .false.
      if (.not. fulfills) exit
      call cell_iter%next()
  end do

end function marching_cubes_fulfills_assumptions

!========================================================================================
subroutine marching_cubes_mc_tables_create(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: num_dim

  ! To be safe
  call this%mc_tables_free()

  ! Get element type, we assume hex-like topology
  num_dim  = this%triangulation%get_num_dimensions()

  ! Fill in the sizes of the tables
  if (num_dim == 2_ip) then
    this%mc_table_num_cases         = MC_QUA4_NUM_CASES
    this%mc_table_max_num_subcells  = MC_QUA4_MAX_NUM_SUBCELLS
    this%mc_table_max_num_subfaces  = MC_QUA4_MAX_NUM_SUBFACES
    this%mc_table_max_num_cut_edges = MC_QUA4_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_QUA4_NUM_NODES_PER_SUBCELL
    this%mc_table_num_nodes_subface = MC_QUA4_NUM_NODES_PER_SUBFACE
  else
    this%mc_table_num_cases         = MC_HEX8_NUM_CASES
    this%mc_table_max_num_subcells  = MC_HEX8_MAX_NUM_SUBCELLS
    this%mc_table_max_num_subfaces  = MC_HEX8_MAX_NUM_SUBFACES
    this%mc_table_max_num_cut_edges = MC_HEX8_MAX_NUM_CUT_EDGES
    this%mc_table_num_nodes_subcell = MC_HEX8_NUM_NODES_PER_SUBCELL
    this%mc_table_num_nodes_subface = MC_HEX8_NUM_NODES_PER_SUBFACE
  end if

  ! Now, we know the sizes and can allocate
  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_subcells_per_case    , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_subfaces_per_case    , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_cases, &
                 this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__ )

  call memalloc (this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_nodes_subcell, this%mc_table_max_num_subcells, this%mc_table_num_cases, &
                 this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__ )

  call memalloc (this%mc_table_num_nodes_subface, this%mc_table_max_num_subfaces, this%mc_table_num_cases, &
                 this%mc_table_subface_node_ids_per_case, __FILE__, __LINE__ )

  ! Fill tables for the selected element type
  if (num_dim == 2_ip) then
    this%mc_table_num_subcells_per_case(:)      = MC_QUA4_NUM_SUBCELLS_PER_CASE(:)
    this%mc_table_num_subfaces_per_case(:)      = MC_QUA4_NUM_SUBFACES_PER_CASE(:)
    this%mc_table_num_cut_edges_per_case(:)     = MC_QUA4_NUM_CUT_EDGES_PER_CASE(:)
    this%mc_table_inout_subcells_per_case(:,:)    = MC_QUA4_INOUT_SUBCELLS_PER_CASE(:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,:)  = MC_QUA4_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,:)  = MC_QUA4_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
  else
    this%mc_table_num_subcells_per_case(:)      = MC_HEX8_NUM_SUBCELLS_PER_CASE(:)
    this%mc_table_num_subfaces_per_case(:)      = MC_HEX8_NUM_SUBFACES_PER_CASE(:)
    this%mc_table_num_cut_edges_per_case(:)     = MC_HEX8_NUM_CUT_EDGES_PER_CASE(:)
    this%mc_table_inout_subcells_per_case(:,:)    = MC_HEX8_INOUT_SUBCELLS_PER_CASE(:,:)
    this%mc_table_subcell_node_ids_per_case(:,:,:)  = MC_HEX8_SUBCELL_NODE_IDS_PER_CASE(:,:,:)
    this%mc_table_subface_node_ids_per_case(:,:,:)  = MC_HEX8_SUBFACE_NODE_IDS_PER_CASE(:,:,:)
  endif

  this%mc_tables_init = .true.

end subroutine marching_cubes_mc_tables_create

!========================================================================================
subroutine marching_cubes_mc_tables_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  if (allocated (this%mc_table_num_subcells_per_case    )) call memfree (this%mc_table_num_subcells_per_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_subfaces_per_case    )) call memfree (this%mc_table_num_subfaces_per_case    , __FILE__, __LINE__)
  if (allocated (this%mc_table_num_cut_edges_per_case   )) call memfree (this%mc_table_num_cut_edges_per_case   , __FILE__, __LINE__)
  if (allocated (this%mc_table_inout_subcells_per_case  )) call memfree (this%mc_table_inout_subcells_per_case  , __FILE__, __LINE__)
  if (allocated (this%mc_table_subcell_node_ids_per_case)) call memfree (this%mc_table_subcell_node_ids_per_case, __FILE__, __LINE__)
  if (allocated (this%mc_table_subface_node_ids_per_case)) call memfree (this%mc_table_subface_node_ids_per_case, __FILE__, __LINE__)

  this%mc_tables_init = .false.

end subroutine marching_cubes_mc_tables_free

!========================================================================================
subroutine marching_cubes_mc_runtime_info_create(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this

  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  type(point_t), allocatable :: Xe_phys(:), Xe_ref(:)
  integer(ip), parameter :: edge_dim = 1
  integer(ip) :: inode, num_nodes
  integer(ip) :: iedge, first_edge, last_edge, cell_node, edge_node
  type(list_iterator_t) :: nodes_in_edge_iterator
  integer(ip) :: num_cells, ipoin, num_int_points
  integer(ip) :: icase, istat, num_nodes_outside
  integer(ip), parameter :: num_nodes_in_edge = 2
  integer(ip) :: nodes_in_edge(num_nodes_in_edge)
  real(rp)    :: phi_node, phi_edge(num_nodes_in_edge)

  ! To be safe
  call this%mc_runtime_info_free()

  ! Get the nodal coordinates in the reference element
  cell_iter = this%triangulation%create_cell_iterator()
  call cell_iter%current(cell)
  reference_fe_geo => cell%get_reference_fe_geo()
  num_nodes = cell%get_num_nodes()
  allocate( Xe_ref(1:num_nodes), stat=istat ); check(istat == 0)
  call cell%get_coordinates_ref_space( Xe_ref )

  ! Allocate and fill marching cube cases
  num_cells = this%triangulation%get_num_local_cells() + this%triangulation%get_num_ghost_cells()
  call memalloc (num_cells, this%mc_case_per_cell, __FILE__, __LINE__ )
  allocate ( Xe_phys(num_nodes), stat=istat ); check(istat == 0)
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    call cell%get_coordinates(Xe_phys)
    icase = 0_ip
    num_nodes_outside = 0_ip
    do inode = 1, num_nodes
      call this%level_set_function%get_value(Xe_phys(inode),phi_node)
      if (phi_node < 0.0_rp) icase = ior( icase, 2_ip**(inode-1_ip) )
      if (phi_node > 0.0_rp) num_nodes_outside = num_nodes_outside + 1
    end do
    if ( num_nodes_outside == 0_ip ) then
      ! This is to avoid to set as cut an element that has negative and zero nodes 
      ! (which is in fact a full interior element)
      this%mc_case_per_cell(cell%get_lid()) = this%mc_table_num_cases
    else
      this%mc_case_per_cell(cell%get_lid()) = icase + 1
    end if
    call cell_iter%next()
  end do

  ! De-activate cells which are exterior
  call cell_iter%init()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    if (this%mc_case_per_cell(cell%get_lid())==1) call cell%set_as_inactive()
    call cell_iter%next()
  end do

  ! Allocate and fill the intersection points pointers
  call memalloc (num_cells+1, this%mc_ptr_to_intersections, __FILE__, __LINE__ )
  this%mc_ptr_to_intersections(1) = 1
  call cell_iter%init()
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)
    this%mc_ptr_to_intersections(cell%get_lid() + 1) = this%mc_ptr_to_intersections(cell%get_lid()) &
    + this%mc_table_num_cut_edges_per_case(this%mc_case_per_cell(cell%get_lid()))
    call cell_iter%next()
  end do

  ! Allocate and fill the intersection points
  num_int_points = this%mc_ptr_to_intersections(num_cells + 1) - this%mc_ptr_to_intersections(1)
  allocate ( this%mc_intersection_points( num_int_points ), stat = istat )
  check(istat == 0)
  call cell_iter%init()
  ipoin = 1
  do while ( .not. cell_iter%has_finished() )
    call cell_iter%current(cell)

    ! Only execute this loop for cut elements
    if ( this%mc_case_per_cell(cell%get_lid())==1 .or. this%mc_case_per_cell(cell%get_lid())==this%mc_table_num_cases ) then
      call cell_iter%next()
      cycle
    end if

    ! Get nodal coordinates
    call cell%get_coordinates(Xe_phys)

    ! Prepare Loop in cell edges
    reference_fe_geo => cell%get_reference_fe_geo()
    first_edge = reference_fe_geo%get_first_n_face_id_of_dimension(edge_dim)
    last_edge  = first_edge + reference_fe_geo%get_number_n_faces_of_dimension(edge_dim) - 1

    ! Loop in cell edges
    do iedge = first_edge, last_edge

      ! Loop in edge nodes
      nodes_in_edge_iterator = reference_fe_geo%create_nodes_n_face_iterator(iedge)
      do while (.not. nodes_in_edge_iterator%is_upper_bound())
        edge_node = nodes_in_edge_iterator%get_distance_to_lower_bound()
        cell_node = nodes_in_edge_iterator%get_current()

        ! Evaluate the levelset
        call this%level_set_function%get_value(Xe_phys(cell_node),phi_edge(edge_node))

        ! Store the nodes ids of the current edge
        nodes_in_edge(edge_node) = cell_node

        call nodes_in_edge_iterator%next()
      end do

      ! Compute the intersection points of the edge
      if ( (phi_edge(1) >= 0 .and. phi_edge(2) < 0) .or. (phi_edge(2) >= 0 .and. phi_edge(1) < 0)   ) then
        this%mc_intersection_points(ipoin) = Xe_ref(nodes_in_edge(1)) + &
        (abs(phi_edge(1))/(abs(phi_edge(1))+abs(phi_edge(2))))*( Xe_ref(nodes_in_edge(2)) - Xe_ref(nodes_in_edge(1)) )
        ipoin = ipoin + 1
      end if

    end do

    call cell_iter%next()
  end do

  deallocate( Xe_ref, stat=istat );  check(istat == 0)
  deallocate( Xe_phys, stat=istat ); check(istat == 0)

  this%mc_runtime_init = .true.

end subroutine marching_cubes_mc_runtime_info_create

!========================================================================================
subroutine marching_cubes_mc_runtime_info_free(this)
  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip) :: istat, i
  if (allocated (this%mc_case_per_cell       )) call memfree ( this%mc_case_per_cell        , __FILE__, __LINE__ )
  if (allocated (this%mc_ptr_to_intersections)) call memfree ( this%mc_ptr_to_intersections , __FILE__, __LINE__ )
  if (allocated (this%mc_intersection_points)) then
    deallocate(this%mc_intersection_points, stat=istat); check(istat==0)
  end if
  this%mc_runtime_init = .false.
end subroutine marching_cubes_mc_runtime_info_free

!========================================================================================
subroutine marching_cubes_subnodes_data_create( this )

  implicit none
  class(marching_cubes_t), intent(inout) :: this

  integer(ip) :: istat, icase
  type(cell_iterator_t)  :: cell_iter
  type(cell_accessor_t)  :: cell
  class(lagrangian_reference_fe_t), pointer :: reference_fe_geo
  integer(ip) :: n_subcells, n_subfaces, n_subnodes, n_nodes_subcell, n_nodes_subface  

  assert(this%mc_tables_init)
  assert(this%mc_runtime_init)

  call this%subnodes_data_free()
  
  ! TODO we don't really need to allocate for all the mc cases
  allocate( this%subnodes_nodal_quadratures(1:this%get_num_mc_cases()), stat=istat); check(istat==0_ip)
  allocate( this%subnodes_fe_maps          (1:this%get_num_mc_cases()), stat=istat); check(istat==0_ip)

  ! Initialize each one of the quadratures
  cell_iter = this%triangulation%create_cell_iterator()
  call cell_iter%current(cell)
  do icase=1, this%get_num_mc_cases()
    n_subnodes =  this%mc_table_num_cut_edges_per_case(icase) + cell%get_num_nodes()
    call this%subnodes_nodal_quadratures(icase)%create(this%triangulation%get_num_dimensions(),n_subnodes)
  end do

  ! Initialize each one of the fe_maps
  reference_fe_geo => cell%get_reference_fe_geo()
  do icase=1, this%get_num_mc_cases()
    call this%subnodes_fe_maps(icase)%create( this%subnodes_nodal_quadratures(icase), reference_fe_geo)
  end do

  !Allocate place holders for the sub-mesh
  n_subcells      = this%get_max_num_subcells_in_cell()
  n_subfaces      = this%get_max_num_subfaces_in_cell()
  n_subnodes      = this%get_max_num_subnodes_in_cell()
  n_nodes_subcell = this%get_max_num_nodes_in_subcell()
  n_nodes_subface = this%get_max_num_nodes_in_subface()
  call memalloc(n_nodes_subcell,n_subcells,this%subcells_nodal_connectivities,__FILE__,__LINE__)
  call memalloc(n_nodes_subface,n_subfaces,this%subfaces_nodal_connectivities,__FILE__,__LINE__)
  call memalloc(n_subcells,this%subcell_has_been_reoriented,__FILE__,__LINE__)
  allocate( this%subnodes_ref_coords(1:n_subnodes) , stat=istat); check(istat==0_ip)

end subroutine marching_cubes_subnodes_data_create

!========================================================================================
subroutine marching_cubes_subnodes_data_free( this )

  implicit none
  class(marching_cubes_t), intent(inout) :: this
  integer(ip) :: istat, i

  if ( allocated(this%subnodes_ref_coords) ) then
    deallocate( this%subnodes_ref_coords, stat=istat ); check( istat==0_ip )
  end if

  if ( allocated(this%subnodes_nodal_quadratures) ) then
    do i=1,size(this%subnodes_nodal_quadratures)
      call this%subnodes_nodal_quadratures(i)%free()
    end do
    deallocate( this%subnodes_nodal_quadratures, stat=istat ); check( istat==0_ip )
  end if

  if ( allocated(this%subnodes_fe_maps) ) then
    do i=1,size(this%subnodes_fe_maps)
      call this%subnodes_fe_maps(i)%free()
    end do
    deallocate( this%subnodes_fe_maps, stat=istat ); check( istat==0_ip )
  end if

  if(allocated(this%subcells_nodal_connectivities  )) call memfree(this%subcells_nodal_connectivities  ,__FILE__,__LINE__)
  if(allocated(this%subfaces_nodal_connectivities  )) call memfree(this%subfaces_nodal_connectivities  ,__FILE__,__LINE__)
  if(allocated(this%subcell_has_been_reoriented)) call memfree(this%subcell_has_been_reoriented,__FILE__,__LINE__)

end subroutine marching_cubes_subnodes_data_free

!========================================================================================
! TODO put all of this in vtw writer
subroutine marching_cubes_print_vtk_subcells( this )

  implicit none
  class(marching_cubes_t), intent(in)    :: this

  integer(ip) :: num_cells, num_cell_nodes, num_subcells, num_subcell_nodes, num_dime
  integer(ip) :: istat, icell, inode, ino, isubcell
  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell
  type(point_t), allocatable, dimension(:) :: cell_coords, subcell_coords
  integer(ip) :: the_cell_type, the_subcell_type

  ! Used by VTKIO
  integer(ip) :: E_IO
  integer(ip) :: Nn
  integer(ip) :: Ne
  real(rp),    allocatable, dimension(:) :: x
  real(rp),    allocatable, dimension(:) :: y
  real(rp),    allocatable, dimension(:) :: z
  integer(ip), allocatable, dimension(:) :: cell_type
  integer(ip), allocatable, dimension(:) :: offset
  integer(ip), allocatable, dimension(:) :: connect
  integer(ip), allocatable, dimension(:) :: vc
  integer(ip), allocatable :: nodes_vtk2fempar(:), nodesids(:)

  assert( this%mc_runtime_init )

  cell_iter = this%create_unfitted_cell_iterator()
  call cell_iter%current(cell)

  num_dime = this%triangulation%get_num_dimensions()
  num_cells = this%triangulation%get_num_cells()
  num_cell_nodes = cell%get_num_nodes()
  num_subcells = this%get_total_num_of_subcells()
  num_subcell_nodes = this%get_max_num_nodes_in_subcell()
  Ne = num_cells + num_subcells
  Nn = num_cell_nodes*num_cells  + num_subcell_nodes*num_subcells

  call memalloc ( Nn, x, __FILE__, __LINE__ )
  call memalloc ( Nn, y, __FILE__, __LINE__ )
  call memalloc ( Nn, z, __FILE__, __LINE__ )
  call memalloc ( Ne, cell_type, __FILE__, __LINE__ )
  call memalloc ( Ne, offset   , __FILE__, __LINE__ )
  call memalloc ( Nn, connect  , __FILE__, __LINE__ )
  call memalloc ( Ne, vc       , __FILE__, __LINE__ )
  allocate ( cell_coords(1:num_cell_nodes), stat = istat ); check(istat == 0)
  allocate ( subcell_coords(1:num_subcell_nodes), stat = istat ); check(istat == 0)
  call memalloc ( num_cell_nodes, nodes_vtk2fempar, __FILE__, __LINE__ )
  call memalloc ( num_cell_nodes, nodesids        , __FILE__, __LINE__ )

  select case (num_dime)
    case(3)
      the_cell_type = 12_I1P
      the_subcell_type = 10_I1P
      nodes_vtk2fempar(:) = [1, 2 , 4, 3, 5, 6, 8, 7]
    case(2)
      the_cell_type = 9_I1P
      the_subcell_type = 5_I1P
      nodes_vtk2fempar(:) = [1, 2 , 4, 3]
    case default
    check(.false.)
  end select

  ! Fill date to be passed to vtkio
  call cell_iter%init()
  icell = 1
  inode = 1
  do while ( .not. cell_iter%has_finished() )

    call cell_iter%current(cell)

    call cell%update_sub_triangulation()

    call cell%get_coordinates( cell_coords )

    do ino = 1, num_cell_nodes
      x(inode) = cell_coords(ino)%get(1)
      y(inode) = cell_coords(ino)%get(2)
      z(inode) = cell_coords(ino)%get(3)
      nodesids(ino) = inode
      inode = inode + 1
    end do

    connect(nodesids(:)) = nodesids( nodes_vtk2fempar(:) ) - 1

    offset(icell)        = inode - 1
    cell_type(icell)     = the_cell_type

    if ( cell%is_interior() ) then
      vc( icell )  = -1
    else if ( cell%is_cut() ) then
      vc( icell )  = 0
    else
      vc( icell )  = 1
    end if

    icell = icell + 1

    do isubcell = 1, cell%get_number_of_subcells()
      call cell%get_phys_coords_of_subcell(isubcell,subcell_coords)

      do ino = 1, num_subcell_nodes
        x(inode) = subcell_coords(ino)%get(1)
        y(inode) = subcell_coords(ino)%get(2)
        z(inode) = subcell_coords(ino)%get(3)
        connect(inode) = inode - 1
        inode = inode + 1
      end do

      offset(icell)        = inode - 1
      cell_type(icell)     = the_subcell_type

      if ( cell%is_interior_subcell(isubcell) ) then
        vc( icell )  = -2
      else
        vc( icell )  = 2
      end if

      icell = icell + 1

    end do

    call cell_iter%next()
  end do


  if (num_dime == 2_ip) z(:) = 0

  ! Write mesh to .vtu file
  E_IO = VTK_INI_XML(output_format = 'ascii', filename = 'out_mesh.vtu', mesh_topology = 'UnstructuredGrid')
  E_IO = VTK_GEO_XML(NN = Nn, NC = Ne, X = x, Y = y, Z = z)
  E_IO = VTK_CON_XML(NC = Ne, connect = connect, offset = offset, cell_type = int(cell_type,I1P) )
  E_IO = VTK_DAT_XML(var_location = 'cell', var_block_action = 'opeN')
  E_IO = VTK_VAR_XML(NC_NN = Ne, varname = 'cell_scalars', var = vc)
  E_IO = VTK_DAT_XML(var_location = 'cell', var_block_action = 'CLOSE')
  E_IO = VTK_GEO_XML()
  E_IO = VTK_END_XML()

  call memfree ( x        , __FILE__, __LINE__ )
  call memfree ( y        , __FILE__, __LINE__ )
  call memfree ( z        , __FILE__, __LINE__ )
  call memfree ( cell_type, __FILE__, __LINE__ )
  call memfree ( offset   , __FILE__, __LINE__ )
  call memfree ( connect  , __FILE__, __LINE__ )
  call memfree ( vc       , __FILE__, __LINE__ )
  deallocate ( cell_coords, stat = istat ); check(istat == 0)
  deallocate ( subcell_coords, stat = istat ); check(istat == 0)
  call memfree ( nodes_vtk2fempar, __FILE__, __LINE__ )
  call memfree ( nodesids, __FILE__, __LINE__ )

  call cell_iter%free()

end subroutine marching_cubes_print_vtk_subcells

!========================================================================================
! TODO put all of this in vtw writer
subroutine marching_cubes_print_vtk_subfaces( this )

  implicit none
  class(marching_cubes_t), intent(in)    :: this

  integer(ip) :: num_subfaces, num_subface_nodes, num_dime
  integer(ip) :: istat, iface, inode, ino, isubface
  type(unfitted_cell_iterator_t)  :: cell_iter
  type(unfitted_cell_accessor_t)  :: cell
  type(point_t), allocatable, dimension(:) :: subface_coords
  integer(ip) :: the_subface_type

  ! Used by VTKIO
  integer(ip) :: E_IO
  integer(ip) :: Nn
  integer(ip) :: Ne
  real(rp),    allocatable, dimension(:) :: x
  real(rp),    allocatable, dimension(:) :: y
  real(rp),    allocatable, dimension(:) :: z
  integer(ip), allocatable, dimension(:) :: cell_type
  integer(ip), allocatable, dimension(:) :: offset
  integer(ip), allocatable, dimension(:) :: connect

  assert( this%mc_runtime_init )

  cell_iter = this%create_unfitted_cell_iterator()
  call cell_iter%current(cell)

  num_dime = this%triangulation%get_num_dimensions()
  num_subfaces = this%get_total_num_of_subfaces()
  num_subface_nodes = this%get_max_num_nodes_in_subface()
  Ne = num_subfaces
  Nn = num_subface_nodes*num_subfaces

  call memalloc ( Nn, x, __FILE__, __LINE__ )
  call memalloc ( Nn, y, __FILE__, __LINE__ )
  call memalloc ( Nn, z, __FILE__, __LINE__ )
  call memalloc ( Ne, cell_type, __FILE__, __LINE__ )
  call memalloc ( Ne, offset   , __FILE__, __LINE__ )
  call memalloc ( Nn, connect  , __FILE__, __LINE__ )
  allocate ( subface_coords(1:num_subface_nodes), stat = istat ); check(istat == 0)

  select case (num_dime)
    case(3)
      the_subface_type = 5_I1P
    case(2)
      the_subface_type = 3_I1P
    case default
    check(.false.)
  end select

  ! Fill date to be passed to vtkio
  call cell_iter%init()
  iface = 1
  inode = 1
  do while ( .not. cell_iter%has_finished() )

    call cell_iter%current(cell)

    call cell%update_sub_triangulation()

    do isubface = 1, cell%get_number_of_subfaces()
      call cell%get_phys_coords_of_subface(isubface,subface_coords)

      do ino = 1, num_subface_nodes
        x(inode) = subface_coords(ino)%get(1)
        y(inode) = subface_coords(ino)%get(2)
        z(inode) = subface_coords(ino)%get(3)
        connect(inode) = inode - 1
        inode = inode + 1
      end do

      offset(iface)        = inode - 1
      cell_type(iface)     = the_subface_type

      iface = iface + 1

    end do

    call cell_iter%next()
  end do


  if (num_dime == 2_ip) z(:) = 0

  ! Write mesh to .vtu file
  E_IO = VTK_INI_XML(output_format = 'ascii', filename = 'out_mesh_boundary.vtu', mesh_topology = 'UnstructuredGrid')
  E_IO = VTK_GEO_XML(NN = Nn, NC = Ne, X = x, Y = y, Z = z)
  E_IO = VTK_CON_XML(NC = Ne, connect = connect, offset = offset, cell_type = int(cell_type,I1P) ) 
  E_IO = VTK_GEO_XML()
  E_IO = VTK_END_XML()

  call memfree ( x        , __FILE__, __LINE__ )
  call memfree ( y        , __FILE__, __LINE__ )
  call memfree ( z        , __FILE__, __LINE__ )
  call memfree ( cell_type, __FILE__, __LINE__ )
  call memfree ( offset   , __FILE__, __LINE__ )
  call memfree ( connect  , __FILE__, __LINE__ )
  deallocate ( subface_coords, stat = istat ); check(istat == 0)
  call cell_iter%free()

end subroutine marching_cubes_print_vtk_subfaces

